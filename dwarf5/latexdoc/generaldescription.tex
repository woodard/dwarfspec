\chapter{General Description}
\label{chap:generaldescription}
\section{The Debugging Information Entry (DIE)}
\label{chap:thedebuggingentrydie}
DWARF 
\addtoindexx{debugging information entry}
uses 
\addtoindexx{DIE|see{debugging information entry}}
a series of debugging information entries (DIEs) to 
define a low-level
representation of a source program. 
Each debugging information entry consists of an identifying
\addtoindex{tag} and a series of 
\addtoindex{attributes}. 
An entry, or group of entries together, provide a description of a
corresponding 
\addtoindex{entity} in the source program. 
The tag specifies the class to which an entry belongs
and the attributes define the specific characteristics of the entry.

The set of tag names 
\addtoindexx{tag names|see{debugging information entry}}
is listed in Table \refersec{tab:tagnames}. 
The debugging information entries they identify are
described in Chapters 3, 4 and 5.

% These each need to link to definition page: FIXME

\begin{table}[p]
\caption{Tag names}
\label{tab:tagnames}
\simplerule[6in]
\autocols[0pt]{c}{2}{l}{
\DWTAGaccessdeclaration,
\DWTAGarraytype,
\DWTAGatomictype,
\DWTAGbasetype,
\DWTAGcallsite,
\DWTAGcallsiteparameter,
\DWTAGcatchblock,
\DWTAGclasstype,
\DWTAGcoarraytype,
\DWTAGcommonblock,
\DWTAGcommoninclusion,
\DWTAGcompileunit,
\DWTAGcondition,
\DWTAGconsttype,
\DWTAGconstant,
\DWTAGdwarfprocedure,
\DWTAGdynamictype,
\DWTAGentrypoint,
\DWTAGenumerationtype,
\DWTAGenumerator,
\DWTAGfiletype,
\DWTAGformalparameter,
\DWTAGfriend,
\DWTAGgenericsubrange,
\DWTAGimporteddeclaration,
\DWTAGimportedmodule,
\DWTAGimportedunit,
\DWTAGinheritance,
\DWTAGinlinedsubroutine,
\DWTAGinterfacetype,
\DWTAGlabel,
\DWTAGlexicalblock,
\DWTAGmodule,
\DWTAGmember,
\DWTAGnamelist,
\DWTAGnamelistitem,
\DWTAGnamespace,
\DWTAGpackedtype,
\DWTAGpartialunit,
\DWTAGpointertype,
\DWTAGptrtomembertype,
\DWTAGreferencetype,
\DWTAGrestricttype,
\DWTAGrvaluereferencetype,
\DWTAGsettype,
\DWTAGsharedtype,
\DWTAGstringtype,
\DWTAGstructuretype,
\DWTAGsubprogram,
\DWTAGsubrangetype,
\DWTAGsubroutinetype,
\DWTAGtemplatealias,
\DWTAGtemplatetypeparameter,
\DWTAGtemplatevalueparameter,
\DWTAGthrowntype,
\DWTAGtryblock,
\DWTAGtypedef,
\DWTAGtypeunit,
\DWTAGuniontype,
\DWTAGunspecifiedparameters,
\DWTAGunspecifiedtype,
\DWTAGvariable,
\DWTAGvariant,
\DWTAGvariantpart,
\DWTAGvolatiletype,
\DWTAGwithstmt
}
\simplerule[6in]
\end{table}


\textit{The debugging information entry descriptions 
in Sections 3, 4 and 5 generally include mention of
most, but not necessarily all, of the attributes 
that are normally or possibly used with the entry.
Some attributes, whose applicability tends to be 
pervasive and invariant across many kinds of
debugging information entries, are described in 
this section and not necessarily mentioned in all
contexts where they may be appropriate. 
Examples include 
\DWATartificial, 
the \livelink{chap:declarationcoordinates}{declaration coordinates}, and 
\DWATdescription, 
among others.}

The debugging information entries are contained in the 
\dotdebuginfo{} sections of an object file.

\needlines{7}
Optionally, debugging information may be partitioned such
that the majority of the debugging information can remain in
individual object files without being processed by the
linker. These debugging information entries are contained in
the \dotdebuginfodwo{} sections. These
sections may be placed in the object file but marked so that
the linker ignores them, or they may be placed in a separate
DWARF object file that resides alongside the normal object
file. See Section \refersec{datarep:splitdwarfobjects} and
Appendix \refersec{app:splitdwarfobjectsinformative} for details.


\section{Attribute Types}
\label{chap:attributetypes}
Each attribute value is characterized by an attribute name. 
\addtoindexx{attribute duplication}
No more than one attribute with a given name may appear in any
debugging information entry. 
There are no limitations on the
\addtoindexx{attribute ordering}
ordering of attributes within a debugging information entry.

The attributes are listed in Table \refersec{tab:attributenames}.  

The permissible values
\addtoindexx{attribute value classes}
for an attribute belong to one or more classes of attribute
value forms.  
Each form class may be represented in one or more ways. 
For example, some attribute values consist
of a single piece of constant data. 
\doublequote{Constant data}
is the class of attribute value that those attributes may have. 
There are several representations of constant data,
however (one, two, ,four, or eight bytes, and variable length
data). 
The particular representation for any given instance
of an attribute is encoded along with the attribute name as
part of the information that guides the interpretation of a
debugging information entry.  

Attribute value forms belong
\addtoindexx{tag names!list of}
to one of the classes shown in Table \refersec{tab:classesofattributevalue}.

\setlength{\extrarowheight}{0.1cm}
\addtoindexx{attributes!list of}
\begin{longtable}{l|p{9cm}}
  \caption{Attribute names} \label{tab:attributenames} \\
  \hline \bfseries Attribute&\bfseries Identifies or Specifies \\ \hline
\endfirsthead
  \bfseries Attribute&\bfseries Identifies or Specifies \\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot
\DWATabstractoriginTARG
&\livelinki{chap:DWATabstractorigininlineinstance}{Inline instances of inline subprograms} {inline instances of inline subprograms} \\
% Heren livelink we cannot use \dash or \dash{}.
&\livelinki{chap:DWATabstractoriginoutoflineinstance}{Out-of-line instances of inline subprograms}{out-of-line instances of inline subprograms} \\
\DWATaccessibilityTARG
&\livelink{chap:DWATaccessibilitycandadadeclarations}{C++ and Ada declarations} \addtoindexx{Ada} \\
&\livelink{chap:DWATaccessibilitycppbaseclasses}{C++ base classes} \\
&\livelink{chap:DWATaccessibilitycppinheritedmembers}{C++ inherited members} \\
\DWATaddressclassTARG
&\livelinki{chap:DWATadressclasspointerorreferencetypes}{Pointer or reference types}{pointer or reference types}  \\
&\livelinki{chap:DWATaddressclasssubroutineorsubroutinetype}{Subroutine or subroutine type}{subroutine or subroutine type} \\
\DWATaddrbaseTARG
&\livelinki{chap:DWATaddrbaseforaddresstable}{Base offset for address table}{address table} \\
\DWATallocatedTARG
&\livelinki{chap:DWATallocatedallocationstatusoftypes}{Allocation status of types}{allocation status of types}  \\
\DWATartificialTARG
&\livelinki{chap:DWATartificialobjectsortypesthat}{Objects or types that are not actually declared in the source}{objects or types that are not actually declared in the source}  \\
\DWATassociatedTARG{} 
&\livelinki{chap:DWATassociatedassociationstatusoftypes}{Association status of types}{association status of types} \\
\DWATbasetypesTARG{} 
&\livelinki{chap:DWATbasetypesprimitivedatatypesofcompilationunit}{Primitive data types of compilation unit}{primitive data types of compilation unit} \\
\DWATbinaryscaleTARG{} 
&\livelinki{chap:DWATbinaryscalebinaryscalefactorforfixedpointtype}{Binary scale factor for fixed-point type}{binary scale factor for fixed-point type} \\
\DWATbitoffsetTARG{} 
&\livelinki{chap:DWATbitoffsetbasetypebitlocation}{Base type bit location}{base type bit location} \\
&\livelinki{chap:DWATbitoffsetdatamemberbitlocation}{Data member bit location}{data member bit location} \\
\DWATbitsizeTARG{} 
&\livelinki{chap:DWATbitsizebasetypebitsize}{Base type bit size}{base type bit size} \\
&\livelinki{chap:DWATbitsizedatamemberbitsize}{Data member bit size}{data member bit size} \\
\DWATbitstrideTARG{} 
&\livelinki{chap:DWATbitstridearrayelementstrideofarraytype}{Array element stride (of array type)}{array element stride (of array type)} \\
&\livelinki{chap:DWATbitstridesubrangestridedimensionofarraytype}{Subrange stride (dimension of array type)}{subrange stride (dimension of array type)} \\
&\livelinki{chap:DWATbitstrideenumerationstridedimensionofarraytype}{Enumeration stride (dimension of array type)}{enumeration stride (dimension of array type)} \\
\DWATbytesizeTARG{} 
&\livelinki{chap:DWATbytesizedataobjectordatatypesize}{Data object or data type size}{data object or data type size} \\
\DWATbytestrideTARG{} 
&\livelinki{chap:DWATbytestridearrayelementstrideofarraytype}{Array element stride (of array type)}{array element stride (of array type)} \\
&\livelinki{chap:DWATbytestridesubrangestridedimensionofarraytype}{Subrange stride (dimension of array type)}{subrange stride (dimension of array type)} \\
&\livelinki{chap:DWATbytestrideenumerationstridedimensionofarraytype}
           {Enumeration stride (dimension of array type)}
           {enumeration stride (dimension of array type)} \\
\DWATcallallcallsTARG{}
&\livelinki{chap:DWATcallallcallsofasubprogram}
           {All tail and normal calls in a subprogram are described by call site entries}
           {all tail and normal calls in a subprogram are described by call site entries}
           \index{call site!summary!all tail and normal calls are described} \\
\DWATcallallsourcecallsTARG{}
&\livelinki{chap:DWATcallallaourcecallsofa subprogram}
           {All tail, normal and inlined calls in a subprogram are described by call site and inlined subprogram entries}
           {all tail calls in a subprogram are described by call site and inlined subprogram entries}
           \index{call site!summary!all tail, normal and inlined calls are described} \\
\DWATcallalltailcallsTARG{}
&\livelinki{chap:DWATcallalltailcallsofasubprogram}
           {All tail calls in a subprogram are described by call site entries}
           {all tail calls in a subprogram are described by call site entries}
           \index{call site!summary!all tail calls are described} \\
\DWATcallcolumnTARG{} 
&\livelinki{chap:DWATcallcolumncolumnpositionofinlinedsubroutinecall}
           {Column position of inlined subroutine call}
           {column position of inlined subroutine call} \\
\DWATcalldatalocationTARG{}
&\livelinki{chap:DWATcalldatalocationofcallsite}
           {Address of the value pointed to by an argument passed in a call}
           {address of the value pointed to by an argument passed in a call}
           \index{call site!address of the value pointed to by an argument} \\
\DWATcalldatavalueTARG{}
&\livelinki{chap:DWATcalldatavalueofcallsite}
           {Value pointed to by an argument passed in a call}
           {value pointed to by an argument passed in a call}
           \index{call site!value pointed to by an argument} \\
\DWATcallfileTARG
&\livelinki{chap:DWATcallfilefilecontaininginlinedsubroutinecall}
           {File containing inlined subroutine call}
           {file containing inlined subroutine call} \\
\DWATcalllineTARG{} 
&\livelinki{chap:DWATcalllinelinenumberofinlinedsubroutinecall}
           {Line number of inlined subroutine call}
           {line number of inlined subroutine call} \\
\DWATcallingconventionTARG{} 
&\livelinki{chap:DWATcallingconventionsubprogramcallingconvention}
           {Subprogram calling convention}
           {subprogram calling convention} \\
\DWATcalloriginTARG{}
&\livelinki{chap:DWATcalloriginofcallsite}
           {Subprogram called in a call}
           {subprogram called in a call}
           \index{call site!subprogram called} \\
\DWATcallparameterTARG{}
&\livelinki{chap:DWATcallparameterofcallsite}
           {Parameter entry in a call}
           {parameter entry in a call}
           \index{call site!parameter entry} \\
\DWATcallpcTARG{}
&\livelinki{chap:DWATcallpcofcallsite}
           {Address of the call instruction in a call}
           {address of the call instruction in a call}
           \index{call site!address of the call instruction} \\
\DWATcallreturnpcTARG{}
&\livelinki{chap:DWATcallreturnpcofcallsite}
           {Return address from a call}
           {return address from a call}
           \index{call site!return address} \\
\DWATcalltailcallTARG{}
&\livelinki{chap:DWATcalltailcallofcallsite}
           {Call is a tail call}
           {call is a tail call}
           \index{call site!tail call} \\
\DWATcalltargetTARG{}
&\livelinki{chap:DWATcalltargetofcallsite}
           {Address of called routine in a call}
           {address of called routine in a call}
           \index{call site!address of called routine} \\
\DWATcalltargetclobberedTARG{}
&\livelinki{chap:DWATcalltargetclobberedofcallsite}
           {Address of called routine, which may be clobbered, in a call}
           {address of called routine, which may be clobbered, in a call}
           \index{call site!address of called routine, which may be clobbered} \\
\DWATcallvalueTARG{}
&\livelinki{chap:DWATcallvalueofcallsite}
           {Argument value passed in a call}
           {argument value passed in a call}
           \index{call site!argument value passed} \\
\DWATcommonreferenceTARG
&\livelinki{chap:commonreferencecommonblockusage}{Common block usage}{common block usage} \\
\DWATcompdirTARG
&\livelinki{chap:DWATcompdircompilationdirectory}{Compilation directory}{compilation directory} \\
\DWATconstvalueTARG
&\livelinki{chap:DWATconstvalueconstantobject}{Constant object}{constant object} \\
&\livelinki{chap:DWATconstvalueenumerationliteralvalue}{Enumeration literal value}{enumeration literal value} \\
&\livelinki{chap:DWATconstvaluetemplatevalueparameter}{Template value parameter}{template value parameter} \\
\DWATconstexprTARG
&\livelinki{chap:DWATconstexprcompiletimeconstantobject}{Compile-time constant object}{compile-time constant object} \\
&\livelinki{chap:DWATconstexprcompiletimeconstantfunction}{Compile-time constant function}{compile-time constant function} \\
\DWATcontainingtypeTARG
&\livelinki{chap:DWATcontainingtypecontainingtypeofpointertomembertype}{Containing type of pointer to member type}{containing type of pointer to member type} \\
\DWATcountTARG
&\livelinki{chap:DWATcountelementsofsubrangetype}{Elements of subrange type}{elements ofbreg subrange type} \\
\DWATdatabitoffsetTARG
&\livelinki{chap:DWATdatabitoffsetbasetypebitlocation}{Base type bit location}{base type bit location} \\
&\livelinki{chap:DWATdatabitoffsetdatamemberbitlocation}{Data member bit location}{data member bit location} \\
\DWATdatalocationTARG{} 
&\livelinki{chap:DWATdatalocationindirectiontoactualdata}{Indirection to actual data}{indirection to actual data} \\
\DWATdatamemberlocationTARG
&\livelinki{chap:DWATdatamemberlocationdatamemberlocation}{Data member location}{data member location} \\
&\livelinki{chap:DWATdatamemberlocationinheritedmemberlocation}{Inherited member location}{inherited member location} \\
\DWATdecimalscaleTARG
&\livelinki{chap:DWATdecimalscaledecimalscalefactor}{Decimal scale factor}{decimal scale factor} \\
\DWATdecimalsignTARG
&\livelinki{chap:DWATdecimalsigndecimalsignrepresentation}{Decimal sign representation}{decimal sign representation} \\
\DWATdeclcolumnTARG
&\livelinki{chap:DWATdeclcolumncolumnpositionofsourcedeclaration}{Column position of source declaration}{column position of source declaration} \\
\DWATdeclfileTARG
&\livelinki{chap:DWATdeclfilefilecontainingsourcedeclaration}{File containing source declaration}{file containing source declaration} \\
\DWATdecllineTARG
&\livelinki{chap:DWATdecllinelinenumberofsourcedeclaration}{Line number of source declaration}{line number of source declaration} \\
\DWATdeclarationTARG
&\livelinki{chap:DWATdeclarationincompletenondefiningorseparateentitydeclaration}{Incomplete, non-defining, or separate entity declaration}{incomplete, non-defining, or separate entity declaration} \\
\DWATdefaultvalueTARG
&\livelinki{chap:DWATdefaultvaluedefaultvalueofparameter}{Default value of parameter}{default value of parameter} \\
\DWATdescriptionTARG{} 
&\livelinki{chap:DWATdescriptionartificialnameordescription}{Artificial name or description}{artificial name or description} \\
\DWATdigitcountTARG
&\livelinki{chap:DWATdigitcountdigitcountforpackeddecimalornumericstringtype}{Digit count for packed decimal or numeric string type}{digit count for packed decimal or numeric string type} \\
\DWATdiscrTARG
&\livelinki{chap:DWATdiscrdiscriminantofvariantpart}{Discriminant of variant part}{discriminant of variant part} \\
\DWATdiscrlistTARG
&\livelinki{chap:DWATdiscrlistlistofdiscriminantvalues}{List of discriminant values}{list of discriminant values} \\
\DWATdiscrvalueTARG
&\livelinki{chap:DWATdiscrvaluediscriminantvalue}{Discriminant value}{discriminant value} \\
\DWATdwoidTARG
&\livelinki{chap:DWATdwoidforunit}{Signature for compilation unit}{split DWARF object file!unit signature} \\
\DWATdwonameTARG
&\livelinki{chap:DWATdwonameforunit}{Name of split DWARF object file}{split DWARF object file!object file name} \\
\DWATelementalTARG
&\livelinki{chap:DWATelementalelementalpropertyofasubroutine}{Elemental property of a subroutine}{elemental property of a subroutine} \\
\DWATencodingTARG
&\livelinki{chap:DWATencodingencodingofbasetype}{Encoding of base type}{encoding of base type} \\
\DWATendianityTARG
&\livelinki{chap:DWATendianityendianityofdata}{Endianity of data}{endianity of data} \\
\DWATentrypcTARG
&\livelinki{chap:entryaddressofscope}{Entry address of a scope (compilation unit, \mbox{subprogram,} and so on)}{} \\
\DWATenumclassTARG
&\livelinki{chap:DWATenumclasstypesafeenumerationdefinition}{Type safe enumeration definition}{type safe enumeration definition}\\
\DWATexplicitTARG
&\livelinki{chap:DWATexplicitexplicitpropertyofmemberfunction}{Explicit property of member function}{explicit property of member function}\\
\DWATextensionTARG
&\livelinki{chap:DWATextensionpreviousnamespaceextensionororiginalnamespace}{Previous namespace extension or original namespace}{previous namespace extension or original namespace}\\
\DWATexternalTARG
&\livelinki{chap:DWATexternalexternalsubroutine}{External subroutine}{external subroutine} \\
&\livelinki{chap:DWATexternalexternalvariable}{External variable}{external variable} \\
\DWATframebaseTARG
&\livelinki{chap:DWATframebasesubroutineframebaseaddress}{Subroutine frame base address}{subroutine frame base address} \\
\DWATfriendTARG
&\livelinki{chap:DWATfriendfriendrelationship}{Friend relationship}{friend relationship} \\
\DWAThighpcTARG
&\livelinki{chap:DWAThighpccontiguousrangeofcodeaddresses}{Contiguous range of code addresses}{contiguous range of code addresses} \\
\DWATidentifiercaseTARG
&\livelinki{chap:DWATidentifiercaseidentifiercaserule}{Identifier case rule}{identifier case rule} \\
\DWATimportTARG
&\livelinki{chap:DWATimportimporteddeclaration}{Imported declaration}{imported declaration} \\
&\livelinki{chap:DWATimportimportedunit}{Imported unit}{imported unit} \\
&\livelinki{chap:DWATimportnamespacealias}{Namespace alias}{namespace alias} \\
&\livelinki{chap:DWATimportnamespaceusingdeclaration}{Namespace using declaration}{namespace using declaration} \\
&\livelinki{chap:DWATimportnamespaceusingdirective}{Namespace using directive}{namespace using directive} \\
\DWATinlineTARG
&\livelinki{chap:DWATinlineabstracttinstance}{Abstract instance}{abstract instance} \\
&\livelinki{chap:DWATinlineinlinedsubroutine}{Inlined subroutine}{inlined subroutine} \\
\DWATisoptionalTARG
&\livelinki{chap:DWATisoptionaloptionalparameter}{Optional parameter}{optional parameter} \\
\DWATlanguageTARG
&\livelinki{chap:DWATlanguageprogramminglanguage}{Programming language}{programming language} \\
\DWATlinkagenameTARG
&\livelinki{chap:DWATlinkagenameobjectfilelinkagenameofanentity}{Object file linkage name of an entity}{object file linkage name of an entity}\\
\DWATlocationTARG
&\livelinki{chap:DWATlocationdataobjectlocation}{Data object location}{data object location}\\
\DWATlowpcTARG
&\livelinki{chap:DWATlowpccodeaddressorrangeofaddresses}{Code address or range of addresses}{code address or range of addresses}\\
\DWATlowerboundTARG
&\livelinki{chap:DWATlowerboundlowerboundofsubrange}{Lower bound of subrange}{lower bound of subrange} \\
\DWATmacroinfoTARG
&\livelinki{chap:DWATmacroinfomacroinformation}{Macro information (for pre-\DWARFVersionV{} compatibility)} {macro information (legacy)} \\
\DWATmacrosTARG
&\livelinki{chap:DWATmacrosmacroinformation}{Macro information} {macro information} (\texttt{\#define}, \texttt{\#undef}, and so on)\\
\DWATmainsubprogramTARG
&\livelinki{chap:DWATmainsubprogrammainorstartingsubprogram}{Main or starting subprogram}{main or starting subprogram} \\
&\livelinki{chap:DWATmainsubprogramunitcontainingmainorstartingsubprogram}{Unit containing main or starting subprogram}{unit containing main or starting subprogram}\\
\DWATmutableTARG
&\livelinki{chap:DWATmutablemutablepropertyofmemberdata}{Mutable property of member data}{mutable property of member data} \\
\DWATnameTARG
&\livelinki{chap:DWATnamenameofdeclaration}{Name of declaration}{name of declaration}\\
&\livelinki{chap:DWATnamepathnameofcompilationsource}{Path name of compilation source}{path name of compilation source} \\
\DWATnamelistitemTARG
&\livelinki{chap:DWATnamelistitemnamelistitem}{Namelist item}{namelist item}\\
\DWATobjectpointerTARG
&\livelinki{chap:DWATobjectpointerobjectthisselfpointerofmemberfunction}{Object (\texttt{this}, \texttt{self}) pointer of member function}{object (\texttt{this}, \texttt{self}) pointer of member function}\\
\DWATorderingTARG
&\livelinki{chap:DWATorderingarrayrowcolumnordering}{Array row/column ordering} {array row/column ordering}\\
\DWATpicturestringTARG
&\livelinki{chap:DWATpicturestringpicturestringfornumericstringtype}{Picture string for numeric string type}{picture string for numeric string type} \\
\DWATpriorityTARG
&\livelinki{chap:DWATprioritymodulepriority}{Module priority}{module priority}\\
\DWATproducerTARG
&\livelinki{chap:DWATproducercompileridentification}{Compiler identification}{compiler identification}\\
\DWATprototypedTARG
&\livelinki{chap:DWATprototypedsubroutineprototype}{Subroutine prototype}{subroutine prototype}\\
\DWATpureTARG
&\livelinki{chap:DWATpurepurepropertyofasubroutine}{Pure property of a subroutine}{pure property of a subroutine} \\
\DWATrangesTARG
&\livelinki{chap:DWATrangesnoncontiguousrangeofcodeaddresses}{Non-contiguous range of code addresses}{non-contiguous range of code addresses} \\
\DWATrangesbaseTARG
&\livelinki{chap:DWATrangesbaseforrangelists}{Base offset for range lists}{Ranges lists} \\
\DWATrankTARG
&\livelinki{chap:DWATrankofdynamicarray}{Dynamic number of array dimensions}{dynamic number of array dimensions} \\
\DWATrecursiveTARG
&\livelinki{chap:DWATrecursiverecursivepropertyofasubroutine}{Recursive property of a subroutine}{recursive property of a subroutine} \\
\DWATreferenceTARG
&\livelink{chap:DWATreferenceofnonstaticmember}{\&-qualified non-static member function} \\
\DWATreturnaddrTARG
&\livelinki{chap:DWATreturnaddrsubroutinereturnaddresssavelocation}{Subroutine return address save location}{subroutine return address save location} \\
\DWATrvaluereferenceTARG
&\livelink{chap:DWATrvaluereferenceofnonstaticmember}{\&\&-qualified non-static member function} \\

\DWATsegmentTARG
&\livelinki{chap:DWATsegmentaddressinginformation}{Addressing information}{addressing information} \\
\DWATsiblingTARG
&\livelinki{chap:DWATsiblingdebugginginformationentryrelationship}{Debugging information entry relationship}{debugging information entry relationship} \\
\DWATsmallTARG
&\livelinki{chap:DWATsmallscalefactorforfixedpointtype}{Scale factor for fixed-point type}{scale factor for fixed-point type} \\
\DWATsignatureTARG
&\livelinki{chap:DWATsignaturetypesignature}{Type signature}{type signature}\\
\DWATspecificationTARG
&\livelinki{chap:DWATspecificationincompletenondefiningorseparatedeclaration}{Incomplete, non-defining, or separate declaration corresponding to a declaration}{incomplete, non-defining, or separate declaration corresponding to a declaration} \\
\DWATstartscopeTARG
&\livelinki{chap:DWATstartscopeobjectdeclaration}{Object declaration}{object declaration}\\
&\livelinki{chap:DWATstartscopetypedeclaration}{Type declaration}{type declaration}\\
\DWATstaticlinkTARG
&\livelinki{chap:DWATstaticlinklocationofuplevelframe}{Location of uplevel frame}{location of uplevel frame} \\
\DWATstmtlistTARG
&\livelinki{chap:DWATstmtlistlinenumberinformationforunit}{Line number information for unit}{line number information for unit}\\
\DWATstringlengthTARG
&\livelinki{chap:DWATstringlengthstringlengthofstringtype}{String length of string type}{string length of string type}
 \\
\DWATstringlengthbitsizeTARG
&\livelinki{chap:DWATstringlengthstringlengthofstringtype}{Size of string length of string type}{string length of string type!size of}
 \\
\DWATstringlengthbytesizeTARG
&\livelinki{chap:DWATstringlengthstringlengthofstringtype}{Size of string length of string type}{string length of string type!size of}
 \\
\DWATstroffsetsbaseTARG
&\livelinki{chap:DWATstroffsetbaseforindirectstringtable}{Base of string offsets table}{string offsets table} \\
\DWATthreadsscaledTARG
&\livelink{chap:DWATthreadsscaledupcarrayboundthreadsscalfactor}{UPC array bound THREADS scale factor}\\
\DWATtrampolineTARG
&\livelinki{chap:DWATtrampolinetargetsubroutine}{Target subroutine}{target subroutine of trampoline} \\
\DWATtypeTARG
&\livelinki{chap:DWATtypetypeofdeclaration}{Type of declaration}{type of declaration} \\
&\livelinki{chap:DWATtypetypeofsubroutinereturn}{Type of subroutine return}{type of subroutine return} \\
\DWATupperboundTARG
&\livelinki{chap:DWATupperboundupperboundofsubrange}{Upper bound of subrange}{upper bound of subrange} \\
\DWATuselocationTARG
&\livelinki{chap:DWATuselocationmemberlocationforpointertomembertype}{Member location for pointer to member type}{member location for pointer to member type} \\
\DWATuseUTFeightTARG\addtoindexx{use UTF8 attribute}\addtoindexx{UTF-8}
&\livelinki{chap:DWATuseUTF8compilationunitusesutf8strings}{Compilation unit uses UTF-8 strings}{compilation unit uses UTF-8 strings} \\
\DWATvariableparameterTARG
&\livelinki{chap:DWATvariableparameternonconstantparameterflag}{Non-constant parameter flag}{non-constant parameter flag}  \\
\DWATvirtualityTARG
&\livelinki{chap:DWATvirtualityvirtualityindication}{Virtuality indication}{virtuality indication} \\
&\livelinki{chap:DWATvirtualityvirtualityofbaseclass}{Virtuality of base class} {virtuality of base class} \\
&\livelinki{chap:DWATvirtualityvirtualityoffunction}{Virtuality of function}{virtuality of function} \\
\DWATvisibilityTARG
&\livelinki{chap:DWATvisibilityvisibilityofdeclaration}{Visibility of declaration}{visibility of declaration} \\
\DWATvtableelemlocationTARG
&\livelinki{chap:DWATvtableelemlocationvirtualfunctiontablevtableslot}{Virtual function vtable slot}{virtual function vtable slot}\\
\end{longtable}

\addtoindexx{address|see {\textit{also} address class}}
\addtoindexx{addrptr|see {\textit{also} addrptr class}}
\addtoindexx{block|see {\textit{also} block class}}
\addtoindexx{constant|see {\textit{also} constant class}}
\addtoindexx{exprloc|see {\textit{also} exprloc class}}
\addtoindexx{flag|see {\textit{also} flag class}}
\addtoindexx{lineptr|see {\textit{also} lineptr class}}
\addtoindexx{loclistptr|see {\textit{also} loclistptr class}}
\addtoindexx{macptr|see {\textit{also} macptr class}}
\addtoindexx{rangelistptr|see {\textit{also} rangelistptr class}}
\addtoindexx{reference|see {\textit{also} reference class}}
\addtoindexx{string|see {\textit{also} string class}}
\addtoindexx{stroffsetsptr|see {\textit{also} stroffsetsptr class}}

\addtoindexx{class of attribute value!address|see {address class}}
\addtoindexx{class of attribute value!addrptr|see {addrptr class}}
\addtoindexx{class of attribute value!block|see {block class}}
\addtoindexx{class of attribute value!constant|see {constant class}}
\addtoindexx{class of attribute value!exprloc|see {exprloc class}}
\addtoindexx{class of attribute value!flag|see {flag class}}
\addtoindexx{class of attribute value!lineptr|see {lineptr class}}
\addtoindexx{class of attribute value!loclistptr|see {loclistptr class}}
\addtoindexx{class of attribute value!macptr|see {macptr class}}
\addtoindexx{class of attribute value!rangelistptr|see {rangelistptr class}}
\addtoindexx{class of attribute value!reference|see {reference class}}
\addtoindexx{class of attribute value!string|see {string class}}
\addtoindexx{class of attribute value!stroffsetsptr|see {stroffsetsptr class}}


\begin{longtable}{l|p{11cm}}
\caption{Classes of attribute value}
\label{tab:classesofattributevalue} \\
\hline \bfseries Attribute Class & \bfseries General Use and Encoding \\ \hline
\endfirsthead
  \bfseries Attribute Class & \bfseries General Use and Encoding \\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot

\hypertarget{chap:classaddress}{}
\livelinki{datarep:classaddress}{address}{address class}
&Refers to some location in the address space of the described program.
\\

\hypertarget{chap:classaddrptr}{}
\livelinki{datarep:classaddrptr}{addrptr}{addrptr class}
&Refers to a base location in the DWARF section that holds
a series of machine address values. Certain attributes refer
one of these addresses by indexing relative to this base
location.
\\

\hypertarget{chap:classblock}{}
\livelinki{datarep:classblock}{block}{block class}
& An arbitrary number of uninterpreted bytes of data.
\\
 
\hypertarget{chap:classconstant}{}
\livelinki{datarep:classconstant}{constant}{constant class}
&One, two, four or eight bytes of uninterpreted data, or data
encoded in the variable length format known as LEB128 
(see Section \refersec{datarep:variablelengthdata}).

\textit{Most constant values are integers of one kind or
another (codes, offsets, counts, and so on); these are
sometimes called \doublequote{integer constants} for emphasis.}
\addtoindexx{integer constant}
\addtoindexx{constant class!integer}
\\

\hypertarget{chap:classexprloc}{}
\livelinki{datarep:classexprloc}{exprloc}{exprloc class}
&A DWARF expression or location description.
\\

\hypertarget{chap:classflag}{}
\livelinki{datarep:classflag}{flag}{flag class}
&A small constant that indicates the presence or absence of an attribute.
\\

\hypertarget{chap:classlineptr}{}
\livelinki{datarep:classlineptr}{lineptr}{lineptr class}
&Refers to a location in the DWARF section that holds line number information.
\\

\hypertarget{chap:classloclistptr}{}
\livelinki{datarep:classloclistptr}{loclistptr}{loclistptr class}
&Refers to a location in the DWARF section that holds location lists, which
describe objects whose location can change during their lifetime.
\\

\hypertarget{chap:classmacptr}{}
\livelinki{datarep:classmacptr}{macptr}{macptr class}
& Refers to a location in the DWARF section that holds macro definition
 information.
\\

\hypertarget{chap:classrangelistptr}{}
\livelinki{datarep:classrangelistptr}{rangelistptr}{rangelistptr class}
& Refers to a location in the DWARF section that holds non\dash contiguous address ranges.
\\

\hypertarget{chap:classreference}{}
\livelinki{datarep:classreference}{reference}{reference class}
& Refers to one of the debugging information
entries that describe the program.  There are three types of
reference. The first is an offset relative to the beginning
of the compilation unit in which the reference occurs and must
refer to an entry within that same compilation unit. The second
type of reference is the offset of a debugging information
entry in any compilation unit, including one different from
the unit containing the reference. The third type of reference
is an indirect reference to a 
\addtoindexx{type signature}
type definition using a 64\dash bit signature 
for that type.
\\

\hypertarget{chap:classstring}{}
\livelinki{datarep:classstring}{string}{string class}
& A null\dash terminated sequence of zero or more
(non\dash null) bytes. Data in this class are generally
printable strings. Strings may be represented directly in
the debugging information entry or as an offset in a separate
string table.
\\

\hypertarget{chap:classstroffsetsptr}{}
\livelinki{datarep:classstroffsetsptr}{stroffsetsptr}{stroffsetsptr class}
&Refers to a base location in the DWARF section that holds
a series of offsets in the DWARF section that holds strings.
Certain attributes refer one of these offets by indexing 
relative to this base location. The resulting offset is then 
used to index into the DWARF string section.
\\

\hline
\end{longtable}


\section{Relationship of Debugging Information Entries}
\label{chap:relationshipofdebugginginformationentries}
\textit{%
A variety of needs can be met by permitting a single
\addtoindexx{debugging information entry!ownership relation}
debugging information entry to \doublequote{own} an arbitrary number
of other debugging entries and by permitting the same debugging
information entry to be one of many owned by another debugging
information entry. 
This makes it possible, for example, to
describe the static \livelink{chap:lexicalblock}{block} structure 
within a source file,
to show the members of a structure, union, or class, and to
associate declarations with source files or source files
with shared objects.  
}


The ownership relation 
\addtoindexx{debugging information entry!ownership relation}
of debugging
information entries is achieved naturally because the debugging
information is represented as a tree. 
The nodes of the tree
are the debugging information entries themselves. 
The child
entries of any node are exactly those debugging information
entries owned by that node.  

\textit{%
While the ownership relation
of the debugging information entries is represented as a
tree, other relations among the entries exist, for example,
a reference from an entry representing a variable to another
entry representing the type of that variable. 
If all such
relations are taken into account, the debugging entries
form a graph, not a tree.  
}

\needlines{4}
The tree itself is represented
by flattening it in prefix order. 
Each debugging information
entry is defined either to have child entries or not to have
child entries (see Section \refersec{datarep:abbreviationstables}). 
If an entry is defined not
to have children, the next physically succeeding entry is a
sibling. 
If an entry is defined to have children, the next
physically succeeding entry is its first child. 
Additional
children are represented as siblings of the first child. 
A chain of sibling entries is terminated by a null entry.

In cases where a producer of debugging information feels that
\hypertarget{chap:DWATsiblingdebugginginformationentryrelationship}{}
it will be important for consumers of that information to
quickly scan chains of sibling entries, while ignoring the
children of individual siblings, that producer may attach 
\addtoindexx{sibling attribute}
a
\DWATsibling{} attribute 
to any debugging information entry. 
The
value of this attribute is a reference to the sibling entry
of the entry to which the attribute is attached.


\section{Target Addresses}
\label{chap:targetaddresses}
Many places in this document 
refer
\addtoindexx{address size|see{size of an address}}
to the size 
of an
\addtoindexi{address}{size of an address}
on the target architecture (or equivalently, target machine)
to which a DWARF description applies. For processors which
can be configured to have different address sizes or different
instruction sets, the intent is to refer to the configuration
which is either the default for that processor or which is
specified by the object file or executable file which contains
the DWARF information.

\textit{%
For example, if a particular target architecture supports
both 32\dash bit and 64\dash bit addresses, the compiler will generate
an object file which specifies that it contains executable
code generated for one or the other of these 
\addtoindexx{size of an address}
address sizes. In
that case, the DWARF debugging information contained in this
object file will use the same address size.
}

\textit{%
Architectures which have multiple instruction sets are
supported by the isa entry in the line number information
(see Section \refersec{chap:statemachineregisters}).
}

\section{DWARF Expressions}
\label{chap:dwarfexpressions}
DWARF expressions describe how to compute a value or name a
location during debugging of a program. 
They are expressed in
terms of DWARF operations that operate on a stack of values.

All DWARF operations are encoded as a stream of opcodes that
are each followed by zero or more literal operands. 
The number
of operands is determined by the opcode.  

In addition to the
general operations that are defined here, operations that are
specific to location descriptions are defined in 
Section \refersec{chap:locationdescriptions}.

\subsection{General Operations}
\label{chap:generaloperations}
Each general operation represents a postfix operation on
a simple stack machine. Each element of the stack is the
\addtoindex{size of an address} on the target machine. 
The value on the
top of the stack after \doublequote{executing} the 
\addtoindex{DWARF expression}
is 
\addtoindexx{DWARF expression|see{location description}}
taken to be the result (the address of the object, the
value of the array bound, the length of a dynamic string,
the desired value itself, and so on).

\subsubsection{Literal Encodings}
\label{chap:literalencodings}
The 
\addtoindexx{DWARF expression!literal encodings}
following operations all push a value onto the DWARF
stack. 
\addtoindexx{DWARF expression!stack operations}
If the value of a constant in one of these operations
is larger than can be stored in a single stack element, the
value is truncated to the element size and the low\dash order bits
are pushed on the stack.
\begin{enumerate}[1. ]
\itembfnl{\DWOPlitzeroTARG, \DWOPlitoneTARG, \dots, \DWOPlitthirtyoneTARG}
The \DWOPlitnTARG{} operations encode the unsigned literal values
from 0 through 31, inclusive.

\itembfnl{\DWOPaddrTARG}
The \DWOPaddrNAME{} operation has a single operand that encodes
a machine address and whose size is the \addtoindex{size of an address}
on the target machine.

\itembfnl{\DWOPconstoneuTARG, \DWOPconsttwouTARG, \DWOPconstfouruTARG, \DWOPconsteightuTARG}
\DWOPconstnxMARK{}
The single operand of a \DWOPconstnuNAME{} operation provides a 1,
2, 4, or 8\dash byte unsigned integer constant, respectively.

\itembfnl{\DWOPconstonesTARG, \DWOPconsttwosTARG, \DWOPconstfoursTARG, \DWOPconsteightsTARG}
The single operand of a \DWOPconstnsNAME{} operation provides a 1,
2, 4, or 8\dash byte signed integer constant, respectively.

\itembfnl{\DWOPconstuTARG}
The single operand of the \DWOPconstuNAME{} operation provides
an unsigned LEB128\addtoindexx{LEB128!unsigned} integer constant.

\itembfnl{\DWOPconstsTARG}
The single operand of the \DWOPconstsNAME{} operation provides
a signed LEB128\addtoindexx{LEB128!unsigned} integer constant.

\needlines{4}
\itembfnl{\DWOPaddrxTARG}
The \DWOPaddrxNAME{} operation has a single operand that
encodes an unsigned LEB128\addtoindexx{LEB128!unsigned} value, 
which is a zero-based index into the \dotdebugaddr{} section, 
where a machine address is stored.
This index is relative to the value of the 
\DWATaddrbase{} attribute of the associated compilation unit.

\itembfnl{\DWOPconstxTARG}
The \DWOPconstxNAME{} operation has a single operand that
encodes an unsigned LEB128\addtoindexx{LEB128!unsigned} value, 
which is a zero-based
index into the \dotdebugaddr{} section, where a constant, the
size of a machine address, is stored.
This index is relative to the value of the 
\DWATaddrbase{} attribute of the associated compilation unit.

\textit{The \DWOPconstxNAME{} operation is provided for constants that
require link-time relocation but should not be
interpreted by the consumer as a relocatable address
(for example, offsets to thread-local storage).}

\end{enumerate}


\subsubsection{Register Based Addressing}
\label{chap:registerbasedaddressing}
The following operations push a value onto the stack that is
\addtoindexx{DWARF expression!register based addressing}
the result of adding the contents of a register to a given
signed offset.
\begin{enumerate}[1. ]
\itembfnl{\DWOPfbregTARG}
The \DWOPfbregTARG{} operation provides a 
signed LEB128\addtoindexx{LEB128!signed} offset
from the address specified by the location description in the
\DWATframebase{} attribute of the current function. (This
is typically a \doublequote{stack pointer} register plus or minus
some offset. On more sophisticated systems it might be a
location list that adjusts the offset according to changes
in the stack pointer as the PC changes.)

\itembfnl{\DWOPbregzeroTARG, \DWOPbregoneTARG, \dots, \DWOPbregthirtyoneTARG}
The single operand of the \DWOPbregnTARG{} 
operations provides
a signed LEB128\addtoindexx{LEB128!signed} offset from
the specified register.

\itembfnl{\DWOPbregxTARG{} }
The \DWOPbregxINDX{} operation has two operands: a register
which is specified by an unsigned LEB128\addtoindexx{LEB128!unsigned}
number, followed by a signed LEB128\addtoindexx{LEB128!signed} offset.

\end{enumerate}


\subsubsection{Stack Operations}
\label{chap:stackoperations}
The following 
\addtoindexx{DWARF expression!stack operations}
operations manipulate the DWARF stack. Operations
that index the stack assume that the top of the stack (most
recently added entry) has index 0.
\begin{enumerate}[1. ]
\itembfnl{\DWOPdupTARG}
The \DWOPdupTARG{} operation duplicates the value at the top of the stack.

\itembfnl{\DWOPdropTARG}
The \DWOPdropTARG{} operation pops the value at the top of the stack.

\itembfnl{\DWOPpickTARG}
The single operand of the \DWOPpickTARG{} operation provides a
1\dash byte index. A copy of the stack entry with the specified
index (0 through 255, inclusive) is pushed onto the stack.

\itembfnl{\DWOPoverTARG}
The \DWOPoverTARG{} operation duplicates the entry currently second
in the stack at the top of the stack. 
This is equivalent to
a \DWOPpick{} operation, with index 1.  

\itembfnl{\DWOPswapTARG}
The \DWOPswapTARG{} operation swaps the top two stack entries. 
The entry at the top of the
stack becomes the second stack entry, 
and the second entry becomes the top of the stack.

\itembfnl{\DWOProtTARG}
The \DWOProtTARG{} operation rotates the first three stack
entries. The entry at the top of the stack becomes the third
stack entry, the second entry becomes the top of the stack,
and the third entry becomes the second entry.

\itembfnl{\DWOPderefTARG}
The \DWOPderefTARG{} 
operation  pops the top stack entry and 
treats it as an address. The value
retrieved from that address is pushed. 
The size of the data retrieved from the 
\addtoindexi{dereferenced}{address!dereference operator}
address is the \addtoindex{size of an address} on the target machine.

\needlines{4}
\itembfnl{\DWOPderefsizeTARG}
The \DWOPderefsizeTARG{} operation behaves like the 
\DWOPderef{}
operation: it pops the top stack entry and treats it as an
address. The value retrieved from that address is pushed. In
the \DWOPderefsizeINDX{} operation, however, the size in bytes
of the data retrieved from the dereferenced address is
specified by the single operand. This operand is a 1\dash byte
unsigned integral constant whose value may not be larger
than the \addtoindex{size of an address} on the target machine. The data
retrieved is zero extended to the size of an address on the
target machine before being pushed onto the expression stack.

\needlines{7}
\itembfnl{\DWOPxderefTARG}
The \DWOPxderefTARG{} operation provides an extended dereference
mechanism. The entry at the top of the stack is treated as an
address. The second stack entry is treated as an \doublequote{address
space identifier} for those architectures that support
\addtoindexi{multiple}{address space!multiple}
address spaces. The top two stack elements are popped,
and a data item is retrieved through an implementation-defined
address calculation and pushed as the new stack top. The size
of the data retrieved from the 
\addtoindexi{dereferenced}{address!dereference operator}
address is the
\addtoindex{size of an address} on the target machine.

\itembfnl{\DWOPxderefsizeTARG}
The \DWOPxderefsizeTARG{} operation behaves like the
\DWOPxderef{} operation. The entry at the top of the stack is
treated as an address. The second stack entry is treated as
an \doublequote{address space identifier} for those architectures
that support 
\addtoindexi{multiple}{address space!multiple}
address spaces. The top two stack
elements are popped, and a data item is retrieved through an
implementation\dash defined address calculation and pushed as the
new stack top. In the \DWOPxderefsizeINDX{} operation, however,
the size in bytes of the data retrieved from the 
\addtoindexi{dereferenced}{address!dereference operator}
address is specified by the single operand. This operand is a
1\dash byte unsigned integral constant whose value may not be larger
than the \addtoindex{size of an address} on the target machine. The data
retrieved is zero extended to the \addtoindex{size of an address} on the
target machine before being pushed onto the expression stack.

\itembfnl{\DWOPpushobjectaddressTARG}
The \DWOPpushobjectaddressTARG{}
operation pushes the address
of the object currently being evaluated as part of evaluation
of a user presented expression. This object may correspond
to an independent variable described by its own debugging
information entry or it may be a component of an array,
structure, or class whose address has been dynamically
determined by an earlier step during user expression
evaluation.

\textit{This operator provides explicit functionality
(especially for arrays involving descriptors) that is analogous
to the implicit push of the base 
\addtoindexi{address}{address!implicit push of base}
of a structure prior to evaluation of a 
\DWATdatamemberlocation{} 
to access a data member of a structure. For an example, see 
Appendix \refersec{app:aggregateexamples}.}

\needlines{4}
\itembfnl{\DWOPformtlsaddressTARG}
The \DWOPformtlsaddressTARG{} 
operation pops a value from the stack, translates this
value into an address in the 
\addtoindexx{thread-local storage}
thread\dash local storage for a thread, and pushes the address 
onto the stack. 
The meaning of the value on the top of the stack prior to this 
operation is defined by the run-time environment.  If the run-time 
environment supports multiple thread\dash local storage 
\nolink{blocks} for a single thread, then the \nolink{block} 
corresponding to the executable or shared 
library containing this DWARF expression is used.
   
\textit{Some implementations of 
\addtoindex{C} and \addtoindex{C++} support a
thread\dash local storage class. Variables with this storage class
have distinct values and addresses in distinct threads, much
as automatic variables have distinct values and addresses in
each function invocation. Typically, there is a single \nolink{block}
of storage containing all thread\dash local variables declared in
the main executable, and a separate \nolink{block} for the variables
declared in each shared library. 
Each thread\dash local variable can then be accessed in its block using an
identifier. This identifier is typically an offset into the block and pushed
onto the DWARF stack by one of the 
\DWOPconstnx{} operations prior to the
\DWOPformtlsaddress{} operation. 
Computing the address of
the appropriate \nolink{block} can be complex (in some cases, the
compiler emits a function call to do it), and difficult
to describe using ordinary DWARF location descriptions.
Instead of    forcing complex thread-local storage calculations into 
the DWARF expressions, the \DWOPformtlsaddress{} allows the consumer 
to perform the computation based on the run-time environment.}

\itembfnl{\DWOPcallframecfaTARG}
The \DWOPcallframecfaTARG{} 
operation pushes the value of the
CFA, obtained from the Call Frame Information 
(see Section \refersec{chap:callframeinformation}).

\textit{Although the value of \DWATframebase{}
can be computed using other DWARF expression operators,
in some cases this would require an extensive location list
because the values of the registers used in computing the
CFA change during a subroutine. If the 
Call Frame Information 
is present, then it already encodes such changes, and it is
space efficient to reference that.}
\end{enumerate}

\subsubsection{Arithmetic and Logical Operations}
The 
\addtoindexx{DWARF expression!arithmetic operations}
following 
\addtoindexx{DWARF expression!logical operations}
provide arithmetic and logical operations. Except
as otherwise specified, the arithmetic operations perform
addressing arithmetic, that is, unsigned arithmetic that is
performed modulo one plus the largest representable address
(for example, 0x100000000 when the 
\addtoindex{size of an address} is 32 bits). 
Such operations do not cause an exception on overflow.

\needlines{4}
\begin{enumerate}[1. ]
\itembfnl{\DWOPabsTARG}
The \DWOPabsTARG{} operation pops the top stack entry, interprets
it as a signed value and pushes its absolute value. If the
absolute value cannot be represented, the result is undefined.

\needlines{4}
\itembfnl{\DWOPandTARG}
The \DWOPandTARG{} operation pops the top two stack values, performs
a bitwise and operation on the two, and pushes the result.

\itembfnl{\DWOPdivTARG}
The \DWOPdivTARG{} operation pops the top two stack values, divides the former second entry by
the former top of the stack using signed division, and pushes the result.

\itembfnl{\DWOPminusTARG}
The \DWOPminusTARG{} operation pops the top two stack values, subtracts the former top of the
stack from the former second entry, and pushes the result.

\itembfnl{\DWOPmodTARG}
The \DWOPmodTARG{} operation pops the top two stack values and pushes the result of the
calculation: former second stack entry modulo the former top of the stack.

\itembfnl{\DWOPmulTARG}
The \DWOPmulTARG{} operation pops the top two stack entries, multiplies them together, and
pushes the result.

\itembfnl{\DWOPnegTARG}
The \DWOPnegTARG{} operation pops the top stack entry, interprets
it as a signed value and pushes its negation. If the negation
cannot be represented, the result is undefined.

\itembfnl{\DWOPnotTARG}
The \DWOPnotTARG{} operation pops the top stack entry, and pushes
its bitwise complement.

\itembfnl{\DWOPorTARG}
The \DWOPorTARG{} operation pops the top two stack entries, performs
a bitwise or operation on the two, and pushes the result.

\itembfnl{\DWOPplusTARG}
The \DWOPplusTARG{} operation pops the top two stack entries,
adds them together, and pushes the result.

\needlines{6}
\itembfnl{\DWOPplusuconstTARG}
The \DWOPplusuconstTARG{} operation pops the top stack entry,
adds it to the unsigned LEB128\addtoindexx{LEB128!unsigned}
constant operand and pushes the result.

\textit{This operation is supplied specifically to be
able to encode more field offsets in two bytes than can be
done with
\doublequote{\DWOPlitn~\DWOPplus.}}

\needlines{3}
\itembfnl{\DWOPshlTARG}
The \DWOPshlTARG{} operation pops the top two stack entries,
shifts the former second entry left (filling with zero bits)
by the number of bits specified by the former top of the stack,
and pushes the result.

\itembfnl{\DWOPshrTARG}
The \DWOPshrTARG{} operation pops the top two stack entries,
shifts the former second entry right logically (filling with
zero bits) by the number of bits specified by the former top
of the stack, and pushes the result.

\needlines{6}
\itembfnl{\DWOPshraTARG}
The \DWOPshraTARG{} operation pops the top two stack entries,
shifts the former second entry right arithmetically (divide
the magnitude by 2, keep the same sign for the result) by
the number of bits specified by the former top of the stack,
and pushes the result.

\itembfnl{\DWOPxorTARG}
The \DWOPxorTARG{} operation pops the top two stack entries,
performs a bitwise exclusive\dash or operation on the two, and
pushes the result.

\end{enumerate}

\subsubsection{Control Flow Operations}
\label{chap:controlflowoperations}
The 
\addtoindexx{DWARF expression!control flow operations}
following operations provide simple control of the flow of a DWARF expression.
\begin{enumerate}[1. ]
\itembfnl{\DWOPleTARG, \DWOPgeTARG, \DWOPeqTARG, \DWOPltTARG, \DWOPgtTARG, \DWOPneTARG}
The six relational operators each:
\begin{itemize}
\item pop the top two stack values,

\item compare the operands:
\linebreak
\textless~former second entry~\textgreater  \textless~relational operator~\textgreater \textless~former top entry~\textgreater

\item push the constant value 1 onto the stack 
if the result of the operation is true or the
constant value 0 if the result of the operation is false.
\end{itemize}

Comparisons are performed as signed operations. The six
operators are \DWOPleINDX{} (less than or equal to), \DWOPgeINDX{}
(greater than or equal to), \DWOPeqINDX{} (equal to), \DWOPltINDX{} (less
than), \DWOPgtINDX{} (greater than) and \DWOPneINDX{} (not equal to).

\needlines{6}
\itembfnl{\DWOPskipTARG}
\DWOPskipTARG{} is an unconditional branch. Its single operand
is a 2\dash byte signed integer constant. The 2\dash byte constant is
the number of bytes of the DWARF expression to skip forward
or backward from the current operation, beginning after the
2\dash byte constant.

\itembfnl{\DWOPbraTARG}
\DWOPbraTARG{} is a conditional branch. Its single operand is a
2\dash byte signed integer constant.  This operation pops the
top of stack. If the value popped is not the constant 0,
the 2\dash byte constant operand is the number of bytes of the
DWARF expression to skip forward or backward from the current
operation, beginning after the 2\dash byte constant.

% The following item does not correctly hyphenate leading
% to an overfull hbox and a visible artifact. 
% So we use \- to suggest hyphenation in this rare situation.
\itembfnl{\DWOPcalltwoTARG, \DWOPcallfourTARG, \DWOPcallrefTARG}
\DWOPcalltwoINDX, 
\DWOPcallfourINDX, 
and \DWOPcallrefINDX{} perform
subroutine calls during evaluation of a DWARF expression or
location description. 
For \DWOPcalltwoINDX{} and \DWOPcallfour{}, 
the operand is the 2\dash~ or 4\dash byte unsigned offset, respectively,
of a debugging information entry in the current compilation
unit. The \DWOPcallref{} operator has a single operand. In the
\thirtytwobitdwarfformat,
the operand is a 4\dash byte unsigned value;
in the \sixtyfourbitdwarfformat, it is an 8\dash byte unsigned value
(see Section \refersec{datarep:32bitand64bitdwarfformats}). 
The operand is used as the offset of a
debugging information entry in a 
\dotdebuginfo{}
section which may be contained in a shared object or executable
other than that containing the operator. For references from
one shared object or executable to another, the relocation
must be performed by the consumer.  

\textit{Operand interpretation of
\DWOPcalltwo, \DWOPcallfour{} and \DWOPcallref{} is exactly like
that for \DWFORMreftwo, \DWFORMreffour{} and \DWFORMrefaddr,
respectively  
(see Section  \refersec{datarep:attributeencodings}).  
}

These operations transfer
control of DWARF expression evaluation to 
\addtoindexx{location attribute}
the 
\DWATlocation{}
attribute of the referenced debugging information entry. If
there is no such attribute, then there is no effect. Execution
of the DWARF expression of 
\addtoindexx{location attribute}
a 
\DWATlocation{} attribute may add
to and/or remove from values on the stack. Execution returns
to the point following the call when the end of the attribute
is reached. Values on the stack at the time of the call may be
used as parameters by the called expression and values left on
the stack by the called expression may be used as return values
by prior agreement between the calling and called expressions.
\end{enumerate}

\needlines{7}
\subsubsection{Special Operations}
There 
\addtoindexx{DWARF expression!special operations}
are these special operations currently defined:
\begin{enumerate}[1. ]
\itembfnl{\DWOPnopNAME}
The \DWOPnopTARG{} operation is a place holder. It has no effect
on the location stack or any of its values.

\itembfnl{\DWOPentryvalueNAME}
The \DWOPentryvalueTARG{} operation pushes a value that had a known location
upon entering the current subprogram.  It uses two operands: an 
unsigned LEB128\addtoindexx{LEB128!unsigned} length, followed by 
a block containing a DWARF expression or
a simple register location description.  The length gives the length
in bytes of the block.  If the block contains a register location
description, \DWOPentryvalueNAME{} pushes the value that register had upon
entering the current subprogram.  If the block contains a DWARF expression,
the DWARF expression is evaluated as if it has been evaluated upon entering
the current subprogram.  The DWARF expression should not assume any values
being present on the DWARF stack initially and should result in exactly one
value being pushed on the DWARF stack when completed.  That value is the value
being pushed by the \DWOPentryvalueNAME{} operation.  

\DWOPpushobjectaddress{} is not meaningful inside of this DWARF operation.

\textit{The \DWOPentryvalueNAME{} operation can be used by consumers if they are able
to find the call site in the caller function, unwind to it and the corresponding
\DWTAGcallsiteparameter{} entry has \DWATcallvalue{} or
\DWATcalldatavalue{} attributes that can be evaluated to find out the
value a function parameter had on the first instruction in the function.
Or non-interactive consumers which know what variables will need to be
inspected ahead of running the debugged program could put breakpoint
on the first instruction in functions where there is no other way to find
some variable's value, but evaluating \DWOPentryvalueNAME{} operation.  The
consumer can collect there the value of registers or memory referenced in
\DWOPentryvalueNAME{} operations, then continue to breakpoints where the values
of variables or parameters need to be inspected and use there the remembered
register or memory values during \DWOPentryvalueNAME{} evaluation.
}

\end{enumerate}

\subsection{Example Stack Operations}
\textit {The 
\addtoindexx{DWARF expression!examples}
stack operations defined in 
Section \refersec{chap:stackoperations}.
are fairly conventional, but the following
examples illustrate their behavior graphically.}

\begin{longtable}[c]{rrcrr} 
\multicolumn{2}{c}{Before} & Operation & \multicolumn{2}{c}{After} \\
\hline
\endhead
\endfoot
0& 17& \DWOPdup{} &0 &17 \\
1&   29& &  1 & 17 \\
2& 1000 & & 2 & 29\\
& & &         3&1000\\

& & & & \\
0 & 17 & \DWOPdrop{} & 0 & 29 \\
1 &29  &            & 1 & 1000 \\
2 &1000& & &          \\

& & & & \\
0 & 17 & \DWOPpick, 2 & 0 & 1000 \\
1 & 29 & & 1&17 \\
2 &1000& &2&29 \\
  &    & &3&1000 \\

& & & & \\
0&17& \DWOPover&0&29 \\
1&29& &  1&17 \\
2&1000 & & 2&29\\
 &     & & 3&1000 \\

& & & & \\
0&17& \DWOPswap{} &0&29 \\
1&29& &  1&17 \\
2&1000 & & 2&1000 \\

& & & & \\
0&17&\DWOProt{} & 0 &29 \\
1&29 & & 1 & 1000 \\
2& 1000 & &  2 & 17 \\
\end{longtable}

\section{Location Descriptions}
\label{chap:locationdescriptions}
\textit{Debugging information 
\addtoindexx{location description}
must 
\addtoindexx{location description|see{\textit{also} DWARF expression}}
provide consumers a way to find
the location of program variables, determine the bounds
of dynamic arrays and strings, and possibly to find the
base address of a subroutine\textquoteright s stack frame or the return
address of a subroutine. Furthermore, to meet the needs of
recent computer architectures and optimization techniques,
debugging information must be able to describe the location of
an object whose location changes over the object\textquoteright s lifetime.}

Information about the location of program objects is provided
by location descriptions. Location descriptions can be either
of two forms:
\begin{enumerate}[1. ]
\item \textit{Single location descriptions}, 
which 
\addtoindexx{location description!single}
are 
\addtoindexx{single location description}
a language independent representation of
addressing rules of arbitrary complexity built from 
DWARF expressions (See Section \refersec{chap:dwarfexpressions}) 
and/or other
DWARF operations specific to describing locations. They are
sufficient for describing the location of any object as long
as its lifetime is either static or the same as the 
\livelink{chap:lexicalblock}{lexical block} that owns it, 
and it does not move during its lifetime.

Single location descriptions are of two kinds:
\begin{enumerate}[a) ]
\item Simple location descriptions, which describe the location
\addtoindexx{location description!simple}
of one contiguous piece (usually all) of an object. A simple
location description may describe a location in addressable
memory, or in a register, or the lack of a location (with or
without a known value).

\item  Composite location descriptions, which describe an
\addtoindexx{location description!composite}
object in terms of pieces each of which may be contained in
part of a register or stored in a memory location unrelated
to other pieces.

\end{enumerate}
\item \textit{Location lists}, which are used to 
\addtoindexx{location list}
describe
\addtoindexx{location description!use in location list}
objects that have a limited lifetime or change their location
during their lifetime. Location lists are described in
Section \refersec{chap:locationlists} below.

\end{enumerate}

Location descriptions are distinguished in a context sensitive
manner. As the value of an attribute, a location description
is encoded using 
\addtoindexx{exprloc class}
class \livelink{chap:classexprloc}{exprloc}  
and a location list is encoded
using class \livelink{chap:classloclistptr}{loclistptr}
(which 
\addtoindex{loclistptr}
serves as an offset into a
separate 
\addtoindexx{location list}
location list table).


\subsection{Single Location Descriptions}
A single location description is either:
\begin{enumerate}[1. ]
\item A simple location description, representing an object
\addtoindexx{location description!simple}
which 
\addtoindexx{simple location description}
exists in one contiguous piece at the given location, or 
\item A composite location description consisting of one or more
\addtoindexx{location description!composite}
simple location descriptions, each of which is followed by
one composition operation. Each simple location description
describes the location of one piece of the object; each
composition operation describes which part of the object is
located there. Each simple location description that is a
DWARF expression is evaluated independently of any others
(as though on its own separate stack, if any). 
\end{enumerate}



\subsubsection{Simple Location Descriptions}

A 
\addtoindexx{location description!simple}
simple location description consists of one 
contiguous piece or all of an object or value.


\subsubsubsection{Memory Location Descriptions}
A 
\addtoindexx{location description!memory}
memory location description 
\addtoindexx{memory location description}
consists of a non\dash empty DWARF
expression (see 
Section \refersec{chap:dwarfexpressions}
), whose value is the address of
a piece or all of an object or other entity in memory.

\subsubsubsection{Register Location Descriptions}
\label{chap:registerlocationdescriptions}
A register location description consists of a register name
operation, which represents a piece or all of an object
located in a given register.

\textit{Register location descriptions describe an object
(or a piece of an object) that resides in a register, while
the opcodes listed in 
Section \refersec{chap:registerbasedaddressing}
are used to describe an object (or a piece of
an object) that is located in memory at an address that is
contained in a register (possibly offset by some constant). A
register location description must stand alone as the entire
description of an object or a piece of an object.
}

The following DWARF operations can be used to name a register.


\textit{Note that the register number represents a DWARF specific
mapping of numbers onto the actual registers of a given
architecture. The mapping should be chosen to gain optimal
density and should be shared by all users of a given
architecture. It is recommended that this mapping be defined
by the ABI authoring committee for each architecture.
}
\begin{enumerate}[1. ]
\itembfnl{\DWOPregzeroTARG, \DWOPregoneTARG, ..., \DWOPregthirtyoneTARG}
The \DWOPregnTARG{} operations encode the names of up to 32
registers, numbered from 0 through 31, inclusive. The object
addressed is in register \textit{n}.

\needlines{4}
\itembfnl{\DWOPregxTARG}
The \DWOPregxTARG{} operation has a single 
unsigned LEB128\addtoindexx{LEB128!unsigned} literal
operand that encodes the name of a register.  

\end{enumerate}

\textit{These operations name a register location. To
fetch the contents of a register, it is necessary to use
one of the register based addressing operations, such as
\DWOPbregx{} 
(Section \refersec{chap:registerbasedaddressing})}.

\subsubsubsection{Implicit Location Descriptions}
An \addtoindex{implicit location description}
represents a piece or all
\addtoindexx{location description!implicit}
of an object which has no actual location but whose contents
are nonetheless either known or known to be undefined.

The following DWARF operations may be used to specify a value
that has no location in the program but is a known constant
or is computed from other locations and values in the program.

The following DWARF operations may be used to specify a value
that has no location in the program but is a known constant
or is computed from other locations and values in the program.
\begin{enumerate}[1. ]
\itembfnl{\DWOPimplicitvalueTARG}
The \DWOPimplicitvalueTARG{} 
operation specifies an immediate value
using two operands: an unsigned LEB128\addtoindexx{LEB128!unsigned}
length, followed by
%FIXME: should this block be a reference? To what?
a \nolink{block} representing the value in the memory representation
of the target machine. The length operand gives the length
in bytes of the \nolink{block}.

\itembfnl{\DWOPstackvalueTARG}
The \DWOPstackvalueTARG{} 
operation specifies that the object
does not exist in memory but its value is nonetheless known
and is at the top of the DWARF expression stack. In this form
of location description, the DWARF expression represents the
actual value of the object, rather than its location. The
\DWOPstackvalueINDX{} operation terminates the expression.

\itembfnl{\DWOPimplicitpointerTARG}
The \DWOPimplicitpointerNAME{} operation specifies that the object
is a pointer that cannot be represented as a real pointer,
even though the value it would point to can be described. In
this form of location description, the DWARF expression refers
to a debugging information entry that represents the actual
value of the object to which the pointer would point. Thus, a
consumer of the debug information would be able to show the
value of the dereferenced pointer, even when it cannot show
the value of the pointer itself.

\needlines{5}
The \DWOPimplicitpointerNAME{} operation has two operands: a 
reference to a debugging information entry that describes 
the dereferenced object's value, and a signed number that 
is treated as a byte offset from the start of that value. 
The first operand is a 4-byte unsigned value in the 32-bit 
DWARF format, or an 8-byte unsigned value in the 64-bit 
DWARF format (see Section 
\refersec{datarep:32bitand64bitdwarfformats}).
The second operand is a 
signed LEB128\addtoindexx{LEB128!signed} number.

The first operand is used as the offset of a debugging
information entry in a \dotdebuginfo{} section, which may be
contained in a shared object or executable other than that
containing the operator. For references from one shared object
or executable to another, the relocation must be performed by
the consumer.

\textit{The debugging information entry referenced by a 
\DWOPimplicitpointerNAME{} operation is typically a
\DWTAGvariable{} or \DWTAGformalparameter{} entry whose
\DWATlocation{} attribute gives a second DWARF expression or a
location list that describes the value of the object, but the
referenced entry may be any entry that contains a \DWATlocation{}
or \DWATconstvalue{} attribute (for example, \DWTAGdwarfprocedure).
By using the second DWARF expression, a consumer can
reconstruct the value of the object when asked to dereference
the pointer described by the original DWARF expression
containing the \DWOPimplicitpointer{} operation.}

\end{enumerate}

\textit{DWARF location expressions are intended to yield the \textbf{location}
of a value rather than the value itself. An optimizing compiler
may perform a number of code transformations where it becomes
impossible to give a location for a value, but remains possible
to describe the value itself. 
Section \refersec{chap:registerlocationdescriptions}
describes operators that can be used to
describe the location of a value when that value exists in a
register but not in memory. The operations in this section are
used to describe values that exist neither in memory nor in a
single register.}

\paragraph{Empty Location Descriptions}

An \addtoindex{empty location description}
consists of a DWARF expression
\addtoindexx{location description!empty}
containing no operations. It represents a piece or all of an
object that is present in the source but not in the object code
(perhaps due to optimization).

\needlines{5}
\subsubsection{Composite Location Descriptions}
A composite location description describes an object or
value which may be contained in part of a register or stored
in more than one location. Each piece is described by a
composition operation, which does not compute a value nor
store any result on the DWARF stack. There may be one or
more composition operations in a single composite location
description. A series of such operations describes the parts
of a value in memory address order.

Each composition operation is immediately preceded by a simple
location description which describes the location where part
of the resultant value is contained.
\begin{enumerate}[1. ]
\itembfnl{\DWOPpieceTARG}
The \DWOPpieceTARG{} operation takes a 
single operand, which is an
unsigned LEB128\addtoindexx{LEB128!unsigned} number.  
The number describes the size in bytes
of the piece of the object referenced by the preceding simple
location description. If the piece is located in a register,
but does not occupy the entire register, the placement of
the piece within that register is defined by the ABI.

\textit{Many compilers store a single variable in sets of registers,
or store a variable partially in memory and partially in
registers. \DWOPpieceINDX{} provides a way of describing how large
a part of a variable a particular DWARF location description
refers to. }

\itembfnl{\DWOPbitpieceTARG}
The \DWOPbitpieceTARG{} 
operation takes two operands. The first
is an unsigned LEB128\addtoindexx{LEB128!unsigned} 
number that gives the size in bits
of the piece. The second is an 
unsigned LEB128\addtoindexx{LEB128!unsigned} number that
gives the offset in bits from the location defined by the
preceding DWARF location description.  

Interpretation of the
offset depends on the kind of location description. If the
location description is empty, the offset doesn\textquoteright t matter and
the \DWOPbitpieceINDX{} operation describes a piece consisting
of the given number of bits whose values are undefined. If
the location is a register, the offset is from the least
significant bit end of the register. If the location is a
memory address, the \DWOPbitpieceINDX{} operation describes a
sequence of bits relative to the location whose address is
on the top of the DWARF stack using the bit numbering and
direction conventions that are appropriate to the current
language on the target system. If the location is any implicit
value or stack value, the \DWOPbitpieceINDX{} operation describes
a sequence of bits using the least significant bits of that
value.  
\end{enumerate}

\textit{\DWOPbitpieceINDX{} is 
used instead of \DWOPpieceINDX{} when
the piece to be assembled into a value or assigned to is not
byte-sized or is not at the start of a register or addressable
unit of memory.}




\subsubsection{Example Single Location Descriptions}

Here are some examples of how DWARF operations are used to form location descriptions:
% Probably the only place that this will be used, so not in dwarf.tex?
\newcommand{\descriptionitemnl}[1]{\item[#1]\mbox{}\\}
\begin{description}
\descriptionitemnl{\DWOPregthree}
The value is in register 3.

\descriptionitemnl{\DWOPregx{} 54}
The value is in register 54.

\descriptionitemnl{\DWOPaddr{} 0x80d0045c}
The value of a static variable is at machine address 0x80d0045c.

\descriptionitemnl{\DWOPbregeleven{} 44}
Add 44 to the value in register 11 to get the address of an automatic
variable instance.

\needlines{4}
\descriptionitemnl{\DWOPfbreg{} -50}
Given a \DWATframebase{} value of
\doublequote{\DWOPbregthirtyone{} 64,} this example
computes the address of a local variable that is -50 bytes from a
logical frame pointer that is computed by adding 64 to the current
stack pointer (register 31).

\descriptionitemnl{\DWOPbregx{} 54 32 \DWOPderef}
A call-by-reference parameter whose address is in the word 32 bytes
from where register 54 points.

\needlines{4}
\descriptionitemnl{\DWOPplusuconst{} 4}
A structure member is four bytes from the start of the structure
instance. The base address is assumed to be already on the stack.

\descriptionitemnl{\DWOPregthree{} \DWOPpiece{} 4 \DWOPregten{} \DWOPpiece{} 2}
A variable whose first four bytes reside in register 3 and whose next
two bytes reside in register 10.

\descriptionitemnl{\DWOPregzero{} \DWOPpiece{} 4 \DWOPpiece{} 4 \DWOPfbreg{} -12 \DWOPpiece{} 4}
\vspace{-2\parsep}A twelve byte value whose first four bytes reside in register zero,
whose middle four bytes are unavailable (perhaps due to optimization),
and whose last four bytes are in memory, 12 bytes before the frame
base.

\descriptionitemnl{\DWOPbregone{} 0 \DWOPbregtwo{} 0 \DWOPplus{} \DWOPstackvalue{} }
Add the contents of r1 and r2 to compute a value. This value is the
\doublequote{contents} of an otherwise anonymous location.


\descriptionitemnl{\DWOPlitone{} \DWOPstackvalue{} \DWOPpiece{} 4 \DWOPbregthree{} 0 \DWOPbregfour{} 0}
\vspace{-2\parsep}\descriptionitemnl{
\hspace{0.5cm}\DWOPplus{} \DWOPstackvalue{} \DWOPpiece{} 4 \DWOPpiece{} 4}
The object value is found in an anonymous (virtual) location whose
value consists of two parts, given in memory address order: the 4 byte
value 1 followed by the four byte value computed from the sum of the
contents of r3 and r4.

\descriptionitemnl{\DWOPentryvalue{} 1 \DWOPregone{} \DWOPstackvalue }
The value register 1 had upon entering the current subprogram.

\descriptionitemnl{\DWOPentryvalue{} 2 \DWOPbregone{} 0 \DWOPstackvalue }
The value register 1 had upon entering the current subprogram (same as the previous example).
%Both of these location descriptions evaluate to the value register 1 had upon
%entering the current subprogram.

%FIXME: The following gets an undefined control sequence error for reasons unknown... 
%\descriptionitemnl{\DWOPentryvalue{} 1 \DWOPregthirtyone{} \DWOPregone{} \DWOPadd{} \DWOPstackvalue }
%The value register 31 had upon entering the current subprogram
%plus the value register 1 currently has.

\descriptionitemnl{\DWOPentryvalue{} 3 \DWOPbregfour{} 16 \DWOPderef{} \DWOPstackvalue }
%FIXME: similar undefined as just above
%\descriptionitemnl{\DWOPentryvalue{} 6 \DWOPentryvalue{} 1 \DWOPregfour{} \DWOPplusuconst{} 16 \DWOPderef{} \DWOPstackvalue }
%These two location expressions do the same thing, p
Push the value of the
memory location with the size of an address pointed to by the value of
register 4 upon entering the current subprogram and add 16.

\end{description}


\subsection{Location Lists}
\label{chap:locationlists}
There are two forms of location lists. The first form 
is intended for use in other than a split DWARF object,
while the second is intended for use in a split DWARF object
(see Section \refersec{datarep:splitdwarfobjects}). The two
forms are otherwise equivalent.

\textit{The form for split DWARF objects is new in \DWARFVersionV.}

\subsubsection{Location Lists in Non-split Objects}
\label{chap:locationlistsinnonsplitobjects}
Location lists 
\addtoindexx{location list}
are used in place of location expressions
whenever the object whose location is being described
can change location during its lifetime. 
Location lists
\addtoindexx{location list}
are contained in a separate object file section called
\dotdebugloc{}. A location list is indicated by a location
attribute whose value is an offset from the beginning of
the \dotdebugloc{} section to the first byte of the list for the
object in question.

Each entry in a location list is either a location 
\addtoindexi{list}{address selection|see{base address selection}} 
entry,
a 
\addtoindexi{base}{base address selection entry!in location list} 
address selection entry, 
\addtoindexx{location list!base address selection entry}
or an 
\addtoindexx{end of list entry!in location list}
end of list entry.

A location list entry has two forms:
a normal location list entry and a default location list entry.

A 
\addtoindexx{location list!normal entry}
normal location list entry consists of:
\begin{enumerate}[1. ]
\item A beginning address offset. 
This address offset has the \addtoindex{size of an address} and is
relative to the applicable base address of the compilation
unit referencing this location list. It marks the beginning
of the address 
\addtoindexi{range}{address range!in location list} 
over which the location is valid.

\item An ending address offset.  This address offset again
has the \addtoindex{size of an address} and is relative to the applicable
base address of the compilation unit referencing this location
list. It marks the first address past the end of the address
range over which the location is valid. The ending address
must be greater than or equal to the beginning address.

\textit{A location list entry (but not a base address selection or 
end of list entry) whose beginning
and ending addresses are equal has no effect 
because the size of the range covered by such
an entry is zero.}

\item A 2-byte length describing the length of the location 
description that follows.

\item A \addtoindex{single location description} 
describing the location of the object over the range specified by
the beginning and end addresses.
\end{enumerate}

\needlines{5}
The applicable base address of a normal
location list entry is
\addtoindexx{location list!base address selection entry}
determined by the closest preceding base address selection
entry (see below) in the same location list. If there is
no such selection entry, then the applicable base address
defaults to the base address of the compilation unit (see
Section \refersec{chap:normalandpartialcompilationunitentries}).  

\textit{In the case of a compilation unit where all of
the machine code is contained in a single contiguous section,
no base address selection entry is needed.}

Address ranges defined by normal location list entries
may overlap. When they do, they describe a
situation in which an object exists simultaneously in more than
one place. If all of the address ranges in a given location
list do not collectively cover the entire range over which the
object in question is defined, it is assumed that the object is
not available for the portion of the range that is not covered.

A default location list entry consists of:
\addtoindexx{location list!default entry}
\begin{enumerate}[1. ]
\item The value 0.
\item The value of the largest representable address offset (for
      example, \wffffffff when the size of an address is 32 bits).
\item A simple location description describing the location of the
      object when there is no prior normal location list entry
      that applies in the same location list.
\end{enumerate}

A default location list entry is independent of any applicable
base address (except to the extent to which base addresses
affect prior normal location list entries).

A default location list entry must be the last location list
entry of a location list except for the terminating end of list
entry.

A default location list entry describes an unlimited number
(zero, one or more) of address ranges, none of which overlap
any of the address ranges defined earlier in the same location
list. Further, all such address ranges have the same simple
location.

\needlines{5}
A base 
\addtoindexi{address}{address selection|see{base address selection}}
\addtoindexx{location list!base address selection entry}
selection 
\addtoindexi{entry}{base address selection entry!in location list}
consists of:
\begin{enumerate}[1. ]
\item The value of the largest representable 
address offset (for example, \wffffffff when the size of
an address is 32 bits).
\item An address, which defines the 
appropriate base address for use in interpreting the beginning
and ending address offsets of subsequent entries of the location list.
\end{enumerate}

\textit{A base address selection entry 
affects only the list in which it is contained.}

\needlines{5}
The end of any given location list is marked by an 
\addtoindexx{location list!end of list entry}
end of list entry, which consists of a 0 for the beginning address
offset and a 0 for the ending address offset. A location list
containing only an 
\addtoindexx{end of list entry!in location list}
end of list entry describes an object that
exists in the source code but not in the executable program.

Neither a base address selection entry nor an end of list
entry includes a location description.

\textit{When a DWARF consumer is parsing and decoding a location
list, it must recognize the beginning and ending address
offsets of (0, 0) for an end of list entry and (0, \doublequote{-1}) for
a default location list entry prior to applying any base
address. Any other pair of offsets beginning with 0 is a
valid normal location list entry. Next, it must recognize the
beginning address offset of \doublequote{-1} for a base address selection
entry prior to applying any base address. The current base
address is not applied to the subsequent value (although there
may be an underlying object language relocation that affects
that value).}

\textit{A base address selection entry and an end of list
entry for a location list are identical to a base address
selection entry and end of list entry, respectively, for a
\addtoindex{range list}
(see Section \refersec{chap:noncontiguousaddressranges}) 
in interpretation
and representation.}

\subsubsection{Location Lists in Split Objects}
\label{chap:locationlistsinsplitobjects}
In a split DWARF object (see 
Section \refersec{datarep:splitdwarfobjects}), 
location lists are contained in the \dotdebuglocdwo{} section.

Each entry in the location list
begins with a type code, which is a single byte that
identifies the type of entry. There are five types of entries:
\begin{enumerate}
\itembfnl{\DWLLEendoflistentryTARG}
This entry indicates the end of a location list, and
contains no further data.

\itembfnl{\DWLLEbaseaddressselectionentryTARG}
This entry contains an 
unsigned LEB128\addtoindexx{LEB128!unsigned} value immediately
following the type code. This value is the index of an
address in the \dotdebugaddr{} section, which is then used as
the base address when interpreting offsets in subsequent
location list entries of type \DWLLEoffsetpairentry.
This index is relative to the value of the 
\DWATaddrbase{} attribute of the associated compilation unit.

\itembfnl{\DWLLEstartendentryTARG}
This entry contains two unsigned LEB128\addtoindexx{LEB128!unsigned}
values immediately following the type code. These values are the
indices of two addresses in the \dotdebugaddr{} section.
These indices are relative to the value of the 
\DWATaddrbase{} attribute of the associated compilation unit.
These indicate the starting and ending addresses,
respectively, that define the address range for which
this location is valid. The starting and ending addresses
given by this type of entry are not relative to the
compilation unit base address. A single location
description follows the fields that define the address range.

\itembfnl{\DWLLEstartlengthentryTARG}
This entry contains one unsigned LEB128\addtoindexx{LEB128!unsigned}
value and a 4-byte
unsigned value immediately following the type code. The
first value is the index of an address in the \dotdebugaddr{}
section, which marks the beginning of the address range
over which the location is valid.
This index is relative to the value of the 
\DWATaddrbase{} attribute of the associated compilation unit.
The starting address given by this
type of entry is not relative to the compilation unit
base address. The second value is the
length of the range. A single location
description follows the fields that define the address range.

\itembfnl{\DWLLEoffsetpairentryTARG}
This entry contains two 4-byte unsigned values
immediately following the type code. These values are the
starting and ending offsets, respectively, relative to
the applicable base address, that define the address
range for which this location is valid. A single location
description follows the fields that define the address range.
\end{enumerate}


\section{Types of Program Entities}
\label{chap:typesofprogramentities}
Any 
\hypertarget{chap:DWATtypetypeofdeclaration}{}
debugging information entry describing a declaration that
has a type has 
\addtoindexx{type attribute}
a \DWATtype{} attribute, whose value is a
reference to another debugging information entry. The entry
referenced may describe a base type, that is, a type that is
not defined in terms of other data types, or it may describe a
user-defined type, such as an array, structure or enumeration.
Alternatively, the entry referenced may describe a type
modifier, such as constant, packed, pointer, reference or
volatile, which in turn will reference another entry describing
a type or type modifier (using 
\addtoindexx{type attribute}
a \DWATtype{} attribute of its
own). See 
Section  \referfol{chap:typeentries} 
for descriptions of the entries describing
base types, user-defined types and type modifiers.



\section{Accessibility of Declarations}
\label{chap:accessibilityofdeclarations}
\textit{Some languages, notably C++ and 
\addtoindex{Ada}, have the concept of
the accessibility of an object or of some other program
entity. The accessibility specifies which classes of other
program objects are permitted access to the object in question.}

The accessibility of a declaration is 
\hypertarget{chap:DWATaccessibilitycandadadeclarations}{}
represented by a 
\DWATaccessibility{} 
attribute, whose
\addtoindexx{accessibility attribute}
value is a constant drawn from the set of codes listed in Table 
\refersec{tab:accessibilitycodes}.

\begin{simplenametable}[1.9in]{Accessibility codes}{tab:accessibilitycodes}
\DWACCESSpublicTARG{}          \\
\DWACCESSprivateTARG{}        \\
\DWACCESSprotectedTARG{}    \\
\end{simplenametable}

\section{Visibility of Declarations}
\label{chap:visibilityofdeclarations}

\textit{Several languages (such as \addtoindex{Modula-2}) 
have the concept of the visibility of a declaration. The
visibility specifies which declarations are to be 
visible outside of the entity in which they are
declared.}

The 
\hypertarget{chap:DWATvisibilityvisibilityofdeclaration}{}
visibility of a declaration is represented 
by a \DWATvisibility{}
attribute\addtoindexx{visibility attribute}, whose value is a
constant drawn from the set of codes listed in 
Table \refersec{tab:visibilitycodes}.

\begin{simplenametable}[1.5in]{Visibility codes}{tab:visibilitycodes}
\DWVISlocalTARG{}          \\
\DWVISexportedTARG{}    \\
\DWVISqualifiedTARG{}  \\
\end{simplenametable}

\section{Virtuality of Declarations}
\label{chap:virtualityofdeclarations}
\textit{C++ provides for virtual and pure virtual structure or class
member functions and for virtual base classes.}

The 
\hypertarget{chap:DWATvirtualityvirtualityindication}{}
virtuality of a declaration is represented by a
\DWATvirtuality{}
attribute\addtoindexx{virtuality attribute}, whose value is a constant drawn
from the set of codes listed in 
Table \refersec{tab:virtualitycodes}.

\begin{simplenametable}[2.5in]{Virtuality codes}{tab:virtualitycodes}
\DWVIRTUALITYnoneTARG{}                      \\
\DWVIRTUALITYvirtualTARG{}                \\
\DWVIRTUALITYpurevirtualTARG{}    \\
\end{simplenametable}

\section{Artificial Entries}
\label{chap:artificialentries}
\textit{A compiler may wish to generate debugging information entries
for objects or types that were not actually declared in the
source of the application. An example is a formal parameter
%FIXME: The word 'this' should be rendered like a variant italic,
%FIXME: not as a quoted name. Changed to tt font--RB
entry to represent the 
\texttt{this} parameter\index{this parameter@\texttt{this} parameter}
hidden \texttt{this} parameter that most C++
implementations pass as the first argument to non-static member
functions.}  

Any debugging information entry representing the
\addtoindexx{artificial attribute}
declaration of an object or type artificially generated by
a compiler and not explicitly declared by the source program
\hypertarget{chap:DWATartificialobjectsortypesthat}{}
may have a 
\DWATartificial{} attribute, 
which is a \livelink{chap:classflag}{flag}.

\section{Segmented Addresses}
\label{chap:segmentedaddresses}
\textit{In some systems, addresses are specified as offsets within a
given 
\addtoindexx{address space!segmented}
segment 
\addtoindexx{segmented addressing|see{address space}}
rather than as locations within a single flat
\addtoindexx{address space!flat}
address space.}

Any debugging information entry that contains a description
\hypertarget{chap:DWATsegmentaddressinginformation}{}
of the location of an object or subroutine may have a 
\DWATsegment{} attribute, 
\addtoindexx{segment attribute}
whose value is a location
description. The description evaluates to the segment selector
of the item being described. If the entry containing the
\DWATsegment{} attribute has a 
\DWATlowpc, 
\DWAThighpc,
\DWATranges{} or 
\DWATentrypc{} attribute, 
\addtoindexx{entry pc attribute}
or 
a location
description that evaluates to an address, then those address
values represent the offset portion of the address within
the segment specified 
\addtoindexx{segment attribute}
by \DWATsegment.

If an entry has no 
\DWATsegment{} attribute, it inherits
\addtoindexx{segment attribute}
the segment value from its parent entry.  If none of the
entries in the chain of parents for this entry back to
its containing compilation unit entry have 
\DWATsegment{} attributes, 
then the entry is assumed to exist within a flat
address space. 
Similarly, if the entry has a 
\DWATsegment{} attribute 
\addtoindexx{segment attribute}
containing an empty location description, that
entry is assumed to exist within a 
\addtoindexi{flat}{address space!flat}
address space.

\textit{Some systems support different classes of 
addresses
\addtoindexx{address class!attribute}. 
The
address class may affect the way a pointer is dereferenced
or the way a subroutine is called.}


Any debugging information entry representing a pointer or
reference type or a subroutine or subroutine type may 
have a 
\DWATaddressclass{}
attribute, whose value is an integer
constant.  The set of permissible values is specific to
each target architecture. The value \DWADDRnoneTARG, 
however,
is common to all encodings, and means that no address class
has been specified.

\textit {For example, the Intel386 \texttrademark\  processor might use the following values:}

\begin{table}[here]
\caption{Example address class codes}
\label{tab:inteladdressclasstable}
\centering
\begin{tabular}{l|c|l}
\hline
Name&Value&Meaning  \\
\hline
\textit{DW\_ADDR\_none}&   0 & \textit{no class specified} \\
\textit{DW\_ADDR\_near16}& 1 & \textit{16\dash bit offset, no segment} \\
\textit{DW\_ADDR\_far16}&  2 & \textit{16\dash bit offset, 16\dash bit segment} \\
\textit{DW\_ADDR\_huge16}& 3 & \textit{16\dash bit offset, 16\dash bit segment} \\
\textit{DW\_ADDR\_near32}& 4 & \textit{32\dash bit offset, no segment} \\
\textit{DW\_ADDR\_far32}&  5 & \textit{32\dash bit offset, 16\dash bit segment} \\
\hline
\end{tabular}
\end{table}

\needlines{6}
\section{Non-Defining Declarations and Completions}
\label{nondefiningdeclarationsandcompletions}
A debugging information entry representing a program entity
typically represents the defining declaration of that
entity. In certain contexts, however, a debugger might need
information about a declaration of an entity that is not
\addtoindexx{incomplete declaration}
also a definition, or is otherwise incomplete, to evaluate
\hypertarget{chap:DWATdeclarationincompletenondefiningorseparateentitydeclaration}{}
an expression correctly.

\needlines{10}
\textit{As an example, consider the following fragment of \addtoindex{C} code:}

\begin{lstlisting}
void myfunc()
{
  int x;
  {
    extern float x;
    g(x);
  }
}
\end{lstlisting}


\textit{\addtoindex{C} scoping rules require that the 
value of the variable x passed to the function g is the value of the
global variable x rather than of the local version.}

\subsection{Non-Defining Declarations}
A debugging information entry that 
represents a non-defining 
\addtoindexx{non-defining declaration}
or otherwise 
\addtoindex{incomplete declaration}
of a program entity has a
\addtoindexx{declaration attribute}
\DWATdeclaration{} attribute, which is a 
\livelink{chap:classflag}{flag}.

\subsection{Declarations Completing Non-Defining Declarations}
A debugging information entry that represents a 
\hypertarget{chap:DWATspecificationincompletenondefiningorseparatedeclaration}{}
declaration that completes another (earlier) 
non\dash defining declaration may have a 
\DWATspecification{}
attribute whose value is a \livelink{chap:classreference}{reference} to
the debugging information entry representing the non-defining declaration. A debugging
information entry with a 
\DWATspecification{} 
attribute does not need to duplicate information
provided by the debugging information entry referenced by that specification attribute.

It is not the case that all attributes of the debugging information entry referenced by a
\DWATspecification{} attribute 
apply to the referring debugging information entry.

\textit{For 
\addtoindexx{declaration attribute}
example,
\DWATsibling{} and 
\DWATdeclaration{} 
\addtoindexx{declaration attribute}
clearly cannot apply to a 
\addtoindexx{declaration attribute}
referring
\addtoindexx{sibling attribute}
entry.}



\section{Declaration Coordinates}
\label{chap:declarationcoordinates}
\livetargi{chap:declarationcoordinates}{}{declaration coordinates}
\textit{It is sometimes useful in a debugger to be able to associate
a declaration with its occurrence in the program source.}

Any debugging information 
\hypertarget{chap:DWATdeclfilefilecontainingsourcedeclaration}{}
entry 
\hypertarget{chap:DWATdecllinelinenumberofsourcedeclaration}{}
representing 
\hypertarget{chap:DWATdeclcolumncolumnpositionofsourcedeclaration}{}
the
\addtoindexx{line number of declaration}
declaration of an object, module, subprogram or
\addtoindex{declaration column attribute}
type 
\addtoindex{declaration file attribute}
may 
\addtoindex{declaration line attribute}
have
\DWATdeclfile, 
\DWATdeclline{} and 
\DWATdeclcolumn{}
attributes each of whose value is an unsigned
\livelink{chap:classconstant}{integer constant}.

The value of 
\addtoindexx{declaration file attribute}
the 
\DWATdeclfile{}
attribute 
\addtoindexx{file containing declaration}
corresponds to
a file number from the line number information table for the
compilation unit containing the debugging information entry and
represents the source file in which the declaration appeared
(see Section \refersec{chap:linenumberinformation}). 
The value 0 indicates that no source file
has been specified.

The value of 
\addtoindexx{declaration line attribute}
the \DWATdeclline{} attribute represents
the source line number at which the first character of
the identifier of the declared object appears. The value 0
indicates that no source line has been specified.

The value of 
\addtoindexx{declaration column attribute}
the \DWATdeclcolumn{} attribute represents
the source column number at which the first character of
the identifier of the declared object appears. The value 0
indicates that no column has been specified.

\section{Identifier Names}
\label{chap:identifiernames}
Any 
\hypertarget{chap:DWATnamenameofdeclaration}{}
debugging information entry 
\addtoindexx{identifier names}
representing 
\addtoindexx{names!identifier}
a program entity
that has been given a name may have a 
\DWATname{} attribute,
whose 
\addtoindexx{name attribute}
value is a \livelink{chap:classstring}{string} 
representing the name as it appears in
the source program. A debugging information entry containing
no name attribute, or containing a name attribute whose value
consists of a name containing a single null byte, represents
a program entity for which no name was given in the source.

\textit{Because the names of program objects described by DWARF are the
names as they appear in the source program, implementations
of language translators that use some form of mangled name
\addtoindexx{mangled names}
(as do many implementations of C++) should use the unmangled
form of the name in the 
DWARF \DWATname{} attribute,
\addtoindexx{name attribute}
including the keyword operator (in names such as \doublequote{operator +}),
if present. See also 
Section \referfol{chap:linkagenames} regarding the use
of \DWATlinkagename{} for 
\addtoindex{mangled names}.
Sequences of
multiple whitespace characters may be compressed.}

\section{Data Locations and DWARF Procedures}
Any debugging information entry describing a data object (which
\hypertarget{chap:DWATlocationdataobjectlocation}{}
includes variables and parameters) or 
\livelink{chap:commonblockentry}{common blocks}
may have 
\addtoindexx{location attribute}
a
\DWATlocation{} attribute,
\addtoindexx{location attribute}
whose value is a location description
(see Section \refersec{chap:locationdescriptions}).

\needlines{4}
A 
\addtoindex{DWARF procedure}
is represented by any
kind of debugging information entry that has 
\addtoindexx{location attribute}
a 
\DWATlocation{}
attribute. 
\addtoindexx{location attribute}
If a suitable entry is not otherwise available,
a DWARF procedure can be represented using a debugging
\addtoindexx{DWARF procedure entry}
information entry with the 
tag \DWTAGdwarfprocedureTARG{}
together with 
\addtoindexx{location attribute}
a \DWATlocation{} attribute.  

A DWARF procedure
is called by a \DWOPcalltwo, 
\DWOPcallfour{} or 
\DWOPcallref{}
DWARF expression operator 
(see Section \refersec{chap:controlflowoperations}).

\needlines{5}
\section{Code Addresses and Ranges}
\label{chap:codeaddressesandranges}
Any debugging information entry describing an entity that has
a machine code address or range of machine code addresses,
which includes compilation units, module initialization,
\hypertarget{chap:DWATrangesnoncontiguousrangeofcodeaddresses}{}
subroutines, ordinary \nolink{blocks}, 
try/catch \nolink{blocks} (see Section\refersec{chap:tryandcatchblockentries}), 
labels and the like, may have
\begin{itemize}
\item A \DWATlowpc{} attribute for
\hypertarget{chap:DWATlowpccodeaddressorrangeofaddresses}{}
a single address,

\item A \DWATlowpc{}
\addtoindexx{low PC attribute}
and 
\DWAThighpc{}
\addtoindexx{high PC attribute}
\hypertarget{chap:DWAThighpccontiguousrangeofcodeaddresses}{}
pair of attributes for 
a single contiguous range of
addresses, or

\item A \DWATranges{} attribute 
\addtoindexx{ranges attribute}
for a non-contiguous range of addresses.
\end{itemize}

In addition, a non-contiguous range of 
addresses may also be specified for the
\DWATstartscope{} attribute.
\addtoindexx{start scope attribute}

If an entity has no associated machine code, 
none of these attributes are specified.

\subsection{Single Address} 
When there is a single address associated with an entity,
such as a label or alternate entry point of a subprogram,
the entry has a \DWATlowpc{} attribute whose value is the
relocated address for the entity.

\textit{While the \DWATentrypc{}
attribute might also seem appropriate for this purpose,
historically the \DWATlowpc{} attribute was used before the
\DWATentrypc{} was introduced 
(in \addtoindex{DWARF Version 3}). There is
insufficient reason to change this.}

\needlines{8}
\subsection{Continuous Address Range}
\label{chap:contiguousaddressranges}
When the set of addresses of a debugging information entry can
be described as a single contiguous range, the entry 
\addtoindexx{high PC attribute}
may 
\addtoindexx{low PC attribute}
have
a \DWATlowpc{} and 
\DWAThighpc{} pair of attributes. 
The value
of the 
\DWATlowpc{} attribute 
is the relocated address of the
first instruction associated with the entity. If the value of
the \DWAThighpc{} is of class address, it is the relocated
address of the first location past the last instruction
associated with the entity; if it is of class constant, the
value is an unsigned integer offset which when added to the
low PC gives the address of the first location past the last
instruction associated with the entity.

\textit{The high PC value
may be beyond the last valid instruction in the executable.}

\needlines{5}
The presence of low and high PC attributes for an entity
implies that the code generated for the entity is contiguous
and exists totally within the boundaries specified by those
two attributes. If that is not the case, no low and high PC
attributes should be produced.

\subsection{Non\dash Contiguous Address Ranges}
\label{chap:noncontiguousaddressranges}
When the set of addresses of a debugging information entry
\addtoindexx{non-contiguous address ranges}
cannot be described as a single contiguous range, the entry has
a \DWATranges{} attribute 
\addtoindexx{ranges attribute}
whose value is of class \livelink{chap:classrangelistptr}{rangelistptr}
and indicates the beginning of a \addtoindex{range list}.
Similarly,
a \DWATstartscope{} attribute 
\addtoindexx{start scope attribute}
may have a value of class
\livelink{chap:classrangelistptr}{rangelistptr} for the same reason.  

Range lists are contained in a separate object file section called 
\dotdebugranges{}. A
\addtoindex{range list} is indicated by a 
\DWATranges{} attribute whose
\addtoindexx{ranges attribute}
value is represented as an offset from the beginning of the
\dotdebugranges{} section to the beginning of the 
\addtoindex{range list}.

If the current compilation unit contains a \DWATrangesbase{}
attribute, the value of that attribute establishes a base
offset within the \dotdebugranges{} section for the compilation
unit. The offset given by the \DWATranges{} attribute is
relative to that base.

\textit{The \DWATrangesbase{} attribute is new in \addtoindex{DWARF Version 5}.
The advantage of this attribute is that is reduces the number of
object language relocations needed for references to the \dotdebugranges{}
section from one for each reference to a single relocation that
applies for the entire compilation unit.}

Each entry in a \addtoindex{range list} is either a 
\addtoindex{range list} entry,
\addtoindexx{base address selection entry!in range list}
a base address selection entry, or an 
\addtoindexx{end of list entry!in range list}
end of list entry.

A \addtoindex{range list} entry consists of:
\begin{enumerate}[1. ]
\item A beginning address offset. This address offset has the 
\addtoindex{size of an address} and is relative to
the applicable base address of the compilation unit referencing this 
\addtoindex{range list}. 
It marks the
beginning of an 
\addtoindexi{address}{address range!in range list} 
range.

\item An ending address offset. This address offset again has the 
\addtoindex{size of an address} and is relative
to the applicable base address of the compilation unit referencing 
this \addtoindex{range list}.
It marks the
first address past the end of the address range.
The ending address must be greater than or
equal to the beginning address.

\textit{A \addtoindex{range list} entry (but not a base address selection or end of list entry) whose beginning and
ending addresses are equal has no effect because the size of the range covered by such an
entry is zero.}
\end{enumerate}

The applicable base address of a \addtoindex{range list} entry
is determined
by the closest preceding base address selection entry (see
below) in the same range list. If there is no such selection
entry, then the applicable base address defaults to the base
address of the compilation unit 
(see Section \refersec{chap:normalandpartialcompilationunitentries}).

\textit{In the case of a compilation unit where all of the machine
code is contained in a single contiguous section, no base
address selection entry is needed.}

Address range entries in
a \addtoindex{range list} may not overlap.
There is no requirement that
the entries be ordered in any particular way.

\needlines{5}
A base address selection entry consists of:
\begin{enumerate}[1. ]
\item The value of the largest representable address offset (for example, \wffffffff when the size of
an address is 32 bits).

\item An address, which defines the appropriate base address for use in interpreting the beginning
and ending address offsets of subsequent entries of the location list.
\end{enumerate}
\textit{A base address selection entry 
affects only the list in which it is contained.}


The end of any given \addtoindex{range list} is marked by an 
\addtoindexx{end of list entry!in range list}
end of list entry, 
which consists of a 0 for the beginning address
offset and a 0 for the ending address offset. 
A \addtoindex{range list}
containing only an end of list entry describes an empty scope
(which contains no instructions).

\textit{A base address selection entry and an 
\addtoindexx{end of list entry!in range list}
end of list entry for
a \addtoindex{range list} 
are identical to a base address selection entry
and end of list entry, respectively, for a location list
(see Section \refersec{chap:locationlists}) 
in interpretation and representation.}



\section{Entry Address}
\label{chap:entryaddress}
\textit{The entry or first executable instruction generated
for an entity, if applicable, is often the lowest addressed
instruction of a contiguous range of instructions. In other
cases, the entry address needs to be specified explicitly.}

Any debugging information entry describing an entity that has
a range of code addresses, which includes compilation units,
module initialization, subroutines, 
ordinary \livelink{chap:lexicalblock}{block}, 
try/catch \nolink{blocks} (see Section 
\refersec{chap:tryandcatchblockentries}),
and the like, may have a \DWATentrypcNAME{} attribute to
indicate the first executable instruction within that range
\hypertarget{chap:entryaddressofscope}{}
of addresses. The value of the \DWATentrypcNAME{} attribute is a
relocated address if the
value of \DWATentrypcNAME{} is of class address; or if it is of class
constant, the value is an unsigned integer offset which, when
added to the base address of the function, gives the entry
address. 

The base address of the containing scope is given by either the
\DWATlowpc{} attribute, or the first range entry in the list of
ranges given by the \DWATranges{} attribute. 
If no \DWATentrypcNAME{} attribute is present,
then the entry address is assumed to be the same as the
value of the \DWATlowpc{} attribute, if present; otherwise,
the entry address is unknown.

\section{Static and Dynamic Values of Attributes}
\label{chap:staticanddynamicvaluesofattributes}

Some attributes that apply to types specify a property (such
as the lower bound of an array) that is an integer value,
where the value may be known during compilation or may be
computed dynamically during execution.

The value of these
attributes is determined based on the class as follows:
\begin{itemize}
\item For a \livelink{chap:classconstant}{constant}, the value of the constant is the value of
the attribute.

\item For a \livelink{chap:classreference}{reference}, the
value is a DWARF procedure that computes the value of the attribute.

\item For an \livelink{chap:classexprloc}{exprloc}, the value is interpreted as a 
DWARF expression; 
evaluation of the expression yields the value of
the attribute.
\end{itemize}

\textit{%
Whether an attribute value can be dynamic depends on the
rules of the applicable programming language.
}

\textit{The applicable attributes include: 
\DWATallocated,
\DWATassociated, 
\DWATbitoffset, 
\DWATbitsize,
\DWATbitstride,
\DWATbytesize,
\DWATbytestride, 
\DWATcount, 
\DWATlowerbound,
\DWATrank,
\DWATupperbound,
(and possibly others).}

\needlines{4}
\section{Entity Descriptions}
\textit{Some debugging information entries may describe entities
in the program that are artificial, or which otherwise are
\doublequote{named} in ways which are not valid identifiers in the
programming language. For example, several languages may
capture or freeze the value of a variable at a particular
point in the program. 
\addtoindex{Ada} 95 has package elaboration routines,
type descriptions of the form typename\textquoteright Class, and 
\doublequote{access typename} parameters.  }

Generally, any debugging information
entry that 
\hypertarget{chap:DWATdescriptionartificialnameordescription}{}
has, or may have, 
\addtoindexx{name attribute}
a 
\DWATname{} attribute, may
also have 
\addtoindexx{description attribute}
a 
\DWATdescription{} attribute whose value is a
null-terminated string providing a description of the entity.


\textit{It is expected that a debugger will only display these
descriptions as part of the description of other entities. It
should not accept them in expressions, nor allow them to be
assigned, or the like.}

\section{Byte and Bit Sizes}
\label{chap:byteandbitsizes}
% Some trouble here with hbox full, so we try optional word breaks.
Many debugging information entries allow either a
\DWATbytesize{} attribute or a 
\DWATbitsize{} attribute,
whose \livelink{chap:classconstant}{integer constant} value 
(see Section \ref{chap:staticanddynamicvaluesofattributes}) 
specifies an
amount of storage. The value of the 
\DWATbytesize{} attribute
is interpreted in bytes and the value of the 
\DWATbitsize{}
attribute is interpreted in bits. The
\DWATstringlengthbytesize{} and 
\DWATstringlengthbitsize{} 
attributes are similar.

In addition, the \livelink{chap:classconstant}{integer constant}
value of a \DWATbytestride{} attribute is interpreted
in bytes and the \livelink{chap:classconstant}{integer constant} value of a 
\DWATbitstride{}
attribute is interpreted in bits.

\section{Linkage Names}
\label{chap:linkagenames}
\textit{Some language implementations, notably 
\addtoindex{C++} and similar
languages, 
make use of implementation-defined names within
object files that are different from the identifier names
(see Section \refersec{chap:identifiernames}) of entities as they appear in the
source. Such names, sometimes known 
\addtoindexx{names!mangled}
as 
\addtoindex{mangled names},
are used in various ways, such as: to encode additional
information about an entity, to distinguish multiple entities
that have the same name, and so on. When an entity has an
associated distinct linkage name it may sometimes be useful
for a producer to include this name in the DWARF description
of the program to facilitate consumer access to and use of
object file information about an entity and/or information
\hypertarget{chap:DWATlinkagenameobjectfilelinkagenameofanentity}{}
that is encoded in the linkage name itself.  
}

% Some trouble maybe with hbox full, so we try optional word breaks.
A debugging
information entry may have 
\addtoindexx{linkage name attribute}
a 
\DWATlinkagename{}
attribute
whose value is a null-terminated string describing the object
file linkage name associated with the corresponding entity.

% Some trouble here with hbox full, so we try optional word breaks.
\textit{Debugging information entries to which \DWATlinkagename{}
may apply include: \DWTAGcommonblock, \DWTAGconstant,
\DWTAGentrypoint, \DWTAGsubprogram{} 
and \DWTAGvariable.
}

\section{Template Parameters}
\label{chap:templateparameters}
\textit{
In \addtoindex{C++}, a template is a generic definition of a class, function, member
function, or typedef (alias).  A template has formal parameters that
can be types or constant values; the class, function,
member function, or typedef is instantiated differently for each
distinct combination of type or value actual parameters.  DWARF does
not represent the generic template definition, but does represent each
instantiation.
}

A debugging information entry that represents a 
\addtoindex{template instantiation}
will contain child entries describing the actual template parameters.
The containing entry and each of its child entries reference a template
parameter entry in any circumstance where the template definition
referenced a formal template parameter.

A template type parameter is represented by a debugging information
entry with the tag
\addtoindexx{template type parameter entry}
\DWTAGtemplatetypeparameterTARG. 
A template value parameter is represented by a debugging information
entry with the tag
\addtoindexx{template value parameter entry}
\DWTAGtemplatevalueparameterTARG.
The actual template parameter entries appear in the same order as the 
corresponding template formal parameter declarations in the 
source program.

\needlines{4}
A type or value parameter entry may have a \DWATname{} attribute, 
\addtoindexx{name attribute}
whose value is a
null\dash terminated string containing the name of the corresponding 
formal parameter as it appears in the source program.
The entry may also have a 
\DWATdefaultvalue{} attribute, which is a flag indicating 
that the value corresponds to the default argument for the 
template parameter.


A
\addtoindexx{formal type parameter|see{template type parameter entry}}
template type parameter entry has a
\addtoindexx{type attribute}
\DWATtype{} attribute
describing the actual type by which the formal is replaced.


A template value parameter entry has a \DWATtype{} attribute 
describing the type of the parameterized value.
The entry also has an attribute giving the 
actual compile-time or run-time constant value 
of the value parameter for this instantiation.
This can be a 
\DWATconstvalue{}\livetarg{chap:DWATconstvaluetemplatevalueparameter}{} 
attribute, whose
value is the compile-time constant value as represented 
on the target architecture. 
Or, the attribute can be a \DWATlocation{} attribute, whose value is a 
single location description for the run-time constant address.

