\chapter{General Description}
\label{chap:generaldescription}
\section{The Debugging Information Entry (DIE)}
\label{chap:thedebuggingentrydie}
DWARF 
\addtoindexx{debugging information entry}
uses 
\addtoindexx{DIE|see{debugging information entry}}
a series of debugging information entries (DIEs) to 
define a low-level
representation of a source program. 
Each debugging information entry consists of an identifying
\addtoindex{tag} and a series of 
\addtoindex{attributes}. 
An entry, or group of entries together, provide a description of a
corresponding 
\addtoindex{entity} in the source program. 
The tag specifies the class to which an entry belongs
and the attributes define the specific characteristics of the entry.

The set of tag names 
\addtoindexx{tag names|see{debugging information entry}}
is listed in Table \refersec{tab:tagnames}. 
The debugging information entries they identify are
described in Chapters 3, 4 and 5.

\begin{table}[p]
\caption{Tag names}
\label{tab:tagnames}
\simplerule[6in]
\autocols[0pt]{c}{2}{l}{
\DWTAGaccessdeclaration,
\DWTAGarraytype,
\DWTAGatomictype,
\DWTAGbasetype,
\DWTAGcallsite,
\DWTAGcallsiteparameter,
\DWTAGcatchblock,
\DWTAGclasstype,
\DWTAGcoarraytype,
\DWTAGcommonblock,
\DWTAGcommoninclusion,
\DWTAGcompileunit,
\DWTAGcondition,
\DWTAGconsttype,
\DWTAGconstant,
\DWTAGdwarfprocedure,
\DWTAGdynamictype,
\DWTAGentrypoint,
\DWTAGenumerationtype,
\DWTAGenumerator,
\DWTAGfiletype,
\DWTAGformalparameter,
\DWTAGfriend,
\DWTAGgenericsubrange,
\DWTAGimporteddeclaration,
\DWTAGimportedmodule,
\DWTAGimportedunit,
\DWTAGinheritance,
\DWTAGinlinedsubroutine,
\DWTAGinterfacetype,
\DWTAGlabel,
\DWTAGlexicalblock,
\DWTAGmodule,
\DWTAGmember,
\DWTAGnamelist,
\DWTAGnamelistitem,
\DWTAGnamespace,
\DWTAGpackedtype,
\DWTAGpartialunit,
\DWTAGpointertype,
\DWTAGptrtomembertype,
\DWTAGreferencetype,
\DWTAGrestricttype,
\DWTAGrvaluereferencetype,
\DWTAGsettype,
\DWTAGsharedtype,
\DWTAGstringtype,
\DWTAGstructuretype,
\DWTAGsubprogram,
\DWTAGsubrangetype,
\DWTAGsubroutinetype,
\DWTAGtemplatealias,
\DWTAGtemplatetypeparameter,
\DWTAGtemplatevalueparameter,
\DWTAGthrowntype,
\DWTAGtryblock,
\DWTAGtypedef,
\DWTAGtypeunit,
\DWTAGuniontype,
\DWTAGunspecifiedparameters,
\DWTAGunspecifiedtype,
\DWTAGvariable,
\DWTAGvariant,
\DWTAGvariantpart,
\DWTAGvolatiletype,
\DWTAGwithstmt
}
\simplerule[6in]
\end{table}


\textit{The debugging information entry descriptions 
in Sections 3, 4 and 5 generally include mention of
most, but not necessarily all, of the attributes 
that are normally or possibly used with the entry.
Some attributes, whose applicability tends to be 
pervasive and invariant across many kinds of
debugging information entries, are described in 
this section and not necessarily mentioned in all
contexts where they may be appropriate. 
Examples include 
\DWATartificial, 
the \livelink{chap:declarationcoordinates}{declaration coordinates}, and 
\DWATdescription, 
among others.}

The debugging information entries are contained in the 
\dotdebuginfo{} and/or \dotdebuginfodwo{} sections of an object file.

\needlines{7}
Optionally, debugging information may be partitioned such
that the majority of the debugging information can remain in
individual object files without being processed by the
linker. These debugging information entries are contained in
the \dotdebuginfodwo{} sections. These
sections may be placed in the object file but marked so that
the linker ignores them, or they may be placed in a separate
DWARF object file that resides alongside the normal object
file. See Section \refersec{datarep:splitdwarfobjectfiles} and
Appendix \refersec{app:splitdwarfobjectsinformative} for details.

As a further option, debugging information entries and other debugging
information that are the same in multiple executable or shared object files 
may be found in a separate \addtoindex{supplementary object file} that 
contains supplementary debug sections.
The executable or shared object file which contains references to
those debugging information entries contain a \dotdebugsup{} section
with information that identifies the \addtoindex{supplementary object file}; 
the \addtoindex{supplementary object file} contains a variant of this same section
that is used to unambiguously associate it with the referencing object.
See Section \refersec{datarep:dwarfsupplemetaryobjectfiles} for
further details.
 
\section{Attribute Types}
\label{chap:attributetypes}
Each attribute value is characterized by an attribute name. 
\addtoindexx{attribute duplication}
No more than one attribute with a given name may appear in any
debugging information entry. 
There are no limitations on the
\addtoindexx{attribute ordering}
ordering of attributes within a debugging information entry.

The attributes are listed in Table \referfol{tab:attributenames}.  

\setlength{\extrarowheight}{0.1cm}
\addtoindexx{attributes!list of}
\begin{longtable}{l|P{9cm}}
  \caption{Attribute names} \label{tab:attributenames} \\
  \hline \bfseries Attribute&\bfseries Identifies or Specifies \\ \hline
\endfirsthead
  \bfseries Attribute&\bfseries Identifies or Specifies \\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot

\DWATabstractoriginTARG
&\livelinki{chap:DWATabstractorigininlineinstance}
        {Inline instances of inline subprograms} 
        {inline instances of inline subprograms} \\
% Heren livelink we cannot use \dash or \dash{}.
&\livelinki{chap:DWATabstractoriginoutoflineinstance}
        {Out-of-line instances of inline subprograms}
        {out-of-line instances of inline subprograms} \\
\DWATaccessibilityTARG
&\livelink{chap:DWATaccessibilitycandadadeclarations}
        {Accessibility of declarations} (\addtoindex{C++}, \addtoindex{Ada}) \\
&\livelink{chap:DWATaccessibilitycppbaseclasses}
        {Accessibility of base classes} (\addtoindex{C++}) \\
&\livelink{chap:DWATaccessibilitycppinheritedmembers}
        {Accessibility of inherited members} (\addtoindex{C++}) \\
\DWATaddressclassTARG
&\livelinki{chap:DWATadressclasspointerorreferencetypes}
        {Pointer or reference types}
        {pointer or reference types}  \\
&\livelinki{chap:DWATaddressclasssubroutineorsubroutinetype}
        {Subroutine or subroutine type}
        {subroutine or subroutine type} \\
\DWATaddrbaseTARG
&\livelinki{chap:DWATaddrbaseforaddresstable}
        {Base offset for address table}
        {address table} \\
\DWATalignmentTARG
&\livelinki{chap:DWATalignmentnondefault}
        {Non-default alignment of type, subprogram or variable}
        {non-default alignment} \addtoindexx{alignment!non-default} \\
\DWATallocatedTARG
&\livelinki{chap:DWATallocatedallocationstatusoftypes}
        {Allocation status of types}
        {allocation status of types}  \\
\DWATartificialTARG
&\livelinki{chap:DWATartificialobjectsortypesthat}
        {Objects or types that are not actually declared in the source}
        {objects or types that are not actually declared in the source}  \\
\DWATassociatedTARG{} 
&\livelinki{chap:DWATassociatedassociationstatusoftypes}
        {Association status of types}
        {association status of types} \\
\DWATbasetypesTARG{} 
&\livelinki{chap:DWATbasetypesprimitivedatatypesofcompilationunit}
        {Primitive data types of compilation unit}
        {primitive data types of compilation unit} \\
\DWATbinaryscaleTARG{} 
&\livelinki{chap:DWATbinaryscalebinaryscalefactorforfixedpointtype}
        {Binary scale factor for fixed-point type}
        {binary scale factor for fixed-point type} \\
%\DWATbitoffsetTARG{} 
%&\livelinki{chap:DWATbitoffsetbasetypebitlocation}{Base type bit location}{base type bit location} \\
%&\livelinki{chap:DWATbitoffsetdatamemberbitlocation}{Data member bit location}{data member bit location} \\
\DWATbitsizeTARG{} 
&\livelinki{chap:DWATbitsizebasetypebitsize}
        {Size of a base type in bits}
        {base type bit size} \\
&\livelinki{chap:DWATbitsizedatamemberbitsize}
        {Size of a data member in bits}
        {data member bit size} \\
\DWATbitstrideTARG{} 
&\livelinki{chap:DWATbitstridearrayelementstrideofarraytype}
           {Array element stride (of array type)}
           {array element stride (of array type)} \\
&\livelinki{chap:DWATbitstridesubrangestridedimensionofarraytype}
           {Subrange stride (dimension of array type)}
           {subrange stride (dimension of array type)} \\
&\livelinki{chap:DWATbitstrideenumerationstridedimensionofarraytype}
           {Enumeration stride (dimension of array type)}
           {enumeration stride (dimension of array type)} \\
\DWATbytesizeTARG{} 
&\livelinki{chap:DWATbytesizedataobjectordatatypesize}
           {Size of a data object or data type in bytes}
           {data object or data type size} \\
\DWATbytestrideTARG{} 
&\livelinki{chap:DWATbytestridearrayelementstrideofarraytype}
           {Array element stride (of array type)}
           {array element stride (of array type)} \\
&\livelinki{chap:DWATbytestridesubrangestridedimensionofarraytype}
           {Subrange stride (dimension of array type)}
           {subrange stride (dimension of array type)} \\
&\livelinki{chap:DWATbytestrideenumerationstridedimensionofarraytype}
           {Enumeration stride (dimension of array type)}
           {enumeration stride (dimension of array type)} \\
\DWATcallallcallsTARG{}
&\livelinki{chap:DWATcallallcallsofasubprogram}
           {All tail and normal calls in a subprogram are described by call site entries}
           {all tail and normal calls are described}
           \index{call site!summary!all tail and normal calls are described} \\
\DWATcallallsourcecallsTARG{}
&\livelinki{chap:DWATcallallsourcecallsofasubprogram}
           {All tail, normal and inlined calls in a subprogram are described by call site and inlined subprogram entries}
           {all tail, normal and inlined calls are described}
           \index{call site!summary!all tail, normal and inlined calls are described} \\
\DWATcallalltailcallsTARG{}
&\livelinki{chap:DWATcallalltailcallsofasubprogram}
           {All tail calls in a subprogram are described by call site entries}
           {all tail calls are described}
           \index{call site!summary!all tail calls are described} \\
\DWATcallcolumnTARG{} 
&\livelinki{chap:DWATcallcolumncolumnpositionofinlinedsubroutinecall}
           {Column position of inlined subroutine call}
           {column position of inlined subroutine call} \\
\DWATcalldatalocationTARG{}
&\livelinki{chap:DWATcalldatalocationofcallparameter}
           {Address of the value pointed to by an argument passed in a call}
           {address of the value pointed to by an argument}
           \index{call site!address of the value pointed to by an argument} \\
\DWATcalldatavalueTARG{}
&\livelinki{chap:DWATcalldatavalueofcallparameter}
           {Value pointed to by an argument passed in a call}
           {value pointed to by an argument}
           \index{call site!value pointed to by an argument} \\
\DWATcallfileTARG
&\livelinki{chap:DWATcallfilefilecontaininginlinedsubroutinecall}
           {File containing inlined subroutine call}
           {file containing inlined subroutine call} \\
\DWATcalllineTARG{} 
&\livelinki{chap:DWATcalllinelinenumberofinlinedsubroutinecall}
           {Line number of inlined subroutine call}
           {line number of inlined subroutine call} \\
\DWATcallingconventionTARG{} 
&\livelinki{chap:DWATcallingconventionforsubprograms}
           {Calling convention for subprograms}
           {Calling convention!for subprograms} \\
&\livelinki{chap:DWATcallingconventionfortypes}
           {Calling convention for types}
           {Calling convention!for types} \\
\DWATcalloriginTARG{}
&\livelinki{chap:DWATcalloriginofcallsite}
           {Subprogram called in a call}
           {subprogram called}
           \index{call site!subprogram called} \\
\DWATcallparameterTARG{}
&\livelinki{chap:DWATcallparameterofcallparameter}
           {Parameter entry in a call}
           {parameter entry}
           \index{call site!parameter entry} \\
\DWATcallpcTARG{}
&\livelinki{chap:DWATcallpcofcallsite}
           {Address of the call instruction in a call}
           {address of call instruction}
           \index{call site!address of the call instruction} \\
\DWATcallreturnpcTARG{}
&\livelinki{chap:DWATcallreturnpcofcallsite}
           {Return address from a call}
           {return address from a call}
           \index{call site!return address} \\
\DWATcalltailcallTARG{}
&\livelinki{chap:DWATcalltailcallofcallsite}
           {Call is a tail call}
           {call is a tail call}
           \index{call site!tail call} \\
\DWATcalltargetTARG{}
&\livelinki{chap:DWATcalltargetofcallsite}
           {Address of called routine in a call}
           {address of called routine}
           \index{call site!address of called routine} \\
\DWATcalltargetclobberedTARG{}
&\livelinki{chap:DWATcalltargetclobberedofcallsite}
           {Address of called routine, which may be clobbered, in a call}
           {address of called routine, which may be clobbered}
           \index{call site!address of called routine, which may be clobbered} \\
\DWATcallvalueTARG{}
&\livelinki{chap:DWATcallvalueofcallparameter}
           {Argument value passed in a call}
           {argument value passed}
           \index{call site!argument value passed} \\
\DWATcommonreferenceTARG
&\livelinki{chap:commonreferencecommonblockusage}
        {Common block usage}
        {common block usage} \\
\DWATcompdirTARG
&\livelinki{chap:DWATcompdircompilationdirectory}
        {Compilation directory}
        {compilation directory} \\
\DWATconstexprTARG
&\livelinki{chap:DWATconstexprcompiletimeconstantobject}
        {Compile-time constant object}
        {compile-time constant object} \\
&\livelinki{chap:DWATconstexprcompiletimeconstantfunction}
        {Compile-time constant function}
        {compile-time constant function} \\
\DWATconstvalueTARG
&\livelinki{chap:DWATconstvalueconstantobject}
        {Constant object}
        {constant object} \\
&\livelinki{chap:DWATconstvalueenumerationliteralvalue}
        {Enumeration literal value}
        {enumeration literal value} \\
&\livelinki{chap:DWATconstvaluetemplatevalueparameter}
        {Template value parameter}
        {template value parameter} \\
\DWATcontainingtypeTARG
&\livelinki{chap:DWATcontainingtypecontainingtypeofpointertomembertype}
        {Containing type of pointer to member type}
        {containing type of pointer to member type} \\
\DWATcountTARG
&\livelinki{chap:DWATcountelementsofsubrangetype}
        {Elements of subrange type}
        {elements of breg subrange type} \\
\DWATdatabitoffsetTARG
&\livelinki{chap:DWATdatabitoffsetbasetypebitlocation}
        {Base type bit location}
        {base type bit location} \\
&\livelinki{chap:DWATdatabitoffsetdatamemberbitlocation}
        {Data member bit location}
        {data member bit location} \\
\DWATdatalocationTARG{} 
&\livelinki{chap:DWATdatalocationindirectiontoactualdata}
        {Indirection to actual data}   
        {indirection to actual data} \\
\DWATdatamemberlocationTARG
&\livelinki{chap:DWATdatamemberlocationdatamemberlocation}
        {Data member location}
        {data member location} \\
&\livelinki{chap:DWATdatamemberlocationinheritedmemberlocation}
        {Inherited member location}
        {inherited member location} \\
\DWATdecimalscaleTARG
&\livelinki{chap:DWATdecimalscaledecimalscalefactor}
        {Decimal scale factor}
        {decimal scale factor} \\
\DWATdecimalsignTARG
&\livelinki{chap:DWATdecimalsigndecimalsignrepresentation}
        {Decimal sign representation}
        {decimal sign representation} \\
\DWATdeclcolumnTARG
&\livelinki{chap:DWATdeclcolumncolumnpositionofsourcedeclaration}
        {Column position of source declaration}
        {column position of source declaration} \\
\DWATdeclfileTARG
&\livelinki{chap:DWATdeclfilefilecontainingsourcedeclaration}
        {File containing source declaration}
        {file containing source declaration} \\
\DWATdecllineTARG
&\livelinki{chap:DWATdecllinelinenumberofsourcedeclaration}
        {Line number of source declaration}
        {line number of source declaration} \\
\DWATdeclarationTARG
&\livelinki{chap:DWATdeclarationincompletenondefiningorseparateentitydeclaration}
        {Incomplete, non-defining, or separate entity declaration}
        {incomplete, non-defining, or separate entity declaration} \\
\DWATdefaultedTARG
&\livelinki{chap:DWATdefaulteddef}
        {Whether a member function has been declared as default}
        {defaulted attribute} \\
\DWATdefaultvalueTARG
&\livelinki{chap:DWATdefaultvaluedefaultvalueofparameter}
        {Default value of parameter}
        {default value of parameter} \\
\DWATdeletedTARG
&\livelinki{chap:DWATdeleteddef}
        {Whether a member has been declared as deleted}
        {Deletion of member function} \\
\DWATdescriptionTARG{} 
&\livelinki{chap:DWATdescriptionartificialnameordescription}
        {Artificial name or description}
        {artificial name or description} \\
\DWATdigitcountTARG
&\livelinki{chap:DWATdigitcountdigitcountforpackeddecimalornumericstringtype}
        {Digit count for packed decimal or numeric string type}
        {digit count for packed decimal or numeric string type} \\
\DWATdiscrTARG
&\livelinki{chap:DWATdiscrdiscriminantofvariantpart}
        {Discriminant of variant part}
        {discriminant of variant part} \\
\DWATdiscrlistTARG
&\livelinki{chap:DWATdiscrlistlistofdiscriminantvalues}
        {List of discriminant values}
        {list of discriminant values} \\
\DWATdiscrvalueTARG
&\livelinki{chap:DWATdiscrvaluediscriminantvalue}
        {Discriminant value}
        {discriminant value} \\
\DWATdwoidTARG
&\livelinki{chap:DWATdwoidforunit}
        {Signature for compilation unit}
        {split DWARF object file!unit signature} \\
\DWATdwonameTARG
&\livelinki{chap:DWATdwonameforunit}
        {Name of split DWARF object file}
        {split DWARF object file!object file name} \\
\DWATelementalTARG
&\livelinki{chap:DWATelementalelementalpropertyofasubroutine}
        {Elemental property of a subroutine}
        {elemental property of a subroutine} \\
\DWATencodingTARG
&\livelinki{chap:DWATencodingencodingofbasetype}
        {Encoding of base type}
        {encoding of base type} \\
\DWATendianityTARG
&\livelinki{chap:DWATendianityendianityofdata}
        {Endianity of data}
        {endianity of data} \\
\DWATentrypcTARG
&\livelinki{chap:entryaddressofscope}
        {Entry address of a scope (compilation unit, \mbox{subprogram,} and so on)}
        {entry address of a scope} \\
\DWATenumclassTARG
&\livelinki{chap:DWATenumclasstypesafeenumerationdefinition}
        {Type safe enumeration definition}
        {type safe enumeration definition}\\
\DWATexplicitTARG
&\livelinki{chap:DWATexplicitexplicitpropertyofmemberfunction}
        {Explicit property of member function}
        {explicit property of member function}\\
\DWATexportsymbolsTARG
&\livelinki{chap:DWATexportsymbolsofnamespace}
        {Export (inline) symbols of namespace}
        {export symbols of a namespace} \\
&\livelinki{chap:DWATexportsymbolsofstructunionclass}
        {Export symbols of a structure, union or class}
        {export symbols of a structure, union or class} \\
\DWATextensionTARG
&\livelinki{chap:DWATextensionpreviousnamespaceextensionororiginalnamespace}
        {Previous namespace extension or original namespace}
        {previous namespace extension or original namespace}\\
\DWATexternalTARG
&\livelinki{chap:DWATexternalexternalsubroutine}
        {External subroutine}
        {external subroutine} \\
&\livelinki{chap:DWATexternalexternalvariable}
        {External variable}
        {external variable} \\
\DWATframebaseTARG
&\livelinki{chap:DWATframebasesubroutineframebaseaddress}
        {Subroutine frame base address}
        {subroutine frame base address} \\
\DWATfriendTARG
&\livelinki{chap:DWATfriendfriendrelationship}
        {Friend relationship}
        {friend relationship} \\
\DWAThighpcTARG
&\livelinki{chap:DWAThighpccontiguousrangeofcodeaddresses}
        {Contiguous range of code addresses}
        {contiguous range of code addresses} \\
\DWATidentifiercaseTARG
&\livelinki{chap:DWATidentifiercaseidentifiercaserule}
        {Identifier case rule}
        {identifier case rule} \\
\DWATimportTARG
&\livelinki{chap:DWATimportimporteddeclaration}
        {Imported declaration}
        {imported declaration} \\
&\livelinki{chap:DWATimportimportedunit}
        {Imported unit}
        {imported unit} \\
&\livelinki{chap:DWATimportnamespacealias}
        {Namespace alias}
        {namespace alias} \\
&\livelinki{chap:DWATimportnamespaceusingdeclaration}
        {Namespace using declaration}
        {namespace using declaration} \\
&\livelinki{chap:DWATimportnamespaceusingdirective}
        {Namespace using directive}
        {namespace using directive} \\
\DWATinlineTARG
&\livelinki{chap:DWATinlineabstracttinstance}
        {Abstract instance}
        {abstract instance} \\
&\livelinki{chap:DWATinlineinlinedsubroutine}
        {Inlined subroutine}
        {inlined subroutine} \\
\DWATisoptionalTARG
&\livelinki{chap:DWATisoptionaloptionalparameter}
        {Optional parameter}
        {optional parameter} \\
\DWATlanguageTARG
&\livelinki{chap:DWATlanguageprogramminglanguage}
        {Programming language}
        {programming language} \\
\DWATlinkagenameTARG
&\livelinki{chap:DWATlinkagenameobjectfilelinkagenameofanentity}
        {Object file linkage name of an entity}
        {object file linkage name of an entity}\\
\DWATlocationTARG
&\livelinki{chap:DWATlocationdataobjectlocation}
        {Data object location}
        {data object location}\\
\DWATlowpcTARG
&\livelinki{chap:DWATlowpccodeaddressorrangeofaddresses}
        {Code address or range of addresses}
        {code address or range of addresses}\\
\DWATlowerboundTARG
&\livelinki{chap:DWATlowerboundlowerboundofsubrange}
        {Lower bound of subrange}
        {lower bound of subrange} \\
\DWATmacroinfoTARG
&\livelinki{chap:DWATmacroinfomacroinformation}
           {Macro preprocessor information (legacy)} 
           {macro preprocessor information (legacy)} \\
&          \textit{(reserved for coexistence with \DWARFVersionIV{} and earlier)} \\
\DWATmacrosTARG
&\livelinki{chap:DWATmacrosmacroinformation}
           {Macro preprocessor information} 
           {macro preprocessor information} \\
&          \textit{(\texttt{\#define}, \texttt{\#undef}, and so on in \addtoindex{C}, 
                \addtoindex{C++} and similar languages)} \\
\DWATmainsubprogramTARG
&\livelinki{chap:DWATmainsubprogrammainorstartingsubprogram}
        {Main or starting subprogram}
        {main or starting subprogram} \\
&\livelinki{chap:DWATmainsubprogramunitcontainingmainorstartingsubprogram}
        {Unit containing main or starting subprogram}
        {unit containing main or starting subprogram}\\
\DWATmutableTARG
&\livelinki{chap:DWATmutablemutablepropertyofmemberdata}
        {Mutable property of member data}
        {mutable property of member data} \\
\DWATnameTARG
&\livelinki{chap:DWATnamenameofdeclaration}
        {Name of declaration}
        {name of declaration}\\
&\livelinki{chap:DWATnamepathnameofcompilationsource}
        {Path name of compilation source}
        {path name of compilation source} \\
\DWATnamelistitemTARG
&\livelinki{chap:DWATnamelistitemnamelistitem}
        {Namelist item}
        {namelist item}\\
\DWATnoreturnTARG
&\livelinki{chap:DWATnoreturnofsubprogram}
        {\doublequote{no return} property of a subprogram}
        {noreturn attribute} \\
\DWATobjectpointerTARG
&\livelinki{chap:DWATobjectpointerobjectthisselfpointerofmemberfunction}
        {Object (\texttt{this}, \texttt{self}) pointer of member function}
        {object (\texttt{this}, \texttt{self}) pointer of member function}\\
\DWATorderingTARG
&\livelinki{chap:DWATorderingarrayrowcolumnordering}
        {Array row/column ordering}
        {array row/column ordering}\\
\DWATpicturestringTARG
&\livelinki{chap:DWATpicturestringpicturestringfornumericstringtype}
        {Picture string for numeric string type}
        {picture string for numeric string type} \\
\DWATpriorityTARG
&\livelinki{chap:DWATprioritymodulepriority}
        {Module priority}
        {module priority}\\
\DWATproducerTARG
&\livelinki{chap:DWATproducercompileridentification}
        {Compiler identification}
        {compiler identification}\\
\DWATprototypedTARG
&\livelinki{chap:DWATprototypedsubroutineprototype}
        {Subroutine prototype}
        {subroutine prototype}\\
\DWATpureTARG
&\livelinki{chap:DWATpurepurepropertyofasubroutine}
        {Pure property of a subroutine}
        {pure property of a subroutine} \\
\DWATrangesTARG
&\livelinki{chap:DWATrangesnoncontiguousrangeofcodeaddresses}
        {Non-contiguous range of code addresses}
        {non-contiguous range of code addresses} \\
\DWATrangesbaseTARG
&\livelinki{chap:DWATrangesbaseforrangelists}
        {Base offset for range lists}
        {ranges lists} \\
\DWATrankTARG
&\livelinki{chap:DWATrankofdynamicarray}
        {Dynamic number of array dimensions}
        {dynamic number of array dimensions} \\
\DWATrecursiveTARG
&\livelinki{chap:DWATrecursiverecursivepropertyofasubroutine}
        {Recursive property of a subroutine}
        {recursive property of a subroutine} \\
\DWATreferenceTARG
&\livelink{chap:DWATreferenceofnonstaticmember}
          {\&-qualified non-static member function} \textit{(\addtoindex{C++})} \\
\DWATreturnaddrTARG
&\livelinki{chap:DWATreturnaddrsubroutinereturnaddresssavelocation}
           {Subroutine return address save location}
           {subroutine return address save location} \\
\DWATrvaluereferenceTARG
&\livelink{chap:DWATrvaluereferenceofnonstaticmember}
          {\&\&-qualified non-static member function} \textit{(\addtoindex{C++})} \\

\DWATsegmentTARG
&\livelinki{chap:DWATsegmentaddressinginformation}
        {Addressing information}
        {addressing information} \\
\DWATsiblingTARG
&\livelinki{chap:DWATsiblingdebugginginformationentryrelationship}
           {Debugging information entry relationship}
           {debugging information entry relationship} \\
\DWATsmallTARG
&\livelinki{chap:DWATsmallscalefactorforfixedpointtype}
           {Scale factor for fixed-point type}
           {scale factor for fixed-point type} \\
\DWATsignatureTARG
&\livelinki{chap:DWATsignaturetypesignature}
           {Type signature}
           {type signature}\\
\DWATspecificationTARG
&\livelinki{chap:DWATspecificationincompletenondefiningorseparatedeclaration}
           {Incomplete, non-defining, or separate declaration corresponding to a declaration}
           {incomplete, non-defining, or separate declaration corresponding to a declaration} \\
\DWATstartscopeTARG
&\livelinki{chap:DWATstartscopeobjectdeclaration}
        {Object declaration}
        {object declaration}\\*
&\livelinki{chap:DWATstartscopetypedeclaration}
        {Type declaration}
        {type declaration}\\
\DWATstaticlinkTARG
&\livelinki{chap:DWATstaticlinklocationofuplevelframe}
        {Location of uplevel frame}
        {location of uplevel frame} \\
\DWATstmtlistTARG
&\livelinki{chap:DWATstmtlistlinenumberinformationforunit}
           {Line number information for unit}
           {line number information for unit}\\
\DWATstringlengthTARG
&\livelinki{chap:DWATstringlengthstringlengthofstringtype}
           {String length of string type}
           {string length of string type} \\
\DWATstringlengthbitsizeTARG
&\livelinki{chap:DWATstringlengthstringlengthofstringtype}
           {Size of string length of string type}
           {string length of string type!size of} \\
\DWATstringlengthbytesizeTARG
&\livelinki{chap:DWATstringlengthstringlengthofstringtype}
           {Size of string length of string type}
           {string length of string type!size of} \\
\DWATstroffsetsbaseTARG
&\livelinki{chap:DWATstroffsetbaseforindirectstringtable}
        {Base of string offsets table}
        {string offsets table} \\
\DWATthreadsscaledTARG
&\livelink{chap:DWATthreadsscaledupcarrayboundthreadsscalfactor}
        {UPC array bound THREADS scale factor}\\
\DWATtrampolineTARG
&\livelinki{chap:DWATtrampolinetargetsubroutine}
        {Target subroutine}
        {target subroutine of trampoline} \\
\DWATtypeTARG
&\livelinki{chap:DWATtypeofcallsite}
        {Type of call site}
        {type!of call site} \\
&\livelinki{char:DWAATtypeofstringtype}
        {Type of string type components}
        {type!of string type components} \\
&\livelinki{chap:DWATtypetypeofsubroutinereturn}
        {Type of subroutine return}
        {type!of subroutine return} \\
&\livelinki{chap:DWATtypetypeofdeclaration}
        {Type of declaration}
        {type!of declaration} \\
\DWATupperboundTARG
&\livelinki{chap:DWATupperboundupperboundofsubrange}
        {Upper bound of subrange}
        {upper bound of subrange} \\
\DWATuselocationTARG
&\livelinki{chap:DWATuselocationmemberlocationforpointertomembertype}
        {Member location for pointer to member type}
        {member location for pointer to member type} \\
\DWATuseUTFeightTARG\addtoindexx{use UTF8 attribute}\addtoindexx{UTF-8}
&\livelinki{chap:DWATuseUTF8compilationunitusesutf8strings}
        {Compilation unit uses UTF-8 strings}
        {compilation unit uses UTF-8 strings} \\
\DWATvariableparameterTARG
&\livelinki{chap:DWATvariableparameternonconstantparameterflag}
        {Non-constant parameter flag}
        {non-constant parameter flag}  \\
\DWATvirtualityTARG
&\livelinki{chap:DWATvirtualityvirtualityindication}
        {Virtuality indication}
        {virtuality indication} \\
&\livelinki{chap:DWATvirtualityvirtualityofbaseclass}
        {Virtuality of base class}
        {virtuality of base class} \\
&\livelinki{chap:DWATvirtualityvirtualityoffunction}
        {Virtuality of function}
        {virtuality of function} \\
\DWATvisibilityTARG
&\livelinki{chap:DWATvisibilityvisibilityofdeclaration}
        {Visibility of declaration}
        {visibility of declaration} \\
\DWATvtableelemlocationTARG
&\livelinki{chap:DWATvtableelemlocationvirtualfunctiontablevtableslot}
        {Virtual function vtable slot}
        {virtual function vtable slot}\\
\end{longtable}

\addtoindexx{address|see {\textit{also} address class}}
\addtoindexx{addrptr|see {\textit{also} addrptr class}}
\addtoindexx{block|see {\textit{also} block class}}
\addtoindexx{constant|see {\textit{also} constant class}}
\addtoindexx{exprloc|see {\textit{also} exprloc class}}
\addtoindexx{flag|see {\textit{also} flag class}}
\addtoindexx{lineptr|see {\textit{also} lineptr class}}
\addtoindexx{loclistptr|see {\textit{also} loclistptr class}}
\addtoindexx{macptr|see {\textit{also} macptr class}}
\addtoindexx{rangelistptr|see {\textit{also} rangelistptr class}}
\addtoindexx{reference|see {\textit{also} reference class}}
\addtoindexx{string|see {\textit{also} string class}}
\addtoindexx{stroffsetsptr|see {\textit{also} stroffsetsptr class}}

\addtoindexx{class of attribute value!address|see {address class}}
\addtoindexx{class of attribute value!addrptr|see {addrptr class}}
\addtoindexx{class of attribute value!block|see {block class}}
\addtoindexx{class of attribute value!constant|see {constant class}}
\addtoindexx{class of attribute value!exprloc|see {exprloc class}}
\addtoindexx{class of attribute value!flag|see {flag class}}
\addtoindexx{class of attribute value!lineptr|see {lineptr class}}
\addtoindexx{class of attribute value!loclistptr|see {loclistptr class}}
\addtoindexx{class of attribute value!macptr|see {macptr class}}
\addtoindexx{class of attribute value!rangelistptr|see {rangelistptr class}}
\addtoindexx{class of attribute value!reference|see {reference class}}
\addtoindexx{class of attribute value!string|see {string class}}
\addtoindexx{class of attribute value!stroffsetsptr|see {stroffsetsptr class}}

The permissible values
\addtoindexx{attribute value classes}
for an attribute belong to one or more classes of attribute
value forms.  
Each form class may be represented in one or more ways. 
For example, some attribute values consist
of a single piece of constant data. 
\doublequote{Constant data}
is the class of attribute value that those attributes may have. 
There are several representations of constant data,
however (one, two, four, or eight bytes, and variable length
data). 
The particular representation for any given instance
of an attribute is encoded along with the attribute name as
part of the information that guides the interpretation of a
debugging information entry.  

\needlines{4}
Attribute value forms belong
\addtoindexx{tag names!list of}
to one of the classes shown in Table \referfol{tab:classesofattributevalue}.

\begin{longtable}{l|P{11cm}}
\caption{Classes of attribute value}
\label{tab:classesofattributevalue} \\
\hline \bfseries Attribute Class & \bfseries General Use and Encoding \\ \hline
\endfirsthead
  \bfseries Attribute Class & \bfseries General Use and Encoding \\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot

\hypertarget{chap:classaddress}{}
\livelinki{datarep:classaddress}{address}{address class}
&Refers to some location in the address space of the \mbox{described} program.
\\

\hypertarget{chap:classaddrptr}{}
\livelinki{datarep:classaddrptr}{addrptr}{addrptr class}
&Refers to a base location in the DWARF section that holds
a series of machine address values. Certain attributes \mbox{refer}
one of these addresses by indexing relative to this base
location.
\\

\hypertarget{chap:classblock}{}
\livelinki{datarep:classblock}{block}{block class}
& An arbitrary number of uninterpreted bytes of data.
\\
 
\hypertarget{chap:classconstant}{}
\livelinki{datarep:classconstant}{constant}{constant class}
&One, two, four or eight bytes of uninterpreted data, or data
encoded in the variable length format known as LEB128 
(see Section \refersec{datarep:variablelengthdata}).

\textit{Most constant values are integers of one kind or
another (codes, offsets, counts, and so on); these are
sometimes called \doublequote{integer constants} for emphasis.}
\addtoindexx{integer constant}
\addtoindexx{constant class!integer}
\\

\hypertarget{chap:classexprloc}{}
\livelinki{datarep:classexprloc}{exprloc}{exprloc class}
&A DWARF expression for a value or a location in the \mbox{address} space of the described program.
\\

\hypertarget{chap:classflag}{}
\livelinki{datarep:classflag}{flag}{flag class}
&A small constant that indicates the presence or absence of an attribute.
\\

\hypertarget{chap:classlineptr}{}
\livelinki{datarep:classlineptr}{lineptr}{lineptr class}
&Refers to a location in the DWARF section that holds line number information.
\\

\hypertarget{chap:classloclistptr}{}
\livelinki{datarep:classloclistptr}{loclistptr}{loclistptr class}
&Refers to a location in the DWARF section that holds \mbox{location} lists, which
describe objects whose location can change during their lifetime.
\\

\hypertarget{chap:classmacptr}{}
\livelinki{datarep:classmacptr}{macptr}{macptr class}
& Refers to a location in the DWARF section that holds macro definition
 information.
\\

\hypertarget{chap:classrangelistptr}{}
\livelinki{datarep:classrangelistptr}{rangelistptr}{rangelistptr class}
& Refers to a location in the DWARF section that holds non\dash contiguous address ranges.
\\

\hypertarget{chap:classreference}{}
\livelinki{datarep:classreference}{reference}{reference class}
& Refers to one of the debugging information
entries that \mbox{describe} the program.  There are four types of
\mbox{reference}. The first is an offset relative to the beginning
of the \mbox{compilation} unit in which the reference occurs and must
refer to an entry within that same compilation unit. The second
type of reference is the offset of a debugging \mbox{information}
entry in any compilation unit, including one different from
the unit containing the reference. The third type of reference
is an indirect reference to a 
\addtoindexx{type signature}
type definition using a 64-bit \mbox{signature} 
for that type. The fourth type of reference is a reference from within the 
\dotdebuginfo{} section of the executable or shared object file to
a debugging information entry in the \dotdebuginfo{} section of 
a \addtoindex{supplementary object file}.
\\

\hypertarget{chap:classstring}{}
\livelinki{datarep:classstring}{string}{string class}
& A null\dash terminated sequence of zero or more
(non\dash null) bytes. Data in this class are generally
printable strings. Strings may be represented directly in
the debugging \mbox{information} entry or as an offset in a separate
string table.
\\

\hypertarget{chap:classstroffsetsptr}{}
\livelinki{datarep:classstroffsetsptr}{stroffsetsptr}{stroffsetsptr class}
&Refers to a base location in the DWARF section that holds
a series of offsets in the DWARF section that holds strings.
Certain attributes refer to one of these offsets by indexing 
\mbox{relative} to this base location. The resulting offset is then 
used to index into the DWARF string section.
\\

\hline
\end{longtable}


\section{Relationship of Debugging Information Entries}
\label{chap:relationshipofdebugginginformationentries}
\textit{%
A variety of needs can be met by permitting a single
\addtoindexx{debugging information entry!ownership relation}
debugging information entry to \doublequote{own} an arbitrary number
of other debugging entries and by permitting the same debugging
information entry to be one of many owned by another debugging
information entry. 
This makes it possible, for example, to
describe the static \livelink{chap:lexicalblock}{block} structure 
within a source file,
to show the members of a structure, union, or class, and to
associate declarations with source files or source files
with shared object files.  
}


The ownership relation 
\addtoindexx{debugging information entry!ownership relation}
of debugging
information entries is achieved naturally because the debugging
information is represented as a tree. 
The nodes of the tree
are the debugging information entries themselves. 
The child
entries of any node are exactly those debugging information
entries owned by that node.  

\textit{%
While the ownership relation
of the debugging information entries is represented as a
tree, other relations among the entries exist, for example,
a reference from an entry representing a variable to another
entry representing the type of that variable. 
If all such
relations are taken into account, the debugging entries
form a graph, not a tree.  
}

\needlines{4}
The tree itself is represented
by flattening it in prefix order. 
Each debugging information
entry is defined either to have child entries or not to have
child entries (see Section \refersec{datarep:abbreviationstables}). 
If an entry is defined not
to have children, the next physically succeeding entry is a
sibling. 
If an entry is defined to have children, the next
physically succeeding entry is its first child. 
Additional
children are represented as siblings of the first child. 
A chain of sibling entries is terminated by a null entry.

In cases where a producer of debugging information feels that
\hypertarget{chap:DWATsiblingdebugginginformationentryrelationship}{}
it will be important for consumers of that information to
quickly scan chains of sibling entries, while ignoring the
children of individual siblings, that producer may attach a
\addtoindexx{sibling attribute}
\DWATsiblingDEFN{} attribute 
to any debugging information entry. 
The value of this attribute is a reference to the sibling entry
of the entry to which the attribute is attached.


\section{Target Addressable Units and Addresses}
\label{chap:targetaddressableunitsandaddresses}
The standard assumes that the smallest directly 
\addtoindex{addressable unit} of memory on the
target architecture is a byte consisting of eight bits.

\label{chap:targetaddresses}
Many places in this document refer to the size of an
\addtoindexx{size of an address|see{\textit{also} \texttt{address\_size}}}
\addtoindexi{address}{size of an address}
\addtoindexx{address size|see{size of an address}}
\addtoindexx{address size|see{\textit{also} \texttt{address\_size}}}
on the target architecture (or equivalently, target machine)
to which a DWARF description applies. For processors which
can be configured to have different address sizes or different
instruction sets, the intent is to refer to the configuration
which is either the default for that processor or which is
specified by the object file or executable file which contains
the DWARF information.

\textit{%
For example, if a particular target architecture supports
both 32-bit and 64-bit addresses, the compiler will generate
an object file which specifies that it contains executable
code generated for one or the other of these 
\addtoindexx{size of an address}
address sizes. In
that case, the DWARF debugging information contained in this
object file will use the same address size.
}

\textit{%
Architectures which have multiple instruction sets are
supported by the \texttt{isa} entry in the line number information
(see Section \refersec{chap:statemachineregisters}).
}

\section{DWARF Expressions}
\label{chap:dwarfexpressions}
DWARF expressions describe how to compute a value or name a
location during debugging of a program. 
They are expressed in
terms of DWARF operations that operate on a stack of values.

All DWARF operations are encoded as a stream of opcodes that
are each followed by zero or more literal operands. 
The number
of operands is determined by the opcode.  

In addition to the
general operations that are defined here, operations that are
specific to location descriptions are defined in 
Section \refersec{chap:locationdescriptions}.

\subsection{General Operations}
\label{chap:generaloperations}
Each general operation represents a postfix operation on
a simple stack machine. 
Each element of the stack has a type and a value, and can represent
a value of any supported base type of the target machine.  Instead of
a base type, elements can have a 
\livetarg{chap:specialaddresstype}{special address type},
which is an integral type that has the 
\addtoindex{size of an address} on the target machine and 
unspecified signedness. The value on the top of the stack after 
\doublequote{executing} the 
\addtoindex{DWARF expression}
is 
\addtoindexx{DWARF expression|see{\textit{also} location description}}
taken to be the result (the address of the object, the
value of the array bound, the length of a dynamic string,
the desired value itself, and so on).

\needlines{4}
\textit{While the abstract definition of the stack calls for variable-size entries
able to hold any supported base type, in practice it is expected that each
element of the stack can be represented as a fixed-size element large enough
to hold a value of any type supported by the DWARF consumer for that target,
plus a small identifier sufficient to encode the type of that element.
Support for base types other than what is required to do address arithmetic
is intended only for debugging of optimized code, and the completeness of the
DWARF consumer's support for the full set of base types is a
quality-of-implementation issue. If a consumer encounters a DWARF expression
that uses a type it does not support, it should ignore the entire expression
and report its inability to provide the requested information.}

\textit{It should also be noted that floating-point arithmetic is highly dependent
on the computational environment. It is not the intention of this expression
evaluation facility to produce identical results to those produced by the
program being debugged while executing on the target machine. Floating-point
computations in this stack machine will be done with precision control and
rounding modes as defined by the implementation.}

\needlines{4}
\subsubsection{Literal Encodings}
\label{chap:literalencodings}
The 
\addtoindexx{DWARF expression!literal encodings}
following operations all push a value onto the DWARF
stack. 
\addtoindexx{DWARF expression!stack operations}
Operations other than \DWOPconsttype{} push a value with the 
\specialaddresstype, and if the value of a constant in one of these 
operations is larger than can be stored in a single stack element, 
the value is truncated to the element size and the low-order bits
are pushed on the stack.
\begin{enumerate}[1. ]
\itembfnl{\DWOPlitzeroTARG, \DWOPlitoneTARG, \dots, \DWOPlitthirtyoneTARG}
The \DWOPlitnTARG{} operations encode the unsigned literal values
from 0 through 31, inclusive.

\itembfnl{\DWOPaddrTARG}
The \DWOPaddrNAME{} operation has a single operand that encodes
a machine address and whose size is the \addtoindex{size of an address}
on the target machine.

\itembfnl{\DWOPconstoneuTARG, \DWOPconsttwouTARG, \DWOPconstfouruTARG, \DWOPconsteightuTARG}
\DWOPconstnxMARK{}
The single operand of a \DWOPconstnuNAME{} operation provides a 1,
2, 4, or 8-byte unsigned integer constant, respectively.

\itembfnl{\DWOPconstonesTARG, \DWOPconsttwosTARG, \DWOPconstfoursTARG, \DWOPconsteightsTARG}
The single operand of a \DWOPconstnsNAME{} operation provides a 1,
2, 4, or 8-byte signed integer constant, respectively.

\itembfnl{\DWOPconstuTARG}
The single operand of the \DWOPconstuNAME{} operation provides
an unsigned LEB128\addtoindexx{LEB128!unsigned} integer constant.

\itembfnl{\DWOPconstsTARG}
The single operand of the \DWOPconstsNAME{} operation provides
a signed LEB128\addtoindexx{LEB128!unsigned} integer constant.

\needlines{4}
\itembfnl{\DWOPaddrxTARG}
The \DWOPaddrxNAME{} operation has a single operand that
encodes an unsigned LEB128\addtoindexx{LEB128!unsigned} value, 
which is a zero-based index into the \dotdebugaddr{} section, 
where a machine address is stored.
This index is relative to the value of the 
\DWATaddrbase{} attribute of the associated compilation unit.

\itembfnl{\DWOPconstxTARG}
The \DWOPconstxNAME{} operation has a single operand that
encodes an unsigned LEB128\addtoindexx{LEB128!unsigned} value, 
which is a zero-based
index into the \dotdebugaddr{} section, where a constant, the
size of a machine address, is stored.
This index is relative to the value of the 
\DWATaddrbase{} attribute of the associated compilation unit.

\needlines{3}
\textit{The \DWOPconstxNAME{} operation is provided for constants that
require link-time relocation but should not be
interpreted by the consumer as a relocatable address
(for example, offsets to thread-local storage).}

\needlines{12}
\itembfnl{\DWOPconsttypeTARG}
The \DWOPconsttypeNAME{} operation takes three operands. The first operand 
is an unsigned LEB128 integer that represents the offset of a debugging
information entry in the current compilation unit, which must be a
\DWTAGbasetype{} entry that provides the type of the constant provided. The
second operand is 1-byte unsigned integer that specifies the size of the
constant value, which is the same as the size of the base type referenced
by the first operand. The third operand is a block of specified 
size that is to be interpreted as a value of the referenced type.

\textit{While the size of the constant could be inferred from the base type
definition, it is encoded explicitly into the operation so that the
operation can be parsed easily without reference to the \dotdebuginfo{}
section.}

\end{enumerate}

\needlines{10}
\subsubsection{Register Values}
\label{chap:registervalues}
The following operations push a value onto the stack that is either the
contents of a register or the result of adding the contents of a register
to a given signed offset. 
\addtoindexx{DWARF expression!register based addressing}
\DWOPregvaltype{} pushes the contents
of the register together with the given base type, while the other operations
push the result of adding the contents of a register to a given
signed offset together with the \specialaddresstype.

\needlines{4}
\begin{enumerate}[1. ]
\itembfnl{\DWOPfbregTARG}
The \DWOPfbregNAME{} operation provides a 
signed LEB128\addtoindexx{LEB128!signed} offset
from the address specified by the location description in the
\DWATframebase{} attribute of the current function. (This
is typically a \doublequote{stack pointer} register plus or minus
some offset. On more sophisticated systems it might be a
location list that adjusts the offset according to changes
in the stack pointer as the PC changes.)

\itembfnl{\DWOPbregzeroTARG, \DWOPbregoneTARG, \dots, \DWOPbregthirtyoneTARG}
The single operand of the \DWOPbregnTARG{} 
operations provides
a signed LEB128\addtoindexx{LEB128!signed} offset from
the specified register.

\itembfnl{\DWOPbregxTARG}
The \DWOPbregxNAME{} operation provides the sum of two values specified
by its two operands. The first operand is a register number
which is specified by an unsigned LEB128\addtoindexx{LEB128!unsigned}
number. The second operand is a signed LEB128\addtoindexx{LEB128!signed} offset.

\needlines{8}
\itembfnl{\DWOPregvaltypeTARG}
The \DWOPregvaltypeNAME{} operation provides the contents of
a given register interpreted as a value of a given type. The first 
operand is an unsigned LEB128\addtoindexx{LEB128!unsigned} number, 
which identifies a register whose contents is to
be pushed onto the stack. The second operand is an 
unsigned LEB128\addtoindexx{LEB128!unsigned} number
that represents the offset of a debugging information entry in the current
compilation unit, which must be a \DWTAGbasetype{} entry that provides the
type of the value contained in the specified register.

\end{enumerate}

\needlines{6}
\subsubsection{Stack Operations}
\label{chap:stackoperations}
The following 
\addtoindexx{DWARF expression!stack operations}
operations manipulate the DWARF stack. Operations
that index the stack assume that the top of the stack (most
recently added entry) has index 0.

The \DWOPdup{}, \DWOPdrop{}, \DWOPpick{}, \DWOPover{}, \DWOPswap{}
and \DWOProt{} operations manipulate the elements of the stack as pairs
consisting of the value together with its type identifier. 
The \DWOPderef{}, \DWOPderefsize{}, \DWOPxderef{}, \DWOPxderefsize{} 
and \DWOPformtlsaddress{}
operations require the popped values to have an integral type, either the
\specialaddresstype{} or some other integral base type, and push a 
value with the \specialaddresstype.  
\DWOPdereftype{} and \DWOPxdereftype{} operations have the
same requirement on the popped values, but push a value together 
with the same type as the popped values.
All other operations push a value together with the \specialaddresstype.

\begin{enumerate}[1. ]
\itembfnl{\DWOPdupTARG}
The \DWOPdupNAME{} operation duplicates the value (including its 
type identifier) at the top of the stack.

\itembfnl{\DWOPdropTARG}
The \DWOPdropNAME{} operation pops the value (including its type 
identifier) at the top of the stack.

\itembfnl{\DWOPpickTARG}
The single operand of the \DWOPpickNAME{} operation provides a
1-byte index. A copy of the stack entry (including its 
type identifier) with the specified
index (0 through 255, inclusive) is pushed onto the stack.

\itembfnl{\DWOPoverTARG}
The \DWOPoverNAME{} operation duplicates the entry currently second
in the stack at the top of the stack. 
This is equivalent to a
\DWOPpick{} operation, with index 1.  

\needlines{4}
\itembfnl{\DWOPswapTARG}
The \DWOPswapNAME{} operation swaps the top two stack entries. 
The entry at the top of the stack (including its type identifier)
becomes the second stack entry, and the second entry (including 
its type identifier) becomes the top of the stack.

\itembfnl{\DWOProtTARG}
The \DWOProtNAME{} operation rotates the first three stack
entries. The entry at the top of the stack (including its 
type identifier) becomes the third stack entry, the second 
entry (including its type identifier) becomes the top of 
the stack, and the third entry (including its type identifier)
becomes the second entry.

\itembfnl{\DWOPderefTARG}
The \DWOPderefNAME{} operation pops the top stack entry and 
treats it as an address. The popped value must have an integral type.
The value retrieved from that address is pushed, together with the
\specialaddresstype{} identifier. 
The size of the data retrieved from the 
\addtoindexi{dereferenced}{address!dereference operator}
address is the \addtoindex{size of an address} on the target machine.

\needlines{4}
\itembfnl{\DWOPderefsizeTARG}
The \DWOPderefsizeNAME{} operation behaves like the 
\DWOPderef{}
operation: it pops the top stack entry and treats it as an
address. The popped value must have an integral type.
The value retrieved from that address is pushed, together with the
\specialaddresstype{} identifier. In
the \DWOPderefsizeNAME{} operation, however, the size in bytes
of the data retrieved from the dereferenced address is
specified by the single operand. This operand is a 1-byte
unsigned integral constant whose value may not be larger
than the size of the \specialaddresstype. The data
retrieved is zero extended to the size of an address on the
target machine before being pushed onto the expression stack.

\itembfnl{\DWOPdereftypeTARG}
The \DWOPdereftypeNAME{} operation behaves like the \DWOPderefsize{} operation:
it pops the top stack entry and treats it as an address. 
The popped value must have an integral type.
The value retrieved from that address is pushed together with a type identifier. 
In the \DWOPdereftypeNAME{} operation, the size in
bytes of the data retrieved from the dereferenced address is specified by
the first operand. This operand is a 1-byte unsigned integral constant whose
value which is the same as the size of the base type referenced
by the second operand.
The second operand is an unsigned LEB128 integer that
represents the offset of a debugging information entry in the current
compilation unit, which must be a \DWTAGbasetype{} entry that provides the
type of the data pushed.

\textit{While the size of the pushed value could be inferred from the base 
type definition, it is encoded explicitly into the operation so that the
operation can be parsed easily without reference to the \dotdebuginfo{}
section.}

\needlines{7}
\itembfnl{\DWOPxderefTARG}
The \DWOPxderefNAME{} operation provides an extended dereference
mechanism. The entry at the top of the stack is treated as an
address. The second stack entry is treated as an \doublequote{address
space identifier} for those architectures that support
\addtoindexi{multiple}{address space!multiple}
address spaces. 
Both of these entries must have integral type identifiers.
The top two stack elements are popped,
and a data item is retrieved through an implementation-defined
address calculation and pushed as the new stack top together with the
\specialaddresstype{} identifier.
The size of the data retrieved from the 
\addtoindexi{dereferenced}{address!dereference operator}
address is the size of the \specialaddresstype.

\itembfnl{\DWOPxderefsizeTARG}
The \DWOPxderefsizeNAME{} operation behaves like the
\DWOPxderef{} operation. The entry at the top of the stack is
treated as an address. The second stack entry is treated as
an \doublequote{address space identifier} for those architectures
that support 
\addtoindexi{multiple}{address space!multiple}
address spaces. 
Both of these entries must have integral type identifiers.
The top two stack
elements are popped, and a data item is retrieved through an
implementation\dash defined address calculation and pushed as the
new stack top. In the \DWOPxderefsizeNAME{} operation, however,
the size in bytes of the data retrieved from the 
\addtoindexi{dereferenced}{address!dereference operator}
address is specified by the single operand. This operand is a
1-byte unsigned integral constant whose value may not be larger
than the \addtoindex{size of an address} on the target machine. The data
retrieved is zero extended to the \addtoindex{size of an address} on the
target machine before being pushed onto the expression stack together
with the \specialaddresstype{} identifier.

\itembfnl{\DWOPxdereftypeTARG}
The \DWOPxdereftypeNAME{} operation behaves like the \DWOPxderefsize{}
operation: it pops the top two stack entries, treats them as an address and
an address space identifier, and pushes the value retrieved. In the
\DWOPxdereftypeNAME{} operation, the size in bytes of the data retrieved from
the dereferenced address is specified by the first operand. This operand is
a 1-byte unsigned integral constant whose value 
value which is the same as the size of the base type referenced
by the second operand. The second
operand is an unsigned LEB128 integer that represents the offset of a
debugging information entry in the current compilation unit, which must be a
\DWTAGbasetype{} entry that provides the type of the data pushed.

\needlines{6}
\itembfnl{\DWOPpushobjectaddressTARG}
The \DWOPpushobjectaddressNAME{}
operation pushes the address
of the object currently being evaluated as part of evaluation
of a user presented expression. This object may correspond
to an independent variable described by its own debugging
information entry or it may be a component of an array,
structure, or class whose address has been dynamically
determined by an earlier step during user expression
evaluation.

\textit{This operator provides explicit functionality
(especially for arrays involving descriptors) that is analogous
to the implicit push of the base 
\addtoindexi{address}{address!implicit push of base}
of a structure prior to evaluation of a 
\DWATdatamemberlocation{} 
to access a data member of a structure. For an example, see 
Appendix \refersec{app:aggregateexamples}.}

\needlines{4}
\itembfnl{\DWOPformtlsaddressTARG}
The \DWOPformtlsaddressNAME{} 
operation pops a value from the stack, which must have an 
integral type identifier, translates this
value into an address in the 
\addtoindex{thread-local storage}
for a thread, and pushes the address 
onto the stack together with the \specialaddresstype{} identifier. 
The meaning of the value on the top of the stack prior to this 
operation is defined by the run-time environment.  If the run-time 
environment supports multiple thread-local storage 
\nolink{blocks} for a single thread, then the \nolink{block} 
corresponding to the executable or shared 
library containing this DWARF expression is used.
   
\textit{Some implementations of 
\addtoindex{C}, \addtoindex{C++}, \addtoindex{Fortran}, and other 
languages, support a 
thread-local storage class. Variables with this storage class
have distinct values and addresses in distinct threads, much
as automatic variables have distinct values and addresses in
each function invocation. Typically, there is a single \nolink{block}
of storage containing all thread\dash local variables declared in
the main executable, and a separate \nolink{block} for the variables
declared in each shared library. Each 
thread\dash local variable can then be accessed in its block using an
identifier. This identifier is typically an offset into the block and 
pushed onto the DWARF stack by one of the 
\DWOPconstnx{} operations prior to the
\DWOPformtlsaddress{} operation. 
Computing the address of
the appropriate \nolink{block} can be complex (in some cases, the
compiler emits a function call to do it), and difficult
to describe using ordinary DWARF location descriptions.
Instead of    forcing complex thread-local storage calculations into 
the DWARF expressions, the \DWOPformtlsaddress{} allows the consumer 
to perform the computation based on the run-time environment.}

\needlines{4}
\itembfnl{\DWOPcallframecfaTARG}
The \DWOPcallframecfaNAME{} 
operation pushes the value of the
CFA, obtained from the Call Frame Information 
(see Section \refersec{chap:callframeinformation}).

\textit{Although the value of \DWATframebase{}
can be computed using other DWARF expression operators,
in some cases this would require an extensive location list
because the values of the registers used in computing the
CFA change during a subroutine. If the 
Call Frame Information 
is present, then it already encodes such changes, and it is
space efficient to reference that.}
\end{enumerate}

\textit{Examples illustrating many of these stack operations are
found in Appendix \refersec{app:dwarfstackoperationexamples}.}

\subsubsection{Arithmetic and Logical Operations} 
\addtoindexx{DWARF expression!arithmetic operations}
\addtoindexx{DWARF expression!logical operations}
The following provide arithmetic and logical operations.  If an operation
pops two values from the stack, both values must have the same type,
either the same base type or both the \specialaddresstype.
The result of the operation which is pushed back has the same type
as the type of the operands.  

If the type of the operands is the \specialaddresstype, 
except as otherwise specified, the arithmetic operations
perform addressing arithmetic, that is, unsigned arithmetic that is performed
modulo one plus the largest representable address (for example, 0x100000000
when the \addtoindex{size of an address} is 32 bits). 

Operations other than \DWOPabs{},
\DWOPdiv{}, \DWOPminus{}, \DWOPmul{}, \DWOPneg{} and \DWOPplus{} 
require integral types of the operand (either integral base type 
or the \specialaddresstype).  Operations do not cause an exception 
on overflow.

\needlines{4}
\begin{enumerate}[1. ]
\itembfnl{\DWOPabsTARG}
The \DWOPabsNAME{} operation pops the top stack entry, interprets
it as a signed value and pushes its absolute value. If the
absolute value cannot be represented, the result is undefined.

\needlines{4}
\itembfnl{\DWOPandTARG}
The \DWOPandNAME{} operation pops the top two stack values, performs
a bitwise and operation on the two, and pushes the result.

\itembfnl{\DWOPdivTARG}
The \DWOPdivNAME{} operation pops the top two stack values, divides the former second entry by
the former top of the stack using signed division, and pushes the result.

\itembfnl{\DWOPminusTARG}
The \DWOPminusNAME{} operation pops the top two stack values, subtracts the former top of the
stack from the former second entry, and pushes the result.

\itembfnl{\DWOPmodTARG}
The \DWOPmodNAME{} operation pops the top two stack values and pushes the result of the
calculation: former second stack entry modulo the former top of the stack.

\needlines{4}
\itembfnl{\DWOPmulTARG}
The \DWOPmulNAME{} operation pops the top two stack entries, multiplies them together, and
pushes the result.

\itembfnl{\DWOPnegTARG}
The \DWOPnegNAME{} operation pops the top stack entry, interprets
it as a signed value and pushes its negation. If the negation
cannot be represented, the result is undefined.

\itembfnl{\DWOPnotTARG}
The \DWOPnotNAME{} operation pops the top stack entry, and pushes
its bitwise complement.

\itembfnl{\DWOPorTARG}
The \DWOPorNAME{} operation pops the top two stack entries, performs
a bitwise or operation on the two, and pushes the result.

\itembfnl{\DWOPplusTARG}
The \DWOPplusNAME{} operation pops the top two stack entries,
adds them together, and pushes the result.

\needlines{6}
\itembfnl{\DWOPplusuconstTARG}
The \DWOPplusuconstNAME{} operation pops the top stack entry,
adds it to the unsigned LEB128\addtoindexx{LEB128!unsigned}
constant operand and pushes the result.

\textit{This operation is supplied specifically to be
able to encode more field offsets in two bytes than can be
done with
\doublequote{\DWOPlitn~\DWOPplus.}}

\needlines{3}
\itembfnl{\DWOPshlTARG}
The \DWOPshlNAME{} operation pops the top two stack entries,
shifts the former second entry left (filling with zero bits)
by the number of bits specified by the former top of the stack,
and pushes the result.

\itembfnl{\DWOPshrTARG}
The \DWOPshrNAME{} operation pops the top two stack entries,
shifts the former second entry right logically (filling with
zero bits) by the number of bits specified by the former top
of the stack, and pushes the result.

\needlines{3}
\itembfnl{\DWOPshraTARG}
The \DWOPshraNAME{} operation pops the top two stack entries,
shifts the former second entry right arithmetically (divide
the magnitude by 2, keep the same sign for the result) by
the number of bits specified by the former top of the stack,
and pushes the result.

\itembfnl{\DWOPxorTARG}
The \DWOPxorNAME{} operation pops the top two stack entries,
performs a bitwise exclusive\dash or operation on the two, and
pushes the result.

\end{enumerate}

\subsubsection{Control Flow Operations}
\label{chap:controlflowoperations}
The 
\addtoindexx{DWARF expression!control flow operations}
following operations provide simple control of the flow of a DWARF expression.
\begin{enumerate}[1. ]
\itembfnl{\DWOPleTARG, \DWOPgeTARG, \DWOPeqTARG, \DWOPltTARG, \DWOPgtTARG, \DWOPneTARG}
The six relational operators each:
\begin{itemize}
\item pop the top two stack values, which should both have the same type,
either the same base type or both the \specialaddresstype, 

\item compare the operands:
\linebreak
\textless~former second entry~\textgreater  \textless~relational operator~\textgreater \textless~former top entry~\textgreater

\item push the constant value 1 onto the stack 
if the result of the operation is true or the
constant value 0 if the result of the operation is false.
The pushed value has the \specialaddresstype.
\end{itemize}

If the operands have the \specialaddresstype, the comparisons  
are performed as signed operations.
The six operators are \DWOPleNAME{} (less than or equal to), \DWOPgeNAME{}
(greater than or equal to), \DWOPeqNAME{} (equal to), \DWOPltNAME{} (less
than), \DWOPgtNAME{} (greater than) and \DWOPneNAME{} (not equal to).

\needlines{6}
\itembfnl{\DWOPskipTARG}
\DWOPskipNAME{} is an unconditional branch. Its single operand
is a 2-byte signed integer constant. The 2-byte constant is
the number of bytes of the DWARF expression to skip forward
or backward from the current operation, beginning after the
2-byte constant.

\itembfnl{\DWOPbraTARG}
\DWOPbraNAME{} is a conditional branch. Its single operand is a
2-byte signed integer constant.  This operation pops the
top of stack. If the value popped is not the constant 0,
the 2-byte constant operand is the number of bytes of the
DWARF expression to skip forward or backward from the current
operation, beginning after the 2-byte constant.

% The following item does not correctly hyphenate leading
% to an overfull hbox and a visible artifact. 
% So we use \- to suggest hyphenation in this rare situation.
\itembfnl{\DWOPcalltwoTARG, \DWOPcallfourTARG, \DWOPcallrefTARG}
\DWOPcalltwoNAME, 
\DWOPcallfourNAME, 
and \DWOPcallrefNAME{} perform
DWARF procedure calls during evaluation of a DWARF expression or
location description. 
For \DWOPcalltwoNAME{} and \DWOPcallfourNAME{}, 
the operand is the 2\dash~ or 4-byte unsigned offset, respectively,
of a debugging information entry in the current compilation
unit. The \DWOPcallrefNAME{} operator has a single operand. In the
\thirtytwobitdwarfformat,
the operand is a 4-byte unsigned value;
in the \sixtyfourbitdwarfformat, it is an 8-byte unsigned value
(see Section \referfol{datarep:32bitand64bitdwarfformats}). 
The operand is used as the offset of a
debugging information entry in a 
\dotdebuginfo{}
section which may be contained in an executable or shared object file
other than that containing the operator. For references from
one executable or shared object file to another, the relocation
must be performed by the consumer.  

\textit{Operand interpretation of
\DWOPcalltwo, \DWOPcallfour{} and \DWOPcallref{} is exactly like
that for \DWFORMreftwo, \DWFORMreffour{} and \DWFORMrefaddr,
respectively  
(see Section  \refersec{datarep:attributeencodings}).  
}

These operations transfer
control of DWARF expression evaluation to 
\addtoindexx{location attribute}
the 
\DWATlocation{}
attribute of the referenced debugging information entry. If
there is no such attribute, then there is no effect. Execution
of the DWARF expression of 
\addtoindexx{location attribute}
a 
\DWATlocation{} attribute may add
to and/or remove from values on the stack. Execution returns
to the point following the call when the end of the attribute
is reached. Values on the stack at the time of the call may be
used as parameters by the called expression and values left on
the stack by the called expression may be used as return values
by prior agreement between the calling and called expressions.
\end{enumerate}

\subsubsection{Type Conversions}
\label{chap:typeconversions}
The following operations provides for explicit type conversion.

\begin{enumerate}[1. ]
\itembfnl{\DWOPconvertTARG}
The \DWOPconvertNAME{} operation pops the top stack entry, converts it to a
different type, then pushes the result. It takes one operand, which is an
unsigned LEB128 integer that represents the offset of a debugging
information entry in the current compilation unit, or value 0 which
represents the \specialaddresstype. If the operand is non-zero, the
referenced entry must be a \DWTAGbasetype{} entry that provides the type
to which the value is converted.

\itembfnl{\DWOPreinterpretTARG}
The \DWOPreinterpretNAME{} operation pops the top stack entry, reinterprets
the bits in its value as a value of a different type, then pushes the
result. It takes one operand, which is an unsigned LEB128 integer that
represents the offset of a debugging information entry in the current
compilation unit, or value 0 which represents the \specialaddresstype.
If the operand is non-zero, the referenced entry must be a
\DWTAGbasetype{} entry that provides the type to which the value is converted.
The type of the operand and result type should have the same size in bits.

\end{enumerate}

\needlines{7}
\subsubsection{Special Operations}
\label{chap:specialoperations}
There 
\addtoindexx{DWARF expression!special operations}
are these special operations currently defined:
\begin{enumerate}[1. ]
\itembfnl{\DWOPnopNAME}
The \DWOPnopTARG{} operation is a place holder. It has no effect
on the location stack or any of its values.

\itembfnl{\DWOPentryvalueNAME}
The \DWOPentryvalueTARG{} operation pushes a value that had a known location
upon entering the current subprogram.  It has two operands: an 
unsigned LEB128\addtoindexx{LEB128!unsigned} length, followed by 
a block containing a DWARF expression or a register location description 
(see Section \refersec{chap:registerlocationdescriptions}).  
The length operand specifies the length
in bytes of the block.  If the block contains a register location
description, \DWOPentryvalueNAME{} pushes the value that register had upon
entering the current subprogram.  If the block contains a DWARF expression,
the DWARF expression is evaluated as if it has been evaluated upon entering
the current subprogram.  The DWARF expression should not assume any values
being present on the DWARF stack initially and should result in exactly one
value being pushed on the DWARF stack when completed.  That value is the value
being pushed by the \DWOPentryvalueNAME{} operation.  

\DWOPpushobjectaddress{} is not meaningful inside of this DWARF operation.

\textit{The \DWOPentryvalueNAME{} operation can be used by consumers if they are able
to find the call site in the caller function, can unwind to it, and the corresponding
\DWTAGcallsiteparameter{} entry has \DWATcallvalue{} or
\DWATcalldatavalue{} attributes that can be evaluated to find the
value a function parameter had on the first instruction in the function.
Non-interactive consumers which know what variables will need to be
inspected in advance of running the debugged program could put breakpoints
on the first instruction in functions where there is no way to find
some variable's value other than by evaluating the \DWOPentryvalueNAME{} 
operation.  The consumer can collect the value of registers or 
memory referenced in
\DWOPentryvalueNAME{} operations, then continue to breakpoints where the values
of variables or parameters need to be inspected and use the remembered
register or memory values during \DWOPentryvalueNAME{} evaluation.}

\end{enumerate}

\needlines{5}
\section{Location Descriptions}
\label{chap:locationdescriptions}
\textit{Debugging information 
\addtoindexx{location description}
must 
\addtoindexx{location description|see{\textit{also} DWARF expression}}
provide consumers a way to find
the location of program variables, determine the bounds
of dynamic arrays and strings, and possibly to find the
base address of a subroutine\textquoteright s stack frame or the return
address of a subroutine. Furthermore, to meet the needs of
recent computer architectures and optimization techniques,
debugging information must be able to describe the location of
an object whose location changes over the object\textquoteright s lifetime.}

Information about the location of program objects is provided
by location descriptions. Location descriptions can be either
of two forms:
\begin{enumerate}[1. ]
\item \textit{Single location descriptions}, 
which 
\addtoindexx{location description!single}
are 
\addtoindexx{single location description}
a language independent representation of
addressing rules of arbitrary complexity built from 
DWARF expressions (See Section \refersec{chap:dwarfexpressions}) 
and/or other
DWARF operations specific to describing locations. They are
sufficient for describing the location of any object as long
as its lifetime is either static or the same as the 
\livelink{chap:lexicalblock}{lexical block} that owns it, 
and it does not move during its lifetime.

Single location descriptions are of two kinds:
\begin{enumerate}[a) ]
\item Simple location descriptions, which describe the location
\addtoindexx{location description!simple}
of one contiguous piece (usually all) of an object. A simple
location description may describe a location in addressable
memory, or in a register, or the lack of a location (with or
without a known value).

\item  Composite location descriptions, which describe an
\addtoindexx{location description!composite}
object in terms of pieces each of which may be contained in
part of a register or stored in a memory location unrelated
to other pieces.

\end{enumerate}

\needlines{4}
\item \textit{Location lists}, which are used to 
\addtoindexx{location list}
describe
\addtoindexx{location description!use in location list}
objects that have a limited lifetime or change their location
during their lifetime. Location lists are described in
Section \refersec{chap:locationlists} below.

\end{enumerate}

Location descriptions are distinguished in a context sensitive
manner. As the value of an attribute, a location description
is encoded using 
\addtoindexx{exprloc class}
class \livelink{chap:classexprloc}{exprloc}  
and a location list is encoded
using class \livelink{chap:classloclistptr}{loclistptr}
(which 
\addtoindex{loclistptr}
serves as an offset into a
separate 
\addtoindexx{location list}
location list table).

\needlines{8}
\subsection{Single Location Descriptions}
A single location description is either:
\begin{enumerate}[1. ]
\item A simple location description, representing an object
\addtoindexx{location description!simple}
which 
\addtoindexx{simple location description}
exists in one contiguous piece at the given location, or 
\item A composite location description consisting of one or more
\addtoindexx{location description!composite}
simple location descriptions, each of which is followed by
one composition operation. Each simple location description
describes the location of one piece of the object; each
composition operation describes which part of the object is
located there. Each simple location description that is a
DWARF expression is evaluated independently of any others
(as though on its own separate stack, if any). 
\end{enumerate}



\subsubsection{Simple Location Descriptions}
A 
\addtoindexx{location description!simple}
simple location description consists of one 
contiguous piece or all of an object or value.


\subsubsubsection{Memory Location Descriptions}
A 
\addtoindexx{location description!memory}
memory location description 
\addtoindexx{memory location description}
consists of a non\dash empty DWARF
expression (see 
Section \refersec{chap:dwarfexpressions}
), whose value is the address of
a piece or all of an object or other entity in memory.

\subsubsubsection{Register Location Descriptions}
\label{chap:registerlocationdescriptions}
A register location description consists of a register name
operation, which represents a piece or all of an object
located in a given register.

\textit{Register location descriptions describe an object
(or a piece of an object) that resides in a register, while
the opcodes listed in 
Section \refersec{chap:registervalues}
are used to describe an object (or a piece of
an object) that is located in memory at an address that is
contained in a register (possibly offset by some constant). A
register location description must stand alone as the entire
description of an object or a piece of an object.
}

The following DWARF operations can be used to name a register.


\textit{Note that the register number represents a DWARF specific
mapping of numbers onto the actual registers of a given
architecture. The mapping should be chosen to gain optimal
density and should be shared by all users of a given
architecture. It is recommended that this mapping be defined
by the ABI authoring committee for each architecture.
}
\begin{enumerate}[1. ]
\itembfnl{\DWOPregzeroTARG, \DWOPregoneTARG, ..., \DWOPregthirtyoneTARG}
The \DWOPregnTARG{} operations encode the names of up to 32
registers, numbered from 0 through 31, inclusive. The object
addressed is in register \textit{n}.

\needlines{4}
\itembfnl{\DWOPregxTARG}
The \DWOPregxNAME{} operation has a single 
unsigned LEB128\addtoindexx{LEB128!unsigned} literal
operand that encodes the name of a register.  

\end{enumerate}

\textit{These operations name a register location. To
fetch the contents of a register, it is necessary to use
one of the register based addressing operations, such as
\DWOPbregx{} 
(Section \refersec{chap:registervalues})}.

\subsubsubsection{Implicit Location Descriptions}
An \addtoindex{implicit location description}
represents a piece or all
\addtoindexx{location description!implicit}
of an object which has no actual location but whose contents
are nonetheless either known or known to be undefined.

The following DWARF operations may be used to specify a value
that has no location in the program but is a known constant
or is computed from other locations and values in the program.
\begin{enumerate}[1. ]
\itembfnl{\DWOPimplicitvalueTARG}
The \DWOPimplicitvalueNAME{} 
operation specifies an immediate value
using two operands: an unsigned LEB128\addtoindexx{LEB128!unsigned}
length, followed by
%FIXME: should this block be a reference? To what?
a \nolink{block} representing the value in the memory representation
of the target machine. The length operand gives the length
in bytes of the \nolink{block}.

\itembfnl{\DWOPstackvalueTARG}
The \DWOPstackvalueNAME{} 
operation specifies that the object
does not exist in memory but its value is nonetheless known
and is at the top of the DWARF expression stack. In this form
of location description, the DWARF expression represents the
actual value of the object, rather than its location. The
\DWOPstackvalueNAME{} operation terminates the expression.

\needlines{4}
\itembfnl{\DWOPimplicitpointerTARG}
The \DWOPimplicitpointerNAME{} operation specifies that the object
is a pointer that cannot be represented as a real pointer,
even though the value it would point to can be described. In
this form of location description, the DWARF expression refers
to a debugging information entry that represents the actual
value of the object to which the pointer would point. Thus, a
consumer of the debug information would be able to show the
value of the dereferenced pointer, even when it cannot show
the value of the pointer itself.

\needlines{5}
The \DWOPimplicitpointerNAME{} operation has two operands: a 
reference to a debugging information entry that describes 
the dereferenced object's value, and a signed number that 
is treated as a byte offset from the start of that value. 
The first operand is a 4-byte unsigned value in the 32-bit 
DWARF format, or an 8-byte unsigned value in the 64-bit 
DWARF format (see Section 
\refersec{datarep:32bitand64bitdwarfformats}).
The second operand is a 
signed LEB128\addtoindexx{LEB128!signed} number.

The first operand is used as the offset of a debugging
information entry in a \dotdebuginfo{} section, which may be
contained in an executable or shared object file other than that
containing the operator. For references from one executable or
shared object file to another, the relocation must be performed 
by the consumer.

\textit{The debugging information entry referenced by a 
\DWOPimplicitpointerNAME{} operation is typically a
\DWTAGvariable{} or \DWTAGformalparameter{} entry whose
\DWATlocation{} attribute gives a second DWARF expression or a
location list that describes the value of the object, but the
referenced entry may be any entry that contains a \DWATlocation{}
or \DWATconstvalue{} attribute (for example, \DWTAGdwarfprocedure).
By using the second DWARF expression, a consumer can
reconstruct the value of the object when asked to dereference
the pointer described by the original DWARF expression
containing the \DWOPimplicitpointer{} operation.}

\end{enumerate}

\textit{DWARF location expressions are intended to yield the \textbf{location}
of a value rather than the value itself. An optimizing compiler
may perform a number of code transformations where it becomes
impossible to give a location for a value, but it remains possible
to describe the value itself. 
Section \refersec{chap:registerlocationdescriptions}
describes operators that can be used to
describe the location of a value when that value exists in a
register but not in memory. The operations in this section are
used to describe values that exist neither in memory nor in a
single register.}

\subsubsubsection{Empty Location Descriptions}
An \addtoindex{empty location description}
consists of a DWARF expression
\addtoindexx{location description!empty}
containing no operations. It represents a piece or all of an
object that is present in the source but not in the object code
(perhaps due to optimization).

\needlines{5}
\subsubsection{Composite Location Descriptions}
A composite location description describes an object or
value which may be contained in part of a register or stored
in more than one location. Each piece is described by a
composition operation, which does not compute a value nor
store any result on the DWARF stack. There may be one or
more composition operations in a single composite location
description. A series of such operations describes the parts
of a value in memory address order.

Each composition operation is immediately preceded by a simple
location description which describes the location where part
of the resultant value is contained.
\begin{enumerate}[1. ]
\itembfnl{\DWOPpieceTARG}
The \DWOPpieceNAME{} operation takes a 
single operand, which is an
unsigned LEB128\addtoindexx{LEB128!unsigned} number.  
The number describes the size in bytes
of the piece of the object referenced by the preceding simple
location description. If the piece is located in a register,
but does not occupy the entire register, the placement of
the piece within that register is defined by the ABI.

\textit{Many compilers store a single variable in sets of registers,
or store a variable partially in memory and partially in
registers. \DWOPpieceNAME{} provides a way of describing how large
a part of a variable a particular DWARF location description
refers to. }

\itembfnl{\DWOPbitpieceTARG}
The \DWOPbitpieceNAME{} 
operation takes two operands. The first
is an unsigned LEB128\addtoindexx{LEB128!unsigned} 
number that gives the size in bits
of the piece. The second is an 
unsigned LEB128\addtoindexx{LEB128!unsigned} number that
gives the offset in bits from the location defined by the
preceding DWARF location description.  

Interpretation of the
offset depends on the kind of location description. If the
location description is empty, the offset doesn\textquoteright t matter and
the \DWOPbitpieceNAME{} operation describes a piece consisting
of the given number of bits whose values are undefined. If
the location is a register, the offset is from the least
significant bit end of the register. If the location is a
memory address, the \DWOPbitpieceNAME{} operation describes a
sequence of bits relative to the location whose address is
on the top of the DWARF stack using the bit numbering and
direction conventions that are appropriate to the current
language on the target system. If the location is any implicit
value or stack value, the \DWOPbitpieceNAME{} operation describes
a sequence of bits using the least significant bits of that
value.  
\end{enumerate}

\textit{\DWOPbitpieceNAME{} is 
used instead of \DWOPpieceNAME{} when
the piece to be assembled into a value or assigned to is not
byte-sized or is not at the start of a register or addressable
unit of memory.}

\needlines{6}
\subsection{Location Lists}
\label{chap:locationlists}
There are two forms of location lists. The first form 
is intended for use in other than a \splitDWARFobjectfile,
while the second is intended for use in a \splitDWARFobjectfile{} 
(see Section \refersec{datarep:splitdwarfobjectfiles}). The two
forms are otherwise equivalent.

\textit{The form for \splitDWARFobjectfile{s} is new in \DWARFVersionV.}

\subsubsection{Location Lists in Non-split Objects}
\label{chap:locationlistsinnonsplitobjects}
Location lists 
\addtoindexx{location list}
are used in place of location expressions
whenever the object whose location is being described
can change location during its lifetime. 
Location lists
\addtoindexx{location list}
are contained in a separate object file section called
\dotdebugloc{}. A location list is indicated by a location
attribute whose value is an offset from the beginning of
the \dotdebugloc{} section to the first byte of the list for the
object in question.

The \addtoindex{applicable base address} of a normal
location list entry (see following) is
\addtoindexx{location list!base address selection entry}
determined by the closest preceding base address selection
entry in the same location list. If there is
no such selection entry, then the applicable base address
defaults to the base address of the compilation unit (see
Section \refersec{chap:normalandpartialcompilationunitentries}).  

\textit{In the case of a compilation unit where all of
the machine code is contained in a single contiguous section,
no base address selection entry is needed.}

Each entry in a location list is either a location 
\addtoindexi{list}{address selection|see{base address selection}} 
entry,
a 
\addtoindexi{base}{base address selection entry!in location list} 
address selection entry, 
\addtoindexx{location list!base address selection entry}
or an 
\addtoindexx{end-of-list entry!in location list}
end-of-list entry.

\subsubsubsection{Location List Entry}
A location list entry has two forms:
a normal location list entry and a default location list entry.

\needlines{4}
\subsubsubsubsection{Normal Location List Entry}
A\addtoindexx{location list!normal entry}
\addtoindex{normal location list entry} consists of:
\begin{enumerate}[1. ]
\item A beginning address offset. 
This address offset has the \addtoindex{size of an address} and is
relative to the applicable base address of the compilation
unit referencing this location list. It marks the beginning
of the address 
\addtoindexi{range}{address range!in location list} 
over which the location is valid.

\item An ending address offset.  This address offset again
has the \addtoindex{size of an address} and is relative to the applicable
base address of the compilation unit referencing this location
list. It marks the first address past the end of the address
range over which the location is valid. The ending address
must be greater than or equal to the beginning address.

\textit{A location list entry (but not a base address selection or 
end-of-list entry) whose beginning
and ending addresses are equal has no effect 
because the size of the range covered by such
an entry is zero.}

\item An unsigned 2-byte length describing the length of the location 
description that follows.

\item A \addtoindex{single location description} 
describing the location of the object over the range specified by
the beginning and end addresses.
\end{enumerate}

Address ranges defined by normal location list entries
may overlap. When they do, they describe a
situation in which an object exists simultaneously in more than
one place. If all of the address ranges in a given location
list do not collectively cover the entire range over which the
object in question is defined, it is assumed that the object is
not available for the portion of the range that is not covered.

\needlines{4}
\subsubsubsubsection{Default Location List Entry}
A \addtoindex{default location list entry} consists of:
\addtoindexx{location list!default entry}
\begin{enumerate}[1. ]
\item The value 0.
\item The value of the largest representable address offset (for
      example, \wffffffff when the size of an address is 32 bits).
\item A simple location description describing the location of the
      object when there is no prior normal location list entry
      that applies in the same location list.
\end{enumerate}

A default location list entry is independent of any applicable
base address (except to the extent to which base addresses
affect prior normal location list entries).

A default location list entry must be the last location list
entry of a location list except for the terminating end-of-list
entry.

A \addtoindex{default location list entry} describes a simple 
location which applies to all addresses which are not included 
in any range defined earlier in the same location list.

\needlines{5}
\subsubsubsection{Base Address Selection Entry}
A base 
\addtoindexi{address}{address selection|see{base address selection}}
\addtoindexx{location list!base address selection entry}
selection 
\addtoindexi{entry}{base address selection entry!in location list}
consists of:
\begin{enumerate}[1. ]
\item The value of the largest representable 
address offset (for example, \wffffffff when the size of
an address is 32 bits).
\item An address, which defines the 
appropriate base address for use in interpreting the beginning
and ending address offsets of subsequent entries of the location list.
\end{enumerate}

\textit{A base address selection entry 
affects only the remainder of the list in which it is contained.}

\needlines{5}
\subsubsubsection{End-of-List Entry}
The end of any given location list is marked by an 
\addtoindexx{location list!end-of-list entry}
end-of-list entry, which consists of a 0 for the beginning address
offset and a 0 for the ending address offset. A location list
containing only an 
\addtoindexx{end-of-list entry!in location list}
end-of-list entry describes an object that
exists in the source code but not in the executable program.

Neither a base address selection entry nor an end-of-list
entry includes a location description.

\needlines{4}
\textit{When a DWARF consumer is parsing and decoding a location
list, it must recognize the beginning and ending address
offsets of (0, 0) for an end-of-list entry and 
\mbox{(0, \texttt{maximum-address})} for
a default location list entry prior to applying any base
address. Any other pair of offsets beginning with 0 is a
valid normal location list entry. Next, it must recognize the
beginning address offset of \texttt{maximum-address} for a base address selection
entry prior to applying any base address. The current base
address is not applied to the subsequent value (although there
may be an underlying object language relocation that affects
that value).}

\textit{A base address selection entry and an end-of-list
entry for a location list are identical to a base address
selection entry and end-of-list entry, respectively, for a
\addtoindex{range list}
(see Section \refersec{chap:noncontiguousaddressranges}) 
in interpretation and representation.}

\needlines{5}
\subsubsection{Location Lists in Split Object Files}
\label{chap:locationlistsinsplitobjectfiles}
In a \splitDWARFobjectfile{} (see 
Section \refersec{datarep:splitdwarfobjectfiles}), 
location lists are contained in the \dotdebuglocdwo{} section.

The \addtoindex{applicable base address} of a split
location list entry (see following) is
\addtoindexx{location list!base address selection entry}
determined by the closest preceding base address selection
entry (\DWLLEbaseaddressselectionentry) in the same location list. If there is
no such selection entry, then the applicable base address
defaults to the base address of the compilation unit (see
Section \refersec{chap:normalandpartialcompilationunitentries}).

Each entry in the split location list
begins with a type code, which is a single unsigned byte that
identifies the type of entry. There are five types of entries:
\begin{enumerate}
\itembfnl{\DWLLEendoflistentryTARG}
This entry indicates the end of a location list, and
contains no further data.

\needlines{6}
\itembfnl{\DWLLEbaseaddressselectionentryTARG}
This entry contains an 
unsigned LEB128\addtoindexx{LEB128!unsigned} value immediately
following the type code. This value is the index of an
address in the \dotdebugaddr{} section, which is then used as
the base address when interpreting offsets in subsequent
location list entries of type \DWLLEoffsetpairentry.
This index is relative to the value of the 
\DWATaddrbase{} attribute of the associated compilation unit.

\itembfnl{\DWLLEstartendentryTARG}
This entry contains two unsigned LEB128\addtoindexx{LEB128!unsigned}
values immediately following the type code. These values are the
indices of two addresses in the \dotdebugaddr{} section.
These indices are relative to the value of the 
\DWATaddrbase{} attribute of the associated compilation unit
(see Section \refersec{chap:unitentries}).
These indicate the starting and ending addresses,
respectively, that define the address range for which
this location is valid. The starting and ending addresses
given by this type of entry are not relative to the
compilation unit base address. A single location
description follows the fields that define the address range.

\itembfnl{\DWLLEstartlengthentryTARG}
This entry contains one unsigned LEB128\addtoindexx{LEB128!unsigned}
value and a 4-byte
unsigned value immediately following the type code. The
first value is the index of an address in the \dotdebugaddr{}
section, which marks the beginning of the address range
over which the location is valid.
This index is relative to the value of the 
\DWATaddrbase{} attribute of the associated compilation unit.
The starting address given by this
type of entry is not relative to the compilation unit
base address. The second value is the
length of the range. A single location
description follows the fields that define the address range.

\itembfnl{\DWLLEoffsetpairentryTARG}
This entry contains two 4-byte unsigned values
immediately following the type code. These values are the
starting and ending offsets, respectively, relative to
the applicable base address, that define the address
range for which this location is valid. A single location
description follows the fields that define the address range.
\end{enumerate}

\textit{The \DWLLEbaseaddressselectionentry, \DWLLEstartendentry{}
and \DWLLEstartlengthentry entries obtain addresses within the 
target program indirectly using an index (not an offset) into an 
array of addresses. The base of that array is obtained using the 
\DWATaddrbase{} attribute of the containing compilation unit. 
The value of that attribute is the offset of the base of the array 
in the \dotdebugaddr{} section of the unit.}

\needlines{10}
\section{Types of Program Entities}
\label{chap:typesofprogramentities}
\hypertarget{chap:DWATtypetypeofdeclaration}{}
Any debugging information entry describing a declaration that
has a type has 
\addtoindexx{type attribute}
a \DWATtypeDEFN{} attribute, whose value is a
reference to another debugging information entry. The entry
referenced may describe a base type, that is, a type that is
not defined in terms of other data types, or it may describe a
user-defined type, such as an array, structure or enumeration.
Alternatively, the entry referenced may describe a type
modifier, such as constant, packed, pointer, reference or
volatile, which in turn will reference another entry describing
a type or type modifier (using 
\addtoindexx{type attribute}
a \DWATtypeNAME{} attribute of its
own). See 
Section  \referfol{chap:typeentries} 
for descriptions of the entries describing
base types, user-defined types and type modifiers.


\needlines{6}
\section{Accessibility of Declarations}
\label{chap:accessibilityofdeclarations}
\textit{Some languages, notably \addtoindex{C++} and 
\addtoindex{Ada}, have the concept of
the accessibility of an object or of some other program
entity. The accessibility specifies which classes of other
program objects are permitted access to the object in question.}

The accessibility of a declaration is 
\hypertarget{chap:DWATaccessibilitycandadadeclarations}{}
represented by a 
\DWATaccessibilityDEFN{} 
attribute, whose
\addtoindexx{accessibility attribute}
value is a constant drawn from the set of codes listed in Table 
\refersec{tab:accessibilitycodes}.

\begin{simplenametable}[1.9in]{Accessibility codes}{tab:accessibilitycodes}
\DWACCESSpublicTARG{}          \\
\DWACCESSprivateTARG{}        \\
\DWACCESSprotectedTARG{}    \\
\end{simplenametable}

\needlines{5}
\section{Visibility of Declarations}
\label{chap:visibilityofdeclarations}

\textit{Several languages (such as \addtoindex{Modula-2}) 
have the concept of the visibility of a declaration. The
visibility specifies which declarations are to be 
visible outside of the entity in which they are
declared.}

The 
\hypertarget{chap:DWATvisibilityvisibilityofdeclaration}{}
visibility of a declaration is represented 
by a \DWATvisibilityDEFN{}
attribute\addtoindexx{visibility attribute}, whose value is a
constant drawn from the set of codes listed in 
Table \refersec{tab:visibilitycodes}.

\begin{simplenametable}[1.5in]{Visibility codes}{tab:visibilitycodes}
\DWVISlocalTARG{}          \\
\DWVISexportedTARG{}    \\
\DWVISqualifiedTARG{}  \\
\end{simplenametable}

\needlines{8}
\section{Virtuality of Declarations}
\label{chap:virtualityofdeclarations}
\textit{\addtoindex{C++} provides for virtual and pure virtual structure or class
member functions and for virtual base classes.}

The 
\hypertarget{chap:DWATvirtualityvirtualityindication}{}
virtuality of a declaration is represented by a
\DWATvirtualityDEFN{}
attribute\addtoindexx{virtuality attribute}, whose value is a constant drawn
from the set of codes listed in 
Table \refersec{tab:virtualitycodes}.

\begin{simplenametable}[2.5in]{Virtuality codes}{tab:virtualitycodes}
\DWVIRTUALITYnoneTARG{}                      \\
\DWVIRTUALITYvirtualTARG{}                \\
\DWVIRTUALITYpurevirtualTARG{}    \\
\end{simplenametable}

\needlines{8}
\section{Artificial Entries}
\label{chap:artificialentries}
\textit{A compiler may wish to generate debugging information entries
for objects or types that were not actually declared in the
source of the application. An example is a formal parameter
%FIXME: The word 'this' should be rendered like a variant italic,
%FIXME: not as a quoted name. Changed to tt font--RB
entry to represent the hidden 
\texttt{this} parameter\index{this parameter@\texttt{this} parameter}
that most \addtoindex{C++} implementations pass as the first argument 
to non-static member functions.}  

Any debugging information entry representing the
\addtoindexx{artificial attribute}
declaration of an object or type artificially generated by
a compiler and not explicitly declared by the source program
\hypertarget{chap:DWATartificialobjectsortypesthat}{}
may have a 
\DWATartificialDEFN{} attribute, 
which is a \livelink{chap:classflag}{flag}.

\needlines{6}
\section{Segmented Addresses}
\label{chap:segmentedaddresses}
\textit{In some systems, addresses are specified as offsets within a
given 
\addtoindexx{address space!segmented}
segment 
\addtoindexx{segmented addressing|see{address space}}
rather than as locations within a single flat
\addtoindexx{address space!flat}
address space.}

Any debugging information entry that contains a description
\hypertarget{chap:DWATsegmentaddressinginformation}{}
of the location of an object or subroutine may have a 
\DWATsegmentDEFN{} attribute, 
\addtoindexx{segment attribute}
whose value is a location
description. The description evaluates to the segment selector
of the item being described. If the entry containing the
\DWATsegmentNAME{} attribute has a 
\DWATlowpc, 
\DWAThighpc,
\DWATranges{} or 
\DWATentrypc{} attribute, 
\addtoindexx{entry PC attribute}
or 
a location
description that evaluates to an address, then those address
values represent the offset portion of the address within
the segment specified 
\addtoindexx{segment attribute}
by \DWATsegmentNAME.

If an entry has no 
\DWATsegmentNAME{} attribute, it inherits
\addtoindexx{segment attribute}
the segment value from its parent entry.  If none of the
entries in the chain of parents for this entry back to
its containing compilation unit entry have 
\DWATsegmentNAME{} attributes, 
then the entry is assumed to exist within a flat
address space. 
Similarly, if the entry has a 
\DWATsegmentNAME{} attribute 
\addtoindexx{segment attribute}
containing an empty location description, that
entry is assumed to exist within a 
\addtoindexi{flat}{address space!flat}
address space.

\textit{Some systems support different 
classes of addresses\addtoindexx{address class}. 
The address class may affect the way a pointer is dereferenced
or the way a subroutine is called.}


Any debugging information entry representing a pointer or
reference type or a subroutine or subroutine type may 
have a 
\DWATaddressclass{}
attribute, whose value is an integer
constant.  The set of permissible values is specific to
each target architecture. The value \DWADDRnoneTARG, 
however,
is common to all encodings, and means that no address class
has been specified.

\needlines{4}
\textit {For example, the Intel386 \texttrademark\  processor might use the following values:}

\begin{table}[here]
\caption{Example address class codes}
\label{tab:inteladdressclasstable}
\centering
\begin{tabular}{l|c|l}
\hline
Name&Value&Meaning  \\
\hline
\textit{DW\_ADDR\_none}&   0 & \textit{no class specified} \\
\textit{DW\_ADDR\_near16}& 1 & \textit{16-bit offset, no segment} \\
\textit{DW\_ADDR\_far16}&  2 & \textit{16-bit offset, 16-bit segment} \\
\textit{DW\_ADDR\_huge16}& 3 & \textit{16-bit offset, 16-bit segment} \\
\textit{DW\_ADDR\_near32}& 4 & \textit{32-bit offset, no segment} \\
\textit{DW\_ADDR\_far32}&  5 & \textit{32-bit offset, 16-bit segment} \\
\hline
\end{tabular}
\end{table}

\needlines{6}
\section{Non-Defining Declarations and Completions}
\label{nondefiningdeclarationsandcompletions}
A debugging information entry representing a program entity
typically represents the defining declaration of that
entity. In certain contexts, however, a debugger might need
information about a declaration of an entity that is not
\addtoindexx{incomplete declaration}
also a definition, or is otherwise incomplete, to evaluate
\hypertarget{chap:DWATdeclarationincompletenondefiningorseparateentitydeclaration}{}
an expression correctly.

\needlines{10}
\textit{As an example, consider the following fragment of \addtoindex{C} code:}

\begin{lstlisting}
void myfunc()
{
  int x;
  {
    extern float x;
    g(x);
  }
}
\end{lstlisting}


\textit{\addtoindex{C} scoping rules require that the 
value of the variable \texttt{x} passed to the function 
\texttt{g} is the value of the global \texttt{float} 
variable \texttt{x} rather than of the local \texttt{int} 
variable \texttt{x}.}

\subsection{Non-Defining Declarations}
A debugging information entry that 
represents a non-defining 
\addtoindexx{non-defining declaration}
or otherwise 
\addtoindex{incomplete declaration}
of a program entity has a
\addtoindexx{declaration attribute}
\DWATdeclarationDEFN{} attribute, which is a 
\livelink{chap:classflag}{flag}.

\subsection{Declarations Completing Non-Defining Declarations}
A debugging information entry that represents a 
declaration\hypertarget{chap:DWATspecificationincompletenondefiningorseparatedeclaration}{}
that completes another (earlier) non-defining declaration may have a 
\DWATspecificationDEFN{}
attribute whose value is a \livelink{chap:classreference}{reference} to
the debugging information entry representing the non-defining declaration. 
A debugging information entry with a 
\DWATspecificationNAME{} 
attribute does not need to duplicate information provided by the 
debugging information entry referenced by that specification attribute.

When the non-defining declaration is contained within a type that has
been placed in a separate type unit (see Section \refersec{chap:typeunitentries}), 
the \DWATspecification{} attribute cannot refer directly to the entry in
the type unit. Instead, the current compilation unit may contain a
\doublequote{skeleton} declaration of the type, which contains only the relevant
declaration and its ancestors as necessary to provide the context
(including containing types and namespaces). The \DWATspecification{}
attribute would then be a reference to the declaration entry within
the skeleton declaration tree. The debugging information entry for the
top-level type in the skeleton tree may contain a \DWATsignature{}
attribute whose value is the type signature 
(see Section \refersec{datarep:typesignaturecomputation}).


Not all attributes of the debugging information entry referenced by a
\DWATspecification{} attribute 
apply to the referring debugging information entry.
For\addtoindexx{declaration attribute}
example,
\DWATsibling{} and 
\DWATdeclaration{} 
\addtoindexx{declaration attribute}
cannot apply to a 
\addtoindexx{declaration attribute}
referring
\addtoindexx{sibling attribute}
entry.


\section{Declaration Coordinates}
\label{chap:declarationcoordinates}
\livetargi{chap:declarationcoordinates}{}{declaration coordinates}
\textit{It is sometimes useful in a debugger to be able to associate
a declaration with its occurrence in the program source.}

Any debugging information 
\hypertarget{chap:DWATdeclfilefilecontainingsourcedeclaration}{}
entry 
\hypertarget{chap:DWATdecllinelinenumberofsourcedeclaration}{}
representing 
\hypertarget{chap:DWATdeclcolumncolumnpositionofsourcedeclaration}{}
the
\addtoindexx{line number of declaration}
declaration of an object, module, subprogram or
\addtoindex{declaration column attribute}
type 
\addtoindex{declaration file attribute}
may 
\addtoindex{declaration line attribute}
have
\DWATdeclfileDEFN, 
\DWATdecllineDEFN{} and 
\DWATdeclcolumnDEFN{}
attributes each of whose value is an unsigned
\livelink{chap:classconstant}{integer constant}.

The value of 
\addtoindexx{declaration file attribute}
the 
\DWATdeclfile{}
attribute 
\addtoindexx{file containing declaration}
corresponds to
a file number from the line number information table for the
compilation unit containing the debugging information entry and
represents the source file in which the declaration appeared
(see Section \refersec{chap:linenumberinformation}). 
The value 0 indicates that no source file
has been specified.

The value of 
\addtoindexx{declaration line attribute}
the \DWATdeclline{} attribute represents
the source line number at which the first character of
the identifier of the declared object appears. The value 0
indicates that no source line has been specified.

The value of 
\addtoindexx{declaration column attribute}
the \DWATdeclcolumn{} attribute represents
the source column number at which the first character of
the identifier of the declared object appears. The value 0
indicates that no column has been specified.

\section{Identifier Names}
\label{chap:identifiernames}
Any\hypertarget{chap:DWATnamenameofdeclaration}{}
debugging information entry 
\addtoindexx{identifier names}
representing 
\addtoindexx{names!identifier}
a program entity that has been given a name may have a 
\DWATnameDEFN{} 
attribute\addtoindexx{name attribute}, whose value of 
\CLASSstring{} represents the name as it appears in
the source program. A debugging information entry containing
no name attribute, or containing a name attribute whose value
consists of a name containing a single null byte, represents
a program entity for which no name was given in the source.

\textit{Because the names of program objects described by DWARF are 
the names as they appear in the source program, implementations
of language translators that use some form of mangled name
\addtoindexx{mangled names}
(as do many implementations of \addtoindex{C++}) should use the 
unmangled form of the name in the 
\DWATname{} attribute,
\addtoindexx{name attribute}
including the keyword operator (in names such as \doublequote{operator +}),
if present. See also 
Section \referfol{chap:linkagenames} regarding the use of 
\DWATlinkagename{} for 
\addtoindex{mangled names}.
Sequences of multiple whitespace characters may be compressed.}

\section{Data Locations and DWARF Procedures}
Any debugging information entry describing a data object (which
\hypertarget{chap:DWATlocationdataobjectlocation}{}
includes variables and parameters) or 
\livelink{chap:commonblockentry}{common blocks}
may have 
\addtoindexx{location attribute}
a
\DWATlocationDEFN{} attribute,
\addtoindexx{location attribute}
whose value is a location description
(see Section \refersec{chap:locationdescriptions}).

\needlines{4}
A 
\addtoindex{DWARF procedure}
is represented by any
kind of debugging information entry that has a
\addtoindexx{location attribute}
\DWATlocationNAME{}
attribute. 
\addtoindexx{location attribute}
If a suitable entry is not otherwise available,
a DWARF procedure can be represented using a debugging
\addtoindexx{DWARF procedure entry}
information entry with the 
tag \DWTAGdwarfprocedureTARG{}
together with 
\addtoindexx{location attribute}
a \DWATlocationNAME{} attribute.  

A DWARF procedure
is called by a \DWOPcalltwo, 
\DWOPcallfour{} or 
\DWOPcallref{}
DWARF expression operator 
(see Section \refersec{chap:controlflowoperations}).

\needlines{5}
\section{Code Addresses and Ranges}
\label{chap:codeaddressesandranges}
Any debugging information entry describing an entity that has
a machine code address or range of machine code addresses,
which includes compilation units, module initialization,
subroutines, ordinary \nolink{blocks}, 
try/catch \nolink{blocks} (see Section\refersec{chap:tryandcatchblockentries}), 
labels and the like, may have
\begin{itemize}
\item A \DWATlowpcDEFN{} attribute for
\hypertarget{chap:DWATlowpccodeaddressorrangeofaddresses}{}
a single address,

\item A \DWATlowpcDEFN{}
\addtoindexx{low PC attribute}
and 
\DWAThighpcDEFN{}
\addtoindexx{high PC attribute}
\hypertarget{chap:DWAThighpccontiguousrangeofcodeaddresses}{}
pair of attributes for 
a single contiguous range of
addresses, or

\item A \DWATrangesDEFN{} attribute 
\addtoindexx{ranges attribute}
\hypertarget{chap:DWATrangesnoncontiguousrangeofcodeaddresses}{}
for a non-contiguous range of addresses.
\end{itemize}

In addition, a non-contiguous range of 
addresses may also be specified for the
\DWATstartscope{} attribute.
\addtoindexx{start scope attribute}

If an entity has no associated machine code, 
none of these attributes are specified.

\subsection{Single Address} 
When there is a single address associated with an entity,
such as a label or alternate entry point of a subprogram,
the entry has a \DWATlowpc{} attribute whose value is the
relocated address for the entity.

\textit{While the \DWATentrypc{}
attribute might also seem appropriate for this purpose,
historically the \DWATlowpc{} attribute was used before
\DWATentrypc{} was introduced 
(in \addtoindex{DWARF Version 3}). There is
insufficient reason to change this;
\DWATlowpc{} serves as a default entry PC address as described
in Section \refersec{chap:entryaddress}.}

\needlines{8}
\subsection{Continuous Address Range}
\label{chap:contiguousaddressranges}
When the set of addresses of a debugging information entry can
be described as a single contiguous range, the entry 
\addtoindexx{high PC attribute}
may 
\addtoindexx{low PC attribute}
have
a \DWATlowpc{} and 
\DWAThighpc{} pair of attributes. 
The value
of the 
\DWATlowpc{} attribute 
is the relocated address of the
first instruction associated with the entity. If the value of
the \DWAThighpc{} is of class address, it is the relocated
address of the first location past the last instruction
associated with the entity; if it is of class constant, the
value is an unsigned integer offset which when added to the
low PC gives the address of the first location past the last
instruction associated with the entity.

\textit{The high PC value
may be beyond the last valid instruction in the executable.}

\needlines{5}
The presence of low and high PC attributes for an entity
implies that the code generated for the entity is contiguous
and exists totally within the boundaries specified by those
two attributes. If that is not the case, no low and high PC
attributes should be produced.

\subsection{Non-Contiguous Address Ranges}
\label{chap:noncontiguousaddressranges}
When the set of addresses of a debugging information entry
\addtoindexx{non-contiguous address ranges}
cannot be described as a single contiguous range, the entry has
a \DWATranges{} attribute 
\addtoindexx{ranges attribute}
whose value is of class \livelink{chap:classrangelistptr}{rangelistptr}
and indicates the beginning of a \addtoindex{range list}.
Similarly,
a \DWATstartscope{} attribute 
\addtoindexx{start scope attribute}
may have a value of class
\livelink{chap:classrangelistptr}{rangelistptr} for the same reason.  

Range lists are contained in a separate object file section called 
\dotdebugranges{}. A
\addtoindex{range list} is indicated by a 
\DWATranges{} attribute whose
\addtoindexx{ranges attribute}
value is represented as an offset from the beginning of the
\dotdebugranges{} section to the beginning of the 
\addtoindex{range list}.

\needlines{4}
If the current compilation unit contains a \DWATrangesbase{}
attribute, the value of that attribute establishes a base
offset within the \dotdebugranges{} section for the compilation
unit. The offset given by the \DWATranges{} attribute is
relative to that base.

\textit{The \DWATrangesbase{} attribute is new in \DWARFVersionV.
The advantage of this attribute is that it reduces the number of
object language relocations needed for references to the \dotdebugranges{}
section from one for each range entry to a single relocation that
applies for the entire compilation unit.}

The \addtoindex{applicable base address} of a \addtoindex{range list} 
entry is determined
by the closest preceding base address selection entry (see
below) in the same range list. If there is no such selection
entry, then the applicable base address defaults to the base
address of the compilation unit 
(see Section \refersec{chap:normalandpartialcompilationunitentries}).

\textit{In the case of a compilation unit where all of the machine
code is contained in a single contiguous section, no base
address selection entry is needed.}

Address range entries in a \addtoindex{range list} may not overlap.
There is no requirement that the entries be ordered in any particular way.

Each entry in a \addtoindex{range list} is either a 
\addtoindex{range list entry},
\addtoindexx{base address selection entry!in range list}
a base address selection entry, or an 
\addtoindexx{end-of-list entry!in range list}
end-of-list entry.

\needlines{5}
\subsubsection{Range List Entry}
A \addtoindex{range list entry} consists of:
\begin{enumerate}[1. ]
\item A beginning address offset. This address offset has the 
\addtoindex{size of an address} and is relative to
the \addtoindex{applicable base address} of the compilation unit referencing this 
\addtoindex{range list}. 
It marks the beginning of an 
\addtoindexi{address range}{address range!in range list}. 

\item An ending address offset. This address offset again has the 
\addtoindex{size of an address} and is relative
to the \addtoindex{applicable base address} of the compilation unit referencing 
this \addtoindex{range list}.
It marks the first address past the end of the address range.
The ending address must be greater than or
equal to the beginning address.

\needlines{4}
\textit{A \addtoindex{range list} entry (but not a base address 
selection or end-of-list entry) whose beginning and
ending addresses are equal has no effect because the size of the 
range covered by such an entry is zero.}
\end{enumerate}

\needlines{5}
\subsubsection{Base Address Selection Entry}
A \addtoindex{base address selection entry} consists of:
\begin{enumerate}[1. ]
\item The value of the largest representable address offset 
(for example, \wffffffff when the size of an address is 32 bits).

\item An address, which defines the appropriate base address 
for use in interpreting the beginning and ending address offsets 
of subsequent entries of the location list.
\end{enumerate}

\textit{A base address selection entry affects only the 
remainder of list in which it is contained.}

\subsubsection{End-of-List Entry}
The end of any given \addtoindex{range list} is marked by an 
\addtoindexx{end-of-list entry!in range list}
end-of-list entry, 
which consists of a 0 for the beginning address
offset and a 0 for the ending address offset. 
A \addtoindex{range list}
containing only an end-of-list entry describes an empty scope
(which contains no instructions).

\textit{A base address selection entry and an 
\addtoindexx{end-of-list entry!in range list}
end-of-list entry for
a \addtoindex{range list} 
are identical to a base address selection entry
and end-of-list entry, respectively, for a location list
(see Section \refersec{chap:locationlists}) 
in interpretation and representation.}


\section{Entry Address}
\label{chap:entryaddress}
\textit{The entry or first executable instruction generated
for an entity, if applicable, is often the lowest addressed
instruction of a contiguous range of instructions. In other
cases, the entry address needs to be specified explicitly.}

Any debugging information entry describing an entity that has
a range of code addresses, which includes compilation units,
module initialization, subroutines, 
\livelink{chap:lexicalblock}{lexical \nolink{blocks}},
\livelink{chap:tryandcatchblockentries}{try/catch \nolink{blocks}},
and the like, may have a \DWATentrypcDEFN{} attribute 
\addtoindexx{entry PC address}
to indicate the first executable instruction within that 
range\hypertarget{chap:entryaddressofscope}{}
of addresses. The value of the \DWATentrypcNAME{} attribute is a
relocated address if the
value of \DWATentrypcNAME{} is of class \CLASSaddress; or if it is of class
\CLASSconstant, the value is an unsigned integer offset which, when
added to the base address of the function, gives the entry
address. 

The base address of the containing scope is given by either the
\DWATlowpc{} attribute, or the first range entry in the list of
ranges given by the \DWATranges{} attribute. 
If no \DWATentrypcNAME{} attribute is present,
then the entry address is assumed to be the same as the
base address.


\section{Static and Dynamic Values of Attributes}
\label{chap:staticanddynamicvaluesofattributes}

Some attributes that apply to types specify a property (such
as the lower bound of an array) that is an integer value,
where the value may be known during compilation or may be
computed dynamically during execution.

\needlines{5}
The value of these
attributes is determined based on the class as follows:
\begin{itemize}
\item For a \livelink{chap:classconstant}{constant}, the value of the constant is the value of
the attribute.

\item For a \livelink{chap:classreference}{reference}, the
value is a reference to another DIE.  This DIE may:
\begin{itemize}
\renewcommand{\itemsep}{0cm}
\item describe a constant which is the attribute value,
\item describe a variable which contains the attribute value, or
\item contain a DWARF expression which computes the attribute value
      (for example, be a \DWTAGdwarfprocedure{} entry).
\end{itemize}

\item For an \livelink{chap:classexprloc}{exprloc}, the value is interpreted as a 
DWARF expression; 
evaluation of the expression yields the value of
the attribute.
\end{itemize}

\textit{Whether an attribute value can be dynamic depends on the
rules of the applicable programming language.
}

\needlines{4}
\section{Entity Descriptions}
\textit{Some debugging information entries may describe entities
in the program that are artificial, or which otherwise have a 
\doublequote{name} that is not a valid identifier in the
programming language. For example, several languages may
capture or freeze the value of a variable at a particular
point in the program and hold that value in an artificial variable. 
\addtoindex{Ada} 95 has package elaboration routines,
type descriptions of the form \texttt{typename\textquoteright Class}, and 
\doublequote{\texttt{access} typename} parameters.}

Generally, any debugging information entry that 
\hypertarget{chap:DWATdescriptionartificialnameordescription}{}
has, or may have, a \DWATname{} attribute, may
also have a
\addtoindexx{description attribute}
\DWATdescriptionDEFN{} attribute whose value is a
null-terminated string providing a description of the entity.

\textit{It is expected that a debugger will only display these
descriptions as part of the description of other entities.}

\needlines{4}
\section{Byte and Bit Sizes}
\label{chap:byteandbitsizes}
% Some trouble here with hbox full, so we try optional word breaks.
Many debugging information entries allow either a
\DWATbytesizeNAME{} attribute or a 
\DWATbitsizeNAME{} attribute,
whose \livelink{chap:classconstant}{integer constant} value 
(see Section \ref{chap:staticanddynamicvaluesofattributes}) 
specifies an
amount of storage. The value of the 
\DWATbytesizeDEFN{} attribute
is interpreted in bytes and the value of the 
\DWATbitsizeDEFN{}
attribute is interpreted in bits. The
\DWATstringlengthbytesize{} and 
\DWATstringlengthbitsize{} 
attributes are similar.

In addition, the \livelink{chap:classconstant}{integer constant}
value of a \DWATbytestride{} attribute is interpreted
in bytes and the \livelink{chap:classconstant}{integer constant} value of a 
\DWATbitstride{}
attribute is interpreted in bits.

\section{Linkage Names}
\label{chap:linkagenames}
\textit{Some language implementations, notably 
\addtoindex{C++} and similar
languages, make use of implementation-defined names within
object files that are different from the \addtoindex{identifier names}
(see Section \refersec{chap:identifiernames}) of entities as they 
appear in the source. Such names, sometimes known as 
\addtoindex{mangled names}\addtoindexx{names!mangled},
are used in various ways, such as: to encode additional
information about an entity, to distinguish multiple entities
that have the same name, and so on. When an entity has an
associated distinct linkage name it may sometimes be useful
for a producer to include this name in the DWARF description
of the program to facilitate consumer access to and use of
object file information about an entity and/or information
\hypertarget{chap:DWATlinkagenameobjectfilelinkagenameofanentity}{}
that is encoded in the linkage name itself.  
}

% Some trouble maybe with hbox full, so we try optional word breaks.
A debugging information entry may have a
\addtoindexx{linkage name attribute}
\DWATlinkagenameDEFN{}
attribute whose value is a null-terminated string containing the 
object file linkage name associated with the corresponding entity.


\section{Template Parameters}
\label{chap:templateparameters}
\textit{In \addtoindex{C++}, a template is a generic definition 
of a class, function, member function, or typedef (alias).  
A template has formal parameters that
can be types or constant values; the class, function,
member function, or typedef is instantiated differently for each
distinct combination of type or value actual parameters.  DWARF does
not represent the generic template definition, but does represent each
instantiation.}

A debugging information entry that represents a 
\addtoindex{template instantiation}
will contain child entries describing the actual template parameters.
The containing entry and each of its child entries reference a template
parameter entry in any circumstance where the template definition
referenced a formal template parameter.

A template type parameter is represented by a debugging information
entry with the tag
\addtoindexx{template type parameter entry}
\DWTAGtemplatetypeparameterTARG. 
A template value parameter is represented by a debugging information
entry with the tag
\addtoindexx{template value parameter entry}
\DWTAGtemplatevalueparameterTARG.
The actual template parameter entries appear in the same order as the 
corresponding template formal parameter declarations in the 
source program.

\needlines{4}
A type or value parameter entry may have a \DWATname{} attribute, 
\addtoindexx{name attribute}
whose value is a
null\dash terminated string containing the name of the corresponding 
formal parameter as it appears in the source program.
The entry may also have a 
\DWATdefaultvalue{} attribute, which is a flag indicating 
that the value corresponds to the default argument for the 
template parameter.

A
\addtoindexx{formal type parameter|see{template type parameter entry}}
template type parameter entry has a
\addtoindexx{type attribute}
\DWATtype{} attribute
describing the actual type by which the formal is replaced.

A template value parameter entry has a \DWATtype{} attribute 
describing the type of the parameterized value.
The entry also has an attribute giving the 
actual compile-time or run-time constant value 
of the value parameter for this instantiation.
This can be a 
\DWATconstvalueDEFN{} attribute, 
\addtoindexx{constant value attribute}
\livetarg{chap:DWATconstvaluetemplatevalueparameter}{} 
whose value is the compile-time constant value 
as represented on the target architecture, or a 
\DWATlocation{} attribute, whose value is a 
single location description for the run-time constant address.

\section{Alignment}
\label{chap:alignment}
\livetarg{chap:DWATalignmentnondefault}{}
A debugging information entry may have a 
\DWATalignmentDEFN{} attribute\addtoindexx{alignment attribute}
that describes the (non-default) alignment requirements of the entry.
\DWATalignment{} has a positive, non-zero, integer constant value
describing the strictest specified (non-default) alignment of the entity. 
This constant describes the actual alignment used by the compiler.
(If there are multiple alignments specified by the user, or if the 
user specified an alignment the compiler could not satisfy, then 
only the strictest alignment is added using this attribute.)

\textit{For example, an alignment attribute whose value is 8 indicates
that the entity to which it applies occurs at an address that is a
multiple of eight (not a multiple of $2^8$ or 256).}