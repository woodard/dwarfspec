\chapter{General Description}
\label{chap:generaldescription}
\section{The Debugging Information Entry (DIE)}
\label{chap:thedebuggingentrydie}
DWARF 
\addtoindexx{debugging information entry}
uses a series of debugging information entries 
(DIEs)\addtoindexx{DIE|see{debugging information entry}} 
to define a low-level representation of a source program. 
Each debugging information entry consists of an identifying
\addtoindex{tag} and a series of 
\addtoindex{attributes}. 
An entry, or group of entries together, provide a description of a
corresponding 
\addtoindex{entity} in the source program. 
The tag specifies the class to which an entry belongs
and the attributes define the specific characteristics of the entry.

The set of tag names
\addtoindexx{tag names|see{debugging information entry}}
is listed in Table \refersec{tab:tagnames}. 
The debugging information entries they identify are
described in Chapters 3, 4 and 5.

\begin{table}[p]
\caption{Tag names}
\label{tab:tagnames}
\simplerule[6in]
\autocols[0pt]{c}{2}{l}{
\DWTAGaccessdeclaration,
\DWTAGarraytype,
\DWTAGatomictype,
\DWTAGbasetype,
\DWTAGcallsite,
\DWTAGcallsiteparameter,
\DWTAGcatchblock,
\DWTAGclasstype,
\DWTAGcoarraytype,
\DWTAGcommonblock,
\DWTAGcommoninclusion,
\DWTAGcompileunit,
\DWTAGcondition,
\DWTAGconsttype,
\DWTAGconstant,
\DWTAGdwarfprocedure,
\DWTAGdynamictype,
\DWTAGentrypoint,
\DWTAGenumerationtype,
\DWTAGenumerator,
\DWTAGfiletype,
\DWTAGformalparameter,
\DWTAGfriend,
\DWTAGgenericsubrange,
\bb
\DWTAGimmutabletype,
\eb
\DWTAGimporteddeclaration,
\DWTAGimportedmodule,
\DWTAGimportedunit,
\DWTAGinheritance,
\DWTAGinlinedsubroutine,
\DWTAGinterfacetype,
\DWTAGlabel,
\DWTAGlexicalblock,
\bb
\DWTAGmember,
\DWTAGmodule,
\eb
\DWTAGnamelist,
\DWTAGnamelistitem,
\DWTAGnamespace,
\DWTAGpackedtype,
\DWTAGpartialunit,
\DWTAGpointertype,
\DWTAGptrtomembertype,
\DWTAGreferencetype,
\DWTAGrestricttype,
\DWTAGrvaluereferencetype,
\DWTAGsettype,
\DWTAGsharedtype,
\DWTAGskeletonunit,
\DWTAGstringtype,
\DWTAGstructuretype,
\DWTAGsubprogram,
\DWTAGsubrangetype,
\DWTAGsubroutinetype,
\DWTAGtemplatealias,
\DWTAGtemplatetypeparameter,
\DWTAGtemplatevalueparameter,
\DWTAGthrowntype,
\DWTAGtryblock,
\DWTAGtypedef,
\DWTAGtypeunit,
\DWTAGuniontype,
\DWTAGunspecifiedparameters,
\DWTAGunspecifiedtype,
\DWTAGvariable,
\DWTAGvariant,
\DWTAGvariantpart,
\DWTAGvolatiletype,
\DWTAGwithstmt
}
\simplerule[6in]
\end{table}


\textit{The debugging information entry descriptions in
Chapters 3, 4 and 5 generally include mention of
most, but not necessarily all, of the attributes 
that are normally or possibly used with the entry.
Some attributes, whose applicability tends to be 
pervasive and invariant across many kinds of
debugging information entries, are described in 
this section and not necessarily mentioned in all
contexts where they may be appropriate. 
Examples include 
\DWATartificial, 
the \livelink{chap:declarationcoordinates}{declaration coordinates}, and 
\DWATdescription, 
among others.}

The debugging information entries are contained in the 
\dotdebuginfo{} and/or \dotdebuginfodwo{} sections of an object file.

\needlines{4}
Optionally, debugging information may be partitioned such
that the majority of the debugging information can remain in
individual object files without being processed by the
linker. See Section \refersec{datarep:splitdwarfobjectfiles} and
Appendix \refersec{app:splitdwarfobjectsinformative} for details.

\needlines{4}
As a further option, debugging information entries and other debugging
information that are the same in multiple executable or shared object files 
may be found in a separate \addtoindex{supplementary object file} that 
contains supplementary debug sections.
See Section \refersec{datarep:dwarfsupplemetaryobjectfiles} for
further details.
 
\section{Attribute Types}
\label{chap:attributetypes}
Each attribute value is characterized by an attribute name. 
\addtoindexx{attribute duplication}
No more than one attribute with a given name may appear in any
debugging information entry. 
There are no limitations on the
\addtoindexx{attribute ordering}
ordering of attributes within a debugging information entry.

The attributes are listed in Table \referfol{tab:attributenames}.  

\setlength{\extrarowheight}{0.1cm}
\addtoindexx{attributes!list of}
\begin{longtable}{P{6.2cm}|P{8.5cm}}
  \caption{Attribute names} \label{tab:attributenames} \\
  \hline \bfseries Attribute$^*$&\bfseries Usage \\ \hline
\endfirsthead
  \bfseries Attribute$^*$&\bfseries Identifies or Specifies \\ \hline
\endhead
  \hline
  \multicolumn{2}{l}{
  \parbox{15cm}{
  \vspace{2mm}\emph{Continued on next page} \newline
  $^*${\parbox[t]{15cm}{\tiny Links for attributes come to the left column of this table;
  links in the right column "fan-out" to one or more descriptions.}} \newline
  ~\newline}}
\endfoot
  \hline
  \multicolumn{2}{l}{
  $^*${\parbox[t]{15cm}{\tiny Links for attributes come to the left column of this table;
  links in the right column "fan-out" to one or more descriptions.}}}
\endlastfoot

\DWATabstractoriginTARG
&\livelinki{chap:DWATabstractorigininlineinstance}
        {Inline instances of inline subprograms} 
        {inline instances of inline subprograms} \\
% Heren livelink we cannot use \dash or \dash{}.
&\livelinki{chap:DWATabstractoriginoutoflineinstance}
        {Out-of-line instances of inline subprograms}
        {out-of-line instances of inline subprograms} \\
\DWATaccessibilityTARG
&\livelink{chap:DWATaccessdeclaration}
        {Access declaration} (\addtoindex{C++}, \addtoindex{Ada}) \\
&\livelink{chap:DWATaccessibilitycppinheritedmembers}
        {Accessibility of base or inherited class} (\addtoindex{C++}) \\
&\livelinki{chap:DWATaccessibilityattribute}
        {Accessibility of data member or member function}
        {accessibility attribute} 
        \\
\DWATaddressclassTARG
&\livelinki{chap:DWATadressclasspointerorreferencetypes}
        {Pointer or reference types}
        {pointer or reference types}  \\
&\livelinki{chap:DWATaddressclasssubroutineorsubroutinetype}
        {Subroutine or subroutine type}
        {subroutine or subroutine type} \\
\DWATaddrbaseTARG
&\livelinki{chap:DWATaddrbaseforaddresstable}
        {Base offset for address table}
        {address table} \\
\DWATalignmentTARG
&\livelinki{chap:DWATalignmentnondefault}
        {Non-default alignment of type, subprogram or variable}
        {non-default alignment} \addtoindexx{alignment!non-default} \\
\DWATallocatedTARG
&\livelinki{chap:DWATallocatedallocationstatusoftypes}
        {Allocation status of types}
        {allocation status of types}  \\
\DWATartificialTARG
&\livelinki{chap:DWATartificialobjectsortypesthat}
        {Objects or types that are not actually declared in the source}
        {objects or types that are not actually declared in the source}  \\
\DWATassociatedTARG{} 
&\livelinki{chap:DWATassociatedassociationstatusoftypes}
        {Association status of types}
        {association status of types} \\
\DWATbasetypesTARG{} 
&\livelinki{chap:DWATbasetypesprimitivedatatypesofcompilationunit}
        {Primitive data types of compilation unit}
        {primitive data types of compilation unit} \\
\DWATbinaryscaleTARG{} 
&\livelinki{chap:DWATbinaryscalebinaryscalefactorforfixedpointtype}
        {Binary scale factor for fixed-point type}
        {binary scale factor for fixed-point type} \\
%\DWATbitoffsetTARG{} 
%&\livelinki{chap:DWATbitoffsetbasetypebitlocation}{Base type bit location}{base type bit location} \\
%&\livelinki{chap:DWATbitoffsetdatamemberbitlocation}{Data member bit location}{data member bit location} \\
\DWATbitsizeTARG{} 
&\livelinki{chap:DWATbitsizebasetypebitsize}
        {Size of a base type in bits}
        {base type bit size} \\
&\livelinki{chap:DWATbitsizedatamemberbitsize}
        {Size of a data member in bits}
        {data member bit size} \\
\DWATbitstrideTARG{} 
&\livelinki{chap:DWATbitstridearrayelementstrideofarraytype}
           {Array element stride (of array type)}
           {array element stride (of array type)} \\*
&\livelinki{chap:DWATbitstridesubrangestridedimensionofarraytype}
           {Subrange stride (dimension of array type)}
           {subrange stride (dimension of array type)} \\*
&\livelinki{chap:DWATbitstrideenumerationstridedimensionofarraytype}
           {Enumeration stride (dimension of array type)}
           {enumeration stride (dimension of array type)} \\
\DWATbytesizeTARG{} 
&\livelinki{chap:DWATbytesizedataobjectordatatypesize}
           {Size of a data object or data type in bytes}
           {data object or data type size} \\
\DWATbytestrideTARG{} 
&\livelinki{chap:DWATbytestridearrayelementstrideofarraytype}
           {Array element stride (of array type)}
           {array element stride (of array type)} \\
&\livelinki{chap:DWATbytestridesubrangestridedimensionofarraytype}
           {Subrange stride (dimension of array type)}
           {subrange stride (dimension of array type)} \\
&\livelinki{chap:DWATbytestrideenumerationstridedimensionofarraytype}
           {Enumeration stride (dimension of array type)}
           {enumeration stride (dimension of array type)} \\
\DWATcallallcallsTARG{}
&\livelinki{chap:DWATcallallcallsofasubprogram}
           {All tail and normal calls in a subprogram are described by call site entries}
           {all tail and normal calls are described}
           \index{call site!summary!all tail and normal calls are described} \\
\DWATcallallsourcecallsTARG{}
&\livelinki{chap:DWATcallallsourcecallsofasubprogram}
           {All tail, normal and inlined calls in a subprogram are described by call site and inlined subprogram entries}
           {all tail, normal and inlined calls are described}
           \index{call site!summary!all tail, normal and inlined calls are described} \\
\DWATcallalltailcallsTARG{}
&\livelinki{chap:DWATcallalltailcallsofasubprogram}
           {All tail calls in a subprogram are described by call site entries}
           {all tail calls are described}
           \index{call site!summary!all tail calls are described} \\
\DWATcallcolumnTARG{} 
&\livelinki{chap:DWATcallcolumncolumnpositionofinlinedsubroutinecall}
           {Column position of inlined subroutine call}
           {column position of inlined subroutine call} \\
&\livelinki{chap:DWATcallcolumnofcallsite}
           {Column position of call site of non-inlined call} 
           {column position of call site of non-inlined call} \\
\DWATcalldatalocationTARG{}
&\livelinki{chap:DWATcalldatalocationofcallparameter}
           {Address of the value pointed to by an argument passed in a call}
           {address of the value pointed to by an argument}
           \index{call site!address of the value pointed to by an argument} \\
\DWATcalldatavalueTARG{}
&\livelinki{chap:DWATcalldatavalueofcallparameter}
           {Value pointed to by an argument passed in a call}
           {value pointed to by an argument}
           \index{call site!value pointed to by an argument} \\
\DWATcallfileTARG
&\livelinki{chap:DWATcallfilefilecontaininginlinedsubroutinecall}
           {File containing inlined subroutine call}
           {file containing inlined subroutine call} \\
&\livelinki{chap:DWATcallfileofcallsite}
           {File containing call site of non-inlined call} 
           {file containing call site of non-inlined call} \\
\DWATcalllineTARG{} 
&\livelinki{chap:DWATcalllinelinenumberofinlinedsubroutinecall}
           {Line number of inlined subroutine call}
           {line number of inlined subroutine call} \\
&\livelinki{chap:DWATcalllineofcallsite}
           {Line containing call site of non-inlined call} 
           {line containing call site of non-inlined call} \\
\DWATcallingconventionTARG{} 
&\livelinki{chap:DWATcallingconventionforsubprograms}
           {Calling convention for subprograms}
           {Calling convention!for subprograms} \\
&\livelinki{chap:DWATcallingconventionfortypes}
           {Calling convention for types}
           {Calling convention!for types} \\
\DWATcalloriginTARG{}
&\livelinki{chap:DWATcalloriginofcallsite}
           {Subprogram called in a call}
           {subprogram called}
           \index{call site!subprogram called} \\
\DWATcallparameterTARG{}
&\livelinki{chap:DWATcallparameterofcallparameter}
           {Parameter entry in a call}
           {parameter entry}
           \index{call site!parameter entry} \\
\DWATcallpcTARG{}
&\livelinki{chap:DWATcallpcofcallsite}
           {Address of the call instruction in a call}
           {address of call instruction}
           \index{call site!address of the call instruction} \\
\DWATcallreturnpcTARG{}
&\livelinki{chap:DWATcallreturnpcofcallsite}
           {Return address from a call}
           {return address from a call}
           \index{call site!return address} \\
\DWATcalltailcallTARG{}
&\livelinki{chap:DWATcalltailcallofcallsite}
           {Call is a tail call}
           {call is a tail call}
           \index{call site!tail call} \\
\DWATcalltargetTARG{}
&\livelinki{chap:DWATcalltargetofcallsite}
           {Address of called routine in a call}
           {address of called routine}
           \index{call site!address of called routine} \\
\DWATcalltargetclobberedTARG{}
&\livelinki{chap:DWATcalltargetclobberedofcallsite}
           {Address of called routine, which may be clobbered, in a call}
           {address of called routine, which may be clobbered}
           \index{call site!address of called routine, which may be clobbered} \\
\DWATcallvalueTARG{}
&\livelinki{chap:DWATcallvalueofcallparameter}
           {Argument value passed in a call}
           {argument value passed}
           \index{call site!argument value passed} \\
\DWATcommonreferenceTARG
&\livelinki{chap:commonreferencecommonblockusage}
        {Common block usage}
        {common block usage} \\
\DWATcompdirTARG
&\livelinki{chap:DWATcompdircompilationdirectory}
        {Compilation directory}
        {compilation directory} \\
\DWATconstexprTARG
&\livelinki{chap:DWATconstexprcompiletimeconstantobject}
        {Compile-time constant object}
        {compile-time constant object} \\
&\livelinki{chap:DWATconstexprcompiletimeconstantfunction}
        {Compile-time constant function}
        {compile-time constant function} \\
\DWATconstvalueTARG
&\livelinki{chap:DWATconstvalueconstantobject}
        {Constant object}
        {constant object} \\
&\livelinki{chap:DWATconstvalueenumerationliteralvalue}
        {Enumeration literal value}
        {enumeration literal value} \\
&\livelinki{chap:DWATconstvaluetemplatevalueparameter}
        {Template value parameter}
        {template value parameter} \\
\DWATcontainingtypeTARG
&\livelinki{chap:DWATcontainingtypecontainingtypeofpointertomembertype}
        {Containing type of pointer to member type}
        {containing type of pointer to member type} \\
\DWATcountTARG
&\livelinki{chap:DWATcountelementsofsubrangetype}
        {Elements of subrange type}
        {elements of breg subrange type} \\
\DWATdatabitoffsetTARG
&\livelinki{chap:DWATdatabitoffsetbasetypebitlocation}
        {Base type bit location}
        {base type bit location} \\
&\livelinki{chap:DWATdatabitoffsetdatamemberbitlocation}
        {Data member bit location}
        {data member bit location} \\
\DWATdatalocationTARG{} 
&\livelinki{chap:DWATdatalocationindirectiontoactualdata}
        {Indirection to actual data}   
        {indirection to actual data} \\
\DWATdatamemberlocationTARG
&\livelinki{chap:DWATdatamemberlocationdatamemberlocation}
        {Data member location}
        {data member location} \\
&\livelinki{chap:DWATdatamemberlocationinheritedmemberlocation}
        {Inherited member location}
        {inherited member location} \\
\DWATdecimalscaleTARG
&\livelinki{chap:DWATdecimalscaledecimalscalefactor}
        {Decimal scale factor}
        {decimal scale factor} \\
\DWATdecimalsignTARG
&\livelinki{chap:DWATdecimalsigndecimalsignrepresentation}
        {Decimal sign representation}
        {decimal sign representation} \\
\DWATdeclcolumnTARG
&\livelinki{chap:DWATdeclcolumncolumnpositionofsourcedeclaration}
        {Column position of source declaration}
        {column position of source declaration} \\
\DWATdeclfileTARG
&\livelinki{chap:DWATdeclfilefilecontainingsourcedeclaration}
        {File containing source declaration}
        {file containing source declaration} \\
\DWATdecllineTARG
&\livelinki{chap:DWATdecllinelinenumberofsourcedeclaration}
        {Line number of source declaration}
        {line number of source declaration} \\
\DWATdeclarationTARG
&\livelinki{chap:DWATdeclarationincompletenondefiningorseparateentitydeclaration}
        {Incomplete, non-defining, or separate entity declaration}
        {incomplete, non-defining, or separate entity declaration} \\
\DWATdefaultedTARG
&\livelinki{chap:DWATdefaulteddef}
        {Whether a member function has been declared as default}
        {defaulted attribute} \\
\DWATdefaultvalueTARG
&\livelinki{chap:DWATdefaultvaluedefaultvalueofparameter}
        {Default value of parameter}
        {default value of parameter} \\
\DWATdeletedTARG
&\livelinki{chap:DWATdeleteddef}
        {Whether a member has been declared as deleted}
        {Deletion of member function} \\
\DWATdescriptionTARG{} 
&\livelinki{chap:DWATdescriptionartificialnameordescription}
        {Artificial name or description}
        {artificial name or description} \\
\DWATdigitcountTARG
&\livelinki{chap:DWATdigitcountdigitcountforpackeddecimalornumericstringtype}
        {Digit count for packed decimal or numeric string type}
        {digit count for packed decimal or numeric string type} \\
\DWATdiscrTARG
&\livelinki{chap:DWATdiscrdiscriminantofvariantpart}
        {Discriminant of variant part}
        {discriminant of variant part} \\
\DWATdiscrlistTARG
&\livelinki{chap:DWATdiscrlistlistofdiscriminantvalues}
        {List of discriminant values}
        {list of discriminant values} \\
\DWATdiscrvalueTARG
&\livelinki{chap:DWATdiscrvaluediscriminantvalue}
        {Discriminant value}
        {discriminant value} \\
\DWATdwonameTARG
&\livelinki{chap:DWATdwonameforunit}
        {Name of split DWARF object file}
        {split DWARF object file!object file name} \\
\DWATelementalTARG
&\livelinki{chap:DWATelementalelementalpropertyofasubroutine}
        {Elemental property of a subroutine}
        {elemental property of a subroutine} \\
\DWATencodingTARG
&\livelinki{chap:DWATencodingencodingofbasetype}
        {Encoding of base type}
        {encoding of base type} \\
\DWATendianityTARG
&\livelinki{chap:DWATendianityendianityofdata}
        {Endianity of data}
        {endianity of data} \\
\DWATentrypcTARG
&\livelinki{chap:entryaddressofscope}
        {Entry address of a scope (compilation unit, \mbox{subprogram,} and so on)}
        {entry address of a scope} \\
\DWATenumclassTARG
&\livelinki{chap:DWATenumclasstypesafeenumerationdefinition}
        {Type safe enumeration definition}
        {type safe enumeration definition}\\
\DWATexplicitTARG
&\livelinki{chap:DWATexplicitexplicitpropertyofmemberfunction}
        {Explicit property of member function}
        {explicit property of member function}\\
\DWATexportsymbolsTARG
&\livelinki{chap:DWATexportsymbolsofnamespace}
        {Export (inline) symbols of namespace}
        {export symbols of a namespace} \\
&\livelinki{chap:DWATexportsymbolsofstructunionclass}
        {Export symbols of a structure, union or class}
        {export symbols of a structure, union or class} \\
\DWATextensionTARG
&\livelinki{chap:DWATextensionpreviousnamespaceextensionororiginalnamespace}
        {Previous namespace extension or original namespace}
        {previous namespace extension or original namespace}\\
\DWATexternalTARG
&\livelinki{chap:DWATexternalexternalsubroutine}
        {External subroutine}
        {external subroutine} \\
&\livelinki{chap:DWATexternalexternalvariable}
        {External variable}
        {external variable} \\
\DWATframebaseTARG
&\livelinki{chap:DWATframebasesubroutineframebaseaddress}
        {Subroutine frame base address}
        {subroutine frame base address} \\
\DWATfriendTARG
&\livelinki{chap:DWATfriendfriendrelationship}
        {Friend relationship}
        {friend relationship} \\
\DWAThighpcTARG
&\livelinki{chap:DWAThighpccontiguousrangeofcodeaddresses}
        {Contiguous range of code addresses}
        {contiguous range of code addresses} \\
\DWATidentifiercaseTARG
&\livelinki{chap:DWATidentifiercaseidentifiercaserule}
        {Identifier case rule}
        {identifier case rule} \\
\DWATimportTARG
&\livelinki{chap:DWATimportimporteddeclaration}
        {Imported declaration}
        {imported declaration} \\*
&\livelinki{chap:DWATimportimportedunit}
        {Imported unit}
        {imported unit} \\*
&\livelinki{chap:DWATimportnamespacealias}
        {Namespace alias}
        {namespace alias} \\*
&\livelinki{chap:DWATimportnamespaceusingdeclaration}
        {Namespace using declaration}
        {namespace using declaration} \\*
&\livelinki{chap:DWATimportnamespaceusingdirective}
        {Namespace using directive}
        {namespace using directive} \\
\DWATinlineTARG
&\livelinki{chap:DWATinlineabstracttinstance}
        {Abstract instance}
        {abstract instance} \\
&\livelinki{chap:DWATinlineinlinedsubroutine}
        {Inlined subroutine}
        {inlined subroutine} \\
\DWATisoptionalTARG
&\livelinki{chap:DWATisoptionaloptionalparameter}
        {Optional parameter}
        {optional parameter} \\
\DWATlanguageTARG
&\livelinki{chap:DWATlanguageprogramminglanguage}
        {Programming language}
        {programming language} \\
\DWATlinkagenameTARG
&\livelinki{chap:DWATlinkagenameobjectfilelinkagenameofanentity}
        {Object file linkage name of an entity}
        {object file linkage name of an entity} \\
\DWATlocationTARG
&\livelinki{chap:DWATlocationdataobjectlocation}
        {Data object location}
        {data object location} \\
\DWATloclistsbaseTARG
&\livelinki{chap:DWATloclistsbaseinlocationlist}
        {Location lists base}
        {location lists base} \\
\DWATlowpcTARG
&\livelinki{chap:DWATlowpccodeaddressorrangeofaddresses}
        {Code address or range of addresses}
        {code address or range of addresses} \\*
&\livelinki{chap:DWATlowpcbaseaddressofscope}
        {Base address of scope}
        {base address of scope} \\
\DWATlowerboundTARG
&\livelinki{chap:DWATlowerboundlowerboundofsubrange}
        {Lower bound of subrange}
        {lower bound of subrange} \\
\DWATmacroinfoTARG
&\livelinki{chap:DWATmacroinfomacroinformation}
           {Macro preprocessor information (legacy)} 
           {macro preprocessor information (legacy)} \\
&          \textit{(reserved for coexistence with \DWARFVersionIV{} and earlier)} \\
\DWATmacrosTARG
&\livelinki{chap:DWATmacrosmacroinformation}
           {Macro preprocessor information} 
           {macro preprocessor information} \\
&          \textit{(\texttt{\#define}, \texttt{\#undef}, and so on in \addtoindex{C}, 
                \addtoindex{C++} and similar languages)} \\
\DWATmainsubprogramTARG
&\livelinki{chap:DWATmainsubprogrammainorstartingsubprogram}
        {Main or starting subprogram}
        {main or starting subprogram} \\
&\livelinki{chap:DWATmainsubprogramunitcontainingmainorstartingsubprogram}
        {Unit containing main or starting subprogram}
        {unit containing main or starting subprogram}\\
\DWATmutableTARG
&\livelinki{chap:DWATmutablemutablepropertyofmemberdata}
        {Mutable property of member data}
        {mutable property of member data} \\
\DWATnameTARG
&\livelinki{chap:DWATnamenameofdeclaration}
        {Name of declaration}
        {name of declaration}\\
&\livelinki{chap:DWATnamepathnameofcompilationsource}
        {Path name of compilation source}
        {path name of compilation source} \\
\DWATnamelistitemTARG
&\livelinki{chap:DWATnamelistitemnamelistitem}
        {Namelist item}
        {namelist item}\\
\DWATnoreturnTARG
&\livelinki{chap:DWATnoreturnofsubprogram}
        {\doublequote{no return} property of a subprogram}
        {noreturn attribute} \\
\DWATobjectpointerTARG
&\livelinki{chap:DWATobjectpointerobjectthisselfpointerofmemberfunction}
        {Object (\texttt{this}, \texttt{self}) pointer of member function}
        {object (\texttt{this}, \texttt{self}) pointer of member function}\\
\DWATorderingTARG
&\livelinki{chap:DWATorderingarrayrowcolumnordering}
        {Array row/column ordering}
        {array row/column ordering}\\
\DWATpicturestringTARG
&\livelinki{chap:DWATpicturestringpicturestringfornumericstringtype}
        {Picture string for numeric string type}
        {picture string for numeric string type} \\
\DWATpriorityTARG
&\livelinki{chap:DWATprioritymodulepriority}
        {Module priority}
        {module priority}\\
\DWATproducerTARG
&\livelinki{chap:DWATproducercompileridentification}
        {Compiler identification}
        {compiler identification}\\
\DWATprototypedTARG
&\livelinki{chap:DWATprototypedsubroutineprototype}
        {Subroutine prototype}
        {subroutine prototype}\\
\DWATpureTARG
&\livelinki{chap:DWATpurepurepropertyofasubroutine}
        {Pure property of a subroutine}
        {pure property of a subroutine} \\
\DWATrangesTARG
&\livelinki{chap:DWATrangesnoncontiguousrangeofcodeaddresses}
        {Non-contiguous range of code addresses}
        {non-contiguous range of code addresses} \\
\bbeb
\DWATrankTARG
&\livelinki{chap:DWATrankofdynamicarray}
        {Dynamic number of array dimensions}
        {dynamic number of array dimensions} \\
\DWATrecursiveTARG
&\livelinki{chap:DWATrecursiverecursivepropertyofasubroutine}
        {Recursive property of a subroutine}
        {recursive property of a subroutine} \\
\DWATreferenceTARG
&\livelink{chap:DWATreferenceofnonstaticmember}
        {\&-qualified non-static member function} \textit{(\addtoindex{C++})} \\
\DWATreturnaddrTARG
&\livelinki{chap:DWATreturnaddrsubroutinereturnaddresssavelocation}
        {Subroutine return address save location}
        {subroutine return address save location} \\
\bb
\DWATrnglistsbaseTARG
&\livelinki{chap:DWATrnglistsbase}
        {Base offset for range lists}
        {ranges lists} 
\eb     
        \\
\DWATrvaluereferenceTARG
&\livelink{chap:DWATrvaluereferenceofnonstaticmember}
          {\&\&-qualified non-static member function} \textit{(\addtoindex{C++})} \\

\DWATsegmentTARG
&\livelinki{chap:DWATsegmentaddressinginformation}
        {Addressing information}
        {addressing information} \\
\DWATsiblingTARG
&\livelinki{chap:DWATsiblingdebugginginformationentryrelationship}
           {Debugging information entry relationship}
           {debugging information entry relationship} \\
\DWATsmallTARG
&\livelinki{chap:DWATsmallscalefactorforfixedpointtype}
           {Scale factor for fixed-point type}
           {scale factor for fixed-point type} \\
\DWATsignatureTARG
&\livelinki{chap:DWATsignaturetypesignature}
           {Type signature}
           {type signature}\\
\DWATspecificationTARG
&\livelinki{chap:DWATspecificationincompletenondefiningorseparatedeclaration}
           {Incomplete, non-defining, or separate declaration corresponding to a declaration}
           {incomplete, non-defining, or separate declaration corresponding to a declaration} \\
\DWATstartscopeTARG
&\livelinki{chap:DWATstartscopeofdeclaration}
        {Reduced scope of declaration}
        {reduced scope of declaration} \\*
\DWATstaticlinkTARG
&\livelinki{chap:DWATstaticlinklocationofuplevelframe}
        {Location of uplevel frame}
        {location of uplevel frame} \\
\DWATstmtlistTARG
&\livelinki{chap:DWATstmtlistlinenumberinformationforunit}
           {Line number information for unit}
           {line number information for unit}\\
\DWATstringlengthTARG
&\livelinki{chap:DWATstringlengthstringlengthofstringtype}
           {String length of string type}
           {string length of string type} \\
\DWATstringlengthbitsizeTARG
&\livelinki{chap:DWATstringlengthstringlengthofstringtype}
           {Size of string length of string type}
           {string length of string type!size of} \\
\DWATstringlengthbytesizeTARG
&\livelinki{chap:DWATstringlengthstringlengthofstringtype}
           {Size of string length of string type}
           {string length of string type!size of} \\
\DWATstroffsetsbaseTARG
&\livelinki{chap:DWATstroffsetbaseforindirectstringtable}
        {Base of string offsets table}
        {string offsets table} \\
\DWATthreadsscaledTARG
&\livelink{chap:DWATthreadsscaledupcarrayboundthreadsscalfactor}
        {Array bound THREADS scale factor} 
       (\addtoindex{UPC}) \\
\DWATtrampolineTARG
&\livelinki{chap:DWATtrampolinetargetsubroutine}
        {Target subroutine}
        {target subroutine of trampoline} \\
\DWATtypeTARG
&\livelinki{chap:DWATtypeofcallsite}
        {Type of call site}
        {type!of call site} \\
&\livelinki{chap:DWAATtypeofstringtype}
        {Type of string type components}
        {type!of string type components} \\
&\livelinki{chap:DWATtypetypeofsubroutinereturn}
        {Type of subroutine return}
        {type!of subroutine return} \\
&\livelinki{chap:DWATtypetypeofdeclaration}
        {Type of declaration}
        {type!of declaration} \\
\DWATupperboundTARG
&\livelinki{chap:DWATupperboundupperboundofsubrange}
        {Upper bound of subrange}
        {upper bound of subrange} \\
\DWATuselocationTARG
&\livelinki{chap:DWATuselocationmemberlocationforpointertomembertype}
        {Member location for pointer to member type}
        {member location for pointer to member type} \\
\DWATuseUTFeightTARG\addtoindexx{use UTF8 attribute}\addtoindexx{UTF-8}
&\livelinki{chap:DWATuseUTF8compilationunitusesutf8strings}
        {Compilation unit uses UTF-8 strings}
        {compilation unit uses UTF-8 strings} \\
\DWATvariableparameterTARG
&\livelinki{chap:DWATvariableparameternonconstantparameterflag}
        {Non-constant parameter flag}
        {non-constant parameter flag}  \\
\DWATvirtualityTARG
&\livelinki{chap:DWATvirtualityvirtualityindication}
        {virtuality attribute} 
        {Virtuality of member function or base class} \\
\DWATvisibilityTARG
&\livelinki{chap:DWATvisibilityvisibilityofdeclaration}
        {Visibility of declaration}
        {visibility of declaration} \\
\DWATvtableelemlocationTARG
&\livelinki{chap:DWATvtableelemlocationvirtualfunctiontablevtableslot}
        {Virtual function vtable slot}
        {virtual function vtable slot}\\
\end{longtable}

\addtoindexx{address|see {\textit{also} address class}}
\addtoindexx{addrptr|see {\textit{also} addrptr class}}
\addtoindexx{block|see {\textit{also} block class}}
\addtoindexx{constant|see {\textit{also} constant class}}
\addtoindexx{exprloc|see {\textit{also} exprloc class}}
\addtoindexx{flag|see {\textit{also} flag class}}
\addtoindexx{lineptr|see {\textit{also} lineptr class}}
\addtoindexx{loclistsptr|see {\textit{also} loclistsptr class}}
\addtoindexx{loclist|see {\textit{also} loclist class}}
\addtoindexx{macptr|see {\textit{also} macptr class}}
\addtoindexx{reference|see {\textit{also} reference class}}
\addtoindexx{rnglistsptr|see {\textit{also} rnglistsptr class}}
\addtoindexx{rnglist|see {\textit{also} rnglist class}}
\addtoindexx{string|see {\textit{also} string class}}
\addtoindexx{stroffsetsptr|see {\textit{also} stroffsetsptr class}}

\addtoindexx{class of attribute value!address|see {address class}}
\addtoindexx{class of attribute value!addrptr|see {addrptr class}}
\addtoindexx{class of attribute value!block|see {block class}}
\addtoindexx{class of attribute value!constant|see {constant class}}
\addtoindexx{class of attribute value!exprloc|see {exprloc class}}
\addtoindexx{class of attribute value!flag|see {flag class}}
\addtoindexx{class of attribute value!lineptr|see {lineptr class}}
\addtoindexx{class of attribute value!loclistsptr|see {loclistsptr class}}
\addtoindexx{class of attribute value!loclist|see {loclist class}}
\addtoindexx{class of attribute value!macptr|see {macptr class}}
\addtoindexx{class of attribute value!rnglistsptr|see {rnglistsptr class}}
\addtoindexx{class of attribute value!rnglist|see {rnglist class}}
\addtoindexx{class of attribute value!reference|see {reference class}}
\addtoindexx{class of attribute value!string|see {string class}}
\addtoindexx{class of attribute value!stroffsetsptr|see {stroffsetsptr class}}

\needlines{6}
The permissible values
\addtoindexx{attribute value classes}
for an attribute belong to one or more classes of attribute
value forms.  
Each form class may be represented in one or more ways. 
For example, some attribute values consist
of a single piece of constant data. 
\doublequote{Constant data}
is the class of attribute value that those attributes may have. 
There are several representations of constant data,
including fixed length data of one, two, four, eight or 16 bytes 
in size, and variable length data). 
The particular representation for any given instance
of an attribute is encoded along with the attribute name as
part of the information that guides the interpretation of a
debugging information entry.  

\needlines{4}
Attribute value forms belong
\addtoindexx{tag names!list of}
to one of the classes shown in Table \referfol{tab:classesofattributevalue}.

\begin{longtable}{l|P{11cm}}
\caption{Classes of attribute value}
\label{tab:classesofattributevalue} \\
\hline \bfseries Attribute Class & \bfseries General Use and Encoding \\ \hline
\endfirsthead
  \bfseries Attribute Class & \bfseries General Use and Encoding \\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot

\hypertarget{chap:classaddress}{}
\livelinki{datarep:classaddress}{address}{address class}
&Refers to some location in the address space of the \mbox{described} program.
\\

\hypertarget{chap:classaddrptr}{}
\livelinki{datarep:classaddrptr}{addrptr}{addrptr class}
&
Specifies a location in the DWARF section that holds
a series of machine address values. Certain attributes use
one of these addresses by indexing relative to this location.
\\

\hypertarget{chap:classblock}{}
\livelinki{datarep:classblock}{block}{block class}
& An arbitrary number of uninterpreted bytes of data.
The number of data bytes may be implicit from context
or explicitly specified by an initial unsigned LEB128 value
(see Section \refersec{datarep:variablelengthdata}) 
that precedes that number of data bytes.
\\
 
\hypertarget{chap:classconstant}{}
\livelinki{datarep:classconstant}{constant}{constant class}
&One, two, four, eight or sixteen 
bytes of uninterpreted data, or data
encoded in the variable length format known as LEB128 
(see Section \refersec{datarep:variablelengthdata}).
\\

\hypertarget{chap:classexprloc}{}
\livelinki{datarep:classexprloc}{exprloc}{exprloc class}
&A DWARF expression for a value or a location in the 
address space of the described program.
A leading unsigned LEB128 value 
(see Section \refersec{datarep:variablelengthdata})
specifies the number of bytes in the expression.
\\

\hypertarget{chap:classflag}{}
\livelinki{datarep:classflag}{flag}{flag class}
&A small constant that indicates the presence or absence 
of an attribute.
\\

\hypertarget{chap:classlineptr}{}
\livelinki{datarep:classlineptr}{lineptr}{lineptr class}
&Specifies a location in the DWARF section that holds line 
number information.
\\

\hypertarget{chap:classloclist}{}
\livelinki{datarep:classloclist}{loclist}{loclist class}, 
\hypertarget{chap:classloclistsptr}{}
\livelinki{datarep:classloclistsptr}{loclistsptr}{loclistsptr class}
&Specifies a location in the DWARF section that holds location 
lists, which describe objects whose location can change during 
their lifetime.
\\

\hypertarget{chap:classmacptr}{}
\livelinki{datarep:classmacptr}{macptr}{macptr class}
&Specifies 
a location in the DWARF section that holds macro definition
information.
\\

\hypertarget{chap:classreference}{}
\livelinki{datarep:classreference}{reference}{reference class}
&\bbeb
Refers to one of the debugging information
entries that \mbox{describe} the program.  There are four types of
\mbox{reference}. The first is an offset relative to the beginning
of the \mbox{compilation} unit in which the reference occurs and must
refer to an entry within that same compilation unit. The second
type of reference is the offset of a debugging \mbox{information}
entry in any compilation unit, including one different from
the unit containing the reference. The third type of reference
is an indirect reference to a 
\addtoindexx{type signature}
type definition using an 8-byte signature 
for that type. The fourth type of reference is a reference from within the 
\dotdebuginfo{} section of the executable or shared object file to
a debugging information entry in the \dotdebuginfo{} section of 
a \addtoindex{supplementary object file}.
\\

\bb
\hypertarget{chap:classrnglist}{}
\livelinki{datarep:classrnglist}{rnglist}{rnglist class}, 
\hypertarget{chap:classrnglistsptr}{}
\livelinki{datarep:classrnglistsptr}{rnglistsptr}{rnglistsptr class}
&Specifies a location in the DWARF section that holds 
non-contiguous address ranges.
\eb
\\

\hypertarget{chap:classstring}{}
\livelinki{datarep:classstring}{string}{string class}
& A null-terminated sequence of zero or more
(non-null) bytes. Data in this class are generally
printable strings. Strings may be represented directly in
the debugging \mbox{information} entry or as an offset in a separate
string table.
\\

\hypertarget{chap:classstroffsetsptr}{}
\livelinki{datarep:classstroffsetsptr}{stroffsetsptr}{stroffsetsptr class}
&Specifies a location in the DWARF section that holds
a series of offsets into the DWARF section that holds strings.
Certain attributes use one of these offsets by indexing 
relative to this location. The resulting offset is then 
used to index into the DWARF string section.
\\

\hline
\end{longtable}


\section{Relationship of Debugging Information Entries}
\label{chap:relationshipofdebugginginformationentries}
\textit{%
A variety of needs can be met by permitting a single
\addtoindexx{debugging information entry!ownership relation}
debugging information entry to \doublequote{own} an arbitrary number
of other debugging entries and by permitting the same debugging
information entry to be one of many owned by another debugging
information entry. 
This makes it possible, for example, to
describe the static \livelink{chap:lexicalblock}{block} structure 
within a source file,
to show the members of a structure, union, or class, and to
associate declarations with source files or source files
with shared object files.  
}

\needlines{4}
The ownership relationship 
\addtoindexx{debugging information entry!ownership relation}
of debugging
information entries is achieved naturally because the debugging
information is represented as a tree. The nodes of the tree
are the debugging information entries themselves. 
The child entries of any node are exactly those debugging information
entries owned by that node.  

\textit{%
While the ownership relation
of the debugging information entries is represented as a
tree, other relations among the entries exist, for example,
a reference from an entry representing a variable to another
entry representing the type of that variable. 
If all such
relations are taken into account, the debugging entries
form a graph, not a tree.  
}

\needlines{4}
The tree itself is represented
by flattening it in prefix order. 
Each debugging information
entry is defined either to have child entries or not to have
child entries (see Section \refersec{datarep:abbreviationstables}). 
If an entry is defined not
to have children, the next physically succeeding entry is a
sibling. 
If an entry is defined to have children, the next
physically succeeding entry is its first child. 
Additional
children are represented as siblings of the first child. 
A chain of sibling entries is terminated by a null entry.

In cases where a producer of debugging information feels that
it\hypertarget{chap:DWATsiblingdebugginginformationentryrelationship}{}
will be important for consumers of that information to
quickly scan chains of sibling entries, while ignoring the
children of individual siblings, that producer may attach a
\addtoindexx{sibling attribute}
\DWATsiblingDEFN{} attribute 
to any debugging information entry. 
The value of this attribute is a reference to the sibling entry
of the entry to which the attribute is attached.

\section{Target Addresses}
\label{chap:targetaddressableunitsandaddresses}
\label{chap:targetaddresses}
\addtoindexx{size of an address}
\addtoindexx{size of an address|see{\textit{also} \texttt{address\_size}}}
\addtoindexx{address size|see{size of an address}}
\addtoindexx{address size|see{\textit{also} \texttt{address\_size}}}

Addresses, bytes and bits in DWARF use the numbering and direction
conventions that are appropriate to the current language on
the target system.

Many places in this document refer to the size of an address
on the target architecture (or equivalently, target machine)
to which a DWARF description applies. For processors which
can be configured to have different address sizes or different
instruction sets, the intent is to refer to the configuration
which is either the default for that processor or which is
specified by the object file or executable file which contains
the DWARF information.

\textit{%
For example, if a particular target architecture supports
both 32-bit and 64-bit addresses, the compiler will generate
an object file which specifies that it contains executable
code generated for one or the other of these 
\addtoindexx{size of an address}
address sizes. In
that case, the DWARF debugging information contained in this
object file will use the same address size.}

\needlines{6}
\section{DWARF Expressions}
\label{chap:dwarfexpressions}
DWARF expressions describe how to compute a value or 
specify a location. They are expressed in
terms of DWARF operations that operate on a stack of values.

A DWARF expression is encoded as a stream of operations, 
each consisting of an opcode followed by zero or more literal 
operands. The number of operands is implied by the opcode.  

In addition to the
general operations that are defined here, operations that are
specific to location descriptions are defined in 
Section \refersec{chap:locationdescriptions}.

\subsection{General Operations}
\label{chap:generaloperations}
Each general operation represents a postfix operation on
a simple stack machine. 
Each element of the stack has a type and a value, and can represent
a value of any supported base type of the target machine.  Instead of
a base type, elements can have a 
\definitionx{generic type}\livetarg{chap:generictype}{},
which is an integral type that has the 
\addtoindex{size of an address} on the target machine and 
unspecified signedness. The value on the top of the stack after 
\doublequote{executing} the 
\addtoindex{DWARF expression}
is 
\addtoindexx{DWARF expression|see{\textit{also} location description}}
taken to be the result (the address of the object, the
value of the array bound, the length of a dynamic string,
the desired value itself, and so on).

\textit{The
\generictype{} is the same as the unspecified type used for stack operations
defined in \DWARFVersionIV{} and before.
}

\needlines{4}
\subsubsection{Literal Encodings}
\label{chap:literalencodings}
The 
\addtoindexx{DWARF expression!literal encodings}
following operations all push a value onto the DWARF
stack. 
\addtoindexx{DWARF expression!stack operations}
Operations other than \DWOPconsttype{} push a value with the 
\generictype, and if the value of a constant in one of these 
operations is larger than can be stored in a single stack element, 
the value is truncated to the element size and the low-order bits
are pushed on the stack.
\begin{enumerate}[1. ]
\itembfnl{\DWOPlitzeroTARG, \DWOPlitoneTARG, \dots, \DWOPlitthirtyoneTARG}
The \DWOPlitnTARG{} operations encode the unsigned literal values
from 0 through 31, inclusive.

\itembfnl{\DWOPaddrTARG}
The \DWOPaddrNAME{} operation has a single operand that encodes
a machine address and whose size is the \addtoindex{size of an address}
on the target machine.

\itembfnl{\DWOPconstoneuTARG, \DWOPconsttwouTARG, \DWOPconstfouruTARG, \DWOPconsteightuTARG}
\DWOPconstnxMARK{}
The single operand of a \DWOPconstnuNAME{} operation provides a 1,
2, 4, or 8-byte unsigned integer constant, respectively.

\itembfnl{\DWOPconstonesTARG, \DWOPconsttwosTARG, \DWOPconstfoursTARG, \DWOPconsteightsTARG}
The single operand of a \DWOPconstnsNAME{} operation provides a 1,
2, 4, or 8-byte signed integer constant, respectively.

\needlines{4}
\itembfnl{\DWOPconstuTARG}
The single operand of the \DWOPconstuNAME{} operation provides
an unsigned LEB128\addtoindexx{LEB128!unsigned} integer constant.

\itembfnl{\DWOPconstsTARG}
The single operand of the \DWOPconstsNAME{} operation provides
a signed LEB128\addtoindexx{LEB128!unsigned} integer constant.

\needlines{4}
\itembfnl{\DWOPaddrxTARG}
The \DWOPaddrxNAME{} operation has a single operand that
encodes an unsigned LEB128\addtoindexx{LEB128!unsigned} value, 
which is a zero-based index into the \dotdebugaddr{} section, 
where a machine address is stored.
This index is relative to the value of the 
\DWATaddrbase{} attribute of the associated compilation unit.

\itembfnl{\DWOPconstxTARG}
The \DWOPconstxNAME{} operation has a single operand that
encodes an unsigned LEB128\addtoindexx{LEB128!unsigned} value, 
which is a zero-based
index into the \dotdebugaddr{} section, where a constant, the
size of a machine address, is stored.
This index is relative to the value of the 
\DWATaddrbase{} attribute of the associated compilation unit.

\needlines{3}
\textit{The \DWOPconstxNAME{} operation is provided for constants that
require link-time relocation but should not be
interpreted by the consumer as a relocatable address
(for example, offsets to thread-local storage).}

\needlines{8}
\itembfnl{\DWOPconsttypeTARG}
The \DWOPconsttypeNAME{} operation takes three operands. The first operand 
is an unsigned LEB128 integer that represents the offset of a debugging
information entry in the current compilation unit, which must be a
\DWTAGbasetype{} entry that provides the type of the constant provided. The
second operand is 1-byte unsigned integer that specifies the size of the
constant value, which is the same as the size of the base type referenced
by the first operand. The third operand is a 
sequence of bytes of the given size that is 
interpreted as a value of the referenced type.

\textit{While the size of the constant can be inferred from the base type
definition, it is encoded explicitly into the operation so that the
operation can be parsed easily without reference to the \dotdebuginfo{}
section.}

\end{enumerate}

\needlines{10}
\subsubsection{Register Values}
\label{chap:registervalues}
The following operations push a value onto the stack that is either the
contents of a register or the result of adding the contents of a register
to a given signed offset. 
\addtoindexx{DWARF expression!register based addressing}
\DWOPregvaltype{} pushes the contents
of the register together with the given base type, while the other operations
push the result of adding the contents of a register to a given
signed offset together with the \generictype.

\needlines{8}
\begin{enumerate}[1. ]
\itembfnl{\DWOPfbregTARG}
The \DWOPfbregNAME{} operation provides a 
signed LEB128\addtoindexx{LEB128!signed} offset
from the address specified by the location description in the
\DWATframebase{} attribute of the current function.
 
\textit{This is typically a stack pointer register plus or minus some offset.}

\itembfnl{\DWOPbregzeroTARG, \DWOPbregoneTARG, \dots, \DWOPbregthirtyoneTARG}
The single operand of the \DWOPbregnTARG{} 
operations provides
a signed LEB128\addtoindexx{LEB128!signed} offset from
the contents of the specified register.

\itembfnl{\DWOPbregxTARG}
The \DWOPbregxNAME{} operation provides the sum of two values specified
by its two operands. The first operand is a register number
which is specified by an unsigned LEB128\addtoindexx{LEB128!unsigned}
number. The second operand is a signed LEB128\addtoindexx{LEB128!signed} offset.

\needlines{8}
\itembfnl{\DWOPregvaltypeTARG}
The \DWOPregvaltypeNAME{} operation provides the contents of
a given register interpreted as a value of a given type. The first 
operand is an unsigned LEB128\addtoindexx{LEB128!unsigned} number, 
which identifies a register whose contents is to
be pushed onto the stack. The second operand is an 
unsigned LEB128\addtoindexx{LEB128!unsigned} number
that represents the offset of a debugging information entry in the current
compilation unit, which must be a \DWTAGbasetype{} entry that provides the
type of the value contained in the specified register.

\end{enumerate}

\needlines{6}
\subsubsection{Stack Operations}
\label{chap:stackoperations}
The following 
\addtoindexx{DWARF expression!stack operations}
operations manipulate the DWARF stack. Operations
that index the stack assume that the top of the stack (most
recently added entry) has index 0.

Each entry on the stack has an associated type. 

\needlines{4}
\begin{enumerate}[1. ]
\itembfnl{\DWOPdupTARG}
The \DWOPdupNAME{} operation duplicates the value (including its 
type identifier) at the top of the stack.

\itembfnl{\DWOPdropTARG}
The \DWOPdropNAME{} operation pops the value (including its type 
identifier) at the top of the stack.

\itembfnl{\DWOPpickTARG}
The single operand of the \DWOPpickNAME{} operation provides a
1-byte index. A copy of the stack entry (including its 
type identifier) with the specified
index (0 through 255, inclusive) is pushed onto the stack.

\itembfnl{\DWOPoverTARG}
The \DWOPoverNAME{} operation duplicates the entry currently second
in the stack at the top of the stack. 
This is equivalent to a
\DWOPpick{} operation, with index 1.  

\needlines{4}
\itembfnl{\DWOPswapTARG}
The \DWOPswapNAME{} operation swaps the top two stack entries. 
The entry at the top of the stack (including its type identifier)
becomes the second stack entry, and the second entry (including 
its type identifier) becomes the top of the stack.

\itembfnl{\DWOProtTARG}
The \DWOProtNAME{} operation rotates the first three stack
entries. The entry at the top of the stack (including its 
type identifier) becomes the third stack entry, the second 
entry (including its type identifier) becomes the top of 
the stack, and the third entry (including its type identifier)
becomes the second entry.

\itembfnl{\DWOPderefTARG}
The \DWOPderefNAME{} operation pops the top stack entry and 
treats it as an address. The popped value must have an integral type.
The value retrieved from that address is pushed, 
and has the \generictype{}.
The size of the data retrieved from the 
\addtoindexi{dereferenced}{address!dereference operator}
address is the \addtoindex{size of an address} on the target machine.

\needlines{6}
\itembfnl{\DWOPderefsizeTARG}
The \DWOPderefsizeNAME{} operation behaves like the 
\DWOPderef{}
operation: it pops the top stack entry and treats it as an
address. The popped value must have an integral type.
The value retrieved from that address is pushed,
and has the \generictype{}.
In the \DWOPderefsizeNAME{} operation, however, the size in bytes
of the data retrieved from the dereferenced address is
specified by the single operand. This operand is a 1-byte
unsigned integral constant whose value may not be larger
than the size of the \generictype. The data
retrieved is zero extended to the size of an address on the
target machine before being pushed onto the expression stack.

\itembfnl{\DWOPdereftypeTARG}
The \DWOPdereftypeNAME{} operation behaves like the \DWOPderefsize{} operation:
it pops the top stack entry and treats it as an address. 
The popped value must have an integral type.
The value retrieved from that address is pushed together with a type identifier. 
In the \DWOPdereftypeNAME{} operation, the size in
bytes of the data retrieved from the dereferenced address is specified by
the first operand. This operand is a 1-byte unsigned integral constant whose
value which is the same as the size of the base type referenced
by the second operand.
The second operand is an unsigned LEB128 integer that
represents the offset of a debugging information entry in the current
compilation unit, which must be a \DWTAGbasetype{} entry that provides the
type of the data pushed.

\textit{While the size of the pushed value could be inferred from the base 
type definition, it is encoded explicitly into the operation so that the
operation can be parsed easily without reference to the \dotdebuginfo{}
section.}

\needlines{7}
\itembfnl{\DWOPxderefTARG}
The \DWOPxderefNAME{} operation provides an extended dereference
mechanism. The entry at the top of the stack is treated as an
address. The second stack entry is treated as an \doublequote{address
space identifier} for those architectures that support
\addtoindexi{multiple}{address space!multiple}
address spaces. 
Both of these entries must have integral type identifiers.
The top two stack elements are popped,
and a data item is retrieved through an implementation-defined
address calculation and pushed as the new stack top together with the
\generictype{} identifier.
The size of the data retrieved from the 
\addtoindexi{dereferenced}{address!dereference operator}
address is the size of the \generictype.

\needlines{4}
\itembfnl{\DWOPxderefsizeTARG}
The \DWOPxderefsizeNAME{} operation behaves like the
\DWOPxderef{} operation. The entry at the top of the stack is
treated as an address. The second stack entry is treated as
an \doublequote{address space identifier} for those architectures
that support 
\addtoindexi{multiple}{address space!multiple}
address spaces. 
Both of these entries must have integral type identifiers.
The top two stack
elements are popped, and a data item is retrieved through an
implementation\dash defined address calculation and pushed as the
new stack top. In the \DWOPxderefsizeNAME{} operation, however,
the size in bytes of the data retrieved from the 
\addtoindexi{dereferenced}{address!dereference operator}
address is specified by the single operand. This operand is a
1-byte unsigned integral constant whose value may not be larger
than the \addtoindex{size of an address} on the target machine. The data
retrieved is zero extended to the \addtoindex{size of an address} on the
target machine before being pushed onto the expression stack together
with the \generictype{} identifier.

\itembfnl{\DWOPxdereftypeTARG}
The \DWOPxdereftypeNAME{} operation behaves like the \DWOPxderefsize{}
operation: it pops the top two stack entries, treats them as an address and
an address space identifier, and pushes the value retrieved. In the
\DWOPxdereftypeNAME{} operation, the size in bytes of the data retrieved from
the dereferenced address is specified by the first operand. This operand is
a 1-byte unsigned integral constant whose value 
value which is the same as the size of the base type referenced
by the second operand. The second
operand is an unsigned LEB128 integer that represents the offset of a
debugging information entry in the current compilation unit, which must be a
\DWTAGbasetype{} entry that provides the type of the data pushed.

\needlines{6}
\itembfnl{\DWOPpushobjectaddressTARG}
The \DWOPpushobjectaddressNAME{}
operation pushes the address
of the object currently being evaluated as part of evaluation
of a user presented expression. This object may correspond
to an independent variable described by its own debugging
information entry or it may be a component of an array,
structure, or class whose address has been dynamically
determined by an earlier step during user expression
evaluation.

\textit{This operator provides explicit functionality
(especially for arrays involving descriptors) that is analogous
to the implicit push of the base 
\addtoindexi{address}{address!implicit push of base}
of a structure prior to evaluation of a 
\DWATdatamemberlocation{} 
to access a data member of a structure. For an example, see 
Appendix \refersec{app:aggregateexamples}.}

\needlines{4}
\itembfnl{\DWOPformtlsaddressTARG}
The \DWOPformtlsaddressNAME{} 
operation pops a value from the stack, which must have an 
integral type identifier, translates this
value into an address in the 
\addtoindex{thread-local storage}
for a thread, and pushes the address 
onto the stack together with the \generictype{} identifier. 
The meaning of the value on the top of the stack prior to this 
operation is defined by the run-time environment.  If the run-time 
environment supports multiple thread-local storage 
\nolink{blocks} for a single thread, then the \nolink{block} 
corresponding to the executable or shared 
library containing this DWARF expression is used.
   
\textit{Some implementations of 
\addtoindex{C}, \addtoindex{C++}, \addtoindex{Fortran}, and other 
languages, support a 
thread-local storage class. Variables with this storage class
have distinct values and addresses in distinct threads, much
as automatic variables have distinct values and addresses in
each function invocation. Typically, there is a single \nolink{block}
of storage containing all thread\dash local variables declared in
the main executable, and a separate \nolink{block} for the variables
declared in each shared library. Each 
thread\dash local variable can then be accessed in its block using an
identifier. This identifier is typically an offset into the block and 
pushed onto the DWARF stack by one of the 
\DWOPconstnx{} operations prior to the
\DWOPformtlsaddress{} operation. 
Computing the address of
the appropriate \nolink{block} can be complex (in some cases, the
compiler emits a function call to do it), and difficult
to describe using ordinary DWARF location descriptions.
Instead of    forcing complex thread-local storage calculations into 
the DWARF expressions, the \DWOPformtlsaddress{} allows the consumer 
to perform the computation based on the run-time environment.}

\needlines{6}
\itembfnl{\DWOPcallframecfaTARG}
The \DWOPcallframecfaNAME{} 
operation pushes the value of the
CFA, obtained from the Call Frame Information 
(see Section \refersec{chap:callframeinformation}).

\textit{Although the value of \DWATframebase{}
can be computed using other DWARF expression operators,
in some cases this would require an extensive location list
because the values of the registers used in computing the
CFA change during a subroutine. If the 
Call Frame Information 
is present, then it already encodes such changes, and it is
space efficient to reference that.}
\end{enumerate}

\textit{Examples illustrating many of these stack operations are
found in Appendix \refersec{app:dwarfstackoperationexamples}.}

\needlines{4}
\subsubsection{Arithmetic and Logical Operations} 
\addtoindexx{DWARF expression!arithmetic operations}
\addtoindexx{DWARF expression!logical operations}
The following provide arithmetic and logical operations. 
Operands of an operation with two operands
must have the same type,
either the same base type or the \generictype.
The result of the operation which is pushed back has the same type
as the type of the operand(s).  

If the type of the operands is the \generictype, 
except as otherwise specified, the arithmetic operations
perform addressing arithmetic, that is, unsigned arithmetic that is performed
modulo one plus the largest representable address. 

Operations other than \DWOPabs{},
\DWOPdiv{}, \DWOPminus{}, \DWOPmul{}, \DWOPneg{} and \DWOPplus{} 
require integral types of the operand (either integral base type 
or the \generictype).  Operations do not cause an exception 
on overflow.

\needlines{4}
\begin{enumerate}[1. ]
\itembfnl{\DWOPabsTARG}
The \DWOPabsNAME{} operation pops the top stack entry, interprets
it as a signed value and pushes its absolute value. If the
absolute value cannot be represented, the result is undefined.

\needlines{4}
\itembfnl{\DWOPandTARG}
The \DWOPandNAME{} operation pops the top two stack values, performs
a bitwise and operation on the two, and pushes the result.

\itembfnl{\DWOPdivTARG}
The \DWOPdivNAME{} operation pops the top two stack values, divides the former second entry by
the former top of the stack using signed division, and pushes the result.

\itembfnl{\DWOPminusTARG}
The \DWOPminusNAME{} operation pops the top two stack values, subtracts the former top of the
stack from the former second entry, and pushes the result.

\itembfnl{\DWOPmodTARG}
The \DWOPmodNAME{} operation pops the top two stack values and pushes the result of the
calculation: former second stack entry modulo the former top of the stack.

\needlines{4}
\itembfnl{\DWOPmulTARG}
The \DWOPmulNAME{} operation pops the top two stack entries, multiplies them together, and
pushes the result.

\needlines{4}
\itembfnl{\DWOPnegTARG}
The \DWOPnegNAME{} operation pops the top stack entry, interprets
it as a signed value and pushes its negation. If the negation
cannot be represented, the result is undefined.

\itembfnl{\DWOPnotTARG}
The \DWOPnotNAME{} operation pops the top stack entry, and pushes
its bitwise complement.

\itembfnl{\DWOPorTARG}
The \DWOPorNAME{} operation pops the top two stack entries, performs
a bitwise or operation on the two, and pushes the result.

\itembfnl{\DWOPplusTARG}
The \DWOPplusNAME{} operation pops the top two stack entries,
adds them together, and pushes the result.

\needlines{6}
\itembfnl{\DWOPplusuconstTARG}
The \DWOPplusuconstNAME{} operation pops the top stack entry,
adds it to the unsigned LEB128\addtoindexx{LEB128!unsigned}
constant operand 
interpreted as the same type as the operand popped from the 
top of the stack and pushes the result.

\textit{This operation is supplied specifically to be
able to encode more field offsets in two bytes than can be
done with
\doublequote{\DWOPlitn~\DWOPplus.}}

\needlines{3}
\itembfnl{\DWOPshlTARG}
The \DWOPshlNAME{} operation pops the top two stack entries,
shifts the former second entry left (filling with zero bits)
by the number of bits specified by the former top of the stack,
and pushes the result.

\itembfnl{\DWOPshrTARG}
The \DWOPshrNAME{} operation pops the top two stack entries,
shifts the former second entry right logically (filling with
zero bits) by the number of bits specified by the former top
of the stack, and pushes the result.

\needlines{3}
\itembfnl{\DWOPshraTARG}
The \DWOPshraNAME{} operation pops the top two stack entries,
shifts the former second entry right arithmetically (divide
the magnitude by 2, keep the same sign for the result) by
the number of bits specified by the former top of the stack,
and pushes the result.

\itembfnl{\DWOPxorTARG}
The \DWOPxorNAME{} operation pops the top two stack entries,
performs a bitwise exclusive\dash or operation on the two, and
pushes the result.

\end{enumerate}

\subsubsection{Control Flow Operations}
\label{chap:controlflowoperations}
The 
\addtoindexx{DWARF expression!control flow operations}
following operations provide simple control of the flow of a DWARF expression.
\begin{enumerate}[1. ]
\itembfnl{\DWOPleTARG, \DWOPgeTARG, \DWOPeqTARG, \DWOPltTARG, \DWOPgtTARG, \DWOPneTARG}
The six relational operators each:
\begin{itemize}
\item pop the top two stack values, which have the same type,
either the same base type or the \generictype, 

\item compare the operands:
\linebreak
\textless~former second entry~\textgreater  \textless~relational operator~\textgreater \textless~former top entry~\textgreater

\item push the constant value 1 onto the stack 
if the result of the operation is true or the
constant value 0 if the result of the operation is false.
The pushed value has the \generictype.
\end{itemize}

If the operands have the \generictype, the comparisons  
are performed as signed operations.

\needlines{6}
\itembfnl{\DWOPskipTARG}
\DWOPskipNAME{} is an unconditional branch. Its single operand
is a 2-byte signed integer constant. The 2-byte constant is
the number of bytes of the DWARF expression to skip forward
or backward from the current operation, beginning after the
2-byte constant.

\itembfnl{\DWOPbraTARG}
\DWOPbraNAME{} is a conditional branch. Its single operand is a
2-byte signed integer constant.  This operation pops the
top of stack. If the value popped is not the constant 0,
the 2-byte constant operand is the number of bytes of the
DWARF expression to skip forward or backward from the current
operation, beginning after the 2-byte constant.

% The following item does not correctly hyphenate leading
% to an overfull hbox and a visible artifact. 
% So we use \- to suggest hyphenation in this rare situation.
\itembfnl{\DWOPcalltwoTARG, \DWOPcallfourTARG, \DWOPcallrefTARG}
\DWOPcalltwoNAME, 
\DWOPcallfourNAME, 
and \DWOPcallrefNAME{} perform
DWARF procedure calls during evaluation of a DWARF expression or
location description. 
For \DWOPcalltwoNAME{} and \DWOPcallfourNAME{}, 
the operand is the 2\dash~ or 4-byte unsigned offset, respectively,
of a debugging information entry in the current compilation
unit. The \DWOPcallrefNAME{} operator has a single operand. In the
\thirtytwobitdwarfformat,
the operand is a 4-byte unsigned value;
in the \sixtyfourbitdwarfformat, it is an 8-byte unsigned value
(see Section \referfol{datarep:32bitand64bitdwarfformats}). 
The operand is used as the offset of a
debugging information entry in a 
\dotdebuginfo{}
section which may be contained in an executable or shared object file
other than that containing the operator. For references from
one executable or shared object file to another, the relocation
must be performed by the consumer.  

\textit{Operand interpretation of
\DWOPcalltwo, \DWOPcallfour{} and \DWOPcallref{} is exactly like
that for \DWFORMreftwo, \DWFORMreffour{} and \DWFORMrefaddr,
respectively  
(see Section  \refersec{datarep:attributeencodings}).}

These operations transfer control of DWARF expression evaluation to 
\addtoindexx{location attribute}
the 
\DWATlocation{}
attribute of the referenced debugging information entry. If
there is no such attribute, then there is no effect. Execution
of the DWARF expression of 
\addtoindexx{location attribute}
a 
\DWATlocation{} attribute may add
to and/or remove from values on the stack. Execution returns
to the point following the call when the end of the attribute
is reached. Values on the stack at the time of the call may be
used as parameters by the called expression and values left on
the stack by the called expression may be used as return values
by prior agreement between the calling and called expressions.
\end{enumerate}

\subsubsection{Type Conversions}
\label{chap:typeconversions}
The following operations provides for explicit type conversion.

\begin{enumerate}[1. ]
\itembfnl{\DWOPconvertTARG}
The \DWOPconvertNAME{} operation pops the top stack entry, converts it to a
different type, then pushes the result. It takes one operand, which is an
unsigned LEB128 integer that represents the offset of a debugging
information entry in the current compilation unit, or value 0 which
represents the \generictype. If the operand is non-zero, the
referenced entry must be a \DWTAGbasetype{} entry that provides the type
to which the value is converted.

\itembfnl{\DWOPreinterpretTARG}
The \DWOPreinterpretNAME{} operation pops the top stack entry, reinterprets
the bits in its value as a value of a different type, then pushes the
result. It takes one operand, which is an unsigned LEB128 integer that
represents the offset of a debugging information entry in the current
compilation unit, or value 0 which represents the \generictype.
If the operand is non-zero, the referenced entry must be a
\DWTAGbasetype{} entry that provides the type to which the value is converted.
The type of the operand and result type must have the same size in bits.

\end{enumerate}

\needlines{7}
\subsubsection{Special Operations}
\label{chap:specialoperations}
There 
\addtoindexx{DWARF expression!special operations}
are these special operations currently defined:
\begin{enumerate}[1. ]
\itembfnl{\DWOPnopTARG}
The \DWOPnopNAME{} operation is a place holder. It has no effect
on the location stack or any of its values.

\itembfnl{\DWOPentryvalueTARG}
The \DWOPentryvalueNAME{} operation pushes 
the value that the described location held
upon entering the current subprogram.  It has two operands: an 
unsigned LEB128\addtoindexx{LEB128!unsigned} length, followed by 
a block containing a DWARF expression or a register location description 
(see Section \refersec{chap:registerlocationdescriptions}).  
The length operand specifies the length
in bytes of the block.  If the block contains a register location
description, \DWOPentryvalueNAME{} pushes the value that register had upon
entering the current subprogram.  If the block contains a DWARF expression,
the DWARF expression is evaluated as if it has been evaluated upon entering
the current subprogram.  The DWARF expression 
assumes no values are present on the DWARF stack initially and results
in exactly one value being pushed on the DWARF stack when completed.

\DWOPpushobjectaddress{} is not meaningful inside of this DWARF operation.

\textit{The values needed to evaluate \DWOPentryvalueNAME{} could be obtained in
several ways. The consumer could suspend execution on entry to the
subprogram, record values needed by \DWOPentryvalueNAME{} expressions within
the subprogram, and then continue; when evaluating \DWOPentryvalueNAME{},
the consumer would use these recorded values rather than the current
values.  Or, when evaluating \DWOPentryvalueNAME{}, the consumer could
virtually unwind using the Call Frame Information 
(see Section \refersec{chap:callframeinformation}) 
to recover register values that might have been clobbered since the
subprogram entry point.}

\end{enumerate}

\needlines{8}
\section{Location Descriptions}
\label{chap:locationdescriptions}
\textit{Debugging information 
\addtoindexx{location description}
must 
\addtoindexx{location description|see{\textit{also} DWARF expression}}
provide consumers a way to find
the location of program variables, determine the bounds
of dynamic arrays and strings, and possibly to find the
base address of a subroutine\textquoteright s stack frame or the return
address of a subroutine. Furthermore, to meet the needs of
recent computer architectures and optimization techniques,
debugging information must be able to describe the location of
an object whose location changes over the object\textquoteright s lifetime.}

Information about the location of program objects is provided
by location descriptions. Location descriptions can be either
of two forms:
\begin{enumerate}[1. ]
\item \textit{Single location descriptions}, 
which 
\addtoindexx{location description!single}
are 
\addtoindexx{single location description}
a language independent representation of
addressing rules of arbitrary complexity built from 
DWARF expressions (See Section \refersec{chap:dwarfexpressions}) 
and/or other
DWARF operations specific to describing locations. They are
sufficient for describing the location of any object as long
as its lifetime is either static or the same as the 
\livelink{chap:lexicalblock}{lexical block} that owns it, 
and it does not move during its lifetime.


\needlines{4}
\item \textit{Location lists}, which are used to 
\addtoindexx{location list}
describe
\addtoindexx{location description!use in location list}
objects that have a limited lifetime or change their location
during their lifetime. Location lists are described in
Section \refersec{chap:locationlists} below.

\end{enumerate}

Location descriptions are distinguished in a context sensitive
manner. As the value of an attribute, a location description
is encoded using class \CLASSexprloc{}
and a \addtoindex{location list} is encoded
using class \CLASSloclist{} (which serves as an 
index into a separate section containing location lists).

\needlines{8}
\subsection{Single Location Descriptions}
\label{chap:singlelocationdescriptions}
A single location description is either:
\begin{enumerate}[1. ]
\item A simple location description, representing an object
\addtoindexx{location description!simple}
which 
\addtoindexx{simple location description}
exists in one contiguous piece at the given location, or 
\item A composite location description consisting of one or more
\addtoindexx{location description!composite}
simple location descriptions, each of which is followed by
one composition operation. Each simple location description
describes the location of one piece of the object; each
composition operation describes which part of the object is
located there. Each simple location description that is a
DWARF expression is evaluated independently of any others.
\end{enumerate}



\subsubsection{Simple Location Descriptions}
A 
\addtoindexx{location description!simple}
simple location description consists of one 
contiguous piece or all of an object or value.

\needlines{4}
\subsubsubsection{Empty Location Descriptions}
An \addtoindex{empty location description}
consists of a DWARF expression
\addtoindexx{location description!empty}
containing no operations. It represents a piece or all of an
object that is present in the source but not in the object code
(perhaps due to optimization).

\subsubsubsection{Memory Location Descriptions}
A 
\addtoindexx{location description!memory}
memory location description 
\addtoindexx{memory location description}
consists of a non-empty DWARF
expression (see 
Section \refersec{chap:dwarfexpressions}), 
whose value is the address of
a piece or all of an object or other entity in memory.

\subsubsubsection{Register Location Descriptions}
\label{chap:registerlocationdescriptions}
A register location description consists of a register name
operation, which represents a piece or all of an object
located in a given register.

\textit{Register location descriptions describe an object
(or a piece of an object) that resides in a register, while
the opcodes listed in 
Section \refersec{chap:registervalues}
are used to describe an object (or a piece of
an object) that is located in memory at an address that is
contained in a register (possibly offset by some constant). A
register location description must stand alone as the entire
description of an object or a piece of an object.
}

\needlines{4}
The following DWARF operations can be used to 
specify a register location.

\textit{Note that the register number represents a DWARF specific
mapping of numbers onto the actual registers of a given
architecture. The mapping should be chosen to gain optimal
density and should be shared by all users of a given
architecture. It is recommended that this mapping be defined
by the ABI authoring committee for each architecture.
}
\begin{enumerate}[1. ]
\itembfnl{\DWOPregzeroTARG, \DWOPregoneTARG, ..., \DWOPregthirtyoneTARG}
The \DWOPregnTARG{} operations encode the names of up to 32
registers, numbered from 0 through 31, inclusive. The object
addressed is in register \textit{n}.

\needlines{4}
\itembfnl{\DWOPregxTARG}
The \DWOPregxNAME{} operation has a single 
unsigned LEB128\addtoindexx{LEB128!unsigned} literal
operand that encodes the name of a register.  

\end{enumerate}

\textit{These operations name a register location. To
fetch the contents of a register, it is necessary to use
one of the register based addressing operations, such as
\DWOPbregx{} 
(Section \refersec{chap:registervalues})}.

\subsubsubsection{Implicit Location Descriptions}
An \addtoindex{implicit location description}
represents a piece or all
\addtoindexx{location description!implicit}
of an object which has no actual location but whose contents
are nonetheless either known or known to be undefined.

The following DWARF operations may be used to specify a value
that has no location in the program but is a known constant
or is computed from other locations and values in the program.
\begin{enumerate}[1. ]
\itembfnl{\DWOPimplicitvalueTARG}
The \DWOPimplicitvalueNAME{} operation specifies an immediate value
using two operands: an unsigned LEB128\addtoindexx{LEB128!unsigned}
length, followed by a 
sequence of bytes of the given length that contain the value.

\itembfnl{\DWOPstackvalueTARG}
The \DWOPstackvalueNAME{} 
operation specifies that the object
does not exist in memory but its value is nonetheless known
and is at the top of the DWARF expression stack. In this form
of location description, the DWARF expression represents the
actual value of the object, rather than its location. The
\DWOPstackvalueNAME{} operation terminates the expression.

\needlines{4}
\itembfnl{\DWOPimplicitpointerTARG}
\textit{An optimizing compiler may eliminate a pointer, while
still retaining the value that the pointer addressed.  
\DWOPimplicitpointerNAME{} allows a producer to describe this value.}

The \DWOPimplicitpointerNAME{} operation specifies that the object
is a pointer that cannot be represented as a real pointer,
even though the value it would point to can be described. In
this form of location description, the DWARF expression refers
to a debugging information entry that represents the actual
value of the object to which the pointer would point. Thus, a
consumer of the debug information would be able to show the
value of the dereferenced pointer, even when it cannot show
the value of the pointer itself.

\needlines{5}
The \DWOPimplicitpointerNAME{} operation has two operands: a 
reference to a debugging information entry that describes 
the dereferenced object's value, and a signed number that 
is treated as a byte offset from the start of that value. 
The first operand is a 4-byte unsigned value in the 32-bit 
DWARF format, or an 8-byte unsigned value in the 64-bit 
DWARF format (see Section 
\refersec{datarep:32bitand64bitdwarfformats}).
The second operand is a 
signed LEB128\addtoindexx{LEB128!signed} number.

The first operand is used as the offset of a debugging
information entry in a \dotdebuginfo{} section, which may be
contained in an executable or shared object file other than that
containing the operator. For references from one executable or
shared object file to another, the relocation must be performed 
by the consumer.

\textit{The debugging information entry referenced by a 
\DWOPimplicitpointerNAME{} operation is typically a
\DWTAGvariable{} or \DWTAGformalparameter{} entry whose
\DWATlocation{} attribute gives a second DWARF expression or a
location list that describes the value of the object, but the
referenced entry may be any entry that contains a \DWATlocation{}
or \DWATconstvalue{} attribute (for example, \DWTAGdwarfprocedure).
By using the second DWARF expression, a consumer can
reconstruct the value of the object when asked to dereference
the pointer described by the original DWARF expression
containing the \DWOPimplicitpointer{} operation.}

\end{enumerate}

\textit{DWARF location descriptions 
are intended to yield the \textbf{location}
of a value rather than the value itself. An optimizing compiler
may perform a number of code transformations where it becomes
impossible to give a location for a value, but it remains possible
to describe the value itself. 
Section \refersec{chap:registerlocationdescriptions}
describes operators that can be used to
describe the location of a value when that value exists in a
register but not in memory. The operations in this section are
used to describe values that exist neither in memory nor in a
single register.}
 

\needlines{6}
\subsubsection{Composite Location Descriptions}
A composite location description describes an object or
value which may be contained in part of a register or stored
in more than one location. Each piece is described by a
composition operation, which does not compute a value nor
store any result on the DWARF stack. There may be one or
more composition operations in a single composite location
description. A series of such operations describes the parts
of a value in memory address order.

Each composition operation is immediately preceded by a simple
location description which describes the location where part
of the resultant value is contained.
\begin{enumerate}[1. ]
\itembfnl{\DWOPpieceTARG}
The \DWOPpieceNAME{} operation takes a 
single operand, which is an
unsigned LEB128\addtoindexx{LEB128!unsigned} number.  
The number describes the size in bytes
of the piece of the object referenced by the preceding simple
location description. If the piece is located in a register,
but does not occupy the entire register, the placement of
the piece within that register is defined by the ABI.

\textit{Many compilers store a single variable in sets of registers,
or store a variable partially in memory and partially in
registers. \DWOPpieceNAME{} provides a way of describing how large
a part of a variable a particular DWARF location description
refers to.}

\needlines{4}
\itembfnl{\DWOPbitpieceTARG}
The \DWOPbitpieceNAME{} operation takes two operands. 
The first is an unsigned LEB128\addtoindexx{LEB128!unsigned} 
number that gives the size in bits
of the piece. The second is an 
unsigned LEB128\addtoindexx{LEB128!unsigned} number that
gives the offset in bits from the location defined by the
preceding DWARF location description.  

Interpretation of the offset depends on the location description. 
If the location description is empty, the offset 
doesn\textquoteright{}t matter and
the \DWOPbitpieceNAME{} operation describes a piece consisting
of the given number of bits whose values are undefined. If
the location is a register, the offset is from the least
significant bit end of the register. If the location is a
memory address, the \DWOPbitpieceNAME{} operation describes a
sequence of bits relative to the location whose address is
on the top of the DWARF stack using the bit numbering and
direction conventions that are appropriate to the current
language on the target system. If the location is any implicit
value or stack value, the \DWOPbitpieceNAME{} operation describes
a sequence of bits using the least significant bits of that
value.  
\end{enumerate}

\textit{\DWOPbitpieceNAME{} is 
used instead of \DWOPpieceNAME{} when
the piece to be assembled into a value or assigned to is not
byte-sized or is not at the start of a register or addressable
unit of memory.}

\needlines{6}
\subsection{Location Lists}
\label{chap:locationlists}
Location lists are used in place of location descriptions whenever
the object whose location is being described can change location
during its lifetime. Location lists are contained in a separate
object file section called \dotdebugloclists{} or \dotdebugloclistsdwo{}
(for split DWARF object files).

A location list is indicated by a location or other attribute
whose value is of class \CLASSloclist{} 
(see Section \refersec{datarep:classesandforms}).
   
\textit{This location list representation, the \CLASSloclist{} class, and the
related \DWATloclistsbase{} attribute are new in \DWARFVersionV.
Together they eliminate most or all of the object language relocations
previously needed for location lists.}

A location list consists of a series of location list entries.
Each location list entry is one of the following kinds:
\begin{itemize}
\item \definition{Bounded location description}.\addtoindexx{bounded location description} 
This kind of entry provides a
location description that specifies the location of
an object that is valid over a lifetime bounded
by a starting and ending address. The starting address is the
lowest address of the address range over which the location
is valid. The ending address is the address of the first
location past the highest address of the address range.
When the current PC is within the given range, the location
description may be used to locate the specified object.
        
There are several kinds of bounded location description
entries which differ in the way that they specify the
starting and ending addresses.
        
The address ranges defined by the bounded location descriptions
of a location list may overlap. When they do, they describe a
situation in which an object exists simultaneously in more than
one place. If all of the address ranges in a given location
list do not collectively cover the entire range over which the
object in question is defined, and there is no following default
location description, it is assumed that the object is not
available for the portion of the range that is not covered.

\item \definition{Default location description}.\addtoindexx{default location description}
This kind of entry provides a
location description that specifies the location of
an object that is valid when no bounded location description
applies.

\item \definition{Base address}.\addtoindexx{base address!of location list}
This kind of entry provides an address to be
used as the base address for beginning and ending address
offsets given in certain kinds of bounded location description.
The applicable base address of a bounded location description
entry is the address specified by the closest preceding base
address entry in the same location list. If there is no
preceding base address entry, then the applicable base address
defaults to the base address of the compilation unit (see
Section \refersec{chap:fullandpartialcompilationunitentries}).

In the case of a compilation unit where all of the machine
code is contained in a single contiguous section, no base
address entry is needed.

\item  \definition{End-of-list}.\addtoindexx{end-of-list!of location list}
This kind of entry marks the end of the location list.

\end{itemize}

A location list consists of a sequence of zero or more bounded
location description or base address entries, optionally followed
by a default location entry, and terminated by an end-of-list
entry.

Each location list entry begins with a single byte identifying
the kind of that entry, followed by zero or more operands depending
on the kind.   
   
In the descriptions that follow, these terms are used for operands:
   
\begin{itemize}
\item A \definitionx{counted location description} operand consists 
of a two-byte unsigned integer giving the length of the location
description (see Section \refersec{chap:singlelocationdescriptions}) 
that immediately follows.

\needlines{4}
\item An \definitionx{address index} operand is the index of an address
in the \dotdebugaddr{} section. This index is relative to the
value of the \DWATaddrbase{} attribute of the associated
compilation unit. The address given by this kind
of operand is not relative to the compilation unit base address.
   
\item A \definition{target address} operand is an address on the target
machine. (Its size is the same as used for attribute values of
class \CLASSaddress, specifically, \DWFORMaddr.)

\end{itemize}
 
The following entry kinds are defined for use in both
split or non-split units:
   
\begin{enumerate}[1. ]
\itembfnl{\DWLLEendoflistTARG}
An end-of-list entry contains no further data.
       
\textit{A series of this kind of entry may be used for padding or
alignment purposes.}

\itembfnl{\DWLLEbaseaddressxTARG}
This is a form of base address entry that has one unsigned
LEB128 operand. The operand value is an address index (into the 
\dotdebugaddr{} section) that indicates the applicable base address 
used by subsequent \DWLLEoffsetpair{} entries.

\itembfnl{\DWLLEstartxendxTARG}
This is a form of bounded location description entry that
has two unsigned LEB128 operands. The operand values are
address indices (into the \dotdebugaddr{} section). These indicate the
starting and ending addresses, respectively, that define
the address range for which this location is valid.
These operands are followed by a counted location description.

\itembfnl{\DWLLEstartxlengthTARG}
This is a form of bounded location description that has two
unsigned ULEB operands. The first value is an address index 
(into the \dotdebugaddr{} section)
that indicates the beginning of the address range over
which the location is valid.
The second value is the length of the range.
These operands are followed by a counted location description.

\itembfnl{\DWLLEoffsetpairTARG}
This is a form of bounded location description entry that
has two unsigned LEB128 operands. The values of these
operands are the starting and ending offsets, respectively,
relative to the applicable base address, that define the
address range for which this location is valid.
These operands are followed by a counted location description.
       
\itembfnl{\DWLLEdefaultlocationTARG}
The operand is a counted location description which defines 
where an object is located if no prior location description 
is valid.

\end{enumerate}
      
The following kinds of location list entries are defined for
use only in non-split DWARF units:
   
\begin{enumerate}[1. ]
\addtocounter{enumi}{6}
\itembfnl{\DWLLEbaseaddressTARG}
A base address entry has one target address operand.
This address is used as the base address when interpreting
offsets in subsequent location list entries of kind
\DWLLEoffsetpair.

\itembfnl{\DWLLEstartendTARG}
This is a form of bounded location description entry that
has two target address operands. These indicate the
starting and ending addresses, respectively, that define
the address range for which the location is valid.
These operands are followed by a counted location description.
       
\itembfnl{\DWLLEstartlengthTARG}
This is a form of bounded location description entry that
has one target address operand value and an unsigned LEB128
integer operand value. The address is the beginning address
of the range over which the location description is valid, and
the length is the number of bytes in that range.
These operands are followed by a counted location description.

\end{enumerate}

\needlines{10}
\section{Types of Program Entities}
\label{chap:typesofprogramentities}
\hypertarget{chap:DWATtypetypeofdeclaration}{}
Any debugging information entry describing a declaration that
has a type has 
\addtoindexx{type attribute}
a \DWATtypeDEFN{} attribute, whose value is a
reference to another debugging information entry. The entry
referenced may describe a base type, that is, a type that is
not defined in terms of other data types, or it may describe a
user-defined type, such as an array, structure or enumeration.
Alternatively, the entry referenced may describe a type
modifier, such as constant, packed, pointer, reference or
volatile, which in turn will reference another entry describing
a type or type modifier (using a
\DWATtypeNAME{} attribute\addtoindexx{type attribute} of its
own). See Chapter \referfol{chap:typeentries} 
for descriptions of the entries describing
base types, user-defined types and type modifiers.


\needlines{6}
\section{Accessibility of Declarations}
\label{chap:accessibilityofdeclarations}
\textit{Some languages, notably \addtoindex{C++} and 
\addtoindex{Ada}, have the concept of
the accessibility of an object or of some other program
entity. The accessibility specifies which classes of other
program objects are permitted access to the object in question.}

The accessibility of a declaration 
is\hypertarget{chap:DWATaccessibilityattribute}{}
represented by a 
\DWATaccessibilityDEFN{}\addtoindexx{accessibility attribute} 
attribute, whose value is a constant drawn from the set of codes 
listed in Table \refersec{tab:accessibilitycodes}.

\begin{simplenametable}[1.9in]{Accessibility codes}{tab:accessibilitycodes}
\DWACCESSpublicTARG{}          \\
\DWACCESSprivateTARG{}        \\
\DWACCESSprotectedTARG{}    \\
\end{simplenametable}

\needlines{5}
\section{Visibility of Declarations}
\label{chap:visibilityofdeclarations}

\textit{Several languages (such as \addtoindex{Modula-2}) 
have the concept of the visibility of a declaration. The
visibility specifies which declarations are to be 
visible outside of the entity in which they are
declared.}

The\hypertarget{chap:DWATvisibilityvisibilityofdeclaration}{}
visibility of a declaration is represented 
by a \DWATvisibilityDEFN{}
attribute\addtoindexx{visibility attribute}, whose value is a
constant drawn from the set of codes listed in 
Table \refersec{tab:visibilitycodes}.

\begin{simplenametable}[1.5in]{Visibility codes}{tab:visibilitycodes}
\DWVISlocalTARG{}          \\
\DWVISexportedTARG{}    \\
\DWVISqualifiedTARG{}  \\
\end{simplenametable}

\needlines{8}
\section{Virtuality of Declarations}
\label{chap:virtualityofdeclarations}
\textit{\addtoindex{C++} provides for virtual and pure virtual structure or class
member functions and for virtual base classes.}

The\hypertarget{chap:DWATvirtualityvirtualityindication}{}
virtuality of a declaration is represented by a
\DWATvirtualityDEFN{}
attribute\addtoindexx{virtuality attribute}, whose value is a constant drawn
from the set of codes listed in 
Table \refersec{tab:virtualitycodes}.

\begin{simplenametable}[2.5in]{Virtuality codes}{tab:virtualitycodes}
\DWVIRTUALITYnoneTARG{}                      \\
\DWVIRTUALITYvirtualTARG{}                \\
\DWVIRTUALITYpurevirtualTARG{}    \\
\end{simplenametable}

\needlines{8}
\section{Artificial Entries}
\label{chap:artificialentries}
\textit{A compiler may wish to generate debugging information entries
for objects or types that were not actually declared in the
source of the application. An example is a formal parameter
entry to represent the hidden 
\texttt{this} parameter\index{this parameter@\texttt{this} parameter}
that most \addtoindex{C++} implementations pass as the first argument 
to non-static member functions.}  

Any debugging information entry representing the
\addtoindexx{artificial attribute}
declaration of an object or type artificially generated by
a compiler and not explicitly declared by the source 
program\hypertarget{chap:DWATartificialobjectsortypesthat}{}
may have a 
\DWATartificialDEFN{} attribute, 
which is a \livelink{chap:classflag}{flag}.

\needlines{6}
\section{Segmented Addresses}
\label{chap:segmentedaddresses}
\textit{In some systems, addresses are specified as offsets within a
given 
\addtoindexx{address space!segmented}
segment 
\addtoindexx{segmented addressing|see{address space}}
rather than as locations within a single flat
\addtoindexx{address space!flat}
address space.}

Any debugging information entry that contains a description
of\hypertarget{chap:DWATsegmentaddressinginformation}{}
the location of an object or subroutine may have a 
\DWATsegmentDEFN{} attribute, 
\addtoindexx{segment attribute}
whose value is a location
description. The description evaluates to the segment selector
of the item being described. If the entry containing the
\DWATsegmentNAME{} attribute has a 
\DWATlowpc, 
\DWAThighpc,
\DWATranges{} or 
\DWATentrypc{} attribute, 
\addtoindexx{entry PC attribute}
or 
a location
description that evaluates to an address, then those address
values represent the offset portion of the address within
the segment specified 
\addtoindexx{segment attribute}
by \DWATsegmentNAME.

If an entry has no 
\DWATsegmentNAME{} attribute, it inherits
\addtoindexx{segment attribute}
the segment value from its parent entry.  If none of the
entries in the chain of parents for this entry back to
its containing compilation unit entry have 
\DWATsegmentNAME{} attributes, 
then the entry is assumed to exist within a flat
address space. 
Similarly, if the entry has a 
\DWATsegmentNAME{} attribute 
\addtoindexx{segment attribute}
containing an empty location description, that
entry is assumed to exist within a 
\addtoindexi{flat}{address space!flat}
address space.

\textit{Some systems support different 
classes of addresses\addtoindexx{address class}. 
The address class may affect the way a pointer is dereferenced
or the way a subroutine is called.}


Any debugging information entry representing a pointer or
reference type or a subroutine or subroutine type may 
have a 
\DWATaddressclass{}
attribute, whose value is an integer
constant.  The set of permissible values is specific to
each target architecture. The value \DWADDRnoneTARG, 
however,
is common to all encodings, and means that no address class
has been specified.

\needlines{4}
\textit {For example, the Intel386 \texttrademark\  processor might use the following values:}

\begin{table}[ht]
\caption{Example address class codes}
\label{tab:inteladdressclasstable}
\centering
\begin{tabular}{l|c|l}
\hline
Name&Value&Meaning  \\
\hline
\textit{DW\_ADDR\_none}&   0 & \textit{no class specified} \\
\textit{DW\_ADDR\_near16}& 1 & \textit{16-bit offset, no segment} \\
\textit{DW\_ADDR\_far16}&  2 & \textit{16-bit offset, 16-bit segment} \\
\textit{DW\_ADDR\_huge16}& 3 & \textit{16-bit offset, 16-bit segment} \\
\textit{DW\_ADDR\_near32}& 4 & \textit{32-bit offset, no segment} \\
\textit{DW\_ADDR\_far32}&  5 & \textit{32-bit offset, 16-bit segment} \\
\hline
\end{tabular}
\end{table}

\needlines{6}
\section{Non-Defining Declarations and Completions}
\label{chap:nondefiningdeclarationsandcompletions}
A debugging information entry representing a program entity
typically represents the defining declaration of that
entity. In certain contexts, however, a debugger might need
information about a declaration of an entity that is not
\addtoindexx{incomplete declaration}
also a definition, or is otherwise incomplete, to evaluate
an\hypertarget{chap:DWATdeclarationincompletenondefiningorseparateentitydeclaration}{}
expression correctly.

\needlines{10}
\textit{As an example, consider the following fragment of \addtoindex{C} code:}

\begin{nlnlisting}
void myfunc()
{
  int x;
  {
    extern float x;
    g(x);
  }
}
\end{nlnlisting}


\textit{\addtoindex{C} scoping rules require that the 
value of the variable \texttt{x} passed to the function 
\texttt{g} is the value of the global \texttt{float} 
variable \texttt{x} rather than of the local \texttt{int} 
variable \texttt{x}.}

\subsection{Non-Defining Declarations}
A debugging information entry that 
represents a non-defining 
\addtoindexx{non-defining declaration}
or otherwise 
\addtoindex{incomplete declaration}
of a program entity has a
\addtoindexx{declaration attribute}
\DWATdeclarationDEFN{} attribute, which is a 
\livelink{chap:classflag}{flag}.

\textit{A non-defining type declaration may nonetheless have 
children as illustrated in Section
\refersec{app:declarationscompletingnondefiningdeclarations}.}


\subsection{Declarations Completing Non-Defining Declarations}
\hypertarget{chap:DWATspecificationincompletenondefiningorseparatedeclaration}{}
A debugging information entry that represents a declaration
that completes another (earlier) non-defining declaration may have a 
\DWATspecificationDEFN{}
attribute whose value is a \livelink{chap:classreference}{reference} to
the debugging information entry representing the non-defining declaration. 
A debugging information entry with a 
\DWATspecificationNAME{} 
attribute does not need to duplicate information provided by the 
debugging information entry referenced by that specification attribute.

When the non-defining declaration is contained within a type that has
been placed in a separate type unit (see Section \refersec{chap:typeunitentries}), 
the \DWATspecification{} attribute cannot refer directly to the entry in
the type unit. Instead, the current compilation unit may contain a
\doublequote{skeleton} declaration of the type, which contains only the relevant
declaration and its ancestors as necessary to provide the context
(including containing types and namespaces). The \DWATspecification{}
attribute would then be a reference to the declaration entry within
the skeleton declaration tree. The debugging information entry for the
top-level type in the skeleton tree may contain a \DWATsignature{}
attribute whose value is the type signature 
(see Section \refersec{datarep:typesignaturecomputation}).

\needlines{4}
Not all attributes of the debugging information entry referenced by a
\DWATspecification{} attribute 
apply to the referring debugging information entry.
For\addtoindexx{declaration attribute}
example,
\DWATsibling{} and 
\DWATdeclaration{} 
\addtoindexx{declaration attribute}
cannot apply to a 
\addtoindexx{declaration attribute}
referring
\addtoindexx{sibling attribute}
entry.


\section{Declaration Coordinates}
\label{chap:declarationcoordinates}
\livetargi{chap:declarationcoordinates}{}{declaration coordinates}
\textit{It is sometimes useful in a debugger to be able to associate
a declaration with its occurrence in the program source.}

Any debugging information entry representing 
the declaration of an object, module, subprogram or type may have
\DWATdeclfileDEFN,\hypertarget{chap:DWATdeclfilefilecontainingsourcedeclaration}{}
\addtoindexx{declaration file attribute} 
\DWATdecllineDEFN\hypertarget{chap:DWATdecllinelinenumberofsourcedeclaration}{}
\addtoindexx{declaration line attribute} and 
\DWATdeclcolumnDEFN\hypertarget{chap:DWATdeclcolumncolumnpositionofsourcedeclaration}{}
\addtoindexx{declaration column attribute}
attributes, each of whose value is an unsigned
\livelink{chap:classconstant}{integer constant}.

The value of 
\addtoindexx{declaration file attribute}
the 
\DWATdeclfile{}
attribute 
\addtoindexx{file containing declaration}
corresponds to
a file number from the line number information table for the
compilation unit containing the debugging information entry and
represents the source file in which the declaration appeared
(see Section \refersec{chap:linenumberinformation}). 
The value 0 indicates that no source file
has been specified.

The value of 
\addtoindexx{declaration line attribute}
the \DWATdeclline{} attribute represents
the source line number at which the first character of
the identifier of the declared object appears. The value 0
indicates that no source line has been specified.

The value of 
\addtoindexx{declaration column attribute}
the \DWATdeclcolumn{} attribute represents
the source column number at which the first character of
the identifier of the declared object appears. The value 0
indicates that no column has been specified.

\section{Identifier Names}
\label{chap:identifiernames}
Any\hypertarget{chap:DWATnamenameofdeclaration}{}
debugging information entry 
\addtoindexx{identifier names}
representing 
\addtoindexx{names!identifier}
a program entity that has been given a name may have a 
\DWATnameDEFN{} 
attribute\addtoindexx{name attribute}, whose value of 
class \CLASSstring{} represents the name.
A debugging information entry containing
no name attribute, or containing a name attribute whose value
consists of a name containing a single null byte, represents
a program entity for which no name was given in the source.

\textit{Because the names of program objects described by DWARF are 
the names as they appear in the source program, implementations
of language translators that use some form of mangled name
\addtoindexx{mangled names}
(as do many implementations of \addtoindex{C++}) should use the 
unmangled form of the name in the 
\DWATname{} attribute,
\addtoindexx{name attribute}
including the keyword operator (in names such as \doublequote{operator +}),
if present. See also 
Section \referfol{chap:linkagenames} regarding the use of 
\DWATlinkagename{} for 
\addtoindex{mangled names}.
Sequences of multiple whitespace characters may be compressed.}

\textit{For additional discussion, see the Best Practices section 
of the DWARF Wiki 
(\url{http://wiki.dwarfstd.org/index.php?title=Best_Practices}.)}

\section{Data Locations and DWARF Procedures}
\hypertarget{chap:DWATlocationdataobjectlocation}{}
Any debugging information entry describing a data object (which
includes variables and parameters) or 
\livelink{chap:commonblockentry}{common blocks}
may have a \DWATlocationDEFN{} attribute,
\addtoindexx{location attribute}
whose value is a location description
(see Section \refersec{chap:locationdescriptions}).

\needlines{4}
A \addtoindex{DWARF procedure} is represented by any
debugging information entry that has a
\DWATlocationNAME{} attribute.\addtoindexx{location attribute}
If a suitable entry is not otherwise available,
a DWARF procedure can be represented using a debugging
information entry \addtoindexx{DWARF procedure entry}
with the tag \DWTAGdwarfprocedureTARG{} together with a 
\DWATlocationNAME{} attribute.\addtoindexx{location attribute}  

A DWARF procedure is called by a \DWOPcalltwo, \DWOPcallfour{} 
or \DWOPcallref{} DWARF expression operator 
(see Section \refersec{chap:controlflowoperations}).

\needlines{5}
\section{Code Addresses, Ranges and Base Addresses}
\label{chap:codeaddressesandranges}
Any debugging information entry describing an entity that has
a machine code address or range of machine code addresses,
which includes compilation units, module initialization,
subroutines, lexical \nolink{blocks}, 
try/catch \nolink{blocks} (see Section \refersec{chap:tryandcatchblockentries}), 
labels and the like, may have
\begin{itemize}
\item \hypertarget{chap:DWATlowpccodeaddressorrangeofaddresses}{}
A \DWATlowpcDEFN{} attribute for a single address,

\item \hypertarget{chap:DWAThighpccontiguousrangeofcodeaddresses}{}
A \DWATlowpcDEFN{}\addtoindexx{low PC attribute}
and \DWAThighpcDEFN{}\addtoindexx{high PC attribute}
pair of attributes for a single contiguous range of
addresses, or

\item \hypertarget{chap:DWATrangesnoncontiguousrangeofcodeaddresses}{}
A \DWATrangesDEFN{} attribute\addtoindexx{ranges attribute}
for a non-contiguous range of addresses.
\end{itemize}

If an entity has no associated machine code, 
none of these attributes are specified.

%\needlines{4}
The \definitionx{base address} of the scope for any of the
debugging information entries listed above is given by either the 
\DWATlowpcNAME{}\livetargi{chap:DWATlowpcbaseaddressofscope}{}{base address of scope} 
attribute or the first address in the first range entry 
in the list of ranges given by the \DWATrangesNAME{} attribute.
If there is no such attribute, the base address is undefined.

\subsection{Single Address}
\label{chap:singleaddress} 
When there is a single address associated with an entity,
such as a label or alternate entry point of a subprogram,
the entry has a \DWATlowpc{} attribute whose value is the
address for the entity.

\needlines{8}
\subsection{Contiguous Address Range}
\label{chap:contiguousaddressranges}
When the set of addresses of a debugging information entry can
be described as a single contiguous range, the entry may
\addtoindexx{high PC attribute}
\addtoindexx{low PC attribute}
have a \DWATlowpc{} and \DWAThighpc{} pair of attributes. 
The value of the \DWATlowpc{} attribute is the address of the
first instruction associated with the entity. If the value of
the \DWAThighpc{} is of class address, it is the 
address of the first location past the last instruction
associated with the entity; if it is of class constant, the
value is an unsigned integer offset which when added to the
low PC gives the address of the first location past the last
instruction associated with the entity.

\textit{The high PC value
may be beyond the last valid instruction in the executable.}

\subsection{Non-Contiguous Address Ranges}
\label{chap:noncontiguousaddressranges}
Range lists are used when the set of addresses for a debugging
information entry cannot be described as a single contiguous 
range.\addtoindexx{non-contiguous address ranges}
Range lists are contained in a separate object file section
called \dotdebugrnglists{} or \dotdebugrnglistsdwo{} (in split units).
 
A range list is identified by a \DWATranges{}\addtoindexx{ranges attribute} 
or other attribute whose value is of class \CLASSrnglist{} 
(see Section \refersec{datarep:classesandforms}).
 
\textit{This range list representation, the \CLASSrnglist{} class, and the
related \DWATrnglistsbase{} attribute are new in \DWARFVersionV.
Together they eliminate most or all of the object language relocations
previously needed for range lists.}

Each range list entry is one of the following kinds:
\begin{itemize}
\item \definition{Bounded range}.\addtoindexx{bounded range} 
This kind of entry defines an address range
that is included in the range list. The starting address is
the lowest address of the address range. The ending address
is the address of the first location past the highest address
of the address range.
       
There are several kinds of bounded range entries which specify
the starting and ending addresses in different ways.
\needlines{4}
\item \definition{Base address}.\addtoindexx{base address!of range list}
This kind of entry provides an address to be
used as the base address for the beginning and ending
address offsets given in certain bounded range entries. The
applicable base address of a range list entry is
determined by the closest preceding base address
entry in the same range list. If there is no preceding
base address entry, then the applicable base address
defaults to the base address of the compilation unit (see 
Section \refersec{chap:fullandpartialcompilationunitentries}).

In the case of a compilation unit where all of the machine
code is contained in a single contiguous section, no base
address entry is needed.

\item \definition{End-of-list}.\addtoindexx{end-of-list!of range list} 
This kind of entry marks the end of the range list.

\end{itemize}

Each range list consists of a sequence of zero or more bounded
range or base address entries, terminated by an end-of-list entry.

A range list containing only an end-of-list entry describes an
empty scope (which contains no instructions).
   
Bounded range entries in a range list may not overlap. There is
no requirement that the entries be ordered in any particular way.

A bounded range entry whose beginning and ending address offsets
are equal (including zero) indicates an empty range and may be
ignored.
   
Each range list entry begins with a single byte identifying the kind
of that entry, followed by zero or more operands depending on the
kind.

In the descriptions that follow, the term \definitionx{address index}
means the index of an address in the \dotdebugaddr{} section. This
index is relative to the value of the \DWATaddrbase{} attribute
of the associated compilation unit. The address given by this kind
of operand is \emph{not} relative to the compilation unit base 
address.
    
The following entry kinds are defined for use in both
split or non-split units:
\begin{enumerate}[1. ]
\itembfnl{\DWRLEendoflistTARG}
An end-of-list entry contains no further data.

\textit{A series of this kind of entry may be used for padding or
alignment purposes.}
      
\itembfnl{\DWRLEbaseaddressxTARG}
A base address entry has one unsigned LEB128 operand.
The operand value is an address index (into the \dotdebugaddr{} 
section) that indicates the applicable base address used by 
following \DWRLEoffsetpair{} entries.
    
\itembfnl{\DWRLEstartxendxTARG}
This is a form of bounded range entry that
has two unsigned LEB128 operands. The operand values are
address indices (into the \dotdebugaddr{} section) that indicate the
starting and ending addresses, respectively, that define
the address range.

\itembfnl{\DWRLEstartxlengthTARG}
This is a form of bounded location description that
has two unsigned ULEB operands. The first value is an address index
(into the \dotdebugaddr{} section) that indicates the beginning of 
the address range. The second value is the length of the range.
       
\itembfnl{\DWRLEoffsetpairTARG}
This is a form of bounded range entry that
has two unsigned LEB128 operands. The values of these
operands are the starting and ending offsets, respectively,
relative to the applicable base address, that define the
address range.

\end{enumerate} 

The following kinds of range entry may be used only in non-split 
units:
 
\begin{enumerate}[1. ]
\addtocounter{enumi}{5}
\itembfnl{\DWRLEbaseaddressTARG}
A base address entry has one target address operand.
This operand is the same size as used in \DWFORMaddr.
This address is used as the base address when interpreting
offsets in subsequent location list entries of kind
\DWRLEoffsetpair.

\itembfnl{\DWRLEstartendTARG}
This is a form of bounded range entry that
has two target address operands. Each
operand is the same size as used in \DWFORMaddr.
These indicate the starting and ending addresses,
respectively, that define the address range for which
the following location is valid.
       
\itembfnl{\DWRLEstartlengthTARG}
This is a form of bounded range entry that
has one target address operand value and an unsigned LEB128
integer length operand value. The address is the beginning address
of the range over which the location description is valid, and
the length is the number of bytes in that range.

\end{enumerate}

\needlines{12}
\section{Entry Address}
\label{chap:entryaddress}
\textit{The entry or first executable instruction generated
for an entity, if applicable, is often the lowest addressed
instruction of a contiguous range of instructions. In other
cases, the entry address needs to be specified explicitly.}

Any debugging information entry describing an entity that has
a range of code addresses, which includes compilation units,
module initialization, subroutines, 
\livelink{chap:lexicalblock}{lexical \nolink{blocks}},
\livelink{chap:tryandcatchblockentries}{try/catch \nolink{blocks}},
and the like, may have a \DWATentrypcDEFN{} attribute 
\addtoindexx{entry PC address} to indicate the 
\definitionx{entry address} which is the address of the 
instruction where execution begins 
within that range\hypertarget{chap:entryaddressofscope}{}
of addresses. 
If the value of the \DWATentrypcNAME{} attribute is of
class \CLASSaddress{} that address is the entry address;
or, if it is of class
\CLASSconstant, the value is an unsigned integer offset which, 
when added to the base address of the function, gives the entry
address. 


If no \DWATentrypcNAME{} attribute is present,
then the entry address is assumed to be the same as the
base address of the containing scope.


\section{Static and Dynamic Values of Attributes}
\label{chap:staticanddynamicvaluesofattributes}

Some attributes that apply to types specify a property (such
as the lower bound of an array) that is an integer value,
where the value may be known during compilation or may be
computed dynamically during execution.

\needlines{8}
The value of these
attributes is determined based on the class as follows:
\begin{itemize}
\item For a \livelink{chap:classconstant}{constant}, the value 
of the constant is the value of the attribute.

\item For a \livelink{chap:classreference}{reference}, the
value is a reference to another debugging information entry.  
This entry may:
\begin{itemize}
\renewcommand{\itemsep}{0cm}
\item describe a constant which is the attribute value,
\item describe a variable which contains the attribute value, or
\item contain a \DWATlocation{} attribute whose value is a
      DWARF expression which computes the attribute value
      (for example, a \DWTAGdwarfprocedure{} entry).
\end{itemize}

\item For an \livelink{chap:classexprloc}{exprloc}, the value 
is interpreted as a DWARF expression; evaluation of the expression 
yields the value of the attribute.
\end{itemize}


\needlines{4}
\section{Entity Descriptions}
\textit{Some debugging information entries may describe entities
in the program that are artificial, or which otherwise have a 
\doublequote{name} that is not a valid identifier in the
programming language. 
This attribute provides a means for the producer to indicate
the purpose or usage of the containing debugging infor}

Generally, any debugging information entry that 
has,\hypertarget{chap:DWATdescriptionartificialnameordescription}{}
or may have, a \DWATname{} attribute, may also have a
\addtoindexx{description attribute}
\DWATdescriptionDEFN{} attribute whose value is a
null-terminated string providing a description of the entity.

\textit{It is expected that a debugger will 
display these descriptions as part of 
displaying other properties of an entity.}

\needlines{4}
\section{Byte and Bit Sizes}
\label{chap:byteandbitsizes}
% Some trouble here with hbox full, so we try optional word breaks.
Many debugging information entries allow either a
\DWATbytesizeNAME{} attribute or a 
\DWATbitsizeNAME{} attribute,
whose \livelink{chap:classconstant}{integer constant} value 
(see Section \ref{chap:staticanddynamicvaluesofattributes}) 
specifies an
amount of storage. The value of the 
\DWATbytesizeDEFN{} attribute
is interpreted in bytes and the value of the 
\DWATbitsizeDEFN{}
attribute is interpreted in bits. The
\DWATstringlengthbytesize{} and 
\DWATstringlengthbitsize{} 
attributes are similar.

In addition, the \livelink{chap:classconstant}{integer constant}
value of a \DWATbytestride{} attribute is interpreted
in bytes and the \livelink{chap:classconstant}{integer constant} value of a 
\DWATbitstride{}
attribute is interpreted in bits.

\section{Linkage Names}
\label{chap:linkagenames}
\textit{Some language implementations, notably 
\addtoindex{C++} and similar
languages, make use of implementation-defined names within
object files that are different from the \addtoindex{identifier names}
(see Section \refersec{chap:identifiernames}) of entities as they 
appear in the source. Such names, sometimes known as 
\addtoindex{mangled names}\addtoindexx{names!mangled},
are used in various ways, such as: to encode additional
information about an entity, to distinguish multiple entities
that have the same name, and so on. When an entity has an
associated distinct linkage name it may sometimes be useful
for a producer to include this name in the DWARF description
of the program to facilitate consumer access to and use of
object file information about an entity and/or information
that is encoded in the linkage name itself.  
}

% Some trouble maybe with hbox full, so we try optional word breaks.
A debugging information entry may have a
\DWATlinkagenameDEFN{}\hypertarget{chap:DWATlinkagenameobjectfilelinkagenameofanentity}{}
attribute\addtoindexx{linkage name attribute}
whose value is a null-terminated string containing the 
object file linkage name associated with the corresponding entity.


\section{Template Parameters}
\label{chap:templateparameters}
\textit{In \addtoindex{C++}, a template is a generic definition 
of a class, function, member function, or typedef (alias).  
A template has formal parameters that
can be types or constant values; the class, function,
member function, or typedef is instantiated differently for each
distinct combination of type or value actual parameters.  DWARF does
not represent the generic template definition, but does represent each
instantiation.}

A debugging information entry that represents a 
\addtoindex{template instantiation}
will contain child entries describing the actual template parameters.
The containing entry and each of its child entries reference a template
parameter entry in any circumstance where the template definition
referenced a formal template parameter.

A template type parameter is represented by a debugging information
entry with the tag
\addtoindexx{template type parameter entry}
\DWTAGtemplatetypeparameterTARG. 
A template value parameter is represented by a debugging information
entry with the tag
\addtoindexx{template value parameter entry}
\DWTAGtemplatevalueparameterTARG.
The actual template parameter entries appear in the same order as the 
corresponding template formal parameter declarations in the 
source program.

\needlines{4}
A type or value parameter entry may have a \DWATname{} attribute, 
\addtoindexx{name attribute}
whose value is a
null-terminated string containing the name of the corresponding 
formal parameter. The entry may also have a 
\DWATdefaultvalue{} attribute, which is a flag indicating 
that the value corresponds to the default argument for the 
template parameter.

A\addtoindexx{formal type parameter|see{template type parameter entry}}
template type parameter entry has a
\DWATtype{} attribute\addtoindexx{type attribute}
describing the actual type by which the formal is replaced.

A template value parameter entry has a \DWATtype{} attribute 
describing the type of the parameterized value.
The entry also has an attribute giving the 
actual compile-time or run-time constant value 
of the value parameter for this instantiation.
This can be a 
\DWATconstvalueDEFN{} attribute, 
\addtoindexx{constant value attribute}
\livetarg{chap:DWATconstvaluetemplatevalueparameter}{} 
whose value is the compile-time constant value 
as represented on the target architecture, or a 
\DWATlocation{} attribute, whose value is a 
single location description for the run-time constant address.

\needlines{8}
\section{Alignment}
\label{chap:alignment}
\livetarg{chap:DWATalignmentnondefault}{}
A debugging information entry may have a 
\DWATalignmentDEFN{} attribute\addtoindexx{alignment attribute}
whose value of class \CLASSconstant{} is
a positive, non-zero, integer describing the 
alignment of the entity. 

\textit{For example, an alignment attribute whose value is 8 indicates
that the entity to which it applies occurs at an address that is a
multiple of eight (not a multiple of $2^8$ or 256).}

