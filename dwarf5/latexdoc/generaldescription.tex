\chapter{General Description}
\label{chap:generaldescription}
\section{The Debugging Entry (DIE)}
\label{chap:thedebuggingentrydie}
DWARF uses a series of debugging information entries (DIEs) to 
define a low\dash{} level
representation of a source program. 
Each debugging information entry consists of an identifying
tag and a series of attributes. 
An entry, or group of entries together, provide a description of a
corresponding entity in the source program. 
The tag specifies the class to which an entry belongs
and the attributes define the specific characteristics of the entry.

The set of tag names is listed in Figure 1. 
The debugging information entries they identify are
described in Sections 3, 4 and 5.

The debugging information entry descriptions 
in Sections 3, 4 and 5 generally include mention of
most, but not necessarily all, of the attributes 
that are normally or possibly used with the entry.
Some attributes, whose applicability tends to be 
pervasive and invariant across many kinds of
debugging information entries, are described in 
this section and not necessarily mentioned in all
contexts where they may be appropriate. 
Examples include DW\-\_AT\-\_artificial, the declaration
coordinates, and DW\-\_AT\-\_description, among others.

The debugging information entries are contained 
in the .debug\_info and .debug\_types
sections of an object file.



\section{Attribute Types}
\label{chap:attributetypes}
Each attribute value is characterized by an attribute name. 
No more than one attribute with a given name may appear in any
debugging information entry. 
There are no limitations on the
ordering of attributes within a debugging information entry.

The attributes are listed in Figure 2.  

The permissible values
for an attribute belong to one or more classes of attribute
value forms.  
Each form class may be represented in one or more ways. 
For example, some attribute values consist
of a single piece of constant data. 
``Constant data''
is the class of attribute value that those attributes may have. 
There are several representations of constant data,
however (one, two, ,four, or eight bytes, and variable length
data). 
The particular representation for any given instance
of an attribute is encoded along with the attribute name as
part of the information that guides the interpretation of a
debugging information entry.  

Attribute value forms belong
to one of the classes shown in Figure \refersec{tab:classesofattributevalue}.

% These each need to link to definition page: FIXME
\begin{figure}[here]
\autorows[0pt]{c}{2}{l}{
\livelink{chap:DWTAGaccessdeclaration}{DW\-\_TAG\-\_access\-\_declaration},
\livelink{chap:DWTAGarraytype}{DW\-\_TAG\-\_array\-\_type},
\livelink{chap:DWTAGbasetype}{DW\-\_TAG\-\_base\-\_type},
\livelink{chap:DWTAGcatchblock}{DW\-\_TAG\-\_catch\-\_block},
\livelink{chap:DWTAGclasstype}{DW\-\_TAG\-\_class\-\_type},
\livelink{chap:DWTAGcommonblock}{DW\-\_TAG\-\_common\-\_block},
\livelink{chap:DWTAGcommoninclusion}{DW\-\_TAG\-\_common\-\_inclusion},
\livelink{chap:DWTAGcompileunit}{DW\-\_TAG\-\_compile\-\_unit},
\livelink{chap:DWTAGcondition}{DW\-\_TAG\-\_condition},
\livelink{chap:DWTAGconsttype}{DW\-\_TAG\-\_const\-\_type},
\livelink{chap:DWTAGconstant}{DW\-\_TAG\-\_constant},
\livelink{chap:DWTAGdwarfprocedure}{DW\-\_TAG\-\_dwarf\-\_procedure},
\livelink{chap:DWTAGentrypoint}{DW\-\_TAG\-\_entry\-\_point},
\livelink{chap:DWTAGenumerationtype}{DW\-\_TAG\-\_enumeration\-\_type},
\livelink{chap:DWTAGenumerator}{DW\-\_TAG\-\_enumerator},
\livelink{chap:DWTAGfiletype}{DW\-\_TAG\-\_file\-\_type},
\livelink{chap:DWTAGformalparameter}{DW\-\_TAG\-\_formal\-\_parameter},
\livelink{chap:DWTAGfriend}{DW\-\_TAG\-\_friend},
\livelink{chap:DWTAGimporteddeclaration}{DW\-\_TAG\-\_imported\-\_declaration},
\livelink{chap:DWTAGimportedmodule}{DW\-\_TAG\-\_imported\-\_module},
\livelink{chap:DWTAGimportedunit}{DW\-\_TAG\-\_imported\-\_unit},
\livelink{chap:DWTAGinheritance}{DW\-\_TAG\-\_inheritance},
\livelink{chap:DWTAGinlinedsubroutine}{DW\-\_TAG\-\_inlined\-\_subroutine},
\livelink{chap:DWTAGinterfacetype}{DW\-\_TAG\-\_interface\-\_type},
\livelink{chap:DWTAGlabel}{DW\-\_TAG\-\_label},
\livelink{chap:DWTAGlexicalblock}{DW\-\_TAG\-\_lexical\-\_block},
\livelink{chap:DWTAGmodule}{DW\-\_TAG\-\_module},
\livelink{chap:DWTAGmember}{DW\-\_TAG\-\_member},
\livelink{chap:DWTAGnamelist}{DW\-\_TAG\-\_namelist},
\livelink{chap:DWTAGnamelistitem}{DW\-\_TAG\-\_namelist\-\_item},
\livelink{chap:DWTAGnamespace}{DW\-\_TAG\-\_namespace},
\livelink{chap:DWTAGpackedtype}{DW\-\_TAG\-\_packed\-\_type},
\livelink{chap:DWTAGpartialunit}{DW\-\_TAG\-\_partial\-\_unit},
\livelink{chap:DWTAGpointertype}{DW\-\_TAG\-\_pointer\-\_type},
\livelink{chap:DWTAGptrtomembertype}{DW\-\_TAG\-\_ptr\-\_to\-\_member\-\_type},
\livelink{chap:DWTAGreferencetype}{DW\-\_TAG\-\_reference\-\_type},
\livelink{chap:DWTAGrestricttype}{DW\-\_TAG\-\_restrict\-\_type},
\livelink{chap:DWTAGrvaluereferencetype}{DW\-\_TAG\-\_rvalue\-\_reference\-\_type},
\livelink{chap:DWTAGsettype}{DW\-\_TAG\-\_set\-\_type},
\livelink{chap:DWTAGsharedtype}{DW\-\_TAG\-\_shared\-\_type},
\livelink{chap:DWTAGstringtype}{DW\-\_TAG\-\_string\-\_type},
\livelink{chap:DWTAGstructuretype}{DW\-\_TAG\-\_structure\-\_type},
\livelink{chap:DWTAGsubprogram}{DW\-\_TAG\-\_subprogram},
\livelink{chap:DWTAGsubrangetype}{DW\-\_TAG\-\_subrange\-\_type},
\livelink{chap:DWTAGsubroutinetype}{DW\-\_TAG\-\_subroutine\-\_type},
\livelink{chap:DWTAGtemplatealias}{DW\-\_TAG\-\_template\-\_alias},
\livelink{chap:DWTAGtemplatetypeparameter}{DW\-\_TAG\-\_template\-\_type\-\_parameter},
\livelink{chap:DWTAGtemplatevalueparameter}{DW\-\_TAG\-\_template\-\_value\-\_parameter},
\livelink{chap:DWTAGthrowntype}{DW\-\_TAG\-\_thrown\-\_type},
\livelink{chap:DWTAGtryblock}{DW\-\_TAG\-\_try\-\_block},
\livelink{chap:DWTAGtypedef}{DW\-\_TAG\-\_typedef},
\livelink{chap:DWTAGtypeunit}{DW\-\_TAG\-\_type\-\_unit},
\livelink{chap:DWTAGuniontype}{DW\-\_TAG\-\_union\-\_type},
\livelink{chap:DWTAGunspecifiedparameters}{DW\-\_TAG\-\_unspecified\-\_parameters},
\livelink{chap:DWTAGunspecifiedtype}{DW\-\_TAG\-\_unspecified\-\_type},
\livelink{chap:DWTAGvariable}{DW\-\_TAG\-\_variable},
\livelink{chap:DWTAGvariant}{DW\-\_TAG\-\_variant},
\livelink{chap:DWTAGvariantpart}{DW\-\_TAG\-\_variant\-\_part},
\livelink{chap:DWTAGvolatiletype}{DW\-\_TAG\-\_volatile\-\_type},
\livelink{chap:DWTAGwithstmt}{DW\-\_TAG\-\_with\-\_stmt},
}
\caption{Tag names}\label{fig:tagnames}
\end{figure}

\label{tab:attributenames}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|p{9cm}}
  \caption{Attribute names} \\
  \hline \\ \bfseries Attribute&\bfseries Identifies or Specifies \\ \hline
\endfirsthead
  \bfseries Attribute&\bfseries Identifies or Specifies \\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot
DW\-\_AT\-\_abstract\-\_origin
&Inline instances of inline subprograms \\
&Out\dash{} of\dash{} line instances of inline subprograms \\
DW\-\_AT\-\_accessibility
&C++ and Ada declarations \\
&C++ base classes \\
&C++ inherited members \\
DW\-\_AT\-\_address\-\_class
&Pointer or reference types \\
&Subroutine or subroutine type \\
DW\-\_AT\-\_allocated
&Allocation status of types \\
DW\-\_AT\-\_artificial
&Objects or types that are not
actually declared in the source \\
DW\-\_AT\-\_associated 
&Association status of types \\
DW\-\_AT\-\_base\-\_types 
&Primitive data types of compilation unit \\
DW\-\_AT\-\_binary\-\_scale 
&Binary scale factor for fixed\dash point type \\
DW\-\_AT\-\_bit\-\_offset 
&Base type bit location \\
&Data member bit location \\
DW\-\_AT\-\_bit\-\_size 
&Base type bit size \\
&Data member bit size \\
DW\-\_AT\-\_bit\-\_stride 
&Array element stride (of array type) \\
&Subrange stride (dimension of array type) \\
&Enumeration stride (dimension of array type) \\
DW\-\_AT\-\_byte\-\_size 
&Data object or data type size \\
DW\-\_AT\-\_byte\-\_stride 
&Array element stride (of array type) \\
&Subrange stride (dimension of array type) \\
&Enumeration stride (dimension of array type) \\
DW\-\_AT\-\_call\-\_column 
&Column position of inlined subroutine call \\
DW\-\_AT\-\_call\-\_file
&File containing inlined subroutine call \\
DW\-\_AT\-\_call\-\_line 
&Line number of inlined subroutine call \\
DW\-\_AT\-\_calling\-\_convention 
&Subprogram calling convention \\
&DW\-\_AT\-\_common\-\_reference \\
&Common block usage \\
DW\-\_AT\-\_comp\-\_dir
&Compilation directory \\
DW\-\_AT\-\_const\-\_value
&Constant object \\
DW\-\_AT\-\_const\-\_value
&Enumeration literal value \\
&Template value parameter \\
DW\-\_AT\-\_const\-\_expr
&Compile\dash time constant object \\
&Compile\dash time constant function \\
DW\-\_AT\-\_containing\-\_type
&Containing type of pointer to member type \\
DW\-\_AT\-\_count
&Elements of subrange type \\
DW\-\_AT\-\_data\-\_bit\-\_offset
&Base type bit location \\
&Data member bit location \\
DW\-\_AT\-\_data\-\_location 
&Indirection to actual data \\
DW\-\_AT\-\_data\-\_member\-\_location
&Data member location \\
&Inherited member location \\
DW\-\_AT\-\_decimal\-\_scale
&Decimal scale factor \\
DW\-\_AT\-\_decimal\-\_sign
&Decimal sign representation \\
DW\-\_AT\-\_decl\-\_column
&Column position of source declaration \\
DW\-\_AT\-\_decl\-\_file
&File containing source declaration \\
DW\-\_AT\-\_decl\-\_line
&Line number of source declaration \\
DW\-\_AT\-\_declaration
&Incomplete, non\dash defining, or separate entity declaration \\
DW\-\_AT\-\_default\-\_value
&Default value of parameter \\
DW\-\_AT\-\_description 
& Artificial name or description \\
DW\-\_AT\-\_digit\-\_count
&Digit count for packed decimal or numeric string type\\
DW\-\_AT\-\_discr
&Discriminant of variant part\\
DW\-\_AT\-\_discr\-\_list
&List of discriminant values\\
DW\-\_AT\-\_discr\-\_value
&Discriminant value\\
DW\-\_AT\-\_elemental
&Elemental property of a subroutine\\
DW\-\_AT\-\_encoding
&Encoding of base type\\
DW\-\_AT\-\_endianity
&Endianity of data\\
DW\-\_AT\-\_entry\-\_pc
&Entry address of module initialization\\
&Entry address of subprogram\\
&Entry address of inlined subprogram\\
DW\-\_AT\-\_enum\-\_class
&Type safe enumeration definition\\
DW\-\_AT\-\_explicit
&Explicit property of member function\\
DW\-\_AT\-\_extension
&Previous namespace extension or original namespace\\
DW\-\_AT\-\_external
&External subroutine\\
&External variable\\
DW\-\_AT\-\_frame\-\_base
&Subroutine frame base address\\
DW\-\_AT\-\_friend
&Friend relationship\\
DW\-\_AT\-\_high\-\_pc
&Contiguous range of code addresses\\
DW\-\_AT\-\_identifier\-\_case
&Identifier case rule \\
DW\-\_AT\-\_import
&Imported declaration \\
&Imported unit \\
&Namespace alias \\
&Namespace using declaration \\
&Namespace using directive \\
DW\-\_AT\-\_inline
&Abstract instance\\
&Inlined subroutine\\
DW\-\_AT\-\_is\-\_optional
&Optional parameter\\
DW\-\_AT\-\_language
&Programming language\\
DW\-\_AT\-\_linkage\-\_name
&Object file linkage name of an entity\\
DW\-\_AT\-\_location
&Data object location\\
DW\-\_AT\-\_low\-\_pc
&Code address or range of addresses\\
DW\-\_AT\-\_lower\-\_bound
&Lower bound of subrange\\
DW\-\_AT\-\_macro\-\_info
&Macro information (\#define, \#undef)\\
DW\-\_AT\-\_main\-\_subprogram
&Main or starting subprogram\\
&Unit containing main or starting subprogram\\
DW\-\_AT\-\_mutable
&Mutable property of member data\\
DW\-\_AT\-\_name
&Name of declaration\\
&Path name of compilation source\\
DW\-\_AT\-\_namelist\-\_item
&Namelist item\\
DW\-\_AT\-\_object\-\_pointer
&Object (this, self) pointer of member function\\
DW\-\_AT\-\_ordering
&Array row/column ordering\\
DW\-\_AT\-\_picture\-\_string
&Picture string for numeric string type\\
DW\-\_AT\-\_priority
&Module priority\\
DW\-\_AT\-\_producer
&Compiler identification\\
DW\-\_AT\-\_prototyped
&Subroutine prototype\\
DW\-\_AT\-\_pure
&Pure property of a subroutine\\
DW\-\_AT\-\_ranges
&Non\dash contiguous range of code addresses\\
DW\-\_AT\-\_recursive
&Recursive property of a subroutine\\
DW\-\_AT\-\_return\-\_addr
&Subroutine return address save location\\
DW\-\_AT\-\_segment
&Addressing information\\
DW\-\_AT\-\_sibling
&Debugging information entry relationship\\
DW\-\_AT\-\_small
&Scale factor for fixed\dash point type\\
DW\-\_AT\-\_signature
&Type signature\\
DW\-\_AT\-\_specification
&Incomplete, non\dash defining, or separate declaration
corresponding to a declaration\\
DW\-\_AT\-\_start\-\_scope
&Object declaration\\
&Type declaration\\
DW\-\_AT\-\_static\-\_link
&Location of uplevel frame\\
DW\-\_AT\-\_stmt\-\_list
&Line number information for unit\\
DW\-\_AT\-\_string\-\_length
&String length of string type\\
DW\-\_AT\-\_threads\-\_scaled
&UPC array bound THREADS scale factor\\
DW\-\_AT\-\_trampoline
&Target subroutine\\
DW\-\_AT\-\_type
&Type of declaration\\
&Type of subroutine return\\
DW\-\_AT\-\_upper\-\_bound
&Upper bound of subrange\\
DW\-\_AT\-\_use\-\_location
&Member location for pointer to member type\\
DW\-\_AT\-\_use\-\_UTF8
&Compilation unit uses UTF\dash 8 strings \\
DW\-\_AT\-\_variable\-\_parameter
&Non\dash constant parameter flag \\
DW\-\_AT\-\_virtuality
&Virtuality indication \\
&Virtuality of base class \\
&Virtuality of function \\
DW\-\_AT\-\_visibility
&Visibility of declaration\\
DW\-\_AT\-\_vtable\-\_elem\-\_location
&Virtual function vtable slot\\
\end{longtable}

\begin{figure}[here]
\centering
% Attribute Class entries need a ref to definition point.
\setlength{\extrarowheight}{0.1cm}
\label{tab:classesofattributevalue}
\begin{tabular}{l|p{10cm}} \hline
Attribute Class & General Use and Encoding \\ \hline
\livetargi{chap:address}{address}{address class}
&Refers to some location in the address space of the described program.
 \\ 
\livetargi{chap:block}{block}{block class}
& An arbitrary number of uninterpreted bytes of data.
 \\
\livetargi{chap:constant}{constant}{constant class}
&One, two, four or eight bytes of uninterpreted data, or data
encoded in the variable length format known as LEB128 (see
Section 7.6.).

\textit{Most constant values are integers of one kind or
another (codes, offsets, counts, and so on); these are
sometimes called ``integer constants'' for emphasis.} \\

\livetargi{chap:exprloc}{exprloc}{exprloc class}
&A DWARF expression or location description.
\\
\livetargi{chap:flag}{flag}{flag class}
&A small constant that indicates the presence or absence of an attribute.
\\
\livetargi{chap:lineptr}{lineptr}{lineptr class}
&Refers to a location in the DWARF section that holds line number information.
\\
\livetargi{chap:loclistptr}{loclistptr}{loclistptr class}
&Refers to a location in the DWARF section that holds location lists, which
describe objects whose location can change during their lifetime.
\\
\livetargi{chap:macptr}{macptr}{macptr class}
& Refers to a location in the DWARF section that holds macro definition
 information.  \\
\livetargi{chap:rangelistptr}{rangelistptr}{rangelistptr class}
& Refers to a location in the DWARF section that holds non\dash contiguous address ranges.  \\

\livetargi{chap:reference}{reference}{reference class}
& Refers to one of the debugging information
entries that describe the program.  There are three types of
reference. The first is an offset relative to the beginning
of the compilation unit in which the reference occurs and must
refer to an entry within that same compilation unit. The second
type of reference is the offset of a debugging information
entry in any compilation unit, including one different from
the unit containing the reference. The third type of reference
is an indirect reference to a type definition using a 64\dash
bit signature for that type.  \\

\livetargi{chap:string}{string}{string class}
& A null\dash terminated sequence of zero or more
(non\dash null) bytes. Data in this class are generally
printable strings. Strings may be represented directly in
the debugging information entry or as an offset in a separate
string table.  
\end{tabular}
\caption{Classes of Attribute value}
\end{figure}
% It is difficult to get the above table to appear before
% the end of the chapter without a clearpage here.
\clearpage
\section{Relationship of Debugging Information Entries}
\label{chap:relationshipofdebugginginformationentries}
\textit{
A variety of needs can be met by permitting a single
debugging information entry to “own” an arbitrary number
of other debugging entries and by permitting the same debugging
information entry to be one of many owned by another debugging
information entry. 
This makes it possible, for example, to
describe the static block structure within a source file,
to show the members of a structure, union, or class, and to
associate declarations with source files or source files
with shared objects.  
}


The ownership relation of debugging
information entries is achieved naturally because the debugging
information is represented as a tree. 
The nodes of the tree
are the debugging information entries themselves. 
The child
entries of any node are exactly those debugging information
entries owned by that node.  

\textit{
While the ownership relation
of the debugging information entries is represented as a
tree, other relations among the entries exist, for example,
a reference from an entry representing a variable to another
entry representing the type of that variable. 
If all such
relations are taken into account, the debugging entries
form a graph, not a tree.  
}

The tree itself is represented
by flattening it in prefix order. 
Each debugging information
entry is defined either to have child entries or not to have
child entries (see Section 7.5.3). 
If an entry is defined not
to have children, the next physically succeeding entry is a
sibling. 
If an entry is defined to have children, the next
physically succeeding entry is its first child. 
Additional
children are represented as siblings of the first child. 
A chain of sibling entries is terminated by a null entry.

In cases where a producer of debugging information feels that
it will be important for consumers of that information to
quickly scan chains of sibling entries, while ignoring the
children of individual siblings, that producer may attach a
DW\-\_AT\-\_sibling attribute to any debugging information entry. 
The
value of this attribute is a reference to the sibling entry
of the entry to which the attribute is attached.


\section{Target Addresses}
\label{chap:targetaddresses}
Many places in this document refer to the size of an address
on the target architecture (or equivalently, target machine)
to which a DWARF description applies. For processors which
can be configured to have different address sizes or different
instruction sets, the intent is to refer to the configuration
which is either the default for that processor or which is
specified by the object file or executable file which contains
the DWARF information.



\textit{
For example, if a particular target architecture supports
both 32\dash bit and 64\dash bit addresses, the compiler will generate
an object file which specifies that it contains executable
code generated for one or the other of these address sizes. In
that case, the DWARF debugging information contained in this
object file will use the same address size.
}

\textit{
Architectures which have multiple instruction sets are
supported by the isa entry in the line number information
(see Section \refersec{chap:statemachineregisters}).
}


\section{DWARF Expressions}
\label{chap:dwarfexpressions}
DWARF expressions describe how to compute a value or name a
location during debugging of a program. 
They are expressed in
terms of DWARF operations that operate on a stack of values.

All DWARF operations are encoded as a stream of opcodes that
are each followed by zero or more literal operands. 
The number
of operands is determined by the opcode.  

In addition to the
general operations that are defined here, operations that are
specific to location descriptions are defined in 
Section \refersec{chap:locationdescriptions} .

\subsection{General Operations}
\label{chap:generaloperations}
Each general operation represents a postfix operation on
a simple stack machine. Each element of the stack is the
size of an address on the target machine. The value on the
top of the stack after ``executing'' the DWARF expression
is taken to be the result (the address of the object, the
value of the array bound, the length of a dynamic string,
the desired value itself, and so on).

\subsubsection{Literal Encodings}
\label{chap:literalencodings}
The following operations all push a value onto the DWARF
stack. If the value of a constant in one of these operations
is larger than can be stored in a single stack element, the
value is truncated to the element size and the low\dash order bits
are pushed on the stack.

\begin{enumerate}[1]
\item DW\-\_OP\-\_lit0, DW\-\_OP\-\_lit1, \dots, DW\-\_OP\-\_lit31 \\
The DW\-\_OP\-\_litn operations encode the unsigned literal values
from 0 through 31, inclusive.

\item DW\-\_OP\-\_addr \\
The DW\-\_OP\-\_addr operation has a single operand that encodes
a machine address and whose size is the size of an address
on the target machine.

\item DW\-\_OP\-\_const1u, DW\-\_OP\-\_const2u, DW\-\_OP\-\_const4u, DW\-\_OP\-\_const8u \\
The single operand of a DW\-\_OP\-\_constnu operation provides a 1,
2, 4, or 8\dash byte unsigned integer constant, respectively.

\item DW\-\_OP\-\_const1s , DW\-\_OP\-\_const2s, DW\-\_OP\-\_const4s, DW\-\_OP\-\_const8s \\
The single operand of a DW\-\_OP\-\_constns operation provides a 1,
2, 4, or 8\dash byte signed integer constant, respectively.

\item DW\-\_OP\-\_constu \\
The single operand of the DW\-\_OP\-\_constu operation provides
an unsigned LEB128 integer constant.

\item DW\-\_OP\-\_consts \\
The single operand of the DW\-\_OP\-\_consts operation provides
a signed LEB128 integer constant.

\end{enumerate}


\subsubsection{Register Based Addressing}
\label{chap:registerbasedaddressing}
The following operations push a value onto the stack that is
the result of adding the contents of a register to a given
signed offset.

\begin{enumerate}[1]

\item DW\-\_OP\-\_fbreg \\
The DW\-\_OP\-\_fbreg operation provides a signed LEB128 offset
from the address specified by the location description in the
DW\-\_AT\-\_frame\-\_base attribute of the current function. (This
is typically a “stack pointer” register plus or minus
some offset. On more sophisticated systems it might be a
location list that adjusts the offset according to changes
in the stack pointer as the PC changes.)

\item DW\-\_OP\-\_breg0, DW\-\_OP\-\_breg1, \dots, DW\-\_OP\-\_breg31\\
The single operand of the DW\-\_OP\-\_bregn operations provides
a signed LEB128 offset from
the specified register.

\item DW\-\_OP\-\_bregx \\
The DW\-\_OP\-\_bregx operation has two operands: a register
which is specified by an unsigned LEB128 number, followed by
a signed LEB128 offset.

\end{enumerate}


\subsubsection{Stack Operations}
\label{chap:stackoperations}
The following operations manipulate the DWARF stack. Operations
that index the stack assume that the top of the stack (most
recently added entry) has index 0.

\begin{enumerate}[1]
\item \livetarg{chap:DWOPdup}{DW\-\_OP\-\_dup} \\
The DW\-\_OP\-\_dup operation duplicates the value at the top of the stack.

\item \livetarg{chap:DWOPdrop}{DW\-\_OP\-\_drop} \\
The DW\-\_OP\-\_drop operation pops the value at the top of the stack.

\item \livetarg{chap:DWOPpick}{DW\-\_OP\-\_pick} \\
The single operand of the DW\-\_OP\-\_pick operation provides a
1\dash byte index. A copy of the stack entry with the specified
index (0 through 255, inclusive) is pushed onto the stack.

\item \livetarg{chap:DWOPover}{DW\-\_OP\-\_over} \\
The DW\-\_OP\-\_over operation duplicates the entry currently second
in the stack at the top of the stack. 
This is equivalent to
a DW\-\_OP\-\_pick operation, with index 1.  

\item \livetarg{chap:DWOPswap}{DW\-\_OP\-\_swap} \\
The DW\-\_OP\-\_swap operation swaps the top two stack entries. 
The entry at the top of the
stack becomes the second stack entry, 
and the second entry becomes the top of the stack.

\item \livetarg{chap:DWOProt}{DW\-\_OP\-\_rot} \\
The DW\-\_OP\-\_rot operation rotates the first three stack
entries. The entry at the top of the stack becomes the third
stack entry, the second entry becomes the top of the stack,
and the third entry becomes the second entry.

\item  \livetarg{chap:DWOPderef}{DW\-\_OP\-\_deref} \\
The DW\-\_OP\-\_deref operation pops the top stack entry and 
treats it as an address. The value
retrieved from that address is pushed. 
The size of the data retrieved from the dereferenced
address is the size of an address on the target machine.

\item \livetarg{chap:DWOPderefsize}{DW\-\_OP\-\_deref\-\_size} \\
The DW\-\_OP\-\_deref\-\_size operation behaves like the DW\-\_OP\-\_deref
operation: it pops the top stack entry and treats it as an
address. The value retrieved from that address is pushed. In
the DW\-\_OP\-\_deref\-\_size operation, however, the size in bytes
of the data retrieved from the dereferenced address is
specified by the single operand. This operand is a 1\dash byte
unsigned integral constant whose value may not be larger
than the size of an address on the target machine. The data
retrieved is zero extended to the size of an address on the
target machine before being pushed onto the expression stack.

\item \livetarg{chap:DWOPxderef}{DW\-\_OP\-\_xderef} \\
The DW\-\_OP\-\_xderef operation provides an extended dereference
mechanism. The entry at the top of the stack is treated as an
address. The second stack entry is treated as an “address
space identifier” for those architectures that support
multiple address spaces. The top two stack elements are popped,
and a data item is retrieved through an implementation\dash defined
address calculation and pushed as the new stack top. The size
of the data retrieved from the dereferenced address is the
size of an address on the target machine.

\item \livetarg{chap:DWOPxderefsize}{DW\-\_OP\-\_xderef\-\_size}\\
The DW\-\_OP\-\_xderef\-\_size operation behaves like the
DW\-\_OP\-\_xderef operation.The entry at the top of the stack is
treated as an address. The second stack entry is treated as
an “address space identifier” for those architectures
that support multiple address spaces. The top two stack
elements are popped, and a data item is retrieved through an
implementation\dash defined address calculation and pushed as the
new stack top. In the DW\-\_OP\-\_xderef\-\_size operation, however,
the size in bytes of the data retrieved from the dereferenced
address is specified by the single operand. This operand is a
1\dash byte unsigned integral constant whose value may not be larger
than the size of an address on the target machine. The data
retrieved is zero extended to the size of an address on the
target machine before being pushed onto the expression stack.

\item \livetarg{chap:DWOPpushobjectaddress}{DW\-\_OP\-\_push\-\_object\-\_address}\\
The DW\-\_OP\-\_push\-\_object\-\_address operation pushes the address
of the object currently being evaluated as part of evaluation
of a user presented expression. This object may correspond
to an independent variable described by its own debugging
information entry or it may be a component of an array,
structure, or class whose address has been dynamically
determined by an earlier step during user expression
evaluation.  This operator provides explicit functionality
(especially for arrays involving descriptors) that is analogous
to the implicit push of the base address of a structure prior
to evaluation of a DW\-\_AT\-\_data\-\_member\-\_location to access a
data member of a structure. For an example, see 
Appendix \refersec{app:aggregateexamples}.

\item \livetarg{chap:DWOPformtlsaddress}{DW\-\_OP\-\_form\-\_tls\-\_address} \\
The DW\-\_OP\-\_form\-\_tls\-\_address operation pops a value from the
stack, translates it into an address in the current thread's
thread\dash local storage block, and pushes the address. If the
DWARF expression containing the DW\-\_OP\-\_form\-\_tls\-\_address
operation belongs to the main executable's DWARF info, the
operation uses the main executable's thread\dash local storage
block; if the expression belongs to a shared library's
DWARF info, then it uses that shared library's thread\dash local
storage block.  Some implementations of C and C++ support a
\_\_thread storage class. Variables with this storage class
have distinct values and addresses in distinct threads, much
as automatic variables have distinct values and addresses in
each function invocation. Typically, there is a single block
of storage containing all \_\_thread variables declared in
the main executable, and a separate block for the variables
declared in each shared library. Computing the address of
the appropriate block can be complex (in some cases, the
compiler emits a function call to do it), and difficult
to describe using ordinary DWARF location descriptions.
DW\-\_OP\-\_form\-\_tls\-\_address leaves the computation to the
consumer.

\item \livetarg{chap:DWOPcallframecfa}{DW\-\_OP\-\_call\-\_frame\-\_cfa} \\
The DW\-\_OP\-\_call\-\_frame\-\_cfa operation pushes the value of the
CFA, obtained from the Call Frame Information 
(see Section \refersec{chap:callframeinformation}).
Although the value of DW\-\_AT\-\_frame\-\_base
can be computed using other DWARF expression operators,
in some cases this would require an extensive location list
because the values of the registers used in computing the
CFA change during a subroutine. If the 
Call Frame Information 
is present, then it already encodes such changes, and it is
space efficient to reference that.
\end{enumerate}

\subsubsection{Arithmetic and Logical Operations}
The following provide arithmetic and logical operations. Except
as otherwise specified, the arithmetic operations perfom
addressing arithmetic, that is, unsigned arithmetic that is
performed modulo one plus the largest representable address
(for example, 0x100000000 when the size of an address is 32
bits). Such operations do not cause an exception on overflow.

\begin{enumerate}[1]
\item \livetarg{chap:DWOPabs}{DW\-\_OP\-\_abs}  \\
The DW\-\_OP\-\_abs operation pops the top stack entry, interprets
it as a signed value and pushes its absolute value. If the
absolute value cannot be represented, the result is undefined.

\item \livetarg{chap:DWOPand}{DW\-\_OP\-\_and} \\
The DW\-\_OP\-\_and operation pops the top two stack values, performs
a bitwise and operation on the two, and pushes the result.

\item \label{chap:DWOPdiv}{DW\-\_OP\-\_div} \\
The DW\-\_OP\-\_div operation pops the top two stack values, divides the former second entry by
the former top of the stack using signed division, and pushes the result.

\item \livetarg{chap:DWOPminus}{DW\-\_OP\-\_minus} \\
The DW\-\_OP\-\_minus operation pops the top two stack values, subtracts the former top of the
stack from the former second entry, and pushes the result.

\item \livetarg{chap:DWOPmod}{DW\-\_OP\-\_mod}\\
The DW\-\_OP\-\_mod operation pops the top two stack values and pushes the result of the
calculation: former second stack entry modulo the former top of the stack.

\item \livetarg{chap:DWOPmul}{DW\-\_OP\-\_mul} \\
The DW\-\_OP\-\_mul operation pops the top two stack entries, multiplies them together, and
pushes the result.

\item  \livetarg{chap:DWOPneg}{DW\-\_OP\-\_neg} \\
The DW\-\_OP\-\_neg operation pops the top stack entry, interprets
it as a signed value and pushes its negation. If the negation
cannot be represented, the result is undefined.

\item  \livetarg{chap:DWOPnot}{DW\-\_OP\-\_not} \\
The DW\-\_OP\-\_not operation pops the top stack entry, and pushes
its bitwise complement.

\item  \livetarg{chap:DWOPor}{DW\-\_OP\-\_or} \\
The DW\-\_OP\-\_or operation pops the top two stack entries, performs
a bitwise or operation on the two, and pushes the result.

\item  \livetarg{chap:DWOPplus}{DW\-\_OP\-\_plus} \\
The DW\-\_OP\-\_plus operation pops the top two stack entries,
adds them together, and pushes the result.

\item  \livetarg{chap:DWOPplusuconst}{DW\-\_OP\-\_plus\-\_uconst} \\
The DW\-\_OP\-\_plus\-\_uconst operation pops the top stack entry,
adds it to the unsigned LEB128 constant operand and pushes
the result.  This operation is supplied specifically to be
able to encode more field offsets in two bytes than can be
done with “DW\-\_OP\-\_litn DW\-\_OP\-\_plus”.

\item \livetarg{chap:DWOPshl}{DW\-\_OP\-\_shl} \\
The DW\-\_OP\-\_shl operation pops the top two stack entries,
shifts the former second entry left (filling with zero bits)
by the number of bits specified by the former top of the stack,
and pushes the result.

\item \livetarg{chap:DWOPshr}{DW\-\_OP\-\_shr} \\
The DW\-\_OP\-\_shr operation pops the top two stack entries,
shifts the former second entry right logically (filling with
zero bits) by the number of bits specified by the former top
of the stack, and pushes the result.

\item \livetarg{chap:DWOPshra}{DW\-\_OP\-\_shra} \\
The DW\-\_OP\-\_shra operation pops the top two stack entries,
shifts the former second entry right arithmetically (divide
the magnitude by 2, keep the same sign for the result) by
the number of bits specified by the former top of the stack,
and pushes the result.

\item \livetarg{chap:DWOPxor}{DW\-\_OP\-\_xor} \\
The DW\-\_OP\-\_xor operation pops the top two stack entries,
performs a bitwise exclusive\dash or operation on the two, and
pushes the result.

\end{enumerate}

\subsubsection{Control Flow Operations}
\label{chap:controlflowoperations}
The following operations provide simple control of the flow of a DWARF expression.
\begin{enumerate}[1]
\item  DW\-\_OP\-\_le, DW\-\_OP\-\_ge, DW\-\_OP\-\_eq, DW\-\_OP\-\_lt, DW\-\_OP\-\_gt, DW\-\_OP\-\_ne \\
The six relational operators each:
\begin{itemize}
\item pop the top two stack values,

\item compare the operands:
\textless~former second entry~\textgreater  \textless~relational operator~\textgreater \textless~former top entry~\textgreater

\item push the constant value 1 onto the stack 
if the result of the operation is true or the
constant value 0 if the result of the operation is false.
\end{itemize}

Comparisons are performed as signed operations. The six
operators are DW\-\_OP\-\_le (less than or equal to), DW\-\_OP\-\_ge
(greater than or equal to), DW\-\_OP\-\_eq (equal to), DW\-\_OP\-\_lt (less
than), DW\-\_OP\-\_gt (greater than) and DW\-\_OP\-\_ne (not equal to).

\item DW\-\_OP\-\_skip \\
DW\-\_OP\-\_skip is an unconditional branch. Its single operand
is a 2\dash byte signed integer constant. The 2\dash byte constant is
the number of bytes of the DWARF expression to skip forward
or backward from the current operation, beginning after the
2\dash byte constant.

\item DW\-\_OP\-\_bra \\
DW\-\_OP\-\_bra is a conditional branch. Its single operand is a
2\dash byte signed integer constant.  This operation pops the
top of stack. If the value popped is not the constant 0,
the 2\dash byte constant operand is the number of bytes of the
DWARF expression to skip forward or backward from the current
operation, beginning after the 2\dash byte constant.

% The following item does not correctly hyphenate leading
% to an overfull hbox and a visible artifact. 
% So we use \- to suggest hyphenation in this rare situation.
\item DW\-\_OP\-\_call2, DW\-\_OP\-\_call4, DW\-\_OP\-\_call\-\_ref \\
DW\-\_OP\-\_call2, DW\-\_OP\-\_call4, and DW\-\_OP\-\_call\-\_ref perform
subroutine calls during evaluation of a DWARF expression or
location description. 
For DW\-\_OP\-\_call2 and 
DW\-\_OP\-\_call4, 
the
operand is the 2\dash~ or 4\dash byte 
unsigned offset, respectively,
of a debugging information entry in the current compilation
unit. The DW\-\_OP\-\_call\-\_ref operator has a single operand. In the
32\dash bit DWARF format, the operand is a 4\dash byte unsigned value;
in the 64\dash bit DWARF format, it is an 8\dash byte unsigned value
(see Section \refersec{datarep:32bitand64bitdwarfformats}). 
The operand is used as the offset of a
debugging information entry in a .debug\_info or .debug\_types
section which may be contained in a shared object or executable
other than that containing the operator. For references from
one shared object or executable to another, the relocation
must be performed by the consumer.  

\textit{Operand interpretation of
DW\-\_OP\-\_call2, DW\-\_OP\-\_call4 and DW\-\_OP\-\_call\-\_ref is exactly like
that for DW\-\_FORM\-\_ref2, DW\-\_FORM\-\_ref4 and DW\-\_FORM\-\_ref\-\_addr,
respectively  
(see Section  \refersec{datarep:attributeencodings}).  
}

These operations transfer
control of DWARF expression evaluation to the 
DW\-\_AT\-\_location
attribute of the referenced debugging information entry. If
there is no such attribute, then there is no effect. Execution
of the DWARF expression of a DW\-\_AT\-\_location attribute may add
to and/or remove from values on the stack. Execution returns
to the point following the call when the end of the attribute
is reached. Values on the stack at the time of the call may be
used as parameters by the called expression and values left on
the stack by the called expression may be used as return values
by prior agreement between the calling and called expressions.
\end{enumerate}


\subsubsection{Special Operations}
There is one special operation currently defined:
\begin{enumerate}[1]
\item DW\-\_OP\-\_nop \\
The DW\-\_OP\-\_nop operation is a place holder. It has no effect
on the location stack or any of its values.

\end{enumerate}
\subsection{Example Stack Operations}
\textit {The stack operations defined in 
Section \refersec{chap:stackoperations}.
are fairly conventional, but the following
examples illustrate their behavior graphically.
}

\begin{tabular}{rrcrr} 
 &Before & Operation&& After \\

0& 17& \livelink{chap:DWOPdup}{DW\-\_OP\-\_dup} &0 &17 \\
1&   29& &  1 & 17 \\
2& 1000 & & 2 & 29\\
& & &         3&1000\\
& & & & \\
0 & 17 & \livelink{chap:DWOPdrop}{DW\-\_OP\-\_drop} & 0 & 29 \\
1 &29  &            & 1 & 1000 \\
2 &1000& & &          \\

& & & & \\
0 & 17 & \livelink{chap:DWOPpick}{DW\-\_OP\-\_pick} & 0 & 1000 \\
1 & 29 & & 1&17 \\
2 &1000& &2&29 \\
  &    & &3&1000 \\

& & & & \\
0&17& \livelink{chap:DWOPover}{DW\-\_OP\-\_over}&0&29 \\
1&29& &  1&17 \\
2&1000 & & 2&29\\
 &     & & 3&1000 \\

& & & & \\
0&17& \livelink{chap:DWOPswap}{DW\-\_OP\-\_swap} &0&29 \\
1&29& &  1&17 \\
2&1000 & & 2&1000 \\

& & & & \\
0&17&\livelink{chap:DWOProt}{DW\-\_OP\-\_rot} & 0 &29 \\
1&29 & & 1 & 1000 \\
2& 1000 & &  2 & 17 \\
\end{tabular}

\section{Location Descriptions}
\label{chap:locationdescriptions}
\textit{ Debugging information must provide consumers a way to find
the location of program variables, determine the bounds
of dynamic arrays and strings, and possibly to find the
base address of a subroutine’s stack frame or the return
address of a subroutine. Furthermore, to meet the needs of
recent computer architectures and optimization techniques,
debugging information must be able to describe the location of
an object whose location changes over the object’s lifetime.}

Information about the location of program objects is provided
by location descriptions. Location descriptions can be either
of two forms:
\begin{enumerate}[1]
\item \textit{Single location descriptions}, which are a language independent representation of
addressing rules of arbitrary complexity built from 
DWARF expressions (See section \refersec{chap:dwarfexpressions}) 
and/or other
DWARF operations specific to describing locations. They are
sufficient for describing the location of any object as long
as its lifetime is either static or the same as the lexical
block that owns it, and it does not move during its lifetime.

Single location descriptions are of two kinds:
\begin{enumerate}[a]
\item Simple location descriptions, which describe the location
of one contiguous piece (usually all) of an object. A simple
location description may describe a location in addressable
memory, or in a register, or the lack of a location (with or
without a known value).

\item  Composite location descriptions, which describe an
object in terms of pieces each of which may be contained in
part of a register or stored in a memory location unrelated
to other pieces.

\end{enumerate}
\item \textit{Location lists}, which are used to describe
objects that have a limited lifetime or change their location
during their lifetime. Location lists are more completely
described below.

\end{enumerate}

The two forms are distinguished in a context sensitive
manner. As the value of an attribute, a location description
is encoded using class \livelink{chap:exprloc}{exprloc}  
and a location list is encoded
using class \livelink{chap:loclistptr}{loclistptr} (which serves as an offset into a
separate location list table).


\subsection{Single Location Descriptions}
A single location description is either:

\begin{enumerate}[1]
\item A simple location description, representing an object
which exists in one contiguous piece at the given location, or 
\item A composite location description consisting of one or more
simple location descriptions, each of which is followed by
one composition operation. Each simple location description
describes the location of one piece of the object; each
composition operation describes which part of the object is
located there. Each simple location description that is a
DWARF expression is evaluated independently of any others
(as though on its own separate stack, if any). 
\end{enumerate}



\subsubsection{Simple Location Descriptions}

A simple location description consists of one 
contiguous piece or all of an object or value.


\paragraph{Memory Location Descriptions}

A memory location description consists of a non\dash empty DWARF
expression (see 
Section \refersec{chap:dwarfexpressions}
), whose value is the address of
a piece or all of an object or other entity in memory.

\paragraph{Register Location Descriptions}

A register location description consists of a register name
operation, which represents a piece or all of an object
located in a given register.

\textit{Register location descriptions describe an object
(or a piece of an object) that resides in a register, while
the opcodes listed in 
Section \refersec{chap:registerbasedaddressing}
are used to describe an object (or a piece of
an object) that is located in memory at an address that is
contained in a register (possibly offset by some constant). A
register location description must stand alone as the entire
description of an object or a piece of an object.
}

The following DWARF operations can be used to name a register.


\textit{Note that the register number represents a DWARF specific
mapping of numbers onto the actual registers of a given
architecture. The mapping should be chosen to gain optimal
density and should be shared by all users of a given
architecture. It is recommended that this mapping be defined
by the ABI authoring committee for each architecture.
}
\begin{enumerate}[1]
\item DW\-\_OP\-\_reg0, DW\-\_OP\-\_reg1, ..., DW\-\_OP\-\_reg31 \\
The DW\-\_OP\-\_regn operations encode the names of up to 32
registers, numbered from 0 through 31, inclusive. The object
addressed is in register n.

\item DW\-\_OP\-\_regx \\
The DW\-\_OP\-\_regx operation has a single unsigned LEB128 literal
operand that encodes the name of a register.  
\end{enumerate}

\textit{These operations name a register location. To
fetch the contents of a register, it is necessary to use
one of the register based addressing operations, such as
DW\-\_OP\-\_bregx 
(Section \refersec{chap:registerbasedaddressing})}.


\paragraph{Implicit Location Descriptions}

An implicit location description represents a piece or all
of an object which has no actual location but whose contents
are nonetheless either known or known to be undefined.

The following DWARF operations may be used to specify a value
that has no location in the program but is a known constant
or is computed from other locations and values in the program.

The following DWARF operations may be used to specify a value
that has no location in the program but is a known constant
or is computed from other locations and values in the program.

\begin{enumerate}[1]
\item DW\-\_OP\-\_implicit\-\_value \\
The DW\-\_OP\-\_implicit\-\_value operation specifies an immediate value
using two operands: an unsigned LEB128 length, followed by
a block representing the value in the memory representation
of the target machine. The length operand gives the length
in bytes of the block.

\item DW\-\_OP\-\_stack\-\_value \\
The DW\-\_OP\-\_stack\-\_value operation specifies that the object
does not exist in memory but its value is nonetheless known
and is at the top of the DWARF expression stack. In this form
of location description, the DWARF expression represents the
actual value of the object, rather than its location. The
DW\-\_OP\-\_stack\-\_value operation terminates the expression.
\end{enumerate}


\paragraph{Empty Location Descriptions}

An empty location description consists of a DWARF expression
containing no operations. It represents a piece or all of an
object that is present in the source but not in the object code
(perhaps due to optimization).

\subsubsection{Composite Location Descriptions}
A composite location description describes an object or
value which may be contained in part of a register or stored
in more than one location. Each piece is described by a
composition operation, which does not compute a value nor
store any result on the DWARF stack. There may be one or
more composition operations in a single composite location
description. A series of such operations describes the parts
of a value in memory address order.

Each composition operation is immediately preceded by a simple
location description which describes the location where part
of the resultant value is contained.

\begin{enumerate}[1]
\item DW\-\_OP\-\_piece \\
The DW\-\_OP\-\_piece operation takes a single operand, which is an
unsigned LEB128 number.  The number describes the size in bytes
of the piece of the object referenced by the preceding simple
location description. If the piece is located in a register,
but does not occupy the entire register, the placement of
the piece within that register is defined by the ABI.

\textit{Many compilers store a single variable in sets of registers,
or store a variable partially in memory and partially in
registers. DW\-\_OP\-\_piece provides a way of describing how large
a part of a variable a particular DWARF location description
refers to. }

\item DW\-\_OP\-\_bit\-\_piece \\
The DW\-\_OP\-\_bit\-\_piece operation takes two operands. The first
is an unsigned LEB128 number that gives the size in bits
of the piece. The second is an unsigned LEB128 number that
gives the offset in bits from the location defined by the
preceding DWARF location description.  

Interpretation of the
offset depends on the kind of location description. If the
location description is empty, the offset doesn’t matter and
the DW\-\_OP\-\_bit\-\_piece operation describes a piece consisting
of the given number of bits whose values are undefined. If
the location is a register, the offset is from the least
significant bit end of the register. If the location is a
memory address, the DW\-\_OP\-\_bit\-\_piece operation describes a
sequence of bits relative to the location whose address is
on the top of the DWARF stack using the bit numbering and
direction conventions that are appropriate to the current
language on the target system. If the location is any implicit
value or stack value, the DW\-\_OP\-\_bit\-\_piece operation describes
a sequence of bits using the least significant bits of that
value.  
\end{enumerate}

\textit{DW\-\_OP\-\_bit\-\_piece is used instead of DW\-\_OP\-\_piece when
the piece to be assembled into a value or assigned to is not
byte-sized or is not at the start of a register or addressable
unit of memory.}




\subsubsection{Example Single Location Descriptions}

Here are some examples of how DWARF operations are used to form location descriptions:

DW\-\_OP\-\_reg3
\begin{myindentpara}{1cm}
The value is in register 3.
\end{myindentpara}

DW\-\_OP\-\_regx 54
\begin{myindentpara}{1cm}
The value is in register 54.
\end{myindentpara}

DW\-\_OP\-\_addr 0x80d0045c
\begin{myindentpara}{1cm}
The value of a static variable is at machine address 0x80d0045c.
\end{myindentpara}

DW\-\_OP\-\_breg11 44
\begin{myindentpara}{1cm}
Add 44 to the value in register 11 to get the address of an automatic
variable instance.
\end{myindentpara}

DW\-\_OP\-\_fbreg -50
\begin{myindentpara}{1cm}
Given a DW\-\_AT\-\_frame\-\_base value of ``DW\-\_OP\-\_breg31 64,''this example
computes the address of a local variable that is -50 bytes from a
logical frame pointer that is computed by adding 64 to the current
stack pointer (register 31).
\end{myindentpara}

DW\-\_OP\-\_bregx 54 32 DW\-\_OP\-\_deref
\begin{myindentpara}{1cm}
A call-by-reference parameter whose address is in the word 32 bytes
from where register 54 points.
\end{myindentpara}

DW\-\_OP\-\_plus\-\_uconst 4
\begin{myindentpara}{1cm}
A structure member is four bytes from the start of the structure
instance. The base address is assumed to be already on the stack.
\end{myindentpara}

DW\-\_OP\-\_reg3 DW\-\_OP\-\_piece 4 DW\-\_OP\-\_reg10 DW\-\_OP\-\_piece 2
\begin{myindentpara}{1cm}
A variable whose first four bytes reside in register 3 and whose next
two bytes reside in register 10.
\end{myindentpara}

DW\-\_OP\-\_reg0 DW\-\_OP\-\_piece 4 DW\-\_OP\-\_piece 4 DW\-\_OP\-\_fbreg -12 DW\-\_OP\-\_piece 4
\begin{myindentpara}{1cm}
A twelve byte value whose first four bytes reside in register zero,
whose middle four bytes are unavailable (perhaps due to optimization),
and whose last four bytes are in memory, 12 bytes before the frame
base.
\end{myindentpara}

DW\-\_OP\-\_breg1 0 DW\-\_OP\-\_breg2 0 DW\-\_OP\-\_plus DW\-\_OP\-\_stack\-\_value
\begin{myindentpara}{1cm}
Add the contents of r1 and r2 to compute a value. This value is the
“contents” of an otherwise anonymous location.
\end{myindentpara}

DW\-\_OP\-\_lit1 DW\-\_OP\-\_stack\-\_value DW\-\_OP\-\_piece a \\
DW\-\_OP\-\_breg3 0 DW\-\_OP\-\_breg4 0 DW\-\_OP\-\_plus DW\-\_OP\-\_stack\-\_value DW\-\_OP\-\_piece 4
\begin{myindentpara}{1cm}
The object value is found in an anonymous (virtual) location whose
value consists of two parts, given in memory address order: the 4 byte
value 1 followed by the four byte value computed from the sum of the
contents of r3 and r4.
\end{myindentpara}


\subsection{Location Lists}
\label{chap:locationlists}
Location lists are used in place of location expressions
whenever the object whose location is being described
can change location during its lifetime. Location lists
are contained in a separate object file section called
.debug\_loc. A location list is indicated by a location
attribute whose value is an offset from the beginning of
the .debug\_loc section to the first byte of the list for the
object in question.

Each entry in a location list is either a location list entry,
a base address selection entry, or an end of list entry.

A location list entry consists of:

\begin{enumerate}[1]
\item A beginning address offset. 
This address offset has the size of an address and is
relative to the applicable base address of the compilation
unit referencing this location list. It marks the beginning
of the address range over which the location is valid.

\item An ending address offset.  This address offset again
has the size of an address and is relative to the applicable
base address of the compilation unit referencing this location
list. It marks the first address past the end of the address
range over which the location is valid. The ending address
must be greater than or equal to the beginning address.

\textit{A location list entry (but not a base address selection or end of list entry) whose beginning
and ending addresses are equal has no effect because the size of the range covered by such
an entry is zero.}

\item A single location description 
describing the location of the object over the range specified by
the beginning and end addresses.
\end{enumerate}

The applicable base address of a location list entry is
determined by the closest preceding base address selection
entry (see below) in the same location list. If there is
no such selection entry, then the applicable base address
defaults to the base address of the compilation unit (see
Section \refersec{chap:normalandpartialcompilationunitentries}).  
In the case of a compilation unit where all of
the machine code is contained in a single contiguous section,
no base address selection entry is needed.

Address ranges may overlap. When they do, they describe a
situation in which an object exists simultaneously in more than
one place. If all of the address ranges in a given location
list do not collectively cover the entire range over which the
object in question is defined, it is assumed that the object is
not available for the portion of the range that is not covered.

A base address selection entry consists of:
\begin{enumerate}[1]
\item The value of the largest representable 
address offset (for example, 0xffffffff when the size of
an address is 32 bits).
\item An address, which defines the 
appropriate base address for use in interpreting the beginning
and ending address offsets of subsequent entries of the location list.
\end{enumerate}


\textit{A base address selection entry 
affects only the list in which it is contained.}

The end of any given location list is marked by an end of
list entry, which consists of a 0 for the beginning address
offset and a 0 for the ending address offset. A location list
containing only an end of list entry describes an object that
exists in the source code but not in the executable program.

Neither a base address selection entry nor an end of list
entry includes a location description.

\textit{A base address selection entry and an end of list
entry for a location list are identical to a base address
selection entry and end of list entry, respectively, for a
range list 
(see Section \refersec{chap:noncontiguousaddressranges}) 
in interpretation
and representation.}






\section{Types of Program Entities}
\label{chap:typesofprogramentities}
Any debugging information entry describing a declaration that
has a type has a DW\-\_AT\-\_type attribute, whose value is a
reference to another debugging information entry. The entry
referenced may describe a base type, that is, a type that is
not defined in terms of other data types, or it may describe a
user-defined type, such as an array, structure or enumeration.
Alternatively, the entry referenced may describe a type
modifier, such as constant, packed, pointer, reference or
volatile, which in turn will reference another entry describing
a type or type modifier (using a DW\-\_AT\-\_type attribute of its
own). See 
Section  \refersec{chap:typeentries} 
for descriptions of the entries describing
base types, user-defined types and type modifiers.



\section{Accessibility of Declarations}
\label{chap:accessibilityofdeclarations}
\textit{Some languages, notably C++ and Ada, have the concept of
the accessibility of an object or of some other program
entity. The accessibility specifies which classes of other
program objects are permitted access to the object in question.}

The accessibility of a declaration is represented by a DW\-\_AT\-\_accessibility attribute, whose
value is a constant drawn from the set of codes listed in Figure 
\ref{fig:accessibilitycodes}.

\begin{figure}[here]
\begin{description}
\centering
\item [DW\-\_ACCESS\-\_public]
\item [DW\-\_ACCESS\-\_private]
\item [DW\-\_ACCESS\-\_protected]
\end{description}
\caption{Accessibility codes}
\label{fig:accessibilitycodes}
\end{figure}

\section{Visibility of Declarations}
\label{chap:visibilityofdeclarations}

\textit{Several languages (such as Modula-2) 
have the concept of the visibility of a declaration. The
visibility specifies which declarations are to be 
visible outside of the entity in which they are
declared.}

The visibility of a declaration is represented 
by a DW\-\_AT\-\_visibility attribute, whose value is a
constant drawn from the set of codes listed in 
Figure \ref{fig:visibilitycodes}.

\begin{figure}[here]
\begin{description}
\centering
\item [DW\-\_VIS\-\_local]
\item [DW\-\_VIS\-\_exported]
\item [DW\-\_VIS\-\_qualified]
\end{description}
\caption{Visibility codes}
\label{fig:visibilitycodes}
\end{figure}

\section{Virtuality of Declarations}
\label{chap:virtualityofdeclarations}
\textit{C++ provides for virtual and pure virtual structure or class
member functions and for virtual base classes.}

The virtuality of a declaration is represented by a
DW\-\_AT\-\_virtuality attribute, whose value is a constant drawn
from the set of codes listed in 
Figure \ref{fig:virtualitycodes}.

\begin{figure}[here]
\begin{description}
\centering
\item [DW\-\_VIRTUALITY\-\_none]
\item [DW\-\_VIRTUALITY\-\_virtual]
\item [DW\-\_VIRTUALITY\-\_pure\-\_virtual]
\end{description}
\caption{Virtuality codes}
\label{fig:virtualitycodes}
\end{figure}

\section{Artificial Entries}
\label{chap:artificialentries}
\textit{A compiler may wish to generate debugging information entries
for objects or types that were not actually declared in the
source of the application. An example is a formal parameter
entry to represent the hidden this parameter that most C++
implementations pass as the first argument to non-static member
functions.}  

Any debugging information entry representing the
declaration of an object or type artificially generated by
a compiler and not explicitly declared by the source program
may have a DW\-\_AT\-\_artificial attribute, which is a flag.

\section{Segmented Addresses}
\label{chap:segmentedaddresses}
\textit{In some systems, addresses are specified as offsets within a
given segment rather than as locations within a single flat
address space.}

Any debugging information entry that contains a description
of the location of an object or subroutine may have
a DW\-\_AT\-\_segment attribute, whose value is a location
description. The description evaluates to the segment selector
of the item being described. If the entry containing the
DW\-\_AT\-\_segment attribute has a DW\-\_AT\-\_low\-\_pc, DW\-\_AT\-\_high\-\_pc,
DW\-\_AT\-\_ranges or DW\-\_AT\-\_entry\-\_pc attribute, or a location
description that evaluates to an address, then those address
values represent the offset portion of the address within
the segment specified by DW\-\_AT\-\_segment.

If an entry has no DW\-\_AT\-\_segment attribute, it inherits
the segment value from its parent entry.  If none of the
entries in the chain of parents for this entry back to
its containing compilation unit entry have DW\-\_AT\-\_segment
attributes, then the entry is assumed to exist within a flat
address space. Similarly, if the entry has a DW\-\_AT\-\_segment
attribute containing an empty location description, that
entry is assumed to exist within a flat address space.

\textit{Some systems support different classes of addresses. The
address class may affect the way a pointer is dereferenced
or the way a subroutine is called.}


Any debugging information entry representing a pointer or
reference type or a subroutine or subroutine type may have
a DW\-\_AT\-\_address\-\_class attribute, whose value is an integer
constant.  The set of permissible values is specific to
each target architecture. The value DW\-\_ADDR\-\_none, however,
is common to all encodings, and means that no address class
has been specified.

\textit {For example, the Intel386 ™ processor might use the following values:}

\begin{figure}[here]
\centering
\begin{tabular}{lll} 
Name&Value&Meaning  \\
\hline
\textit{DW\-\_ADDR\-\_none}&   0 & \textit{no class specified} \\
\textit{DW\-\_ADDR\-\_near16}& 1 & \textit{16\dash bit offset, no segment} \\
\textit{DW\-\_ADDR\-\_far16}&  2 & \textit{16\dash bit offset, 16\dash bit segment} \\
\textit{DW\-\_ADDR\-\_huge16}& 3 & \textit{16\dash bit offset, 16\dash bit segment} \\
\textit{DW\-\_ADDR\-\_near32}& 4 & \textit{32\dash bit offset, no segment} \\
\textit{DW\-\_ADDR\-\_far32}&  5 & \textit{32\dash bit offset, 16\dash bit segment}
\end{tabular}
\caption{Example address class codes}
\label{fig:inteladdressclasstable}
\end{figure}

\section{Non-Defining Declarations and Completions}
\label{nondefiningdeclarationsandcompletions}
A debugging information entry representing a program entity
typically represents the defining declaration of that
entity. In certain contexts, however, a debugger might need
information about a declaration of an entity that is not
also a definition, or is otherwise incomplete, to evaluate
an expression correctly.

\textit{As an example, consider the following fragment of C code:}

\begin{lstlisting}
void myfunc()
{
  int x;
  {
    extern float x;
    g(x);
  }
}
\end{lstlisting}


\textit{C scoping rules require that the 
value of the variable x passed to the function g is the value of the
global variable x rather than of the local version.}


\section{Declaration Coordinates}
\label{chap:declarationcoordinates}
\textit{It is sometimes useful in a debugger to be able to associate
a declaration with its occurrence in the program source.
}

Any debugging information entry representing the
declaration of an object, module, subprogram or type may have
DW\-\_AT\-\_decl\-\_file, DW\-\_AT\-\_decl\-\_line and DW\-\_AT\-\_decl\-\_column
attributes each of whose value is an unsigned integer constant.

The value of the DW\-\_AT\-\_decl\-\_file attribute corresponds to
a file number from the line number information table for the
compilation unit containing the debugging information entry and
represents the source file in which the declaration appeared
(see Section 6.2). The value 0 indicates that no source file
has been specified.

The value of the DW\-\_AT\-\_decl\-\_line attribute represents
the source line number at which the first character of
the identifier of the declared object appears. The value 0
indicates that no source line has been specified.

The value of the DW\-\_AT\-\_decl\-\_column attribute represents
the source column number at which the first character of
the identifier of the declared object appears. The value 0
indicates that no column has been specified.

\section{Identifier Names}
\label{chap:identifiernames}
Any debugging information entry representing a program entity
that has been given a name may have a DW\-\_AT\-\_name attribute,
whose value is a string representing the name as it appears in
the source program. A debugging information entry containing
no name attribute, or containing a name attribute whose value
consists of a name containing a single null byte, represents
a program entity for which no name was given in the source.

\textit{Because the names of program objects described by DWARF are the
names as they appear in the source program, implementations
of language translators that use some form of mangled name
(as do many implementations of C++) should use the unmangled
form of the name in the DWARF DW\-\_AT\-\_name attribute,
including the keyword operator (in names such as “operator
+”), if present. See also 
Section \refersec{chap:linkagenames} regarding the use
of DW\-\_AT\-\_linkage\-\_name for mangled names. Sequences of
multiple whitespace characters may be compressed.}

\section{Data Locations and DWARF Procedures}
Any debugging information entry describing a data object (which
includes variables and parameters) or common block may have a
DW\-\_AT\-\_location attribute, whose value is a location description
(see Section 2.6).  

A DWARF procedure is represented by any
kind of debugging information entry that has a DW\-\_AT\-\_location
attribute. If a suitable entry is not otherwise available,
a DWARF procedure can be represented using a debugging
information entry with the 
tag \livetarg{chap:DWTAGdwarfprocedure}{DW\-\_TAG\-\_dwarf\-\_procedure}
together with a DW\-\_AT\-\_location attribute.  

A DWARF procedure
is called by a DW\-\_OP\-\_call2, 
DW\-\_OP\-\_call4 or 
DW\-\_OP\-\_call\-\_ref
DWARF expression operator 
(see Section \refersec{chap:controlflowoperations}).

\section{Code Addresses and Ranges}
\label{chap:codeaddressesandranges}
Any debugging information entry describing an entity that has
a machine code address or range of machine code addresses,
which includes compilation units, module initialization,
subroutines, ordinary blocks, try/catch blocks, labels and
the like, may have

\begin{itemize}
\item A DW\-\_AT\-\_low\-\_pc and DW\-\_AT\-\_high\-\_pc pair of 
attributes for a single contiguous range of
addresses, or

\item A DW\-\_AT\-\_ranges attribute for a non-contiguous range of addresses.
\end{itemize}

In addition, a non-contiguous range of 
addresses may also be specified for the
DW\-\_AT\-\_start\-\_scope attribute.
If an entity has no associated machine code, 
none of these attributes are specified.

\subsection{Single Address} 
When there is a single address associated with an entity,
such as a label or alternate entry point of a subprogram,
the entry has a DW\-\_AT\-\_low\-\_pc attribute whose value is the
relocated address for the entity.  While the DW\-\_AT\-\_entry\-\_pc
attribute might also seem appropriate for this purpose,
historically the DW\-\_AT\-\_low\-\_pc attribute was used before the
DW\-\_AT\-\_entry\-\_pc was introduced (in DWARF Version 3). There is
insufficient reason to change this.

\subsection{Continuous Address Range}
\label{chap:contiguousaddressranges}
When the set of addresses of a debugging information entry can
be described as a single continguous range, the entry may have
a DW\-\_AT\-\_low\-\_pc and DW\-\_AT\-\_high\-\_pc pair of attributes. The value
of the DW\-\_AT\-\_low\-\_pc attribute is the relocated address of the
first instruction associated with the entity. If the value of
the DW\-\_AT\-\_high\-\_pc is of class address, it is the relocated
address of the first location past the last instruction
associated with the entity; if it is of class constant, the
value is an unsigned integer offset which when added to the
low PC gives the address of the first location past the last
instruction associated with the entity.  The high PC value
may be beyond the last valid instruction in the executable.
The presence of low and high PC attributes for an entity
implies that the code generated for the entity is contiguous
and exists totally within the boundaries specified by those
two attributes. If that is not the case, no low and high PC
attributes should be produced.

\subsection{Non\dash Contiguous Address Ranges}
\label{chap:noncontiguousaddressranges}
When the set of addresses of a debugging information entry
cannot be described as a single contiguous range, the entry has
a DW\-\_AT\-\_ranges attribute whose value is of class \livelink{chap:rangelistptr}{rangelistptr}
and indicates the beginning of a range list. Similarly,
a DW\-\_AT\-\_start\-\_scope attribute may have a value of class
\livelink{chap:rangelistptr}{rangelistptr} for the same reason.  

Range lists are contained
in a separate object file section called .debug\_ranges. A
range list is indicated by a DW\-\_AT\-\_ranges attribute whose
value is represented as an offset from the beginning of the
.debug\_ranges section to the beginning of the range list.

Each entry in a range list is either a range list entry,
a base address selection entry, or an end of list entry.

A range list entry consists of:

\begin{enumerate}[1]
\item A beginning address offset. This address offset has the size of an address and is relative to
the applicable base address of the compilation unit referencing this range list. It marks the
beginning of an address range.

\item An ending address offset. This address offset again has the size of an address and is relative
to the applicable base address of the compilation unit referencing this range list. It marks the
first address past the end of the address range.The ending address must be greater than or
equal to the beginning address.

\textit{A range list entry (but not a base address selection or end of list entry) whose beginning and
ending addresses are equal has no effect because the size of the range covered by such an
entry is zero.}
\end{enumerate}

The applicable base address of a range list entry is determined
by the closest preceding base address selection entry (see
below) in the same range list. If there is no such selection
entry, then the applicable base address defaults to the base
address of the compilation unit 
(see Section \refersec{chap:normalandpartialcompilationunitentries}).

\textit{In the case of a compilation unit where all of the machine
code is contained in a single contiguous section, no base
address selection entry is needed.}

Address range entries in
a range list may not overlap. There is no requirement that
the entries be ordered in any particular way.

A base address selection entry consists of:

\begin{enumerate}[1]
\item The value of the largest representable address offset (for example, 0xffffffff when the size of
an address is 32 bits).

\item An address, which defines the appropriate base address for use in interpreting the beginning
and ending address offsets of subsequent entries of the location list.
\end{enumerate}
\textit{A base address selection entry 
affects only the list in which it is contained.}


The end of any given range list is marked by an end of
list entry, which consists of a 0 for the beginning address
offset and a 0 for the ending address offset. A range list
containing only an end of list entry describes an empty scope
(which contains no instructions).

\textit{A base address selection entry and an end of list entry for
a range list are identical to a base address selection entry
and end of list entry, respectively, for a location list
(see Section 2.6.2) in interpretation and representation.}



\section{Entry Address}
\label{chap:entryaddress}
\textit{The entry or first executable instruction generated
for an entity, if applicable, is often the lowest addressed
instruction of a contiguous range of instructions. In other
cases, the entry address needs to be specified explicitly.}

Any debugging information entry describing an entity that has
a range of code addresses, which includes compilation units,
module initialization, subroutines, ordinary blocks, try/catch
blocks, and the like, may have a DW\-\_AT\-\_entry\-\_pc attribute to
indicate the first executable instruction within that range
of addresses. The value of the DW\-\_AT\-\_entry\-\_pc attribute is a
relocated address. If no DW\-\_AT\-\_entry\-\_pc attribute is present,
then the entry address is assumed to be the same as the
value of the DW\-\_AT\-\_low\-\_pc attribute, if present; otherwise,
the entry address is unknown.

\section{Static and Dynamic Values of Attributes}
\label{chap:staticanddynamicvaluesofattributes}

Some attributes that apply to types specify a property (such
as the lower bound of an array) that is an integer value,
where the value may be known during compilation or may be
computed dynamically during execution.  The value of these
attributes is determined based on the class as follows:

\begin{itemize}
\item For a \livelink{chap:constant}{constant}, the value of the constant is the value of
the attribute.

\item For a \livelink{chap:reference}{reference}, the
value is a reference to another
entity which specifies the value of the attribute.

\item For an \livelink{chap:exprloc}{exprloc}, the value is interpreted as a 
DWARF expression; 
evaluation of the expression yields the value of
the attribute.
\end{itemize}

\textit{
Whether an attribute value can be dynamic depends on the
rules of the applicable programming language.
}

\textit{The applicable attributes include: 
DW\-\_AT\-\_allocated,
DW\-\_AT\-\_associated, 
DW\-\_AT\-\_bit\-\_offset, 
DW\-\_AT\-\_bit\-\_size,
DW\-\_AT\-\_byte\-\_size, 
DW\-\_AT\-\_count, 
DW\-\_AT\-\_lower\-\_bound,
DW\-\_AT\-\_byte\-\_stride, 
DW\-\_AT\-\_bit\-\_stride, 
DW\-\_AT\-\_upper\-\_bound (and
possibly others).}


\section{Entity Descriptions}
\textit{Some debugging information entries may describe entities
in the program that are artificial, or which otherwise are
``named'' in ways which are not valid identifiers in the
programming language. For example, several languages may
capture or freeze the value of a variable at a particular
point in the program. Ada 95 has package elaboration routines,
type descriptions of the form typename’Class, and 
``access typename'' parameters.  }

Generally, any debugging information
entry that has, or may have, a DW\-\_AT\-\_name attribute, may
also have a DW\-\_AT\-\_description attribute whose value is a
null-terminated string providing a description of the entity.


\textit{It is expected that a debugger will only display these
descriptions as part of the description of other entities. It
should not accept them in expressions, nor allow them to be
assigned, or the like.}

\section{Byte and Bit Sizes}
\label{chap:byteandbitsizes}
% Some trouble here with hbox full, so we try optional word breaks.
Many debugging information entries allow either a
DW\-\_AT\-\_byte\-\_size attribute or a DW\-\_AT\-\_bit\-\_size attribute,
whose integer constant value 
(see \refersec{chap:staticanddynamicvaluesofattributes}) 
specifies an
amount of storage. The value of the DW\-\_AT\-\_byte\-\_size attribute
is interpreted in bytes and the value of the DW\-\_AT\-\_bit\-\_size
attribute is interpreted in bits.  

Similarly, the integer
constant value of a DW\-\_AT\-\_byte\-\_stride attribute is interpreted
in bytes and the integer constant value of a DW\-\_AT\-\_bit\-\_stride
attribute is interpreted in bits.

\section{Linkage Names}
\label{chap:linkagenames}
\textit{Some language implementations, notably C++ and similar
languages, make use of implementation defined names within
object files that are different from the identifier names
(see \refersec{chap:identifiernames}) of entities as they appear in the
source. Such names, sometimes known as mangled names,
are used in various ways, such as: to encode additional
information about an entity, to distinguish multiple entities
that have the same name, and so on. When an entity has an
associated distinct linkage name it may sometimes be useful
for a producer to include this name in the DWARF description
of the program to facilitate consumer access to and use of
object file information about an entity and/or information
that is encoded in the linkage name itself.  
}

% Some trouble maybe with hbox full, so we try optional word breaks.
A debugging
information entry may have a DW\-\_AT\-\_linkage\-\_name attribute
whose value is a null-terminated string describing the object
file linkage name associated with the corresponding entity.

% Some trouble here with hbox full, so we try optional word breaks.
\textit{Debugging information entries to which DW\-\_AT\-\_linkage\-\_name
may apply include: \livelink{chap:DWTAGcommonblock}{DW\-\_TAG\-\_common\-\_block}, \livelink{chap:DWTAGconstant}{DW\-\_TAG\-\_constant},
\livelink{chap:DWTAGentrypoint}{DW\-\_TAG\-\_entry\-\_point}, \livelink{chap:DWTAGsubprogram}{DW\-\_TAG\-\_subprogram} 
and \livelink{chap:DWTAGvariable}{DW\-\_TAG\-\_variable}.
}
