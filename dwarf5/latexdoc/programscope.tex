\chapter{Program Scope Entries}
\label{chap:programscopeentries} 
This section describes debugging information entries that
relate to different levels of program scope: compilation,
module, subprogram, and so on. Except for separate type
entries (see Section \refersec{chap:typeunitentries}), 
these entries may be thought of
as bounded by ranges of text addresses within the program.

\section{Unit Entries}
\label{chap:unitentries}
An object file may contain one or more compilation units,
of which there are
\addtoindexx{unit|see {compilation unit}} 
\addtoindexx{compilation unit}
these kinds:
normal compilation units,
partial compilation units, 
type units,\addtoindexx{type unit} and
skeleton units. A 
\addtoindex{partial compilation unit}
is related to one or more other compilation units that
import it.  
A skeleton unit contains only a subset of the attributes of 
a full normal or partial compilation unit plus two attributes 
used to locate the DWARF object file where the full 
compilation unit can be found.
A \addtoindex{type unit} represents a single complete type 
in a compilation unit of its own.
Either a normal compilation unit or a 
\addtoindex{partial compilation unit}
may be logically incorporated into another
compilation unit using an 
\addtoindex{imported unit entry}
(see Section \refersec{chap:importedunitentries}).


\subsection[Normal and Partial CU Entries]{Normal and Partial Compilation Unit Entries}
\label{chap:normalandpartialcompilationunitentries}
 
A \addtoindex{normal compilation unit}\addtoindexx{compilation unit!normal} 
is represented by a debugging information entry with the tag 
\DWTAGcompileunitTARG. 
A \addtoindex{partial compilation unit}\addtoindexx{compilation unit!partial} 
is represented by a debugging information entry with the tag 
\DWTAGpartialunitTARG.

\needlines{6}
In a simple normal compilation, a single compilation unit with
the tag 
\DWTAGcompileunit{} represents a complete object file
and the tag 
\DWTAGpartialunit{} is not used. 
In a compilation
employing the DWARF space compression and duplicate elimination
techniques from 
Appendix \refersec{app:usingcompilationunits}, 
multiple compilation units using
the tags 
\DWTAGcompileunit{} and/or 
\DWTAGpartialunit{} are
used to represent portions of an object file.

\textit{A normal compilation unit typically represents the text and
data contributed to an executable by a single relocatable
object file. It may be derived from several source files,
including pre-processed header files. 
A \addtoindex{partial compilation unit} typically represents a part of the text
and data of a relocatable object file, in a manner that can
potentially be shared with the results of other compilations
to save space. It may be derived from an \doublequote{include file,}
template instantiation, or other implementation\dash dependent
portion of a compilation. A normal compilation unit can also
function in a manner similar to a partial compilation unit
in some cases.}

A compilation unit entry owns debugging information
entries that represent all or part of the declarations
made in the corresponding compilation. In the case of a
partial compilation unit, the containing scope of its owned
declarations is indicated by imported unit entries in one
or more other compilation unit entries that refer to that
partial compilation unit (see 
Section \refersec{chap:importedunitentries}).


Compilation unit entries may have the following 
attributes:
\begin{enumerate}[1. ]
\item Either a \DWATlowpc{} and 
\DWAThighpc{} pair of
\addtoindexx{high PC attribute}
attributes 
\addtoindexx{low PC attribute}
or 
\addtoindexx{ranges attribute}
a 
\DWATranges{} attribute
\addtoindexx{ranges attribute}
whose values encode 
\addtoindexx{discontiguous address ranges|see{non-contiguous address ranges}}
the
contiguous or 
non\dash contiguous address ranges, respectively,
of the machine instructions generated for the compilation
unit (see Section \refersec{chap:codeaddressesandranges}).
  
A \DWATlowpc{} attribute 
may also
be specified 
in combination 
\addtoindexx{ranges attribute}
with 
\DWATranges{} to specify the
\addtoindexx{ranges attribute}
default base address for use in 
\addtoindexx{location list}
location lists (see Section
\refersec{chap:locationlists}) and range lists 
\addtoindexx{range list}
(see Section \refersec{chap:noncontiguousaddressranges}).

\item A \DWATname{} attribute 
\addtoindexx{name attribute}
whose value is a null\dash terminated
string 
\hypertarget{chap:DWATnamepathnameofcompilationsource}{}
containing the full or relative path name of the primary
source file from which the compilation unit was derived.

\item A \DWATlanguage{} attribute 
\addtoindexx{language attribute}
whose constant value is an
\hypertarget{chap:DWATlanguageprogramminglanguage}{}
integer code 
\addtoindexx{language attribute}
indicating the source language of the compilation
unit. The set of language names and their meanings are given
in Table \refersec{tab:languagenames}.

\begin{centering}
  \setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|l}
  \caption{Language names} \label{tab:languagenames} \\
  \hline \bfseries Language name & \bfseries Meaning \\ \hline
\endfirsthead
  \bfseries Language name & \bfseries Meaning \\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
\endlastfoot
\addtoindexx{ISO-defined language names}
\DWLANGAdaeightythreeTARG{} \dag & ISO Ada:1983 \addtoindexx{Ada:1983 (ISO)} \\
\DWLANGAdaninetyfiveTARG{}  \dag & ISO Ada:1995 \addtoindexx{Ada:1995 (ISO)} \\
\DWLANGCTARG & Non-standardized C, such as K\&R \addtoindexx{C!non-standard}\\
\DWLANGCeightynineTARG & ISO C:1989 \addtoindexx{C:1989 (ISO)} \\
\DWLANGCninetynineTARG & ISO C:1999 \addtoindexx{C:1999 (ISO)} \\
\DWLANGCelevenTARG     & ISO C:2011 \addtoindexx{C:2011 (ISO)} \\
\DWLANGCplusplusTARG          & ISO C++:1998 \addtoindexx{C++:1998 (ISO)} \\
\DWLANGCpluspluszerothreeTARG & ISO C++:2003 \addtoindexx{C++:2003 (ISO)} \\
\DWLANGCpluspluselevenTARG    & ISO C++:2011 \addtoindexx{C++:2011 (ISO)} \\
\DWLANGCplusplusfourteenTARG  & ISO C++:2014 \addtoindexx{C++:2014 (ISO)} \\
\DWLANGCobolseventyfourTARG & ISO COBOL:1974 \addtoindexx{COBOL:1974 (ISO)} \\
\DWLANGCoboleightyfiveTARG  & ISO COBOL:1985 \addtoindexx{COBOL:1985 (ISO)} \\
\DWLANGDTARG{}~\dag & D \addtoindexx{D language} \\
\DWLANGDylanTARG~\dag & Dylan \addtoindexx{Dylan} \\
\DWLANGFortranseventysevenTARG & ISO FORTRAN:1977 \addtoindexx{FORTRAN:1977 (ISO)} \\
\DWLANGFortranninetyTARG       & ISO Fortran:1990 \addtoindexx{Fortran:1990 (ISO)} \\
\DWLANGFortranninetyfiveTARG   & ISO Fortran:1995 \addtoindexx{Fortran:1995 (ISO)} \\
\DWLANGFortranzerothreeTARG    & ISO Fortran:2004 \addtoindexx{Fortran:2004 (ISO)} \\
\DWLANGFortranzeroeightTARG    & ISO Fortran:2010 \addtoindexx{Fortran:2010 (ISO)} \\
\DWLANGGoTARG{}~\dag & \addtoindex{Go} \\
\DWLANGHaskellTARG{} \dag & \addtoindex{Haskell} \\
\DWLANGJavaTARG{} & \addtoindex{Java}\\
\DWLANGJuliaTARG{}~\dag & \addtoindex{Julia} \\
\DWLANGModulatwoTARG   & ISO Modula\dash 2:1996 \addtoindexx{Modula-2:1996 (ISO)} \\
\DWLANGModulathreeTARG & \addtoindex{Modula-3} \\
\DWLANGObjCTARG{}         & \addtoindex{Objective C} \\
\DWLANGObjCplusplusTARG{} & \addtoindex{Objective C++} \\
\DWLANGOCamlTARG{}~\dag  & \addtoindex{OCaml}\index{Objective Caml|see{OCaml}} \\
\DWLANGOpenCLTARG{}~\dag & \addtoindex{OpenCL} \\
\DWLANGPascaleightythreeTARG & ISO Pascal:1983 \addtoindexx{Pascal:1983 (ISO)} \\
\DWLANGPLITARG{}~\dag & ANSI PL/I:1976 \addtoindexx{PL/I:1976 (ANSI)} \\
\DWLANGPythonTARG{}~\dag & \addtoindex{Python} \\
\DWLANGRustTARG{}~\dag & \addtoindex{Rust} \\
\DWLANGSwiftTARG{}~\dag & \addtoindex{Swift} \\
\DWLANGUPCTARG{} & UPC (Unified Parallel C) \addtoindexx{UPC}  
                         \index{Unified Parallel C|see{UPC}} \\ 
\hline
\dag \ \ \textit{Support for these languages is limited}& \\
\end{longtable}
\end{centering}

\needlines{6}
\item A \DWATstmtlist{}\hypertarget{chap:DWATstmtlistlinenumberinformationforunit}{}
attribute whose value is 
\addtoindexx{statement list attribute}
a
\addtoindexx{section offset!in statement list attribute}
section offset to the line number information for this compilation
unit.

This information is placed in a separate object file
section from the debugging information entries themselves. The
value of the statement list attribute is the offset in the
\dotdebugline{} section of the first byte of the line number
information for this compilation unit 
(see Section \refersec{chap:linenumberinformation}).

\item A \DWATmacros{}\hypertarget{chap:DWATmacrosmacroinformation}{}
attribute 
\addtoindexx{macro information attribute}
whose value is a 
\addtoindexx{section offset!in macro information attribute}
section offset to the macro information for this compilation unit.

This information is placed in a separate object file section
from the debugging information entries themselves. The
value of the macro information attribute is the offset in
the \dotdebugmacro{} section of the first byte of the macro
information for this compilation unit 
(see Section \refersec{chap:macroinformation}).

\textit{The \DWATmacros{} attribute is new in \DWARFVersionV, 
and supersedes the 
\DWATmacroinfo{} attribute of earlier DWARF versions.
\livetarg{chap:DWATmacroinfomacroinformation}{}
While \DWATmacros{} and \DWATmacroinfo{} attributes cannot both occur in the same
compilation unit, both may be found in the set of units that make up an executable
or shared object file. The two attributes have distinct encodings to facilitate such
coexistence.}

\needlines{6}
\item  A 
\DWATcompdir{} 
attribute 
\hypertarget{chap:DWATcompdircompilationdirectory}{}
whose value is a
null\dash terminated string containing the current working directory
of the compilation command that produced this compilation
unit in whatever form makes sense for the host system.

\item  A \DWATproducer{} attribute 
\addtoindexx{producer attribute}
whose value is a null\dash
terminated string containing information about the compiler
\hypertarget{chap:DWATproducercompileridentification}{}
that produced the compilation unit. The actual contents of
the string will be specific to each producer, but should
begin with the name of the compiler vendor or some other
identifying character sequence that should avoid confusion
with other producer values.

\needlines{4}
\item  A \DWATidentifiercase{} 
attribute 
\addtoindexx{identifier case attribute}
whose integer
\hypertarget{chap:DWATidentifiercaseidentifiercaserule}{}
constant value is a code describing the treatment
of identifiers within this compilation unit. The
set of identifier case codes is given in
Table \refersec{tab:identifiercasecodes}.

\begin{simplenametable}{Identifier case codes}{tab:identifiercasecodes}
\DWIDcasesensitive{}      \\
\DWIDupcase{}             \\
\DWIDdowncase{}           \\
\DWIDcaseinsensitive{}    \\
\end{simplenametable}

\DWIDcasesensitiveTARG{} is the default for all compilation units
that do not have this attribute.  It indicates that names given
as the values of \DWATname{} attributes 
\addtoindexx{name attribute}
in debugging information
entries for the compilation unit reflect the names as they
appear in the source program. The debugger should be sensitive
to the case of \addtoindex{identifier names} when doing identifier 
lookups.

\needlines{4}
\DWIDupcaseTARG{} means that the 
producer of the debugging
information for this compilation unit converted all source
names to upper case. The values of the name attributes may not
reflect the names as they appear in the source program. The
debugger should convert all names to upper case when doing
lookups.

\DWIDdowncaseTARG{} means that 
the producer of the debugging
information for this compilation unit converted all source
names to lower case. The values of the name attributes may not
reflect the names as they appear in the source program. The
debugger should convert all names to lower case when doing
lookups.

\needlines{4}
\DWIDcaseinsensitiveTARG{} means that the values of the name
attributes reflect the names as they appear in the source
program but that a case insensitive lookup should be used to
access those names.

\needlines{5}
\item A \DWATbasetypes{} attribute whose value is a 
\livelink{chap:classreference}{reference}.

This 
\hypertarget{chap:DWATbasetypesprimitivedatatypesofcompilationunit}{}
attribute 
\addtoindexx{base types attribute}
points to a debugging information entry
representing another compilation unit.  It may be used
to specify the compilation unit containing the base type
entries used by entries in the current compilation unit
(see Section \refersec{chap:basetypeentries}).

\needlines{6}
\textit{This attribute provides a consumer a way to find the definition
of base types for a compilation unit that does not itself
contain such definitions. This allows a consumer, for example,
to interpret a type conversion to a base type 
% getting this link target at the right spot is tricky.
\hypertarget{chap:DWATuseUTF8compilationunitusesutf8strings}{}
correctly.}

\item A \DWATuseUTFeight{} attribute,
\addtoindexx{use UTF8 attribute}\addtoindexx{UTF-8} 
which is a \livelink{chap:classflag}{flag} whose
presence indicates that all strings (such as the names of
declared entities in the source program, or filenames in the line number table) 
are represented using the UTF\dash 8 representation. 

\needlines{4}
\item A \DWATmainsubprogram{} attribute, which is a \livelink{chap:classflag}{flag}
\addtoindexx{main subprogram attribute}
whose presence indicates 
\hypertarget{chap:DWATmainsubprogramunitcontainingmainorstartingsubprogram}{}
that the compilation unit contains a
subprogram that has been identified as the starting function
of the program. If more than one compilation unit contains
this \nolink{flag}, any one of them may contain the starting function.

\textit{\addtoindex{Fortran} has a \addtoindex{PROGRAM statement}
which is used
to specify and provide a user\dash specified name for the main
subroutine of a program. 
\addtoindex{C} uses the name \doublequote{main} to identify
the main subprogram of a program. Some other languages provide
similar or other means to identify the main subprogram of
a program. The \DWATmainsubprogram{} attribute may also be used to
identify such subprograms (see 
Section \refersec{chap:generalsubroutineandentrypointinformation}).}

\item A \DWATentrypc{} attribute whose value is the address of the first
\hypertarget{chap:DWATentrypcofcompileunit}{}
\hypertarget{chap:DWATentrypcofpartialunit}{}
\addtoindexx{entry pc attribute!for normal compilation unit}
\addtoindexx{entry pc attribute!for partial compilation unit}
executable instruction of the unit (see 
Section \refersec{chap:entryaddress}).

\needlines{8}
\item A \DWATstroffsetsbaseNAME\addtoindexx{string offset base attribute}
\hypertarget{chap:DWATstroffsetbaseforindirectstringtable}{} 
attribute, whose value is a reference. 
This attribute points to the first string
offset of the compilation unit's contribution to the
\dotdebugstroffsets{} (or \dotdebugstroffsetsdwo{}) section. 
Indirect string references
(using \DWFORMstrx) within the compilation unit are
interpreted as indices relative to this base.

\needlines{6}
\item A \DWATaddrbaseNAME\addtoindexx{address table base attribute}
\hypertarget{chap:DWATaddrbaseforaddresstable}{}
attribute, whose value is a reference.
This attribute points to the beginning of the compilation
unit's contribution to the \dotdebugaddr{} section.
Indirect references (using \DWFORMaddrx, \DWOPaddrx, 
\DWOPconstx, \DWLLEbaseaddressselectionentry{}, 
\DWLLEstartendentry, or \DWLLEstartlengthentry) within the compilation unit are
interpreted as indices relative to this base.

\needlines{5}
\item A \DWATrangesbaseNAME\addtoindexx{ranges table base attribute}
\hypertarget{chap:DWATrangesbaseforrangelists}{}
attribute, whose value is a reference.
This attribute points to the beginning of the compilation
unit's contribution to the \dotdebugranges{} section.
References to range lists (using \DWFORMsecoffset)
within the compilation unit are
interpreted as offsets relative to this base.

\end{enumerate}

The  base address of a compilation unit is defined as the
value of the \DWATlowpc{} attribute, if present; otherwise,
it is undefined. If the base address is undefined, then any
DWARF entry or structure defined in terms of the base address
of that compilation unit is not valid.

\subsection{Skeleton Compilation Unit Entries}
\label{chap:skeletoncompilationunitentries}
\addtoindexx{compilation unit!skeleton}
\addtoindexx{skeleton compilation unit}
When generating a \splitDWARFobjectfile{} (see 
Section \refersec{datarep:splitdwarfobjectfiles}), the
compilation unit in the \dotdebuginfo{} section is a "skeleton"
compilation unit, which contains \DWATdwoname{} and \DWATdwoid{}
attributes as well as a subset of the
attributes of a full normal or partial compilation unit. In general, 
it contains those attributes that are necessary for the consumer
to locate the object file where the full compilation unit
can be found, and for the consumer to interpret references to
addresses in the program. 

A skeleton compilation unit has \DWATdwoname{} and 
\DWATdwoid{} attributes and no children; it may have additional
attributes from among the following:
\begin{enumerate}[1. ]

\item
Either a \DWATlowpc{} and \DWAThighpc{} pair of attributes
or a \DWATranges{} attribute (the same as for regular
compilation unit entries).

\item
A \DWATstmtlist{} attribute (the same as for regular
compilation unit entries).

\item
A \DWATcompdir{} attribute (the same as for regular
compilation unit entries).

\item
\livetarg{chap:DWATdwonameforunit}{}
A \DWATdwonameNAME{} attribute whose value is a
null-terminated string containing the full or relative
path name of the object file that contains the full
compilation unit.

\item
\livetarg{chap:DWATdwoidforunit}{}
A \DWATdwoidNAME{} attribute whose value is an 8-byte
unsigned hash of the full compilation unit.  This hash
value is computed by the method described in 
Section \refersec{datarep:typesignaturecomputation}.

\needlines{6}
\item
A \DWATuseUTFeight{} attribute (the same as for regular compilation unit
entries).

\textit{This attribute applies to strings referred to by the skeleton
compilation unit entry itself, and strings in the associated line
number information.
The representation for strings in the object file referenced 
by the \DWATdwoname{} attribute is determined by the presence 
of a \DWATuseUTFeight{} attribute in the full compilation unit.}

\item
A \DWATstroffsetsbase{} attribute, for indirect strings references 
from the skeleton compilation unit (the same as for regular 
compilation unit entries).

\item
A \DWATaddrbase{} attribute (the same as for regular
compilation unit entries).

\item
A \DWATrangesbase{} attribute (the same as for regular
compilation unit entries).

\end{enumerate}

All other attributes of a compilation unit entry (described
in Section \refersec{chap:normalandpartialcompilationunitentries}) 
should be placed in the full compilation unit.
The attributes provided by the skeleton compilation
unit entry do not need to be repeated in the full compilation
unit entry, except for \DWATdwoid, which should appear in
both entries so that the consumer can verify that it has
found the correct object file.

\needlines{6}
\subsection{Type Unit Entries}
\label{chap:typeunitentries}
\addtoindexx{type unit}
\addtoindexx{type unit|see{\textit{also} compilation unit}}
\addtoindexx{compilation unit!\textit{see also} type unit}
An object file may contain any number of separate type
unit entries, each representing a single complete type
definition. 
Each \addtoindex{type unit} must be uniquely identified by
a 64-bit signature, stored as part of the type unit, which
can be used to reference the type definition from debugging
information entries in other compilation units and type units.

A type unit is represented by a debugging information entry
with the tag \DWTAGtypeunitTARG. 
A \addtoindex{type unit entry} owns debugging
information entries that represent the definition of a single
type, plus additional debugging information entries that may
be necessary to include as part of the definition of the type.

A type unit entry may have the following attributes:
\begin{enumerate}[1. ]

\item A 
\DWATlanguage{} attribute, 
whose
\addtoindexx{language attribute}
constant value is an integer code indicating the source
language used to define the type. The set of language names
and their meanings are given in Table \refersec{tab:languagenames}.

\needlines{4}
\item A 
\DWATstroffsetsbase\addtoindexx{string base offset attribute}
attribute, whose value is a reference. This attribute points
to the first string offset of the type unit's contribution to
the \dotdebugstroffsets{} section. Indirect string references
(using \DWFORMstrx) within the type unit must be interpreted
as indices relative to this base.

\item A \DWATstmtlist{} attribute\addtoindexx{statement list attribute}
whose value of class \CLASSlineptr{} points to the line number 
information for this type unit.
Because type units do not describe any code, they
do not actually need a line number table, but the line number
tables also contain a list of directories and file names that
may be referenced by the \DWATdeclfile{} attribute. In a
normal object file with a regular compilation unit entry, the
type unit entries can simply refer to the line number table
used by the compilation unit. In a \splitDWARFobjectfile, where
the type units are located in a separate DWARF object file,
the \DWATstmtlist{} attribute refers to a "specialized"
line number table in the \dotdebuglinedwo{} section, which
contains only the list of directories and file names. All
type unit entries in a \splitDWARFobjectfile{} may (but are not
required to) refer to the same \addtoindex{specialized line number table}.

\item A \DWATuseUTFeight{} attribute, which is a flag
whose presence indicates that all strings referred to by this type
unit entry, its children, and its associated 
\addtoindex{specialized line number table}, 
are represented using the UTF-8 representation.

\end{enumerate}

A \addtoindex{type unit} entry for a given type T owns a debugging
information entry that represents a defining declaration
of type T. If the type is nested within enclosing types or
namespaces, the debugging information entry for T is nested
within debugging information entries describing its containers;
otherwise, T is a direct child of the type unit entry.

A type unit entry may also own additional debugging information
entries that represent declarations of additional types that
are referenced by type T and have not themselves been placed in
separate type units. Like T, if an additional type U is nested
within enclosing types or namespaces, the debugging information
entry for U is nested within entries describing its containers;
otherwise, U is a direct child of the type unit entry.

The containing entries for types T and U are declarations,
and the outermost containing entry for any given type T or
U is a direct child of the type unit entry. The containing
entries may be shared among the additional types and between
T and the additional types.

\needlines{4}
\textit{Types are not required to be placed in type units. In general,
only large types such as structure, class, enumeration, and
union types included from header files should be considered
for separate type units. Base types and other small types
are not usually worth the overhead of placement in separate
type units. Types that are unlikely to be replicated, such
as those defined in the main source file, are also better
left in the main compilation unit.}F

\section{Module, Namespace and Importing Entries}
\textit{Modules and namespaces provide a means to collect related
entities into a single entity and to manage the names of
those entities.}

\subsection{Module Entries}
\label{chap:moduleentries}
\textit{Several languages have the concept of a \doublequote{module.}
\addtoindexx{Modula-2}
A Modula\dash 2 definition module 
\addtoindexx{Modula-2!definition module}
may be represented by a module
entry containing a 
\addtoindex{declaration attribute}
(\DWATdeclaration). A
\addtoindex{Fortran 90} module 
\addtoindexx{Fortran!module (Fortran 90)}
may also be represented by a module entry
(but no declaration attribute is warranted because \addtoindex{Fortran}
has no concept of a corresponding module body).}

A module is represented by a debugging information entry
with the 
tag \DWTAGmoduleTARG.  
Module entries may own other
debugging information entries describing program entities
whose declaration scopes end at the end of the module itself.

If the module has a name, the module entry has a 
\DWATname{} attribute 
\addtoindexx{name attribute}
whose value is a null\dash terminated string containing
the module name as it appears in the source program.

The \addtoindex{module entry} may have either a 
\DWATlowpc{} and
\DWAThighpc{} 
pair 
\addtoindexx{high PC attribute}
of 
\addtoindexx{low PC attribute}
attributes or a 
\DWATranges{} attribute
\addtoindexx{ranges attribute}
whose values encode the contiguous or non\dash contiguous address
ranges, respectively, of the machine instructions generated for
the module initialization code 
(see Section \refersec{chap:codeaddressesandranges}). 
\hypertarget{chap:DWATentrypcentryaddressofmoduleinitialization}{}
It may also
\addtoindexx{entry PC attribute!for module initialization}
have a 
\DWATentrypc{} attribute whose value is the address of
the first executable instruction of that initialization code
(see Section \refersec{chap:entryaddress}).

If 
\hypertarget{chap:DWATprioritymodulepriority}{}
the module has been assigned a priority, it may have 
\addtoindexx{priority attribute}
a
\DWATpriority{} attribute. 
The value of this attribute is a
reference to another debugging information entry describing
a variable with a constant value. The value of this variable
is the actual constant value of the module\textquoteright s priority,
represented as it would be on the target architecture.

\subsection{Namespace Entries}
\label{chap:namespaceentries}
\textit{\addtoindex{C++} has the notion of a namespace, which provides a way to
\addtoindexx{namespace (C++)}
implement name hiding, so that names of unrelated things
do not accidentally clash in the 
\addtoindex{global namespace} when an
application is linked together.}

A namespace is represented by a debugging information entry
with the 
tag \DWTAGnamespaceTARG. 
A namespace extension is
\hypertarget{chap:DWATextensionpreviousnamespaceextensionororiginalnamespace}{}
represented by a 
\DWTAGnamespace{} entry 
with 
\addtoindexx{extension attribute}
a 
\DWATextension{}
attribute referring to the previous extension, or if there
is no previous extension, to the original 
\DWTAGnamespace{}
entry. A namespace extension entry does not need to duplicate
information in a previous extension entry of the namespace
nor need it duplicate information in the original namespace
entry. (Thus, for a namespace with a name, 
a \DWATname{} attribute 
\addtoindexx{name attribute}
need only be attached directly to the original
\DWTAGnamespace{} entry.)

\needlines{4}
Namespace and namespace extension entries may own 
\addtoindexx{namespace extension entry}
other
\addtoindexx{namespace declaration entry}
debugging information entries describing program entities
whose declarations occur in the namespace.

\textit{For \addtoindex{C++}, such 
owned program entities may be declarations,
including certain declarations that are also object or
function definitions.}

A namespace may have a 
\DWATexportsymbolsNAME{}\livetarg{chap:DWATexportsymbolsofnamespace}{}
attribute\addtoindexx{export symbols attribute}
\addtoindexx{inline namespace|see{\textit{also} export symbols attribute}}
which indicates that all member names defined within the 
namespace may be referenced as if they were defined within 
the containing namespace. 

\textit{This may be used to describe an \addtoindex{inline namespace} in \addtoindex{C++}}.

If a type, variable, or function declared in a namespace is
defined outside of the body of the namespace declaration,
that type, variable, or function definition entry has a
\DWATspecification{} attribute 
\addtoindexx{specification attribute}
whose value is a \livelink{chap:classreference}{reference} to the
debugging information entry representing the declaration of
the type, variable or function. Type, variable, or function
entries with a 
\DWATspecification{} attribute 
\addtoindexx{specification attribute}
do not need
to duplicate information provided by the declaration entry
referenced by the specification attribute.

\textit{The \addtoindex{C++} \addtoindex{global namespace}
(the 
\addtoindexx{global namespace|see{namespace (C++), global}}
namespace 
\addtoindexx{namespace (C++)!global}
referred to by
\texttt{::f}, for example) is not explicitly represented in
DWARF with a namespace entry (thus mirroring the situation
in \addtoindex{C++} source).  
Global items may be simply declared with no
reference to a namespace.}

\textit{The \addtoindex{C++} 
compilation unit specific \doublequote{unnamed namespace} may
\addtoindexx{namespace (C++)!unnamed}
\addtoindexx{unnamed namespace|see {namespace (C++), unnamed}}
be represented by a namespace entry with no name attribute in
the original namespace declaration entry (and therefore no name
attribute in any namespace extension entry of this namespace).
}

\textit{A compiler emitting namespace information may choose to
explicitly represent namespace extensions, or to represent the
final namespace declaration of a compilation unit; this is a
quality\dash of\dash implementation issue and no specific requirements
are given here. If only the final namespace is represented,
\addtoindexx{namespace (C++)!using declaration}
it is impossible for a debugger to interpret using declaration
references in exactly the manner defined by the 
\addtoindex{C++} language.
}

\textit{Emitting all namespace declaration information in all
compilation units can result in a significant increase in the
size of the debug information and significant duplication of
information across compilation units. 
The \addtoindex{C++} namespace std,
for example, 
\addtoindexx{namespace (C++)!std}
is large and will probably be referenced in
every \addtoindex{C++} compilation unit.
}

\textit{For \addtoindex{C++} namespace examples, 
see Appendix \refersec{app:namespaceexamples}.
}


\needlines{5}
\subsection{Imported (or Renamed) Declaration Entries} 
\label{chap:importedorrenameddeclarationentries}
\textit{Some languages support the concept of importing into or making
accessible in a given unit declarations made in a different
module or scope. An imported declaration may sometimes be
given another name.
}

An 
imported declaration is represented by one or
\addtoindexx{imported declaration entry}
more debugging information entries with the 
tag \DWTAGimporteddeclarationTARG. 
When 
\hypertarget{chap:DWATimportimporteddeclaration}{}
an overloaded entity
is imported, there is one imported declaration entry for
each overloading. 
\addtoindexx{import attribute}
Each imported declaration entry has a
\DWATimport{} attribute,
whose value is a \livelink{chap:classreference}{reference} to the
debugging information entry representing the declaration that
is being imported.

An imported declaration may also have a 
\DWATname{}
attribute
\addtoindexx{name attribute}
whose value is a null-terminated string containing the
name, as it appears in the source program, by which the
imported entity is to be known in the context of the imported
declaration entry (which may be different than the name of
the entity being imported). If no name is present, then the
name by which the entity is to be known is the same as the
name of the entity being imported.

An imported declaration entry with a name attribute may be
used as a general means to rename or provide an alias for
\addtoindexx{alias declaration|see{imported declaration entry}}
an entity, regardless of the context in which the importing
declaration or the imported entity occurs.

\textit{A \addtoindex{C++} namespace alias may be represented by an imported
\hypertarget{chap:DWATimportnamespacealias}{}
declaration entry 
\addtoindexx{namespace (C++)!alias}
with a name attribute whose value is
a null\dash terminated string containing the alias name as it
appears in the source program and an import attribute whose
value is a \livelink{chap:classreference}{reference} to the applicable original namespace or
namespace extension entry.
}

\textit{A \addtoindex{C++} using declaration may be represented by one or more
\hypertarget{chap:DWATimportnamespaceusingdeclaration}{}
imported 
\addtoindexx{namespace (C++)!using declaration}
declaration entries.  When the using declaration
refers to an overloaded function, there is one imported
declaration entry corresponding to each overloading. Each
imported declaration entry has no name attribute but it does
have an import attribute that refers to the entry for the
entity being imported. (\addtoindex{C++} 
provides no means to \doublequote{rename}
an imported entity, other than a namespace).
}

\textit{A \addtoindex{Fortran} use statement 
\addtoindexx{Fortran!use statement}
\addtoindexx{use statement|see {Fortran, use statement}}
with an \doublequote{only list} may be
represented by a series of imported declaration entries,
one (or more) for each entity that is imported. An entity
\addtoindexx{renamed declaration|see{imported declaration entry}}
that is renamed in the importing context may be represented
by an imported declaration entry with a name attribute that
specifies the new local name.
}

\subsection{Imported Module Entries}
\label{chap:importedmoduleentries}

\textit{Some languages support the concept of importing into or making
accessible in a given unit all of the declarations contained
within a separate module or namespace.
}

An imported module declaration is represented by a debugging
information entry with 
\addtoindexx{imported module attribute}
the 
\addtoindexx{imported module entry}
tag \DWTAGimportedmoduleTARG.
An
imported module entry contains a 
\DWATimport{} attribute
\addtoindexx{import attribute}
whose value is a \livelink{chap:classreference}{reference} 
to the module or namespace entry
containing the definition and/or declaration entries for
the entities that are to be imported into the context of the
imported module entry.

An imported module declaration may own a set of imported
declaration entries, each of which refers to an entry in the
module whose corresponding entity is to be known in the context
of the imported module declaration by a name other than its
name in that module. Any entity in the module that is not
renamed in this way is known in the context of the imported
module entry by the same name as it is declared in the module.

\textit{A \addtoindex{C++} using directive
\addtoindexx{namespace (C++)!using directive}
\addtoindexx{using directive|see {namespace (C++), using directive}} 
may be represented by an imported module
\hypertarget{chap:DWATimportnamespaceusingdirective}{}
entry, with an import attribute referring to the namespace
entry of the appropriate extension of the namespace (which
might be the original namespace entry) and no owned entries.
}

\textit{A \addtoindex{Fortran} use statement 
\addtoindexx{Fortran!use statement}
with a \doublequote{rename list} may be
represented by an imported module entry with an import
attribute referring to the module and owned entries
corresponding to those entities that are renamed as part of
being imported.
}

\textit{A \addtoindex{Fortran} use statement
\addtoindexx{Fortran!use statement}
with neither a \doublequote{rename list} nor
an \doublequote{only list} may be represented by an imported module
entry with an import attribute referring to the module and
no owned child entries.
}

\textit{A use statement with an \doublequote{only list} is represented by a
series of individual imported declaration entries as described
in Section \refersec{chap:importedorrenameddeclarationentries}.
}

\textit{A \addtoindex{Fortran} use statement for an entity in a module that is
\addtoindexx{Fortran!use statement}
itself imported by a use statement without an explicit mention
may be represented by an imported declaration entry that refers
to the original debugging information entry. For example, given
}

\begin{lstlisting}
module A
integer X, Y, Z
end module

module B
use A
end module

module C
use B, only Q => X
end module
\end{lstlisting}

\textit{the imported declaration entry for Q within module C refers
directly to the variable declaration entry for X in module A
because there is no explicit representation for X in module B.
}

\textit{A similar situation arises for a \addtoindex{C++} using declaration
\addtoindexx{namespace (C++)!using declaration}
\addtoindexx{using declaration|see {namespace (C++), using declaration}}
that imports an entity in terms of a namespace alias. See 
Appendix  \refersec{app:namespaceexamples}
for an example.
}

\subsection{Imported Unit Entries}
\label{chap:importedunitentries}
The 
\hypertarget{chap:DWATimportimportedunit}{}
place where a normal or partial unit is imported is
represented by a debugging information entry with the 
\addtoindexx{imported unit entry}
tag \DWTAGimportedunitTARG. 
An imported unit entry contains 
\addtoindexx{import attribute}
a
\DWATimport{} attribute 
whose value is a \livelink{chap:classreference}{reference} to the
normal or partial compilation unit whose declarations logically
belong at the place of the imported unit entry.

\textit{An imported unit entry does not necessarily correspond to
any entity or construct in the source program. It is merely
\doublequote{glue} used to relate a partial unit, or a compilation
unit used as a partial unit, to a place in some other
compilation unit.}

\section{Subroutine and Entry Point Entries}
\label{chap:subroutineandentrypointentries}

The following tags exist to describe 
debugging information entries 
\addtoindexx{function entry|see{subroutine entry}}
for 
\addtoindexx{subroutine entry}
subroutines 
\addtoindexx{subprogram entry}
and entry
% FIXME: is entry point entry the right index 'entry'?
\addtoindexx{entry point entry}
points:

\begin{tabular}{lp{9.0cm}}
\DWTAGsubprogramTARG{} & A subroutine or function \\
\DWTAGinlinedsubroutine{} & A particular inlined 
\addtoindexx{inlined subprogram entry}
instance of a subroutine or function \\
\DWTAGentrypointTARG{} & An alternate entry point \\
\end{tabular}


\needlines{6}
\subsection{General Subroutine and Entry Point Information}
\label{chap:generalsubroutineandentrypointinformation}
The subroutine or entry point entry has a \DWATname{} 
attribute whose value is a null-terminated string containing the 
subroutine or entry point name as it appears in the source program.
It may also have a \DWATlinkagename{} attribute as
described in Section \refersec{chap:linkagenames}.

If the name of the subroutine described by an entry with the
\addtoindexx{subprogram entry}
tag \DWTAGsubprogram{}
is visible outside of its containing
\hypertarget{chap:DWATexternalexternalsubroutine}{}
compilation unit, that entry has 
\addtoindexx{external attribute}
a 
\DWATexternalNAME{} attribute,
which is a \livelink{chap:classflag}{flag}.

\textit{Additional attributes for functions that are members of a
class or structure are described in 
Section \refersec{chap:memberfunctionentries}.
}

A 
\hypertarget{chap:DWATmainsubprogrammainorstartingsubprogram}{}
subroutine entry 
may contain a 
\DWATmainsubprogramNAME{}
attribute 
\addtoindexx{main subprogram attribute}
which is 
a \CLASSflag{} whose presence indicates that the
subroutine has been identified as the starting function of
the program.  If more than one subprogram contains this 
\nolink{flag},
any one of them may be the starting subroutine of the program.

\textit{\addtoindex{Fortran} has a \addtoindex{PROGRAM statement} 
which is used to specify
and provide a user\dash supplied name for the main subroutine of
a program.
}

\subsubsection{Calling Convention Information}
A subroutine entry may 
\hypertarget{chap:DWATcallingconventionforsubprograms}{}
contain a 
\DWATcallingconventionNAME{}
\addtoindexx{calling convention attribute}
attribute, whose value is an 
\livelink{chap:classconstant}{integer constant}. The set of
\addtoindexi{calling convention codes for subroutines}{calling convention codes!for subroutines}
is given in Table \refersec{tab:callingconventioncodesforsubroutines}.

\begin{simplenametable}[1.4in]{Calling convention codes for subroutines}{tab:callingconventioncodesforsubroutines}
\DWCCnormal        \\
\DWCCprogram       \\
\DWCCnocall        \\
\end{simplenametable}

If this attribute is not present, or its value is the constant
\DWCCnormalTARG, then the subroutine may be safely called by
obeying the \doublequote{standard} calling conventions of the target
architecture. If the value of the calling convention attribute
is the constant \DWCCnocallTARG, the subroutine does not obey
standard calling conventions, and it may not be safe for the
debugger to call this subroutine.

\textit{Note that \DWCCnormal{} is also used as a calling convention 
code for certain types 
(see Table \refersec{tab:callingconventioncodesfortypes}).}

If the semantics of the language of the compilation unit
containing the subroutine entry distinguishes between ordinary
subroutines and subroutines that can serve as the \doublequote{main
program,} that is, subroutines that cannot be called
directly according to the ordinary calling conventions,
then the debugging information entry for such a subroutine
may have a calling convention attribute whose value is the
constant \DWCCprogramTARG.

\textit{A common debugger feature is to allow the debugger user to call
a subroutine within the subject program. In certain cases,
however, the generated code for a subroutine will not obey
the standard calling conventions for the target architecture
and will therefore not be safe to call from within a debugger.}

\textit{The \DWCCprogram{} 
value is intended to support \addtoindex{Fortran} main
\addtoindexx{Fortran!main program}
programs which in some implementations may not be callable
or which must be invoked in a special way. It is not intended
as a way of finding the entry address for the program.}


\subsubsection{Miscellaneous Subprogram Properties}
\textit{In \addtoindex{C}
there is a difference between the types of functions
declared using function prototype style declarations and
those declared using non\dash prototype declarations.}

A subroutine entry declared with a function prototype style
declaration may have 
\addtoindexx{prototyped attribute}
a 
\DWATprototypedNAME{} attribute, which is
a \CLASSflag.

\textit{The \addtoindex{Fortran} 
language allows the keywords \texttt{elemental}, \texttt{pure}
and \texttt{recursive} to be included as part of the declaration of
a subroutine; these attributes reflect that usage. These
attributes are not relevant for languages that do not support
similar keywords or syntax. In particular, the \DWATrecursiveNAME{}
attribute is neither needed nor appropriate in languages such
as \addtoindex{C} 
where functions support recursion by default.
}

A subprogram entry 
\hypertarget{chap:DWATelementalelementalpropertyofasubroutine}{}
may have 
\addtoindexx{elemental attribute}
a 
\DWATelementalNAME{} attribute, which
is a \livelink{chap:classflag}{flag}. 
The attribute indicates whether the subroutine
or entry point was declared with the \doublequote{elemental} keyword
or property.

A 
\hypertarget{chap:DWATpurepurepropertyofasubroutine}{}
subprogram entry may have 
\addtoindexx{pure attribute}
a 
\DWATpureNAME{} attribute, which is
a \livelink{chap:classflag}{flag}. 
The attribute indicates whether the subroutine was
declared with the \doublequote{pure} keyword or property.

A 
\hypertarget{chap:DWATrecursiverecursivepropertyofasubroutine}{}
subprogram entry may have a 
\DWATrecursiveNAME{} attribute, which
is a \livelink{chap:classflag}{flag}. 
The attribute indicates whether the subroutine
or entry point was declared with the \doublequote{recursive} keyword
or property.

A subprogram entry may have a 
\DWATnoreturnNAME
\livetargi{chap:DWATnoreturnofsubprogram}{ attribute}{noreturn attribute}, 
which is a \CLASSflag. The attribute 
indicates whether the subprogram was declared with the \doublequote{noreturn} keyword or property 
indicating that the subprogram can be called, but will never return to its caller.

\subsubsection{Call Site-Related Attributes}
\textit{While subprogram attributes in the pervious section provide
information about the subprogram and it's entry point(s) as a whole,
the following attributes provide summary information about the calls
that occur within a subprogram.}

A subroutine entry may have \DWATcallalltailcalls, \DWATcallallcalls{} 
and/or \DWATcallallsourcecalls{} attributes, each of which is a 
\livelink{chap:classflag}{flag}.
\addtoindexx{call site summary information}
\addtoindexx{subroutine call site summary attributes}
These flags indicate the completeness of the call site information 
provided by call site entries (see 
Section \refersec{chap:callsiteentries}) within the subprogram.

The \DWATcallalltailcallsNAME{}
\livetargi{chap:DWATcallalltailcallsofasubprogram}{attribute}{all tail calls summary attribute} 
indicates that every tail call 
that occurs in the code for the subprogram is described by a 
\DWTAGcallsite{} entry. 
(There may or may not be other non-tail calls to some of the same 
target subprograms.)

The \DWATcallallcallsNAME{}
\livetargi{chap:DWATcallallcallsofasubprogram}{attribute}{all calls summary attribute} 
indicates that every non-inlined call
(either a tail call or a normal call) that occurs in the code for the subprogram
is described by a \DWTAGcallsite{} entry.

The \DWATcallallsourcecallsNAME{}
\livetargi{chap:DWATcallallsourcecallsofasubprogram}{attribute}{all source calls summary attribute} 
indicates that every call that occurs in the
code for the subprogram, including every call inlined into it, is described by either a 
\DWTAGcallsite{} entry or a \DWTAGinlinedsubroutine{} entry; further, any call
that is optimized out is nonetheless also described using a \DWTAGcallsite{} entry 
that has neither a \DWATcallpc{} nor \DWATcallreturnpc{} attribute.

\textit{The \DWATcallallsourcecallsNAME{} attribute is intended for debugging 
information format consumers that analyse call graphs.}

If the value of the \DWATcallallsourcecalls{} attribute is true then the values of the
\DWATcallallcalls{} and \DWATcallalltailcalls{} attributes are necessarily also true, and 
those attributes need not be present. Similarly, if the value of the 
\DWATcallallcalls{} attribute is true then the value of the \DWATcallalltailcalls{} 
attribute is also true and the latter attribute need not be present.

\needlines{5}
\subsection{Subroutine and Entry Point Return Types}
\label{chap:subroutineandentrypointreturntypes}

If 
\hypertarget{chap:DWATtypetypeofsubroutinereturn}{}
the subroutine or entry point 
\addtoindexx{return type of subroutine}
is a function that returns a
value, then its debugging information entry has 
\addtoindexx{type attribute}
a \DWATtype{} attribute 
to denote the type returned by that function.

\textit{Debugging information entries for 
\addtoindex{C} void functions should
not have an attribute for the return type.  }

\textit{Debugging information entries for declarations of \addtoindex{C++} 
member functions with an 
\autoreturntype{} specifier should use an unspecified type entry (see 
Section \refersec{chap:unspecifiedtypeentries}). 
The debugging information entry for the corresponding definition
should provide the deduced return type.  This practice causes the description of
the containing class to be consistent across compilation units, allowing the class
declaration to be placed into a separate type unit if desired.}


\subsection{Subroutine and Entry Point Locations}
\label{chap:subroutineandentrypointlocations}

A subroutine entry may have either a \DWATlowpc{} and
\DWAThighpc{} pair of attributes or a \DWATranges{} attribute
\addtoindexx{ranges attribute}
whose 
\addtoindexx{high PC attribute}
values 
\addtoindexx{low PC attribute}
encode the contiguous or non\dash contiguous address
ranges, respectively, of the machine instructions generated
for the subroutine (see 
Section \refersec{chap:codeaddressesandranges}).

A 
\hypertarget{chap:DWATentrypcentryaddressofsubprogram}{}
subroutine entry may also have 
\addtoindexx{entry PC attribute!for subroutine}
a 
\DWATentrypc{} attribute
whose value is the address of the first executable instruction
of the subroutine (see 
Section \refersec{chap:entryaddress}).

An entry point has a \DWATlowpc{} attribute whose value is the
relocated address of the first machine instruction generated
for the entry point.

\textit{While the 
\DWATentrypc{} attribute 
\addtoindexx{entry pc attribute!for subroutine}
might 
also seem appropriate
for this purpose, historically the 
\DWATlowpc{} attribute
was used before the 
\DWATentrypc{} was introduced (in
\addtoindex{DWARF Version 3}). 
There is insufficient reason to change this.}


Subroutines 
and 
entry
\addtoindexx{address class attribute}
points 
\hypertarget{chap:DWATaddressclasssubroutineorsubroutinetype}{}
may also have 
\DWATsegment{} 
and
\DWATaddressclass{} attributes,
as appropriate, to specify
which segments the code for the subroutine resides in and
the addressing mode to be used in calling that subroutine.

A subroutine entry representing a subroutine declaration
that is not also a definition does not have code address or
range attributes.


\subsection{Declarations Owned by Subroutines and Entry Points} 
\label{chap:declarationsownedbysubroutinesandentrypoints}
\addtoindexx{subroutine formal parameters}
The declarations enclosed by a subroutine or entry point are
represented by debugging information entries that are owned
by the subroutine or entry point entry. Entries representing
\addtoindexx{formal parameter}
the formal parameters of the subroutine or entry point appear
in the same order as the corresponding declarations in the
source program.

\needlines{5}
\textit{There is no ordering requirement for entries for declarations
other than formal parameters. The formal parameter
entries may be interspersed with other entries used by formal
parameter entries, such as type entries.}

The unspecified (sometimes called \doublequote{varying}) 
parameters of a subroutine parameter list are
represented by a debugging information 
entry\addtoindexx{unspecified parameters entry}
with the tag \DWTAGunspecifiedparametersTARG.

\needlines{4}
The entry for a subroutine that includes a
\addtoindex{Fortran}
\addtoindexx{Fortran!common block}
\livelink{chap:fortrancommonblock}{common} 
\livelink{chap:commonblockentry}{block}
\addtoindexx{common block|see{Fortran common block}}
has a child entry with the 
tag \DWTAGcommoninclusionTARG. 
The
\hypertarget{chap:commonreferencecommonblockusage}{}
common inclusion entry has a 
\DWATcommonreference{} attribute
whose value is a \livelink{chap:classreference}{reference} 
to the debugging information entry
for the common \nolink{block} being included 
(see Section \refersec{chap:commonblockentries}).

\subsection{Low-Level Information}
\label{chap:lowlevelinformation}

A 
\hypertarget{chap:DWATreturnaddrsubroutinereturnaddresssavelocation}{}
subroutine or entry point entry may have 
\addtoindexx{return address attribute}
a 
\DWATreturnaddr{}
attribute, whose value is a location description. The location
specified is the place where the return address for the
subroutine or entry point is stored.

A 
\hypertarget{chap:DWATframebasesubroutineframebaseaddress}{}
subroutine or entry point entry may also have 
\addtoindexx{frame base attribute}
a
\DWATframebase{} attribute, whose value is a location
description that describes the \doublequote{frame base} for the
subroutine or entry point. If the location description is
a simple register location description, the given register
contains the frame base address. If the location description is
a DWARF expression, the result of evaluating that expression
is the frame base address. Finally, for a 
\addtoindex{location list},
this interpretation applies to each location description
contained in the list of \addtoindex{location list} entries.

\textit{The use of one of the \DWOPregn{} 
operations in this
context is equivalent to using 
\DWOPbregn(0) 
but more
compact. However, these are not equivalent in general.}

\needlines{5}
\textit{The frame base for a subprogram is typically an address
relative to the first unit of storage allocated for the
subprogram\textquoteright s stack frame. The \DWATframebase{} attribute
can be used in several ways:}
\begin{enumerate}[1. ]
\item \textit{In subprograms that need 
\addtoindexx{location list}
location lists to locate local
variables, the \DWATframebase{} can hold the needed location
list, while all variables\textquoteright\  location descriptions can be
simpler ones involving the frame base.}

\item \textit{It can be used in resolving \doublequote{up\dash level} addressing
within nested routines. 
(See also \DWATstaticlink, below)}
\end{enumerate}

\needlines{5}
\textit{Some languages support nested subroutines. In such languages,
it is possible to reference the local variables of an
outer subroutine from within an inner subroutine. The
\DWATstaticlink{} and \DWATframebase{} attributes allow
debuggers to support this same kind of referencing.}

If 
\hypertarget{chap:DWATstaticlinklocationofuplevelframe}{}
a 
\addtoindexx{address!uplevel|see {static link attribute}}
\addtoindexx{uplevel address|see {static link attribute}}
subroutine or entry point is nested, it may have a
\DWATstaticlink{}
attribute, whose value is a location
description that computes the frame base of the relevant
instance of the subroutine that immediately encloses the
subroutine or entry point.

In the context of supporting nested subroutines, the
\DWATframebase{} attribute value should obey the following
constraints:

\begin{enumerate}[1. ]
\item It should compute a value that does not change during the
life of the subprogram, and

\item The computed value should be unique among instances of
the same subroutine. (For typical \DWATframebase{} use, this
means that a recursive subroutine\textquoteright s stack frame must have
non\dash zero size.)
\end{enumerate}

\textit{If a debugger is attempting to resolve an up\dash level reference
to a variable, it uses the nesting structure of DWARF to
determine which subroutine is the lexical parent and the
\DWATstaticlink{} value to identify the appropriate active
frame of the parent. It can then attempt to find the reference
within the context of the parent.}


\needlines{8}
\subsection{Types Thrown by Exceptions}
\label{chap:typesthrownbyexceptions}

\textit{In \addtoindex{C++} a subroutine may declare a set of types which
it may validly throw.}

If a subroutine explicitly declares that it may throw
\addtoindexx{exception thrown|see{thrown type entry}}
an 
\addtoindexx{thrown exception|see{thrown type entry}}
exception of one or more types, each such type is
represented by a debugging information entry with 
\addtoindexx{thrown type entry}
the tag
\DWTAGthrowntypeTARG.  
Each such entry is a child of the entry
representing the subroutine that may throw this type. Each
thrown type entry contains 
\addtoindexx{type attribute}
a \DWATtype{} attribute, whose
value is a \livelink{chap:classreference}{reference} 
to an entry describing the type of the
exception that may be thrown.

\subsection{Function Template Instantiations}
\label{chap:functiontemplateinstantiations}

\textit{In \addtoindex{C++}, a function template is a generic definition of
a function that is instantiated differently for calls with
values of different types. DWARF does not represent the generic
template definition, but does represent each instantiation.}

\needlines{4}
A \addtoindex{function template instantiation}\addtoindexx{template instantiation!function} 
is represented by a debugging information entry with the 
\addtoindexx{subprogram entry!use for template instantiation}
tag \DWTAGsubprogram. 
With the following
exceptions, such an entry will contain the same attributes and
will have the same types of child entries as would an entry
for a subroutine defined explicitly using the instantiation
types and values. The exceptions are:

\begin{enumerate}[1. ]
\item Template parameters are described and referenced as specified in
Section \refersec{chap:templateparameters}.

\needlines{4}
\item If the compiler has generated a special compilation unit
to hold the template instantiation and that compilation unit
has a different name from the compilation unit containing
the template definition, the name attribute for the debugging
information entry representing that compilation unit is empty
or omitted.

\item If the subprogram entry representing the template
instantiation or any of its child entries contain declaration
coordinate attributes, those attributes refer to the source
for the template definition, not to any source generated
artificially by the compiler for this instantiation.
\end{enumerate}


\needlines{8}
\subsection{Inlinable and Inlined Subroutines}
\label{chap:inlinedsubroutines}
A declaration or a definition of an inlinable subroutine
is represented by a debugging information entry with the
tag 
\DWTAGsubprogram.
The entry for a 
\addtoindexx{subprogram entry!use in inlined subprogram}
subroutine that is
\hypertarget{chap:DWATinlineinlinedsubroutine}{}
explicitly declared to be available for inline expansion or
that was expanded inline implicitly by the compiler has 
\addtoindexx{inline attribute}
a
\DWATinline{} attribute whose value is an 
\livelink{chap:classconstant}{integer constant}. The
set of values for the \DWATinline{} attribute is given in
Table \refersec{tab:inlinecodes}.

\begin{table}[here]
\centering
\caption{Inline codes}
\label{tab:inlinecodes}
\begin{tabular}{l|p{8cm}}
\hline
Name&Meaning\\ \hline
\DWINLnotinlinedTARG{} & Not declared inline nor inlined by the
  \mbox{compiler} (equivalent to the absence of the
  containing \DWATinline{} attribute) \\
\DWINLinlinedTARG{} & Not declared inline but inlined by the \mbox{compiler} \\
\DWINLdeclarednotinlinedTARG{} & Declared inline but 
  not inlined by the \mbox{compiler} \\
\DWINLdeclaredinlinedTARG{} & Declared inline and inlined by the 
  \mbox{compiler} \\
\hline
\end{tabular}
\end{table}

\textit{In \addtoindex{C++}, a function or a constructor declared with
\addttindex{constexpr} is implicitly declared inline. The abstract inline
instance (see below) is represented by a debugging information
entry with the tag \DWTAGsubprogram. Such an entry has a
\DWATinline{} attribute whose value is \DWINLinlined.}

\needlines{4}
\subsubsection{Abstract Instances}
\label{chap:abstractinstances}
Any subroutine entry that contains a
\DWATinline{} attribute\addtoindexx{inline attribute} 
whose value is other than 
\DWINLnotinlined{}
is known as an
\doublequote{abstract instance root.}\addtoindexx{abstract instance!root}
\hypertarget{chap:DWATinlineabstracttinstance}{}
Any debugging information entry that is owned (either
directly or indirectly) by an abstract instance root
is known as an
\doublequote{abstract instance entry.}\addtoindexx{abstract instance!entry}
Any set of abstract instance entries that are all
children (either directly or indirectly) of some abstract
instance root, together with the root itself, is known as an
\doublequote{abstract instance tree.}\addtoindexx{abstract instance!tree}
However, in the case where an abstract instance tree is 
nested within another abstract instance tree, the entries in the 
\addtoindex{nested abstract instance}
tree are not considered to be entries in the outer abstract
instance tree.

Each abstract instance root is either part of a larger
\addtoindexx{abstract instance!root}
tree (which gives a context for the root) or 
\addtoindexx{specification attribute}
uses
\DWATspecification{} 
to refer to the declaration in context.

\textit{For example, in \addtoindex{C++} the context might be a namespace
declaration or a class declaration.}

\textit{Abstract instance trees are defined so that no entry is part
of more than one abstract instance tree. This simplifies the
following descriptions.}

A debugging information entry that is a member of an abstract
instance tree should not contain any attributes which describe
aspects of the subroutine which vary between distinct inlined
expansions or distinct out\dash of\dash line expansions. For example,
\addtoindexx{entry pc attribute!and abstract instance}
the \DWATlowpc,
\DWAThighpc, 
\DWATranges, 
\DWATentrypc, 
\DWATlocation,
\DWATreturnaddr, 
\DWATstartscope, 
and 
\DWATsegment{}
attributes 
\addtoindexx{location attribute!and abstract instance}
typically 
\addtoindexx{ranges attribute!and abstract instance}
should 
\addtoindexx{high PC attribute!and abstract instance}
be 
\addtoindexx{low PC attribute!and abstract instance}
omitted; 
\addtoindexx{segment attribute!and abstract instance}
however, 
\addtoindexx{return address attribute!and abstract instance}
this 
\addtoindexx{segment attribute!and abstract instance}
list
\addtoindexx{start scope attribute!and abstract instance}
is not exhaustive.

\needlines{5}
\textit{It would not make sense normally to put these attributes into
abstract instance entries since such entries do not represent
actual (concrete) instances and thus do not actually exist at
run\dash time.  However, 
see Appendix \refersec{app:inlineouteronenormalinner} 
for a contrary example.}

The rules for the relative location of entries belonging to
abstract instance trees are exactly the same as for other
similar types of entries that are not abstract. Specifically,
the rule that requires that an entry representing a declaration
be a direct child of the entry representing the scope of the
declaration applies equally to both abstract and non\dash abstract
entries. Also, the ordering rules for formal parameter entries,
member entries, and so on, all apply regardless of whether
or not a given entry is abstract.

\needlines{5}
\subsubsection{Concrete Inlined Instances}
\label{chap:concreteinlinedinstances}

Each inline expansion of a subroutine is represented
by a debugging information entry with the 
tag \DWTAGinlinedsubroutineTARG. 
Each such entry should be a direct
child of the entry that represents the scope within which
the inlining occurs.

\needlines{4}
Each inlined subroutine entry may have either a 
\DWATlowpc{}
and \DWAThighpc{} pair 
of 
\addtoindexx{high PC attribute}
attributes 
\addtoindexx{low PC attribute}
or 
\addtoindexx{ranges attribute}
a 
\DWATranges{}
attribute whose values encode the contiguous or non\dash contiguous
address ranges, respectively, of the machine instructions
generated for the inlined subroutine (see 
Section \referfol{chap:codeaddressesandranges}). 
An
\hypertarget{chap:DWATentrypcentryaddressofinlinedsubprogram}{}
inlined subroutine entry may 
\addtoindexx{inlined subprogram entry!in concrete instance}
also 
\addtoindexx{inlined subprogram entry}
contain 
\addtoindexx{entry PC attribute!for inlined subprogram}
a 
\DWATentrypc{}
attribute, representing the first executable instruction of
the inline expansion (see 
Section \refersec{chap:entryaddress}).

% Positions of the 3 targets here is a bit arbitrary.
An inlined 
\hypertarget{chap:DWATcalllinelinenumberofinlinedsubroutinecall}{}
subroutine 
\hypertarget{chap:DWATcallcolumncolumnpositionofinlinedsubroutinecall}{}
entry 
\hypertarget{chap:DWATcallfilefilecontaininginlinedsubroutinecall}{}
may also have \DWATcallfile,
\DWATcallline{} and \DWATcallcolumn{} attributes, 
each of whose
value is an \livelink{chap:classconstant}{integer constant}. 
These attributes represent the
source file, source line number, and source column number,
respectively, of the first character of the statement or
expression that caused the inline expansion. The call file,
call line, and call column attributes are interpreted in
the same way as the declaration file, declaration line, and
declaration column attributes, respectively (see 
Section \refersec{chap:declarationcoordinates}).

\textit{The call file, call line and call column coordinates do not
describe the coordinates of the subroutine declaration that
was inlined, rather they describe the coordinates of the call.
}

An inlined subroutine entry 
\hypertarget{chap:DWATconstexprcompiletimeconstantfunction}{}
may have a 
\DWATconstexpr{}
attribute, which is a \livelink{chap:classflag}{flag} 
whose presence indicates that the
subroutine has been evaluated as a compile\dash time constant. Such
an entry may also have a \DWATconstvalue{} attribute,
whose value may be of any form that is appropriate for the
representation of the subroutine's return value. The value of
this attribute is the actual return value of the subroutine,
represented as it would be on the target architecture.

\textit{In \addtoindex{C++}, if a function or a constructor declared with 
\addttindex{constexpr}
is called with constant expressions, then the corresponding
concrete inlined instance has a 
\DWATconstexpr{} attribute,
as well as a \DWATconstvalue{} attribute whose value represents
the actual return value of the concrete inlined instance.}

Any debugging information entry that is owned (either
directly or indirectly) by a debugging information entry
with the tag \DWTAGinlinedsubroutine{} is referred to as a
\doublequote{concrete inlined instance entry.} Any entry that has
the tag 
\DWTAGinlinedsubroutine{} 
is known as a \doublequote{concrete inlined instance root.} 
Any set of concrete inlined instance
entries that are all children (either directly or indirectly)
of some concrete inlined instance root, together with the root
itself, is known as a \doublequote{concrete inlined instance tree.}
However, in the case where a concrete inlined instance tree
is nested within another concrete instance tree, the entries
in the \addtoindex{nested concrete inline instance} tree 
are not considered to
be entries in the outer concrete instance tree.

\needlines{3}
\textit{Concrete inlined instance trees are defined so that no entry
is part of more than one concrete inlined instance tree. This
simplifies later descriptions.}

Each concrete inlined instance tree is uniquely associated
with one (and only one) abstract instance tree.

\textit{Note, however, that the reverse is not true. Any given abstract
instance tree may be associated with several different concrete
inlined instance trees, or may even be associated with zero
concrete inlined instance trees.}

Concrete inlined instance entries may omit attributes that
are not specific to the concrete instance (but present in
the abstract instance) and need include only attributes that
are specific to the concrete instance (but omitted in the
abstract instance). In place of these omitted attributes, each
\hypertarget{chap:DWATabstractorigininlineinstance}{}
concrete inlined instance entry 
\addtoindexx{abstract origin attribute}
has a 
\DWATabstractorigin{}
attribute that may be used to obtain the missing information
(indirectly) from the associated abstract instance entry. The
value of the abstract origin attribute is a reference to the
associated abstract instance entry.

If an entry within a concrete inlined instance tree contains
attributes describing the 
\addtoindexx{declaration coordinates!in concrete instance}
\livelink{chap:declarationcoordinates}{declaration coordinates} 
of that entry, then those attributes should refer to the file, line
and column of the original declaration of the subroutine,
not to the point at which it was inlined. As a consequence,
they may usually be omitted from any entry that has an abstract
origin attribute.

\needlines{4}
For each pair of entries that are associated via a
\addtoindexx{abstract origin attribute}
\DWATabstractorigin{} attribute, both members of the pair
have the same tag. So, for example, an entry with the tag
\DWTAGvariable{} can only be associated with another entry
that also has the tag \DWTAGvariable. The only exception
to this rule is that the root of a concrete instance tree
(which must always have the tag \DWTAGinlinedsubroutine)
can only be associated with the root of its associated abstract
instance tree (which must have the tag \DWTAGsubprogram).

\needlines{6}
In general, the structure and content of any given concrete
inlined instance tree will be closely analogous to the
structure and content of its associated abstract instance
tree. There are a few exceptions:

\begin{enumerate}[1. ]
\item An entry in the concrete instance tree may be omitted if
it contains only a 
\addtoindexx{abstract origin attribute}
\DWATabstractorigin{} attribute and either
has no children, or its children are omitted. Such entries
would provide no useful information. In C\dash like languages,
such entries frequently include types, including structure,
union, class, and interface types; and members of types. If any
entry within a concrete inlined instance tree needs to refer
to an entity declared within the scope of the relevant inlined
subroutine and for which no concrete instance entry exists,
the reference should refer to the abstract instance entry.

\needlines{4}
\item Entries in the concrete instance tree which are associated
with entries in the abstract instance tree such that neither
has a \DWATname{} attribute,
\addtoindexx{name attribute}
and neither is referenced by
any other debugging information entry, may be omitted. This
may happen for debugging information entries in the abstract
instance trees that became unnecessary in the concrete instance
tree because of additional information available there. For
example, an anonymous variable might have been created and
described in the abstract instance tree, but because of
the actual parameters for a particular inlined expansion,
it could be described as a constant value without the need
for that separate debugging information entry.

\needlines{4}
\item A concrete instance tree may contain entries which do
not correspond to entries in the abstract instance tree
to describe new entities that are specific to a particular
inlined expansion. In that case, they will not have associated
entries in the abstract instance tree, should not contain
\addtoindexx{abstract origin attribute}
\DWATabstractorigin{} attributes, and must contain all their
own attributes directly. This allows an abstract instance tree
to omit debugging information entries for anonymous entities
that are unlikely to be needed in most inlined expansions. In
any expansion which deviates from that expectation, the
entries can be described in its concrete inlined instance tree.

\end{enumerate}

\subsubsection{Out-of-Line Instances of Inlined Subroutines}
\label{chap:outoflineinstancesofinlinedsubroutines}
Under some conditions, compilers may need to generate concrete
executable instances of inlined subroutines other than at
points where those subroutines are actually called. Such
concrete instances of inlined subroutines are referred to as
\doublequote{concrete out\dash of\dash line instances.}

\textit{In \addtoindex{C++}, for example, 
taking the address of a function declared
to be inline can necessitate the generation of a concrete
out\dash of\dash line instance of the given function.}

The DWARF representation of a concrete out\dash of\dash line instance
of an inlined subroutine is essentially the same as for a
concrete inlined instance of that subroutine (as described in
the preceding section). The representation of such a concrete
% It is critical that the hypertarget and livelink be
% separated to avoid problems with latex.
out\dash of\dash line 
\addtoindexx{abstract origin attribute}
instance 
\hypertarget{chap:DWATabstractoriginoutoflineinstance}{}
makes use of 
\DWATabstractorigin{}
attributes in exactly the same way as they are used for
a concrete inlined instance (that is, as references to
corresponding entries within the associated abstract instance
tree).

The differences between the DWARF representation of a
concrete out\dash of\dash line instance of a given subroutine and the
representation of a concrete inlined instance of that same
subroutine are as follows:
\begin{enumerate}[1. ]
\item  The root entry for a concrete out\dash of\dash line instance
of a given inlined subroutine has the same tag as does its
associated (abstract) inlined subroutine entry (that is, tag
\DWTAGsubprogram{} rather than \DWTAGinlinedsubroutine).

\item The root entry for a concrete out\dash of\dash line instance tree
is normally owned by the same parent entry that also owns
the root entry of the associated abstract instance. However,
it is not required that the abstract and out\dash of\dash line instance
trees be owned by the same parent entry.

\end{enumerate}

\subsubsection{Nested Inlined Subroutines}
\label{nestedinlinedsubroutines}
Some languages and compilers may permit the logical nesting of
a subroutine within another subroutine, and may permit either
the outer or the nested subroutine, or both, to be inlined.

For a non\dash inlined subroutine nested within an inlined
subroutine, the nested subroutine is described normally in
both the abstract and concrete inlined instance trees for
the outer subroutine. All rules pertaining to the abstract
and concrete instance trees for the outer subroutine apply
also to the abstract and concrete instance entries for the
nested subroutine.

\needlines{5}
For an inlined subroutine nested within another inlined
subroutine, the following rules apply to their abstract and
\addtoindexx{abstract instance!nested}
\addtoindexx{concrete instance!nested}
concrete instance trees:

\begin{enumerate}[1. ]
\item The abstract instance tree for the nested subroutine is
described within the abstract instance tree for the outer
subroutine according to the rules in 
Section \refersec{chap:abstractinstances}, and
without regard to the fact that it is within an outer abstract
instance tree.

\item Any abstract instance tree for a nested subroutine is
always omitted within the concrete instance tree for an
outer subroutine.

\item  A concrete instance tree for a nested subroutine is
always omitted within the abstract instance tree for an
outer subroutine.

\item The concrete instance tree for any inlined or 
\addtoindexx{out-of-line instance}
out-of-line
\addtoindexx{out-of-line instance|see{\textit{also} concrete out-of-line instance}}
expansion of the nested subroutine is described within a
concrete instance tree for the outer subroutine according
to the rules in 
Sections \refersec{chap:concreteinlinedinstances} or 
\referfol{chap:outoflineinstancesofinlinedsubroutines}
, respectively,
and without regard to the fact that it is within an outer
concrete instance tree.
\end{enumerate}

See Appendix \refersec{app:inliningexamples} 
for discussion and examples.

\subsection{Trampolines}
\label{chap:trampolines}

\textit{A trampoline is a compiler\dash generated subroutine that serves as
\hypertarget{chap:DWATtrampolinetargetsubroutine}{}
an intermediary in making a call to another subroutine. It may
adjust parameters and/or the result (if any) as appropriate
to the combined calling and called execution contexts.}

A trampoline is represented by a debugging information entry
\addtoindexx{trampoline (subprogram) entry}
with the tag \DWTAGsubprogram{} or \DWTAGinlinedsubroutine{}
that has 
\addtoindexx{trampoline attribute}
a \DWATtrampoline{} attribute. 
The value of that
attribute indicates the target subroutine of the trampoline,
that is, the subroutine to which the trampoline passes
control. (A trampoline entry may but need not also have a
\DWATartificial{} attribute.)

\needlines{5}
The value of the trampoline attribute may be represented
using any of the following forms, which are listed in order
of preference:

\begin{itemize}
\item If the value is of class \CLASSreference{}, then the value
specifies the debugging information entry of the target
subprogram.

\item If the value is of class \CLASSaddress{}, then the value is
the relocated address of the target subprogram.

\needlines{6}
\item If the value is of class \CLASSstring{}, then the value is the
(possibly mangled) \addtoindexx{mangled names}
name of the target subprogram.

\item If the value is of class \CLASSflag, then the value true
indicates that the containing subroutine is a trampoline but
that the target subroutine is not known.
\end{itemize}


The target subprogram may itself be a trampoline. (A sequence
of trampolines necessarily ends with a non\dash trampoline
subprogram.)

\textit{In \addtoindex{C++}, trampolines may be used to implement 
derived virtual member functions; such trampolines typically 
adjust the implicit 
\texttt{this} parameter\index{this parameter@\texttt{this} parameter}
in the course of passing control.  
Other languages and environments may use trampolines in a manner 
sometimes known as transfer functions or transfer vectors.}

\textit{Trampolines may sometimes pass control to the target
subprogram using a branch or jump instruction instead of a
call instruction, thereby leaving no trace of their existence
in the subsequent execution context. }

\textit{This attribute helps make it feasible for a debugger to arrange
that stepping into a trampoline or setting a breakpoint in
a trampoline will result in stepping into or setting the
breakpoint in the target subroutine instead. This helps to
hide the compiler generated subprogram from the user. }

\textit{If the target subroutine is not known, a debugger may choose
to repeatedly step until control arrives in a new subroutine
which can be assumed to be the target subroutine. }

\subsection{Call Site Entries}
\label{chap:callsiteentries}
\textit{
A call site entry provides a way to represent the static or dynamic 
call graph of a program in the debugging information. It also provides
information about how parameters are passed so that they may be more
easily accessed by a debugger. Together with the \DWOPentryvalue{} opcode,
call site entries can be also useful for computing values of variables 
and expressions where some value is no longer present in the current 
subroutine's registers or local stack frame, but it is known that the 
values are equal to some parameter passed to the function.  
The consumer can then use unwind
information to find the caller and it's call site information and then
compute the value passed in a particular parameter.}

A call site is represented by a debugging information entry with the tag
\DWTAGcallsiteTARG{}.  The entry for a call site is owned by the innermost
debugging information entry representing the scope within which the
call is present in the source program.

\textit{A scope entry (for example, for a lexical block) that would not 
otherwise be present in the debugging information of a subroutine
need not be introduced solely to represent the immediately containing scope
of a call.}

A source call can be compiled into different types of machine code:
\begin{itemize}
\item
A \textit{normal call} uses a call-like instruction which transfers 
control to the start of some subprogram and leaves the call site 
location address somewhere where unwind information can find it.  
\item
A \textit{tail call} uses a jump-like instruction which
transfers control to the start of some subprogram, but the call site location
address is not preserved (and thus not available using the unwind information).  
\item
A \textit{tail recursion call} is a call
to the current subroutine which is compiled as a jump into the middle of the
current subroutine.
\needlines{4}
\item
An \textit{inline (or inlined) call} is a call to an inlined subprogram,
where at least one instruction has the location of the inlined subprogram
or any of its blocks or inlined subprograms. 
\end{itemize}

\needlines{4}
There are also different types of \doublequote{optimized out} calls:
\begin{itemize}
\item
An \textit{optimized out (normal) call} is a call that is in unreachable code that 
has not been emitted (such as, for example, the call to \texttt{foo} in 
\texttt{if (0) foo();}).  
\item
An \textit{optimized out inline call}
is a call to an inlined subprogram which either did not expand to any instructions
or only parts of instructions belong to it and for debug information purposes those
instructions are given a location in the caller.
\end{itemize}

\DWTAGcallsite{} entries describe normal and tail calls but not tail recursion calls,
while \DWTAGinlinedsubroutine{} entries describe inlined calls 
(see Section \refersec{chap:inlinedsubroutines}).

The call site entry has a 
\DWATcallreturnpcNAME{}
\livetargi{chap:DWATcallreturnpcofcallsite}{attribute}{call return pc attribute} 
which is the return address after the call.  
The value of this attribute corresponds to the return address computed by 
call frame information in the called subprogram 
(see Section \refersec{datarep:callframeinformation}).

\textit{On many architectures the return address is the address immediately following the
call instruction, but on architectures with delay slots it might
be an address after the delay slot of the call.}

The call site entry may have a 
\DWATcallpcNAME{}
\livetargi{chap:DWATcallpcofcallsite}{attribute}{call pc attribute} which is the
address of the call instruction.

If the call site entry corresponds to a tail call, it has the 
\DWATcalltailcallNAME{}
\livetargi{chap:DWATcalltailcallofcallsite}{attribute}{call tail call attribute},
which is a \CLASSflag.

The call site entry may have a 
\DWATcalloriginNAME{}
\livetargi{chap:DWATcalloriginofcallsite}{attribute}{call origin attribute}
which is a \CLASSreference.  For direct calls or jumps where the called subprogram is
known it is a reference to the called subprogram's debugging
information entry.  For indirect calls it may be a reference to a
\DWTAGvariable{}, \DWTAGformalparameter{} or \DWTAGmember{} entry representing
the subroutine pointer that is called.

\needlines{4}
The call site may have a 
\DWATcalltargetNAME{}
\livetargi{chap:DWATcalltargetofcallsite}{attribute}{call target attribute} which is
a DWARF expression.  For indirect calls or jumps where it is unknown at
compile time which subprogram will be called the expression computes the
address of the subprogram that will be called.  The DWARF expression should
not use register or memory locations that might be clobbered by the call.

\needlines{4}
The call site entry may have a 
\DWATcalltargetclobberedNAME{}
\livetargi{chap:DWATcalltargetclobberedofcallsite}{attribute}{call target clobbered attribute}
which is a DWARF expression.  For indirect calls or jumps where the
address is not computable without use of registers or memory locations that
might be clobbered by the call the \DWATcalltargetclobberedNAME{}
attribute is used instead of the \DWATcalltarget{} attribute.

The call site entry may have a \DWATtypeNAME{}
\livetargi{chap:DWATtypeofcallsite}{attribute}{type attribute!of call site entry}
referencing a debugging information entry for the type of the called function.  

\textit{When \DWATcallorigin{} is present, \DWATtypeNAME{} is usually omitted.}

The call site entry may have 
\DWATcallfileNAME{}, \DWATcalllineNAME{} and \DWATcallcolumnNAME{} 
\livetargi{chap:DWATcallfileofcallsite}{attributes,}{call file attribute!of call site entry}
\livetargi{chap:DWATcalllineofcallsite}{}{call line attribute!of call site entry}
\livetargi{chap:DWATcallcolumnofcallsite}{}{call column attribute!of call site entry}
each of whose value is an integer constant.
These attributes represent the source file, source line number, and source
column number, respectively, of the first character of the call statement or
expression.  The call file, call line, and call column attributes are
interpreted in the same way as the declaration file, declaration
line, and declaration column attributes, respectively 
(see Section \refersec{chap:declarationcoordinates}).

\textit{The call file, call line and call column coordinates do not describe the
coordinates of the subroutine declaration that was called, rather they describe
the coordinates of the call.}

\needlines{5}
The call site entry may own \DWTAGcallsiteparameterTARG{} debugging information
entries\index{call site parameter entry} representing the parameters passed to the call.
Each such entry has a \DWATlocation{} attribute which is a location expression.
This location expression describes where the parameter is passed
(usually either some register, or a memory location expressible as the
contents of the stack register plus some offset).

Each \DWTAGcallsiteparameter{} entry may have a 
\DWATcallvalueNAME{}
\livetargi{chap:DWATcallvalueofcallparameter}{attribute}{call value attribute}
which is a DWARF expression.  This expression computes the value
passed for that parameter.  The expression should not use registers or memory
locations that might be clobbered by the call, as it might be evaluated after
unwinding from the called function back to the caller.  If it is not
possible to avoid registers or memory locations that might be clobbered by
the call in the expression, then the \DWATcallvalueNAME{} attribute should
not be provided.

\textit{The reason for the restriction is that the value of the parameter may be
needed in the middle of the callee, where the call clobbered registers or
memory might be already clobbered, and if the consumer was not assured by
the producer it can safely use those values, the consumer could not safely
use the values at all.}

For parameters passed by reference, where the code passes a pointer to
a location which contains the parameter, or for reference type parameters
the \DWTAGcallsiteparameter{} entry may also have 
\DWATcalldatalocationNAME{}
\livetargi{chap:DWATcalldatalocationofcallparameter}{attribute}{call data location attribute}
whose value is a location expression and a
\DWATcalldatavalueNAME{}
\livetargi{chap:DWATcalldatavalueofcallparameter}{attribute}{call data value attribute}
whose value is a DWARF expression.  The \DWATcalldatalocationNAME{} attribute 
describes where the referenced value lives during the call.  If it is just 
\DWOPpushobjectaddress{}, it may be left out.  The 
\DWATcalldatavalueNAME{} attribute describes the value in that location. 
The expression should not use registers or memory
locations that might be clobbered by the call, as it might be evaluated after
unwinding from the called function back to the caller.

\needlines{4}
Each call site parameter entry may also have a 
\DWATcallparameter{}
\livetargi{chap:DWATcallparameterofcallparameter}{attribute}{call parameter attribute}
which contains a reference to a \DWTAGformalparameter{} entry,
\DWATtype{} attribute referencing the type of the parameter or \DWATname{}
attribute describing the parameter's name.


\needlines{8}
\section{Lexical Block Entries}
\label{chap:lexicalblockentries}

\textit{A 
lexical \livetargi{chap:lexicalblock}{block}{lexical block} 
is 
\addtoindexx{lexical block}
a bracketed sequence of source statements
that may contain any number of declarations. In some languages
(including \addtoindex{C} and \addtoindex{C++}),
\nolink{blocks} can be nested within other
\nolink{blocks} to any depth.}

% We do not need to link to the preceding paragraph.
A lexical \nolink{block} is represented by a debugging information
entry with the 
tag \DWTAGlexicalblockTARG.

The lexical \livetargi{chap:lexicalblockentry}{block}{lexical block entry} 
entry may have 
either a \DWATlowpc{} and
\DWAThighpc{} pair of 
attributes 
\addtoindexx{high PC attribute}
or 
\addtoindexx{low PC attribute}
a 
\DWATranges{} attribute
\addtoindexx{ranges attribute}
whose values encode the contiguous or non-contiguous address
ranges, respectively, of the machine instructions generated
for the lexical \nolink{block} 
(see Section \refersec{chap:codeaddressesandranges}).

A 
\hypertarget{chap:DWATentrypcoflexicalblock}{}
lexical block entry may also have 
\addtoindexx{entry PC attribute!for lexical block}
a 
\DWATentrypc{} attribute
whose value is the address of the first executable instruction
of the lexical block (see 
Section \refersec{chap:entryaddress}).

If a name has been given to the 
lexical \nolink{block} 
in the source
program, then the corresponding 
lexical \nolink{block} entry has a
\DWATname{} attribute whose 
\addtoindexx{name attribute}
value is a null\dash terminated string
containing the name of the lexical \nolink{block} 
as it appears in
the source program.

\textit{This is not the same as a \addtoindex{C} or 
\addtoindex{C++} label (see below).}

The lexical \nolink{block} entry owns 
debugging information entries that
describe the declarations within that lexical \nolink{block}. 
There is
one such debugging information entry for each local declaration
of an identifier or inner lexical \nolink{block}.

\needlines{10}
\section{Label Entries}
\label{chap:labelentries}
\textit{A label is a way of identifying a source statement. A labeled
statement is usually the target of one or more \doublequote{go to}
statements.
}

\needlines{4}
A label is represented by a debugging information entry with
\addtoindexx{label entry}
the 
tag \DWTAGlabelTARG. 
The entry for a label should be owned by
the debugging information entry representing the scope within
which the name of the label could be legally referenced within
the source program.

The label entry has a \DWATlowpc{} attribute whose value
is the relocated address of the first machine instruction
generated for the statement identified by the label in
the source program.  The label entry also has a 
\DWATname{} attribute 
\addtoindexx{name attribute}
whose value is a null-terminated string containing
the name of the label as it appears in the source program.


\section{With Statement Entries}
\label{chap:withstatemententries}

\textit{Both \addtoindex{Pascal} and 
\addtoindexx{Modula-2}
Modula\dash 2 support the concept of a \doublequote{with}
statement. The with statement specifies a sequence of
executable statements within which the fields of a record
variable may be referenced, unqualified by the name of the
record variable.}

A with statement is represented by a
\addtoindexi{debugging information entry}{with statement entry}
with the tag \DWTAGwithstmtTARG.

A with statement entry may have either a 
\DWATlowpc{} and
\DWAThighpc{} pair of attributes 
\addtoindexx{high PC attribute}
or 
\addtoindexx{low PC attribute}
a \DWATranges{} attribute
\addtoindexx{ranges attribute}
whose values encode the contiguous or non\dash contiguous address
ranges, respectively, of the machine instructions generated
for the with statement 
(see Section \refersec{chap:codeaddressesandranges}).

A 
\hypertarget{chap:DWATentrypcofwithstmt}{}
with statement entry may also have 
\addtoindexx{entry PC attribute!for with statement}
a 
\DWATentrypc{} attribute
whose value is the address of the first executable instruction
of the with statement (see 
Section \refersec{chap:entryaddress}).

\needlines{5}
The with statement entry has 
\addtoindexx{type attribute}
a \DWATtype{} attribute, denoting
the type of record whose fields may be referenced without full
qualification within the body of the statement. It also has
\addtoindexx{location attribute}
a \DWATlocation{} attribute, describing how to find the base
address of the record object referenced within the body of
the with statement.

\needlines{6}
\section{Try and Catch Block Entries}
\label{chap:tryandcatchblockentries}
\livetargi{chap:tryandcatchblockentries}{}
\textit{In \addtoindex{C++}, a \livelink{chap:lexicalblock}{lexical block} may be 
designated as a \doublequote{catch \nolink{block}.} 
A catch \nolink{block} is an exception handler that 
handles exceptions thrown by an immediately preceding 
\doublequote{try \nolink{block}.}
A catch \nolink{block} 
designates the type of the exception that it can handle.}

A \livetargi{chap:tryblock}{try block}{try block} is represented 
by a debugging information entry
\addtoindexx{try block entry}
with the tag \DWTAGtryblockTARG.  
A \livetargi{chap:catchblock}{catch block} is represented by
a debugging information entry
\addtoindexx{catch block entry}
with the tag \DWTAGcatchblockTARG.

% nolink as we have links just above and do not have a combo link for both
Both try and catch \nolink{block} entries may have either a
\DWATlowpc{} and 
\DWAThighpc{} pair of attributes 
\addtoindexx{high PC attribute}
or 
\addtoindexx{low PC attribute}
a
\DWATranges{} attribute 
\addtoindexx{ranges attribute}
whose values encode the contiguous
or non\dash contiguous address ranges, respectively, of the
machine instructions generated for the \nolink{block}
(see Section \refersec{chap:codeaddressesandranges}).

\hypertarget{chap:DWATentrypcoftryblock}{}
\hypertarget{chap:DWATentrypcofcatchblock}{}
A try or catch block entry may also have 
\addtoindexx{entry PC attribute!for try block}
\addtoindexx{entry PC attribute!for catch block}
a 
\DWATentrypc{} attribute
whose value is the address of the first executable instruction
of the try or catch block 
(see Section \refersec{chap:entryaddress}).

\needlines{4}
Catch \nolink{block} entries have at least one child entry, 
an entry representing the type of exception accepted by
that catch \nolink{block}. 
This child entry has one of the tags
\DWTAGformalparameter{}\addtoindexx{formal parameter entry!in catch block}
or
\DWTAGunspecifiedparameters,\addtoindexx{unspecified parameters entry!in catch block}
and will have the same form as other parameter entries.

The siblings immediately following a try \nolink{block} 
entry are its corresponding catch \nolink{block} entries.

