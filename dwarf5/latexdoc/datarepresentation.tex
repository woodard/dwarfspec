\chapter{Data Representation}
\label{datarep:datarepresentation}

This section describes the binary representation of the
debugging information entry itself, of the attribute types
and of other fundamental elements described above.


\section{Vendor Extensibility}
\label{datarep:vendorextensibility}
\addtoindexx{vendor extensibility}
\addtoindexx{vendor specific extensions|see{vendor extensibility}}

To 
\addtoindexx{extensibility|see{vendor extensibility}}
reserve a portion of the DWARF name space and ranges of
enumeration values for use for vendor specific extensions,
special labels are reserved for tag names, attribute names,
base type encodings, location operations, language names,
calling conventions and call frame instructions.

The labels denoting the beginning and end of the reserved
\hypertarget{chap:DWXXXlohiuser}{}
value range for vendor specific extensions consist of the
appropriate prefix 
(\DWTAGlouserMARK\DWTAGhiuserMARK{}	DW\_TAG, 
\DWATlouserMARK\DWAThiuserMARK{}	DW\_AT,
\DWENDlouserMARK\DWENDhiuserMARK{}	DW\_END, 
\DWATElouserMARK\DWATEhiuserMARK{}	DW\_ATE, 
\DWOPlouserMARK\DWOPhiuserMARK{}	DW\_OP, 
\DWLANGlouserMARK\DWLANGhiuserMARK{}DW\_LANG, 
\DWLNElouserMARK\DWLNEhiuserMARK{}	DW\_LNE, 
\DWCClouserMARK\DWCChiuserMARK{}	DW\_CC or 
\DWCFAlouserMARK\DWCFAhiuserMARK{}	DW\_CFA 
respectively) followed by
\_lo\_user or \_hi\_user. 
\textit{For example, for entry tags, the special
labels are \DWTAGlouserNAME{} and \DWTAGhiuserNAME.}
Values in the  range between \textit{prefix}\_lo\_user 
and \textit{prefix}\_hi\_user inclusive,
are reserved for vendor specific extensions. Vendors may
use values in this range without conflicting with current or
future system\dash defined values. All other values are reserved
for use by the system.

\textit{There may also be codes for vendor specific extensions
between the number of standard line number opcodes and
the first special line number opcode. However, since the
number of standard opcodes varies with the DWARF version,
the range for extensions is also version dependent. Thus,
\DWLNSlouserTARG{} and 
\DWLNShiuserTARG{} symbols are not defined.
}

Vendor defined tags, attributes, base type encodings, location
atoms, language names, line number actions, calling conventions
and call frame instructions, conventionally use the form
\text{prefix\_vendor\_id\_name}, where 
\textit{vendor\_id}\addtoindexx{vendor id} is some identifying
character sequence chosen so as to avoid conflicts with
other vendors.

To ensure that extensions added by one vendor may be safely
ignored by consumers that do not understand those extensions,
the following rules should be followed:
\begin{enumerate}[1. ]

\item New attributes should be added in such a way that a
debugger may recognize the format of a new attribute value
without knowing the content of that attribute value.

\item The semantics of any new attributes should not alter
the semantics of previously existing attributes.

\item The semantics of any new tags should not conflict with
the semantics of previously existing tags.

\item Do not add any new forms of attribute value.

\end{enumerate}


\section{Reserved Values}
\label{datarep:reservedvalues}
\subsection{Error Values}
\label{datarep:errorvalues}
\addtoindexx{reserved values!error}

As 
\addtoindexx{error value}
a convenience for consumers of DWARF information, the value
0 is reserved in the encodings for attribute names, attribute
forms, base type encodings, location operations, languages,
line number program opcodes, macro information entries and tag
names to represent an error condition or unknown value. DWARF
does not specify names for these reserved values, since they
do not represent valid encodings for the given type and should
not appear in DWARF debugging information.


\subsection{Initial Length Values}
\label{datarep:initiallengthvalues}
\addtoindexx{reserved values!initial length}

An \livetarg{datarep:initiallengthvalues}{initial length field} is one of the length fields that occur
at the beginning 
of those DWARF sections that 
have a header
(\dotdebugaranges{}, 
\dotdebuginfo{}, 
\dotdebugtypes{}, 
\dotdebugline{},
\dotdebugpubnames{}, and 
\dotdebugpubtypes{}) or the length field
that occurs at the beginning of the CIE and FDE structures
in the \dotdebugframe{} section.

In an \addtoindex{initial length field}, the values \wfffffffzero through
\wffffffff are reserved by DWARF to indicate some form of
extension relative to \addtoindex{DWARF Version 2}; such values must not
be interpreted as a length field. The use of one such value,
\xffffffff, is defined below 
(see Section \refersec{datarep:32bitand64bitdwarfformats}); 
the use of
the other values is reserved for possible future extensions.



\section{Relocatable, Executable, Shared and Split Objects} 
\label{datarep:executableobjectsandsharedobjects}

\subsection{Relocatable Objects}

\subsection{Executable Objects}
\label{chap:executableobjects}
The relocated addresses in the debugging information for an
executable object are virtual addresses.

\subsection{Shared Objects}
\label{datarep:sharedobjects}
The relocated
addresses in the debugging information for a shared object
are offsets relative to the start of the lowest region of
memory loaded from that shared object.

\textit{This requirement makes the debugging information for
shared objects position independent.  Virtual addresses in a
shared object may be calculated by adding the offset to the
base address at which the object was attached. This offset
is available in the run\dash time linker\textquoteright s data structures.}

\subsection{Split DWARF Objects}
\label{datarep:splitdwarfobjects}
A DWARF producer may partition the debugging
information such that the majority of the debugging
information can remain in individual object files without
being processed by the linker. The first partition contains
debugging information that must still be processed by the linker,
and includes the following:
\begin{itemize}
\item
The line number tables, range tables, frame tables, and
accelerated access tables, in the usual sections:
\dotdebugline, \dotdebugranges, \dotdebugframe,
\dotdebugpubnames, \dotdebugpubtypes{} and \dotdebugaranges,
respectively.
\item
An address table, in the \dotdebugaddr{} section. This table
contains all addresses and constants that require
link-time relocation, and items in the table can be
referenced indirectly from the debugging information via
the \DWFORMaddrx{} form, and by the \DWOPaddrx{} and
\DWOPconstx{} operators.
\item
A skeleton compilation unit, as described in Section
\refersec{chap:skeletoncompilationunitentries}, 
in the \dotdebuginfo{} section.
\item
An abbreviations table for the skeleton compilation unit,
in the \dotdebugabbrev{} section.
\item
A string table, in the \dotdebugstr{} section. The string
table is necessary only if the skeleton compilation unit
uses either indirect string form, \DWFORMstrp{} or
\DWFORMstrx.
\item
A string offsets table, in the \dotdebugstroffsets{}
section. The string offsets table is necessary only if
the skeleton compilation unit uses the \DWFORMstrx{} form.
\end{itemize}
The attributes contained in the skeleton compilation
unit can be used by a DWARF consumer to find the object file
or DWARF object file that contains the second partition.

The second partition contains the debugging information that
does not need to be processed by the linker. These sections
may be left in the object files and ignored by the linker
(i.e., not combined and copied to the executable object), or
they may be placed by the producer in a separate DWARF object
file. This partition includes the following:
\begin{itemize}
\item
The full compilation unit, in the \dotdebuginfodwo{} section.
Attributes in debugging information entries may refer to
machine addresses indirectly using the \DWFORMaddrx{} form,
and location expressions may do so using the \DWOPaddrx{} and
\DWOPconstx{} forms. Attributes may refer to range table
entries with an offset relative to a base offset in the
range table for the compilation unit.

\item Separate type units, in the \dotdebugtypesdwo{} section.

\item
Abbreviations table(s) for the compilation unit and type
units, in the \dotdebugabbrevdwo{} section.

\item Location lists, in the \dotdebuglocdwo{} section.

\item
A skeleton line table (for the type units), in the
\dotdebuglinedwo{} section (see 
Section \refersec{chap:skeletoncompilationunitentries}).

\item Macro information, in the \dotdebugmacinfodwo{} section.

\item A string table, in the \dotdebugstrdwo{} section.

\item A string offsets table, in the \dotdebugstroffsetsdwo{}
section.
\end{itemize}

Except where noted otherwise, all references in this document
to a debugging information section (for example, \dotdebuginfo),
applies also to the corresponding split DWARF section (for example,
\dotdebuginfodwo).


\section{32-Bit and 64-Bit DWARF Formats}
\label{datarep:32bitand64bitdwarfformats}
\hypertarget{datarep:xxbitdwffmt}{}
\addtoindexx{32-bit DWARF format}
\addtoindexx{64-bit DWARF format}
There are two closely related file formats. In the 32\dash bit DWARF
format, all values that represent lengths of DWARF sections
and offsets relative to the beginning of DWARF sections are
represented using 32\dash bits. In the 64\dash bit DWARF format, all
values that represent lengths of DWARF sections and offsets
relative to the beginning of DWARF sections are represented
using 64\dash bits. A special convention applies to the initial
length field of certain DWARF sections, as well as the CIE and
FDE structures, so that the 32\dash bit and 64\dash bit DWARF formats
can coexist and be distinguished within a single linked object.

The differences between the 32\dash\   and 64\dash bit 
DWARF formats are
detailed in the following:
\begin{enumerate}[1. ]

\item  In the 32\dash bit DWARF format, an 
\addtoindex{initial length field}
(see 
\addtoindexx{initial length field!encoding}
Section \refersec{datarep:initiallengthvalues}) 
is an unsigned 32\dash bit integer (which
must be less than \xfffffffzero); in the 64\dash bit DWARF format,
an \addtoindex{initial length field} is 96 bits in size,
and has two parts:
\begin{itemize}
\item The first 32\dash bits have the value \xffffffff.

\item  The following 64\dash bits contain the actual length
represented as an unsigned 64\dash bit integer.
\end{itemize}

\textit{This representation allows a DWARF consumer to dynamically
detect that a DWARF section contribution is using the 64\dash bit
format and to adapt its processing accordingly.}

\item Section offset and section length
\hypertarget{datarep:sectionoffsetlength}{} 
\addtoindexx{section length!use in headers}
fields that occur
\addtoindexx{section offset!use in headers}
in the headers of DWARF sections (other 
\addtoindexx{initial length field}
than 
\addtoindex{initial length}
fields) are listed following. In the 32\dash bit DWARF format these
are 32\dash bit unsigned integer values; in the 64\dash bit DWARF format,
they 
\addtoindexx{section length!in .debug\_aranges header}
are 
\addtoindexx{section length!in .debug\_pubnames header}
64\dash bit 
\addtoindexx{section length!in .debug\_pubtypes header}
unsigned integer values.

\begin{center}
\begin{tabular}{lll}
Section &Name & Role  \\ \hline
\dotdebugaranges{} & \addtoindex{debug\_info\_offset} & offset in \dotdebuginfo{} \\
\dotdebugframe{}/CIE & \addtoindex{CIE\_id} & CIE distinguished value \\
\dotdebugframe{}/FDE & \addtoindex{CIE\_pointer} & offset in \dotdebugframe{} \\
\dotdebuginfo{} & \addtoindex{debug\_abbrev\_offset} & offset in \dotdebugabbrev{} \\
\dotdebugline{} & \addtoindex{header\_length} & length of header itself \\
\dotdebugpubnames{} & \addtoindex{debug\_info\_offset} & offset in \dotdebuginfo{} \\
                & \addtoindex{debug\_info\_length} & length of \dotdebuginfo{} \\
                &                   & contribution \\
\dotdebugpubtypes{} & \addtoindex{debug\_info\_offset} & offset in \dotdebuginfo{} \\
                & \addtoindex{debug\_info\_length} & length of \dotdebuginfo{} \\
                &                   & contribution \\
\dotdebugtypes{} & \addtoindex{debug\_abbrev\_offset} & offset in \dotdebugabbrev{} \\
                & \addtoindex{type\_offset} & offset in \dotdebugtypes{} \\

\end{tabular}
\end{center}

The \texttt{CIE\_id} field in a CIE structure must be 64 bits because
it overlays the \texttt{CIE\_pointer} in a FDE structure; this implicit
union must be accessed to distinguish whether a CIE or FDE is
present, consequently, these two fields must exactly overlay
each other (both offset and size).

\item Within the body of the \dotdebuginfo{} or \dotdebugtypes{}
section, certain forms of attribute value depend on the choice
of DWARF format as follows. For the 32\dash bit DWARF format,
the value is a 32\dash bit unsigned integer; for the 64\dash bit DWARF
format, the value is a 64\dash bit unsigned integer.
\begin{center}
\begin{tabular}{ll}
Form & Role  \\ \hline
\DWFORMrefaddr& offset in \dotdebuginfo{} \\
\DWFORMsecoffset& offset in a section other than \\
											&\dotdebuginfo{} or \dotdebugstr{} \\
\DWFORMstrp&offset in \dotdebugstr{} \\
\DWOPcallref&offset in \dotdebuginfo{} \\
\end{tabular}
\end{center}

\item Within the body of the \dotdebugpubnames{} and
\dotdebugpubtypes{} 
sections, the representation of the first field
of each tuple (which represents an offset in the 
\dotdebuginfo{}
section) depends on the DWARF format as follows: in the
32\dash bit DWARF format, this field is a 32\dash bit unsigned integer;
in the 64\dash bit DWARF format, it is a 64\dash bit unsigned integer.

\end{enumerate}


The 32\dash bit and 64\dash bit DWARF format conventions must \emph{not} be
intermixed within a single compilation unit.

\textit{Attribute values and section header fields that represent
addresses in the target program are not affected by these
rules.}

A DWARF consumer that supports the 64\dash bit DWARF format must
support executables in which some compilation units use the
32\dash bit format and others use the 64\dash bit format provided that
the combination links correctly (that is, provided that there
are no link\dash time errors due to truncation or overflow). (An
implementation is not required to guarantee detection and
reporting of all such errors.)

\textit{It is expected that DWARF producing compilers will \emph{not} use
the 64\dash bit format \emph{by default}. In most cases, the division of
even very large applications into a number of executable and
shared objects will suffice to assure that the DWARF sections
within each individual linked object are less than 4 GBytes
in size. However, for those cases where needed, the 64\dash bit
format allows the unusual case to be handled as well. Even
in this case, it is expected that only application supplied
objects will need to be compiled using the 64\dash bit format;
separate 32\dash bit format versions of system supplied shared
executable libraries can still be used.}



\section{Format of Debugging Information}
\label{datarep:formatofdebugginginformation}

For each compilation unit compiled with a DWARF producer,
a contribution is made to the \dotdebuginfo{} section of
the object file. Each such contribution consists of a
compilation unit header 
(see Section \refersec{datarep:compilationunitheader}) 
followed by a
single \DWTAGcompileunit{} or 
\DWTAGpartialunit{} debugging
information entry, together with its children.

For each type defined in a compilation unit, a contribution may
be made to the \dotdebugtypes{} 
section of the object file. Each
such contribution consists of a 
\addtoindex{type unit} header 
(see Section \refersec{datarep:typeunitheader}) 
followed by a \DWTAGtypeunit{} entry, together with
its children.

Each debugging information entry begins with a code that
represents an entry in a separate 
\addtoindex{abbreviations table}. This
code is followed directly by a series of attribute values.

The appropriate entry in the 
\addtoindex{abbreviations table} guides the
interpretation of the information contained directly in the
\dotdebuginfo{} or 
\dotdebugtypes{} section.

\needlines{4}
Multiple debugging information entries may share the same
abbreviation table entry. Each compilation unit is associated
with a particular abbreviation table, but multiple compilation
units may share the same table.
\subsection{Unit Headers}
\label{datarep:unitheaders}

\subsubsection{Compilation Unit Header}
\label{datarep:compilationunitheader}
\begin{enumerate}[1. ]

\item \texttt{unit\_length} (\livelink{datarep:initiallengthvalues}{initial length}) \\
\addttindexx{unit\_length}
A 4\dash byte or 12\dash byte 
\addtoindexx{initial length}
unsigned integer representing the length
of the \dotdebuginfo{}
contribution for that compilation unit,
not including the length field itself. In the \thirtytwobitdwarfformat,
 this is a 4\dash byte unsigned integer (which must be less
than \xfffffffzero); in the \sixtyfourbitdwarfformat, this consists
of the 4\dash byte value \wffffffff followed by an 8\dash byte unsigned
integer that gives the actual length 
(see Section \refersec{datarep:32bitand64bitdwarfformats}).

\needlines{4}
\item  \texttt{version} (\addtoindex{uhalf}) \\
A 2\dash byte unsigned integer representing the version of the
DWARF information for the compilation unit \addtoindexx{version number!compilation unit} 
(see Appendix \refersec{app:dwarfsectionversionnumbersinformative}). 
The value in this field is 4.

\item \addttindex{debug\_abbrev\_offset} (\livelink{datarep:sectionoffsetlength}{section offset}) \\
A 
\addtoindexx{section offset!in .debug\_info header}
4\dash byte or 8\dash byte unsigned offset into the 
\dotdebugabbrev{}
section. This offset associates the compilation unit with a
particular set of debugging information entry abbreviations. In
the \thirtytwobitdwarfformat, this is a 4\dash byte unsigned length;
in the \sixtyfourbitdwarfformat, this is an 8\dash byte unsigned length
(see Section \refersec{datarep:32bitand64bitdwarfformats}).

\item \texttt{address\_size} (\addtoindex{ubyte}) \\
A 1\dash byte unsigned integer representing the size in bytes of
\addttindexx{address\_size}
an address on the target architecture. If the system uses
\addtoindexx{address space!segmented}
segmented addressing, this value represents the size of the
offset portion of an address.


\end{enumerate}

\subsubsection{Type Unit Header}
\label{datarep:typeunitheader}

The header for the series of debugging information entries
contributing to the description of a type that has been
placed in its own \addtoindex{type unit}, within the 
\dotdebugtypes{} section,
consists of the following information:
\begin{enumerate}[1. ]

\item \texttt{unit\_length} (\livelink{datarep:initiallengthvalues}{initial length}) \\
\addttindexx{unit\_length}
A 4\dash byte or 12\dash byte unsigned integer 
\addtoindexx{initial length}
representing the length
of the \dotdebugtypes{} contribution for that type unit,
not including the length field itself. In the \thirtytwobitdwarfformat, 
this is a 4\dash byte unsigned integer (which must be
less than \xfffffffzero); in the \sixtyfourbitdwarfformat, this
consists of the 4\dash byte value \wffffffff followed by an 
8\dash byte unsigned integer that gives the actual length
(see Section \refersec{datarep:32bitand64bitdwarfformats}).

\needlines{4}
\item  \texttt{version} (\addtoindex{uhalf}) \\
A 2\dash byte unsigned integer representing the version of the
DWARF information for the 
type unit\addtoindexx{version number!type unit} 
(see Appendix \refersec{app:dwarfsectionversionnumbersinformative}). 
The value in this field is 4.

\item \addttindex{debug\_abbrev\_offset} (\livelink{datarep:sectionoffsetlength}{section offset}) \\
A 
\addtoindexx{section offset!in .debug\_types header}
4\dash byte or 8\dash byte unsigned offset into the 
\dotdebugabbrev{}
section. This offset associates the type unit with a
particular set of debugging information entry abbreviations. In
the \thirtytwobitdwarfformat, this is a 4\dash byte unsigned length;
in the \sixtyfourbitdwarfformat, this is an 8\dash byte unsigned length
(see Section \refersec{datarep:32bitand64bitdwarfformats}).

\item \texttt{address\_size} (ubyte) \\
A 1\dash byte unsigned integer representing the size 
\addtoindexx{size of an address}
in bytes of
\addttindexx{address\_size}
an address on the target architecture. If the system uses
\addtoindexx{address space!segmented}
segmented addressing, this value represents the size of the
offset portion of an address.

\item \texttt{type\_signature} (8\dash byte unsigned integer) \\
\addtoindexx{type signature}
A 
\addttindexx{type\_signature}
64\dash bit unique signature (see Section 
\refersec{datarep:typesignaturecomputation})
of the type described in this type
unit.  

\textit{An attribute that refers (using 
\DWFORMrefsigeight{}) to
the primary type contained in this 
\addtoindex{type unit} uses this value.}

\item \texttt{type\_offset} (\livelink{datarep:sectionoffsetlength}{section offset}) \\
\addttindexx{type\_offset}
A 4\dash byte or 8\dash byte unsigned offset 
\addtoindexx{section offset!in .debug\_types header}
relative to the beginning
of the \addtoindex{type unit} header.
This offset refers to the debugging
information entry that describes the type. Because the type
may be nested inside a namespace or other structures, and may
contain references to other types that have not been placed in
separate type units, it is not necessarily either the first or
the only entry in the type unit. In the \thirtytwobitdwarfformat,
this is a 4\dash byte unsigned length; in the \sixtyfourbitdwarfformat,
this is an 8\dash byte unsigned length
(see Section \refersec{datarep:32bitand64bitdwarfformats}).

\end{enumerate}

\subsection{Debugging Information Entry}
\label{datarep:debugginginformationentry}

Each debugging information entry begins with an unsigned LEB128
number containing the abbreviation code for the entry. This
code represents an entry within the abbreviations table
associated with the compilation unit containing this entry. The
abbreviation code is followed by a series of attribute values.

On some architectures, there are alignment constraints on
section boundaries. To make it easier to pad debugging
information sections to satisfy such constraints, the
abbreviation code 0 is reserved. Debugging information entries
consisting of only the abbreviation code 0 are considered
null entries.

\subsection{Abbreviations Tables}
\label{datarep:abbreviationstables}

The abbreviations tables for all compilation units
are contained in a separate object file section called
\dotdebugabbrev{}.
As mentioned before, multiple compilation
units may share the same abbreviations table.

The abbreviations table for a single compilation unit consists
of a series of abbreviation declarations. Each declaration
specifies the tag and attributes for a particular form of
debugging information entry. Each declaration begins with
an unsigned LEB128 number representing the abbreviation
code itself. It is this code that appears at the beginning
of a debugging information entry in the 
\dotdebuginfo{} or
\dotdebugtypes{}
section. As described above, the abbreviation
code 0 is reserved for null debugging information entries. The
abbreviation code is followed by another unsigned LEB128
number that encodes the entry\textquoteright s tag. The encodings for the
tag names are given in 
Table \refersec{tab:tagencodings}.

\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|l}
  \hline
  \caption{Tag encodings} \label{tab:tagencodings} \\
  \hline \bfseries Tag name&\bfseries Value\\ \hline
\endfirsthead
  \bfseries Tag name&\bfseries Value \\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot
\DWTAGarraytype{} &0x01 \\
\DWTAGclasstype&0x02 \\
\DWTAGentrypoint&0x03 \\
\DWTAGenumerationtype&0x04 \\
\DWTAGformalparameter&0x05 \\
\DWTAGimporteddeclaration&0x08 \\
\DWTAGlabel&0x0a \\
\DWTAGlexicalblock&0x0b \\
\DWTAGmember&0x0d \\
\DWTAGpointertype&0x0f \\
\DWTAGreferencetype&0x10 \\
\DWTAGcompileunit&0x11 \\
\DWTAGstringtype&0x12 \\
\DWTAGstructuretype&0x13 \\
\DWTAGsubroutinetype&0x15 \\
\DWTAGtypedef&0x16 \\
\DWTAGuniontype&0x17 \\
\DWTAGunspecifiedparameters&0x18  \\
\DWTAGvariant&0x19  \\
\DWTAGcommonblock&0x1a  \\
\DWTAGcommoninclusion&0x1b  \\
\DWTAGinheritance&0x1c  \\
\DWTAGinlinedsubroutine&0x1d  \\
\DWTAGmodule&0x1e  \\
\DWTAGptrtomembertype&0x1f  \\
\DWTAGsettype&0x20  \\
\DWTAGsubrangetype&0x21  \\
\DWTAGwithstmt&0x22  \\
\DWTAGaccessdeclaration&0x23  \\
\DWTAGbasetype&0x24  \\
\DWTAGcatchblock&0x25  \\
\DWTAGconsttype&0x26  \\
\DWTAGconstant&0x27  \\
\DWTAGenumerator&0x28  \\
\DWTAGfiletype&0x29  \\
\DWTAGfriend&0x2a  \\
\DWTAGnamelist&0x2b    \\
\DWTAGnamelistitem&0x2c    \\
\DWTAGpackedtype&0x2d    \\
\DWTAGsubprogram&0x2e    \\
\DWTAGtemplatetypeparameter&0x2f    \\
\DWTAGtemplatevalueparameter&0x30    \\
\DWTAGthrowntype&0x31    \\
\DWTAGtryblock&0x32    \\
\DWTAGvariantpart&0x33    \\
\DWTAGvariable&0x34    \\
\DWTAGvolatiletype&0x35    \\
\DWTAGdwarfprocedure&0x36     \\
\DWTAGrestricttype&0x37      \\
\DWTAGinterfacetype&0x38      \\
\DWTAGnamespace&0x39      \\
\DWTAGimportedmodule&0x3a      \\
\DWTAGunspecifiedtype&0x3b      \\
\DWTAGpartialunit&0x3c      \\
\DWTAGimportedunit&0x3d      \\
\DWTAGcondition&\xiiif      \\
\DWTAGsharedtype&0x40      \\
\DWTAGtypeunit{} &0x41      \\
\DWTAGrvaluereferencetype{} &0x42      \\
\DWTAGtemplatealias{} &0x43      \\
\DWTAGcoarraytype &0x44 \\
\DWTAGgenericsubrange &0x45 \\
\DWTAGlouser&0x4080      \\
\DWTAGhiuser&\xffff      \\
\end{longtable}
\end{centering}

Following the tag encoding is a 1\dash byte value that determines
whether a debugging information entry using this abbreviation
has child entries or not. If the value is 
\DWCHILDRENyesTARG,
the next physically succeeding entry of any debugging
information entry using this abbreviation is the first
child of that entry. If the 1\dash byte value following the
abbreviation\textquoteright s tag encoding is 
\DWCHILDRENnoTARG, the next
physically succeeding entry of any debugging information entry
using this abbreviation is a sibling of that entry. (Either
the first child or sibling entries may be null entries). The
encodings for the child determination byte are given in 
Table \refersec{tab:childdeterminationencodings}
(As mentioned in 
Section \refersec{chap:relationshipofdebugginginformationentries}, 
each chain of sibling entries is terminated by a null entry.)

\needlines{6}
\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|l}
  \caption{Child determination encodings}
  \label{tab:childdeterminationencodings}
  \addtoindexx{Child determination encodings} \\
  \hline \bfseries Children determination name&\bfseries Value \\ \hline
\endfirsthead
  \bfseries Children determination name&\bfseries Value \\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot
\DWCHILDRENno&0x00 \\ 
\DWCHILDRENyes&0x01 \\ \hline
\end{longtable}
\end{centering}

\needlines{4}
Finally, the child encoding is followed by a series of
attribute specifications. Each attribute specification
consists of two parts. The first part is an unsigned LEB128
number representing the attribute\textquoteright s name. The second part
is an unsigned LEB128 number representing the attribute\textquoteright s
form. The series of attribute specifications ends with an
entry containing 0 for the name and 0 for the form.

The attribute form 
\DWFORMindirectTARG{} is a special case. For
attributes with this form, the attribute value itself in the
\dotdebuginfo{} or 
\dotdebugtypes{}
section begins with an unsigned
LEB128 number that represents its form. This allows producers
to choose forms for particular attributes 
\addtoindexx{abbreviations table!dynamic forms in}
dynamically,
without having to add a new entry to the abbreviations table.

The abbreviations for a given compilation unit end with an
entry consisting of a 0 byte for the abbreviation code.

\textit{See 
Appendix \refersec{app:compilationunitsandabbreviationstableexample} 
for a depiction of the organization of the
debugging information.}


\subsection{Attribute Encodings}
\label{datarep:attributeencodings}

The encodings for the attribute names are given in 
Table \refersec{tab:attributeencodings}.

The attribute form governs how the value of the attribute is
encoded. There are nine classes of form, listed below. Each
class is a set of forms which have related representations
and which are given a common interpretation according to the
attribute in which the form is used.

Form \DWFORMsecoffsetTARG{} 
is a member of more 
\addtoindexx{rangelistptr class}
than 
\addtoindexx{macptr class}
one 
\addtoindexx{loclistptr class}
class,
\addtoindexx{lineptr class}
namely \livelink{chap:classlineptr}{lineptr}, 
\livelink{chap:classloclistptr}{loclistptr}, 
\livelink{chap:classmacptr}{macptr} or 
\livelink{chap:classrangelistptr}{rangelistptr}; the list
of classes allowed by the applicable attribute in 
Table \refersec{tab:attributeencodings}
determines the class of the form.

\textit{In DWARF V3 the forms \DWFORMdatafour{} and 
\DWFORMdataeight{} were
\addtoindexx{lineptr class}
members 
\addtoindexx{rangelistptr class}
of 
\addtoindexx{macptr class}
either 
\addtoindexx{loclistptr class}
class constant \addtoindexx{constant class}
or one of the classes 
\livelink{chap:classlineptr}{lineptr},
\livelink{chap:classloclistptr}{loclistptr}, 
\livelink{chap:classmacptr}{macptr} or 
\livelink{chap:classrangelistptr}{rangelistptr}, depending on context. In
DWARF V4 
\DWFORMdatafour{} and 
\DWFORMdataeight{} are members of class
constant in all cases. 
The new 
\DWFORMsecoffset{} replaces
their usage for the other classes.}

Each possible form belongs to one or more of the following classes:

\begin{itemize}
\item \livelinki{chap:classaddress}{address}{address class} \\
\livetarg{datarep:classaddress}{}
Represented as either:
\begin{itemize}
\item An object of appropriate size to hold an
address on the target machine 
(\DWFORMaddrTARG). 
The size is encoded in the compilation unit header 
(see Section \refersec{datarep:compilationunitheader}).
This address is relocatable in a relocatable object file and
is relocated in an executable file or shared object.

\item As an indirect index into a table of addresses (as 
described in the previous bullet) in the
\dotdebugaddr{} section (\DWFORMaddrxTARG). 
The representation of a \DWFORMaddrxNAME{} value is an unsigned
\addtoindex{LEB128} value, which is interpreted as a zero-based 
index into an array of addresses in the \dotdebugaddr{} section.
\end{itemize}

\needlines{4}
\item \livelink{chap:classblock}{block} \\
\livetarg{datarep:classblock}{}
Blocks come in four forms:

\begin{myindentpara}{1cm}
A 1\dash byte length followed by 0 to 255 contiguous information
bytes (\DWFORMblockoneTARG).
\end{myindentpara}

\begin{myindentpara}{1cm}
A 2\dash byte length followed by 0 to 65,535 contiguous information
bytes (\DWFORMblocktwoTARG).
\end{myindentpara}

\begin{myindentpara}{1cm}
A 4\dash byte length followed by 0 to 4,294,967,295 contiguous
information bytes (\DWFORMblockfourTARG).
\end{myindentpara}

\begin{myindentpara}{1cm}
An unsigned LEB128 length followed by the number of bytes
specified by the length (\DWFORMblockTARG).
\end{myindentpara}

In all forms, the length is the number of information bytes
that follow. The information bytes may contain any mixture
of relocated (or relocatable) addresses, references to other
debugging information entries or data bytes.

\item \livelinki{chap:classconstant}{constant}{constant class} \\
\livetarg{datarep:classconstant}{}
There are six forms of constants. There are fixed length
constant data forms for one, two, four and eight byte values
(respectively, 
\DWFORMdataoneTARG, 
\DWFORMdatatwoTARG, 
\DWFORMdatafourTARG,
and \DWFORMdataeightTARG). 
There are also variable length constant
data forms encoded using LEB128 numbers (see below). Both
signed (\DWFORMsdataTARG) and unsigned 
(\DWFORMudataTARG) variable
length constants are available

The data in \DWFORMdataone, 
\DWFORMdatatwo, 
\DWFORMdatafour{} and
\DWFORMdataeight{} 
can be anything. Depending on context, it may
be a signed integer, an unsigned integer, a floating\dash point
constant, or anything else. A consumer must use context to
know how to interpret the bits, which if they are target
machine data (such as an integer or floating point constant)
will be in target machine byte\dash order.

\textit{If one of the \DWFORMdataTARG\textless n\textgreater 
forms is used to represent a
signed or unsigned integer, it can be hard for a consumer
to discover the context necessary to determine which
interpretation is intended. Producers are therefore strongly
encouraged to use \DWFORMsdata{} or 
\DWFORMudata{} for signed and
unsigned integers respectively, rather than 
\DWFORMdata\textless n\textgreater.}

\needlines{4}
\item \livelinki{chap:classexprloc}{exprloc}{exprloc class} \\
\livetarg{datarep:classexprloc}{}
This is an unsigned LEB128 length followed by the
number of information bytes specified by the length
(\DWFORMexprlocTARG). 
The information bytes contain a DWARF expression 
(see Section \refersec{chap:dwarfexpressions}) 
or location description 
(see Section \refersec{chap:locationdescriptions}).

\item \livelinki{chap:classflag}{flag}{flag class} \\
\livetarg{datarep:classflag}{}
A flag \addtoindexx{flag class}
is represented explicitly as a single byte of data
(\DWFORMflagTARG) or 
implicitly (\DWFORMflagpresentTARG). 
In the
first case, if the \nolink{flag} has value zero, it indicates the
absence of the attribute; if the \nolink{flag} has a non\dash zero value,
it indicates the presence of the attribute. In the second
case, the attribute is implicitly indicated as present, and
no value is encoded in the debugging information entry itself.

\item \livelinki{chap:classlineptr}{lineptr}{lineptr class} \\
\livetarg{datarep:classlineptr}{}
This is an offset into 
\addtoindexx{section offset!in class lineptr value}
the 
\dotdebugline{} section
(\DWFORMsecoffset).
It consists of an offset from the beginning of the 
\dotdebugline{}
section to the first byte of
the data making up the line number list for the compilation
unit. 
It is relocatable in a relocatable object file, and
relocated in an executable or shared object. In the 
\thirtytwobitdwarfformat, this offset is a 4\dash byte unsigned value;
in the \sixtyfourbitdwarfformat, it is an 8\dash byte unsigned value
(see Section \refersec{datarep:32bitand64bitdwarfformats}).


\item \livelinki{chap:classloclistptr}{loclistptr}{loclistptr class} \\
\livetarg{datarep:classloclistptr}{}
This is an offset into the 
\dotdebugloc{}
section
(\DWFORMsecoffset). 
It consists of an offset from the
\addtoindexx{section offset!in class loclistptr value}
beginning of the 
\dotdebugloc{}
section to the first byte of
the data making up the 
\addtoindex{location list} for the compilation unit. 
It is relocatable in a relocatable object file, and
relocated in an executable or shared object. In the 
\thirtytwobitdwarfformat, this offset is a 4\dash byte unsigned value;
in the \sixtyfourbitdwarfformat, it is an 8\dash byte unsigned value
(see Section \refersec{datarep:32bitand64bitdwarfformats}).


\item \livelinki{chap:classmacptr}{macptr}{macptr class} \\
\livetarg{datarep:classmacptr}{}
This is an 
\addtoindexx{section offset!in class macptr value}
offset into the 
\dotdebugmacinfo{} section
(\DWFORMsecoffset). 
It consists of an offset from the
beginning of the \dotdebugmacinfo{} 
section to the first byte of
the data making up the macro information list for the compilation
unit. 
It is relocatable in a relocatable object file, and
relocated in an executable or shared object. In the 
\thirtytwobitdwarfformat, this offset is a 4\dash byte unsigned value;
in the \sixtyfourbitdwarfformat, it is an 8\dash byte unsigned value
(see Section \refersec{datarep:32bitand64bitdwarfformats}).

\needlines{4}
\item \livelinki{chap:classrangelistptr}{rangelistptr}{rangelistptr class} \\
\livetarg{datarep:classrangelistptr}{}
This is an 
\addtoindexx{section offset!in class rangelistptr value}
offset into the \dotdebugranges{} section
(\DWFORMsecoffset). 
It consists of an
offset from the beginning of the 
\dotdebugranges{} section
to the beginning of the non\dash contiguous address ranges
information for the referencing entity.  
It is relocatable in
a relocatable object file, and relocated in an executable or
shared object. In the \thirtytwobitdwarfformat, this offset
is a 4\dash byte unsigned value; in the 64\dash bit DWARF
format, it is an 8\dash byte unsigned value (see Section
\refersec{datarep:32bitand64bitdwarfformats}).
\end{itemize}

\textit{Because classes \livelink{chap:classlineptr}{lineptr}, 
\livelink{chap:classloclistptr}{loclistptr}, 
\livelink{chap:classmacptr}{macptr} and 
\livelink{chap:classrangelistptr}{rangelistptr}
share a common representation, it is not possible for an
attribute to allow more than one of these classes}


\begin{itemize}
\item \livelinki{chap:classreference}{reference}{reference class} \\
\livetarg{datarep:classreference}{}
There are three types of reference.

The 
\addtoindexx{reference class}
first type of reference can identify any debugging
information entry within the containing unit. 
This type of
reference is an 
\addtoindexx{section offset!in class reference value}
offset from the first byte of the compilation
header for the compilation unit containing the reference. There
are five forms for this type of reference. There are fixed
length forms for one, two, four and eight byte offsets
(respectively,
\DWFORMrefnMARK 
\DWFORMrefoneTARG, 
\DWFORMreftwoTARG, 
\DWFORMreffourTARG,
and \DWFORMrefeightTARG). 
There is also an unsigned variable
length offset encoded form that uses unsigned LEB128 numbers
(\DWFORMrefudataTARG). 
Because this type of reference is within
the containing compilation unit no relocation of the value
is required.

The second type of reference can identify any debugging
information entry within a 
\dotdebuginfo{} section; in particular,
it may refer to an entry in a different compilation unit
from the unit containing the reference, and may refer to an
entry in a different shared object.  This type of reference
(\DWFORMrefaddrTARG) 
is an offset from the beginning of the
\dotdebuginfo{} 
section of the target executable or shared object;
it is relocatable in a relocatable object file and frequently
relocated in an executable file or shared object. For
references from one shared object or static executable file
to another, the relocation and identification of the target
object must be performed by the consumer. In the 
\thirtytwobitdwarfformat, this offset is a 4\dash byte unsigned value; 
in the \sixtyfourbitdwarfformat, it is an 8\dash byte
unsigned value 
(see Section \refersec{datarep:32bitand64bitdwarfformats}).

\textit{A debugging information entry that may be referenced by
another compilation unit using 
\DWFORMrefaddr{} must have a
global symbolic name.}

\textit{For a reference from one executable or shared object to
another, the reference is resolved by the debugger to identify
the shared object or executable and the offset into that
object\textquoteright s \dotdebuginfo{}
section in the same fashion as the run
time loader, either when the debug information is first read,
or when the reference is used.}

The third type of reference can identify any debugging
information type entry that has been placed in its own
\addtoindex{type unit}. This type of 
reference (\DWFORMrefsigeightTARG) is the
\addtoindexx{type signature}
64\dash bit type signature 
(see Section \refersec{datarep:typesignaturecomputation}) 
that was computed
for the type.

\textit{The use of compilation unit relative references will reduce the
number of link\dash time relocations and so speed up linking. The
use of the second and third type of reference allows for the
sharing of information, such as types, across compilation
units.}

\textit{A reference to any kind of compilation unit identifies the
debugging information entry for that unit, not the preceding
header.}

\item \livelinki{chap:classstring}{string}{string class} \\
\livetarg{datarep:classstring}{}
A string is a sequence of contiguous non\dash null bytes followed by
one null byte. 
\addtoindexx{string class}
A string may be represented: 
\begin{itemize}
\item immediately in the debugging information entry itself 
(\DWFORMstringTARG), 
\item as an 
\addtoindexx{section offset!in class string value}
offset into a string table contained in
the \dotdebugstr{} section of the object file 
(\DWFORMstrpTARG).
In the \thirtytwobitdwarfformat, the representation of a 
\DWFORMstrpNAME{}
value is a 4\dash byte unsigned offset; in the \sixtyfourbitdwarfformat,
it is an 8\dash byte unsigned offset 
(see Section \refersec{datarep:32bitand64bitdwarfformats}).
\item as an indirect offset into the string table using an 
index into a table of offsets contained in the 
\dotdebugstroffsets{} section of the object file (\DWFORMstrxTARG).
The representation of a \DWFORMstrxNAME{} value is an unsigned 
\addtoindex{LEB128} value, which is interpreted as a zero-based 
index into an array of offsets in the \dotdebugstroffsets{} section. 
The offset entries in the \dotdebugstroffsets{} section have the 
same representation as \DWFORMstrp{} values.
\end{itemize}
Any combination of these three forms may be used within a single compilation.

If the \DWATuseUTFeight{}
\addtoindexx{use UTF8 attribute}\addtoindexx{UTF-8} attribute is specified for the
compilation, partial or type unit entry, string values are encoded using the
UTF\dash 8 (\addtoindex{Unicode} Transformation Format\dash 8) from the Universal
Character Set standard (ISO/IEC 10646\dash 1:1993). Otherwise,
the string representation is unspecified.

\textit{The \addtoindex{Unicode} Standard Version 3 is fully compatible with
ISO/IEC 10646\dash 1:1993. It contains all the same characters
and encoding points as ISO/IEC 10646, as well as additional
information about the characters and their use.}

\textit{Earlier versions of DWARF did not specify the representation
of strings; for compatibility, this version also does
not. However, the UTF\dash 8 representation is strongly recommended.}

\end{itemize}

In no case does an attribute use 
\addtoindexx{rangelistptr class}
one 
\addtoindexx{loclistptr class}
of 
\addtoindexx{lineptr class}
the 
\addtoindexx{macptr class}
classes \livelink{chap:classlineptr}{lineptr},
\livelink{chap:classloclistptr}{loclistptr}, \livelink{chap:classmacptr}{macptr} or 
\livelink{chap:classrangelistptr}{rangelistptr} to point into either the
\dotdebuginfo{} or \dotdebugstr{} section.

The form encodings are listed in 
Table \refersec{tab:attributeformencodings}.


\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|l|l}
  \caption{Attribute encodings} 
  \label{tab:attributeencodings} 
  \addtoindexx{attribute encodings} \\
  \hline \bfseries Attribute name&\bfseries Value &\bfseries Classes \\ \hline
\endfirsthead
  \bfseries Attribute name&\bfseries Value &\bfseries Classes\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline \ddag\ \textit{New in DWARF Version 5}
\endlastfoot
\DWATsibling&0x01&\livelink{chap:classreference}{reference} 
        \addtoindexx{sibling attribute!encoding} \\
\DWATlocation&0x02&\livelink{chap:classexprloc}{exprloc}, 
        \livelink{chap:classloclistptr}{loclistptr}\addtoindexx{location attribute!encoding}   \\
\DWATname&0x03&\livelink{chap:classstring}{string} 
        \addtoindexx{name attribute!encoding} \\
\DWATordering&0x09&\livelink{chap:classconstant}{constant} 
        \addtoindexx{ordering attribute!encoding}  \\
\DWATbytesize&0x0b&\livelink{chap:classconstant}{constant}, \livelink{chap:classexprloc}{exprloc}, 
        \livelink{chap:classreference}{reference} \addtoindexx{byte size attribute!encoding} \\
\DWATbitoffset&0x0c&\livelink{chap:classconstant}{constant}, 
        \livelink{chap:classexprloc}{exprloc}, \livelink{chap:classreference}{reference} \addtoindexx{bit offset attribute!encoding}  \\
\DWATbitsize&0x0d&\livelink{chap:classconstant}{constant}, 
        \livelink{chap:classexprloc}{exprloc}, \livelink{chap:classreference}{reference} \addtoindexx{bit size attribute!encoding} \\
\DWATstmtlist&0x10&\livelink{chap:classlineptr}{lineptr} 
        \addtoindexx{statement list attribute!encoding} \\
\DWATlowpc&0x11&\livelink{chap:classaddress}{address} 
        \addtoindexx{low PC attribute!encoding}  \\
\DWAThighpc&0x12&\livelink{chap:classaddress}{address}, \livelink{chap:classconstant}{constant} 
        \addtoindexx{high PC attribute!encoding}  \\
\DWATlanguage&0x13&\livelink{chap:classconstant}{constant} 
        \addtoindexx{language attribute!encoding}  \\
\DWATdiscr&0x15&\livelink{chap:classreference}{reference} 
        \addtoindexx{discriminant attribute!encoding}  \\
\DWATdiscrvalue&0x16&\livelink{chap:classconstant}{constant} 
        \addtoindexx{discriminant value attribute!encoding}  \\
\DWATvisibility&0x17&\livelink{chap:classconstant}{constant} 
        \addtoindexx{visibility attribute!encoding} \\
\DWATimport&0x18&\livelink{chap:classreference}{reference} 
        \addtoindexx{import attribute!encoding}  \\
\DWATstringlength&0x19&\livelink{chap:classexprloc}{exprloc}, 
        \livelink{chap:classloclistptr}{loclistptr} \addtoindexx{string length attribute!encoding}  \\
\DWATcommonreference&0x1a&\livelink{chap:classreference}{reference} 
        \addtoindexx{common reference attribute!encoding}  \\
\DWATcompdir&0x1b&\livelink{chap:classstring}{string} 
        \addtoindexx{compilation directory attribute!encoding}  \\
\DWATconstvalue&0x1c&\livelink{chap:classblock}{block}, \livelink{chap:classconstant}{constant}, \livelink{chap:classstring}{string} 
        \addtoindexx{constant value attribute!encoding} \\
\DWATcontainingtype&0x1d&\livelink{chap:classreference}{reference} 
        \addtoindexx{containing type attribute!encoding} \\
\DWATdefaultvalue&0x1e&\livelink{chap:classreference}{reference}, \livelink{chap:classflag}{flag} 
        \addtoindexx{default value attribute!encoding} \\
\DWATinline&0x20&\livelink{chap:classconstant}{constant} 
        \addtoindexx{inline attribute!encoding}  \\
\DWATisoptional&0x21&\livelink{chap:classflag}{flag} 
        \addtoindexx{is optional attribute!encoding} \\
\DWATlowerbound&0x22&\livelink{chap:classconstant}{constant}, 
        \livelink{chap:classexprloc}{exprloc}, \livelink{chap:classreference}{reference} \addtoindexx{lower bound attribute!encoding}  \\
\DWATproducer&0x25&\livelink{chap:classstring}{string} \addtoindexx{producer attribute!encoding}  \\
\DWATprototyped&0x27&\livelink{chap:classflag}{flag} 
        \addtoindexx{prototyped attribute!encoding}  \\
\DWATreturnaddr&0x2a&\livelink{chap:classexprloc}{exprloc},
        \livelink{chap:classloclistptr}{loclistptr} \addtoindexx{return address attribute!encoding}  \\
% FIXME: lower case , not Constant
\DWATstartscope&0x2c&\livelink{chap:classconstant}{constant}, 
        \livelink{chap:classrangelistptr}{rangelistptr} \addtoindexx{start scope attribute!encoding}  \\
\DWATbitstride&0x2e&\livelink{chap:classconstant}{constant},
        \livelink{chap:classexprloc}{exprloc}, \livelink{chap:classreference}{reference} \addtoindexx{bit stride attribute!encoding}  \\
\DWATupperbound&0x2f&\livelink{chap:classconstant}{constant},
        \livelink{chap:classexprloc}{exprloc}, \livelink{chap:classreference}{reference} \addtoindexx{upper bound attribute!encoding}  \\
\DWATabstractorigin&0x31&\livelink{chap:classreference}{reference} 
        \addtoindexx{abstract origin attribute!encoding}  \\
\DWATaccessibility&0x32&\livelink{chap:classconstant}{constant} 
        \addtoindexx{accessibility attribute!encoding}  \\
\DWATaddressclass&0x33&\livelink{chap:classconstant}{constant} 
        \addtoindexx{address class attribute!encoding}  \\
\DWATartificial&0x34&\livelink{chap:classflag}{flag} 
        \addtoindexx{artificial attribute!encoding}  \\
\DWATbasetypes&0x35&\livelink{chap:classreference}{reference} 
        \addtoindexx{base types attribute!encoding}  \\
\DWATcallingconvention&0x36&\livelink{chap:classconstant}{constant} 
        \addtoindexx{calling convention attribute!encoding} \\
\DWATcount&0x37&\livelink{chap:classconstant}{constant}, \livelink{chap:classexprloc}{exprloc}, \livelink{chap:classreference}{reference} 
        \addtoindexx{count attribute!encoding}  \\
\DWATdatamemberlocation&0x38&\livelink{chap:classconstant}{constant}, 
        \livelink{chap:classexprloc}{exprloc}, \livelink{chap:classloclistptr}{loclistptr} 
        \addtoindexx{data member attribute!encoding}  \\
\DWATdeclcolumn&0x39&\livelink{chap:classconstant}{constant} 
        \addtoindexx{declaration column attribute!encoding}  \\
\DWATdeclfile&0x3a&\livelink{chap:classconstant}{constant} 
        \addtoindexx{declaration file attribute!encoding}  \\
\DWATdeclline&0x3b&\livelink{chap:classconstant}{constant} 
        \addtoindexx{declaration line attribute!encoding}  \\
\DWATdeclaration&0x3c&\livelink{chap:classflag}{flag} 
        \addtoindexx{declaration attribute!encoding}  \\
\DWATdiscrlist&0x3d&\livelink{chap:classblock}{block} 
        \addtoindexx{discriminant list attribute!encoding}  \\
\DWATencoding&0x3e&\livelink{chap:classconstant}{constant} 
        \addtoindexx{encoding attribute!encoding}  \\
\DWATexternal&\xiiif&\livelink{chap:classflag}{flag} 
        \addtoindexx{external attribute!encoding}  \\
\DWATframebase&0x40&\livelink{chap:classexprloc}{exprloc}, 
        \livelink{chap:classloclistptr}{loclistptr} \addtoindexx{frame base attribute!encoding}  \\
\DWATfriend&0x41&\livelink{chap:classreference}{reference} 
        \addtoindexx{friend attribute!encoding}  \\
\DWATidentifiercase&0x42&\livelink{chap:classconstant}{constant} 
        \addtoindexx{identifier case attribute!encoding}  \\
\DWATmacroinfo&0x43&\livelink{chap:classmacptr}{macptr} 
        \addtoindexx{macro information attribute!encoding}  \\
\DWATnamelistitem&0x44&\livelink{chap:classreference}{reference} 
        \addtoindexx{name list item attribute!encoding}  \\
\DWATpriority&0x45&\livelink{chap:classreference}{reference} 
        \addtoindexx{priority attribute!encoding}  \\
\DWATsegment&0x46&\livelink{chap:classexprloc}{exprloc}, 
        \livelink{chap:classloclistptr}{loclistptr} \addtoindexx{segment attribute!encoding}  \\
\DWATspecification&0x47&\livelink{chap:classreference}{reference} 
        \addtoindexx{specification attribute!encoding}  \\
\DWATstaticlink&0x48&\livelink{chap:classexprloc}{exprloc}, 
        \livelink{chap:classloclistptr}{loclistptr} \addtoindexx{static link attribute!encoding}  \\
\DWATtype&0x49&\livelink{chap:classreference}{reference} 
        \addtoindexx{type attribute!encoding}  \\
\DWATuselocation&0x4a&\livelink{chap:classexprloc}{exprloc}, 
        \livelink{chap:classloclistptr}{loclistptr} \addtoindexx{location list attribute!encoding}  \\
\DWATvariableparameter&0x4b&\livelink{chap:classflag}{flag} 
        \addtoindexx{variable parameter attribute!encoding}  \\
\DWATvirtuality&0x4c&\livelink{chap:classconstant}{constant} 
        \addtoindexx{virtuality attribute!encoding}  \\
\DWATvtableelemlocation&0x4d&\livelink{chap:classexprloc}{exprloc}, 
        \livelink{chap:classloclistptr}{loclistptr} \addtoindexx{vtable element location attribute!encoding}  \\
\DWATallocated&0x4e&\livelink{chap:classconstant}{constant}, \livelink{chap:classexprloc}{exprloc}, 
        \livelink{chap:classreference}{reference} \addtoindexx{allocated attribute!encoding}  \\
\DWATassociated&0x4f&\livelink{chap:classconstant}{constant}, \livelink{chap:classexprloc}{exprloc}, 
        \livelink{chap:classreference}{reference} \addtoindexx{associated attribute!encoding}  \\
\DWATdatalocation&0x50&\livelink{chap:classexprloc}{exprloc} 
        \addtoindexx{data location attribute!encoding}  \\
\DWATbytestride&0x51&\livelink{chap:classconstant}{constant}, \livelink{chap:classexprloc}{exprloc}, 
        \livelink{chap:classreference}{reference} \addtoindexx{byte stride attribute!encoding}  \\
\DWATentrypc&0x52&\livelink{chap:classaddress}{address}, \livelink{chap:classconstant}{constant} 
        \addtoindexx{entry pc attribute!encoding}  \\
\DWATuseUTFeight&0x53&\livelink{chap:classflag}{flag} 
        \addtoindexx{use UTF8 attribute!encoding}\addtoindexx{UTF-8}  \\
\DWATextension&0x54&\livelink{chap:classreference}{reference} 
        \addtoindexx{extension attribute!encoding}  \\
\DWATranges&0x55&\livelink{chap:classrangelistptr}{rangelistptr} 
        \addtoindexx{ranges attribute!encoding}  \\
\DWATtrampoline&0x56&\livelink{chap:classaddress}{address}, \livelink{chap:classflag}{flag}, 
        \livelink{chap:classreference}{reference}, \livelink{chap:classstring}{string} \addtoindexx{trampoline attribute!encoding}  \\
\DWATcallcolumn&0x57&\livelink{chap:classconstant}{constant} 
        \addtoindexx{call column attribute!encoding}  \\
\DWATcallfile&0x58&\livelink{chap:classconstant}{constant} 
        \addtoindexx{call file attribute!encoding}  \\
\DWATcallline&0x59&\livelink{chap:classconstant}{constant} 
        \addtoindexx{call line attribute!encoding}  \\
\DWATdescription&0x5a&\livelink{chap:classstring}{string} 
        \addtoindexx{description attribute!encoding}  \\
\DWATbinaryscale&0x5b&\livelink{chap:classconstant}{constant} 
        \addtoindexx{binary scale attribute!encoding}  \\
\DWATdecimalscale&0x5c&\livelink{chap:classconstant}{constant} 
        \addtoindexx{decimal scale attribute!encoding}  \\
\DWATsmall{} &0x5d&\livelink{chap:classreference}{reference} 
        \addtoindexx{small attribute!encoding}  \\
\DWATdecimalsign&0x5e&\livelink{chap:classconstant}{constant} 
        \addtoindexx{decimal scale attribute!encoding}  \\
\DWATdigitcount&0x5f&\livelink{chap:classconstant}{constant} 
        \addtoindexx{digit count attribute!encoding}  \\
\DWATpicturestring&0x60&\livelink{chap:classstring}{string} 
        \addtoindexx{picture string attribute!encoding}  \\
\DWATmutable&0x61&\livelink{chap:classflag}{flag} 
        \addtoindexx{mutable attribute!encoding}  \\
\DWATthreadsscaled&0x62&\livelink{chap:classflag}{flag} 
        \addtoindexx{thread scaled attribute!encoding}  \\
\DWATexplicit&0x63&\livelink{chap:classflag}{flag} 
        \addtoindexx{explicit attribute!encoding}  \\
\DWATobjectpointer&0x64&\livelink{chap:classreference}{reference} 
        \addtoindexx{object pointer attribute!encoding}  \\
\DWATendianity&0x65&\livelink{chap:classconstant}{constant} 
        \addtoindexx{endianity attribute!encoding}  \\
\DWATelemental&0x66&\livelink{chap:classflag}{flag} 
        \addtoindexx{elemental attribute!encoding}  \\
\DWATpure&0x67&\livelink{chap:classflag}{flag} 
        \addtoindexx{pure attribute!encoding}  \\
\DWATrecursive&0x68&\livelink{chap:classflag}{flag} 
        \addtoindexx{recursive attribute!encoding}  \\
\DWATsignature{} &0x69&\livelink{chap:classreference}{reference} 
        \addtoindexx{signature attribute!encoding}  \\ 
\DWATmainsubprogram{} &0x6a&\livelink{chap:classflag}{flag} 
        \addtoindexx{main subprogram attribute!encoding}  \\
\DWATdatabitoffset{} &0x6b&\livelink{chap:classconstant}{constant} 
        \addtoindexx{data bit offset attribute!encoding}  \\
\DWATconstexpr{} &0x6c&\livelink{chap:classflag}{flag} 
        \addtoindexx{constant expression attribute!encoding}  \\
\DWATenumclass{} &0x6d&\livelink{chap:classflag}{flag} 
        \addtoindexx{enumeration class attribute!encoding}  \\
\DWATlinkagename{} &0x6e&\livelink{chap:classstring}{string} 
        \addtoindexx{linkage name attribute!encoding}  \\
\DWATstringlengthbitsize{} \ddag&0x6f&
		\livelink{chap:classconstant}{constant}\addtoindexx{string length attribute!size of length}  \\
\DWATstringlengthbytesize{} \ddag&0x70&
		\livelink{chap:classconstant}{constant}\addtoindexx{string length attribute!size of length}  \\
\DWATrank~\ddag&0x71&
		\livelink{chap:DWATrank}{constant, exprloc}\addtoindexx{rank attribute!encoding}  \\
\DWATstroffsetsbase~\ddag&0x72&
		\livelink{chap:classstring}{reference}\addtoindexx{string offsets base!encoding}	\\
\DWATaddrbase~\ddag &0x73&
		\livelink{chap:DWATaddrbase}{reference}\addtoindexx{address table base!encoding} \\
\DWATrangesbase~\ddag&0x74&
		\livelink{chap:DWATrangesbase}{reference}\addtoindexx{ranges base!encoding} \\
\DWATdwoid~\ddag &0x75&
		\livelink{chap:DWATdwoid}{constant}\addtoindexx{split DWARF object id!encoding} \\
\DWATdwoname~\ddag &0x76&
		\livelink{chap:DWATdwname}{string}\addtoindexx{split DWARF object file name!encooding} \\
\DWATlouser&0x2000 & --- \addtoindexx{low user attribute encoding}  \\
\DWAThiuser&\xiiifff& --- \addtoindexx{high user attribute encoding}  \\

\end{longtable} 
\end{centering}


\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|l|l}
  \caption{Attribute form encodings} \label{tab:attributeformencodings} \\
  \hline \bfseries Form name&\bfseries Value &\bfseries Classes \\ \hline
\endfirsthead
  \bfseries Form name&\bfseries Value &\bfseries Classes\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline

\endlastfoot
\DWFORMaddr &0x01&\livelink{chap:classaddress}{address}  \\
\textit{Reserved} &0x02& \\
\DWFORMblocktwo &0x03&\livelink{chap:classblock}{block} \\
\DWFORMblockfour &0x04&\livelink{chap:classblock}{block}  \\
\DWFORMdatatwo &0x05&\livelink{chap:classconstant}{constant} \\
\DWFORMdatafour &0x06&\livelink{chap:classconstant}{constant} \\
\DWFORMdataeight &0x07&\livelink{chap:classconstant}{constant} \\
\DWFORMstring&0x08&\livelink{chap:classstring}{string} \\
\DWFORMblock&0x09&\livelink{chap:classblock}{block} \\
\DWFORMblockone &0x0a&\livelink{chap:classblock}{block} \\
\DWFORMdataone &0x0b&\livelink{chap:classconstant}{constant} \\
\DWFORMflag&0x0c&\livelink{chap:classflag}{flag} \\
\DWFORMsdata&0x0d&\livelink{chap:classconstant}{constant}    \\
\DWFORMstrp&0x0e&\livelink{chap:classstring}{string}         \\
\DWFORMudata&0x0f&\livelink{chap:classconstant}{constant}         \\
\DWFORMrefaddr&0x10&\livelink{chap:classreference}{reference}         \\
\DWFORMrefone&0x11&\livelink{chap:classreference}{reference}          \\
\DWFORMreftwo&0x12&\livelink{chap:classreference}{reference}         \\
\DWFORMreffour&0x13&\livelink{chap:classreference}{reference}         \\
\DWFORMrefeight&0x14&\livelink{chap:classreference}{reference} \\
\DWFORMrefudata&0x15&\livelink{chap:classreference}{reference}  \\
\DWFORMindirect&0x16&(see Section \refersec{datarep:abbreviationstables}) \\
\DWFORMsecoffset{} &0x17&\livelink{chap:classlineptr}{lineptr}, \livelink{chap:classloclistptr}{loclistptr}, \livelink{chap:classmacptr}{macptr}, \livelink{chap:classrangelistptr}{rangelistptr} \\
\DWFORMexprloc{} &0x18&\livelink{chap:classexprloc}{exprloc} \\
\DWFORMflagpresent{} &0x19&\livelink{chap:classflag}{flag} \\
\DWFORMstrx &0x1a&\livelink{chap:classstring}{string} \\
\DWFORMaddrx &0x1b&\livelink{chap:classaddess}{address} \\
\DWFORMrefsigeight &0x20&\livelink{chap:classreference}{reference} \\
 
\end{longtable}
\end{centering}


\needlines{6}
\section{Variable Length Data}
\label{datarep:variablelengthdata}
\addtoindexx{variable length data|see {LEB128}}
Integers may be 
\addtoindexx{Little Endian Base 128|see{LEB128}}
encoded using \doublequote{Little Endian Base 128}
\addtoindexx{little-endian encoding|see{endian attribute}}
(LEB128) numbers. 
\addtoindexx{LEB128}
LEB128 is a scheme for encoding integers
densely that exploits the assumption that most integers are
small in magnitude.

\textit{This encoding is equally suitable whether the target machine
architecture represents data in big\dash\ endian or little\dash endian
order. It is \doublequote{little\dash endian} only in the sense that it
avoids using space to represent the \doublequote{big} end of an
unsigned integer, when the big end is all zeroes or sign
extension bits.}

Unsigned LEB128 (ULEB128) numbers are encoded as follows:
\addtoindexx{LEB128!unsigned, encoding as}
start at the low order end of an unsigned integer and chop
it into 7\dash bit chunks. Place each chunk into the low order 7
bits of a byte. Typically, several of the high order bytes
will be zero; discard them. Emit the remaining bytes in a
stream, starting with the low order byte; set the high order
bit on each byte except the last emitted byte. The high bit
of zero on the last byte indicates to the decoder that it
has encountered the last byte.

The integer zero is a special case, consisting of a single
zero byte.

Table \refersec{tab:examplesofunsignedleb128encodings}
gives some examples of unsigned LEB128 numbers. The
0x80 in each case is the high order bit of the byte, indicating
that an additional byte follows.


The encoding for signed, two\textquoteright s complement LEB128 (SLEB128)
\addtoindexx{LEB128!signed, encoding as}
numbers is similar, except that the criterion for discarding
high order bytes is not whether they are zero, but whether
they consist entirely of sign extension bits. Consider the
32\dash bit integer -2. The three high level bytes of the number
are sign extension, thus LEB128 would represent it as a single
byte containing the low order 7 bits, with the high order
bit cleared to indicate the end of the byte stream. Note
that there is nothing within the LEB128 representation that
indicates whether an encoded number is signed or unsigned. The
decoder must know what type of number to expect. 
Table \refersec{tab:examplesofunsignedleb128encodings}
gives some examples of unsigned LEB128 numbers and 
Table \refersec{tab:examplesofsignedleb128encodings}
gives some examples of signed LEB128 
numbers.

\textit{Appendix \refersec{app:variablelengthdataencodingdecodinginformative} 
\addtoindexx{LEB128!examples}
gives algorithms for encoding and decoding these forms.}

\needlines{8}
\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|l|l}
  \caption{Examples of unsigned LEB128 encodings}
  \label{tab:examplesofunsignedleb128encodings} 
  \addtoindexx{LEB128 encoding!examples} \\
  \hline \bfseries Number&\bfseries First byte &\bfseries Second byte \\ \hline
\endfirsthead
  \bfseries Number&\bfseries First Byte &\bfseries Second byte\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot
2&2& --- \\
127&127& ---\\
128& 0 + 0x80 & 1 \\
129& 1 + 0x80 & 1 \\
130& 2 + 0x80 & 1 \\
12857& 57 + 0x80 & 100 \\
\end{longtable}
\end{centering}



\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|l|l}
  \caption{Examples of signed LEB128 encodings} \label{tab:examplesofsignedleb128encodings} \\
  \hline \bfseries Number&\bfseries First byte &\bfseries Second byte \\ \hline
\endfirsthead
  \bfseries Number&\bfseries First Byte &\bfseries Second byte\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot
2&2& --- \\
-2&0x7e& ---\\
127& 127 + 0x80 & 0 \\
-127& 1 + 0x80 & 0x7f \\
128& 0 + 0x80 & 1 \\
-128& 0 + 0x80 & 0x7f \\
129& 1 + 0x80 & 1 \\
-129& 0x7f + 0x80 & 0x7e \\

\end{longtable}
\end{centering}



\section{DWARF Expressions and Location Descriptions}
\label{datarep:dwarfexpressionsandlocationdescriptions}
\subsection{DWARF Expressions}
\label{datarep:dwarfexpressions}

A 
\addtoindexx{DWARF Expression!operator encoding}
DWARF expression is stored in a \nolink{block} of contiguous
bytes. The bytes form a sequence of operations. Each operation
is a 1\dash byte code that identifies that operation, followed by
zero or more bytes of additional data. The encodings for the
operations are described in 
Table \refersec{tab:dwarfoperationencodings}. 

\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c|c|l}
  \caption{DWARF operation encodings} \label{tab:dwarfoperationencodings} \\
  \hline & &\bfseries No. of  &\\ 
  \bfseries Operation&\bfseries Code &\bfseries Operands &\bfseries Notes\\ \hline
\endfirsthead
   & &\bfseries No. of &\\ 
  \bfseries Operation&\bfseries Code &\bfseries  Operands &\bfseries Notes\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot

\DWOPaddr&0x03&1 & constant address  \\ 
& & &(size is target specific) \\

\DWOPderef&0x06&0 & \\

\DWOPconstoneu&0x08&1&1\dash byte constant  \\
\DWOPconstones&0x09&1&1\dash byte constant   \\
\DWOPconsttwou&0x0a&1&2\dash byte constant   \\
\DWOPconsttwos&0x0b&1&2\dash byte constant   \\
\DWOPconstfouru&0x0c&1&4\dash byte constant    \\
\DWOPconstfours&0x0d&1&4\dash byte constant   \\
\DWOPconsteightu&0x0e&1&8\dash byte constant   \\
\DWOPconsteights&0x0f&1&8\dash byte constant   \\
\DWOPconstu&0x10&1&ULEB128 constant   \\
\DWOPconsts&0x11&1&SLEB128 constant   \\
\DWOPdup&0x12&0 &   \\
\DWOPdrop&0x13&0  &   \\
\DWOPover&0x14&0 &   \\
\DWOPpick&0x15&1&1\dash byte stack index   \\
\DWOPswap&0x16&0 &   \\
\DWOProt&0x17&0 &   \\
\DWOPxderef&0x18&0 &   \\
\DWOPabs&0x19&0 &   \\
\DWOPand&0x1a&0 &   \\
\DWOPdiv&0x1b&0 &   \\
\DWOPminus&0x1c&0 & \\
\DWOPmod&0x1d&0 & \\
\DWOPmul&0x1e&0 & \\
\DWOPneg&0x1f&0 & \\
\DWOPnot&0x20&0 & \\
\DWOPor&0x21&0 & \\
\DWOPplus&0x22&0 & \\
\DWOPplusuconst&0x23&1&ULEB128 addend \\
\DWOPshl&0x24&0 & \\
\DWOPshr&0x25&0 & \\
\DWOPshra&0x26&0 & \\
\DWOPxor&0x27&0 & \\

\DWOPbra&0x28&1 & signed 2\dash byte constant \\
\DWOPeq&0x29&0 & \\
\DWOPge&0x2a&0 & \\
\DWOPgt&0x2b&0 & \\
\DWOPle&0x2c&0 & \\
\DWOPlt&0x2d&0  & \\
\DWOPne&0x2e&0 & \\
\DWOPskip&0x2f&1&signed 2\dash byte constant \\ \hline

\DWOPlitzero & 0x30 & 0 & \\
\DWOPlitone  & 0x31 & 0& literals 0 .. 31 = \\
\ldots & & &\hspace{0.3cm}(\DWOPlitzero{} + literal) \\
\DWOPlitthirtyone & 0x4f & 0 & \\ \hline

\DWOPregzero & 0x50 & 0 & \\*
\DWOPregone  & 0x51 & 0&reg 0 .. 31 = \\*
\ldots & & &\hspace{0.3cm}(\DWOPregzero{} + regnum) \\*
\DWOPregthirtyone & 0x6f & 0 & \\ \hline

\DWOPbregzero & 0x70 &1 & SLEB128 offset \\*
\DWOPbregone  & 0x71 & 1 &base register 0 .. 31 = \\*
... & &              &\hspace{0.3cm}(\DWOPbregzero{} + regnum) \\*
\DWOPbregthirtyone & 0x8f & 1 & \\ \hline

\DWOPregx{} & 0x90 &1&ULEB128 register \\
\DWOPfbreg{} & 0x91&1&SLEB128 offset \\
\DWOPbregx{} & 0x92&2 &ULEB128 register, \\*
                  & & &SLEB128 offset \\
\DWOPpiece{} & 0x93 &1& ULEB128 size of piece \\
\DWOPderefsize{} & 0x94 &1& 1-byte size of data retrieved \\
\DWOPxderefsize{} & 0x95&1&1-byte size of data retrieved \\
\DWOPnop{} & 0x96 &0& \\

\DWOPpushobjectaddress&0x97&0 &  \\
\DWOPcalltwo&0x98&1& 2\dash byte offset of DIE \\
\DWOPcallfour&0x99&1& 4\dash byte offset of DIE \\
\DWOPcallref&0x9a&1& 4\dash\  or 8\dash byte offset of DIE \\
\DWOPformtlsaddress&0x9b &0& \\
\DWOPcallframecfa{} &0x9c &0& \\
\DWOPbitpiece&0x9d &2&ULEB128 size, \\*
                   &&&ULEB128 offset\\
\DWOPimplicitvalue{} &0x9e &2&ULEB128 size, \\*
                   &&&\nolink{block} of that size\\
\DWOPstackvalue{} &0x9f &0& \\
\DWOPimplicitpointer{} &0xa0& 2 &4- or 8-byte offset of DIE, \\*
                              &&&SLEB128 constant offset \\
\DWOPaddrx&0xa1&1&ULEB128 indirect address \\
\DWOPconstx&0xa2&1&ULEB128 indirect constant   \\
\DWOPlouser{} &0xe0 && \\
\DWOPhiuser{} &\xff && \\

\end{longtable}
\end{centering}


\subsection{Location Descriptions}
\label{datarep:locationdescriptions}

A location description is used to compute the 
location of a variable or other entity.

\subsection{Location Lists}
\label{datarep:locationlists}

Each entry in a \addtoindex{location list} is either a location list entry,
a base address selection entry, or an 
\addtoindexx{end of list entry!in location list}
end of list entry.

A \addtoindex{location list} entry consists of two address offsets followed
by a 2\dash byte length, followed by a block of contiguous bytes
that contains a DWARF location description. The length
specifies the number of bytes in that block. The two offsets
are the same size as an address on the target machine.

\needlines{5}
A base address selection entry and an 
\addtoindexx{end of list entry!in location list}
end of list entry each
consist of two (constant or relocated) address offsets. The two
offsets are the same size as an address on the target machine.

For a \addtoindex{location list} to be specified, the base address of
\addtoindexx{base address selection entry!in location list}
the corresponding compilation unit must be defined 
(see Section  \refersec{chap:normalandpartialcompilationunitentries}).

\section{Base Type Attribute Encodings}
\label{datarep:basetypeattributeencodings}

The encodings of the 
\hypertarget{chap:DWATencodingencodingofbasetype}{}
constants used in 
\addtoindexx{encoding attribute!encoding}
the 
\DWATencoding{}
attribute are given in 
Table \refersec{tab:basetypeencodingvalues}

\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Base type encoding values} \label{tab:basetypeencodingvalues} \\
  \hline \bfseries Base type encoding name&\bfseries Value \\ \hline
\endfirsthead
  \bfseries Base type encoding name&\bfseries Value\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot
\DWATEaddress&0x01 \\
\DWATEboolean&0x02 \\
\DWATEcomplexfloat&0x03 \\
\DWATEfloat&0x04 \\
\DWATEsigned&0x05 \\
\DWATEsignedchar&0x06 \\
\DWATEunsigned&0x07 \\
\DWATEunsignedchar&0x08 \\
\DWATEimaginaryfloat&0x09 \\
\DWATEpackeddecimal&0x0a \\
\DWATEnumericstring&0x0b \\
\DWATEedited&0x0c \\
\DWATEsignedfixed&0x0d \\
\DWATEunsignedfixed&0x0e \\
\DWATEdecimalfloat{} & 0x0f \\
\DWATEUTF{} & 0x10 \\
\DWATElouser{} & 0x80 \\
\DWATEhiuser{} & \xff \\
\end{longtable}
\end{centering}

\needlines{4}
The encodings of the constants used in the 
\DWATdecimalsign{} attribute 
are given in 
Table \refersec{tab:decimalsignencodings}.

\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Decimal sign encodings} \label{tab:decimalsignencodings} \\
  \hline \bfseries Decimal sign code name&\bfseries Value \\ \hline
\endfirsthead
  \bfseries Decimal sign code name&\bfseries Value\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot

\DWDSunsigned{} & 0x01  \\
\DWDSleadingoverpunch{} & 0x02  \\
\DWDStrailingoverpunch{} & 0x03  \\
\DWDSleadingseparate{} & 0x04  \\
\DWDStrailingseparate{} & 0x05  \\

\end{longtable}
\end{centering}

\needlines{9}
The encodings of the constants used in the 
\DWATendianity{} attribute are given in 
Table \refersec{tab:endianityencodings}.

\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Endianity encodings} \label{tab:endianityencodings}\\
  \hline \bfseries Endian code name&\bfseries Value \\ \hline
\endfirsthead
  \bfseries Endian code name&\bfseries Value\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot

\DWENDdefault{}  & 0x00 \\
\DWENDbig{} & 0x01 \\
\DWENDlittle{} & 0x02 \\
\DWENDlouser{} & 0x40 \\
\DWENDhiuser{} & \xff \\

\end{longtable}
\end{centering}

\section{Accessibility Codes}
\label{datarep:accessibilitycodes}
The encodings of the constants used in the 
\DWATaccessibility{}
attribute 
\addtoindexx{accessibility attribute!encoding}
are given in 
Table \refersec{tab:accessibilityencodings}.

\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Accessibility encodings} \label{tab:accessibilityencodings}\\
  \hline \bfseries Accessibility code name&\bfseries Value \\ \hline
\endfirsthead
  \bfseries Accessibility code name&\bfseries Value\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot

\DWACCESSpublic&0x01  \\
\DWACCESSprotected&0x02 \\
\DWACCESSprivate&0x03 \\

\end{longtable}
\end{centering}


\section{Visibility Codes}
\label{datarep:visibilitycodes}
The encodings of the constants used in the 
\DWATvisibility{} attribute are given in 
Table \refersec{tab:visibilityencodings}. 

\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Visibility encodings} \label{tab:visibilityencodings}\\
  \hline \bfseries Visiibility code name&\bfseries Value \\ \hline
\endfirsthead
  \bfseries Visibility code name&\bfseries Value\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot

\DWVISlocal&0x01 \\
\DWVISexported&0x02 \\
\DWVISqualified&0x03 \\

\end{longtable}
\end{centering}

\section{Virtuality Codes}
\label{datarep:vitualitycodes}

The encodings of the constants used in the 
\DWATvirtuality{} attribute are given in 
Table \refersec{tab:virtualityencodings}.

\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Virtuality encodings} \label{tab:virtualityencodings}\\
  \hline \bfseries Virtuality code name&\bfseries Value \\ \hline
\endfirsthead
  \bfseries Virtuality code name&\bfseries Value\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot

\DWVIRTUALITYnone&0x00 \\
\DWVIRTUALITYvirtual&0x01 \\
\DWVIRTUALITYpurevirtual&0x02 \\



\end{longtable}
\end{centering}

The value 
\DWVIRTUALITYnone{} is equivalent to the absence of the 
\DWATvirtuality{}
attribute.

\section{Source Languages}
\label{datarep:sourcelanguages}

The encodings of the constants used 
\addtoindexx{language attribute, encoding}
in 
\addtoindexx{language name encoding}
the 
\DWATlanguage{}
attribute are given in 
Table \refersec{tab:languageencodings}.
Names marked with
% If we don't force a following space it looks odd
\dag \  
and their associated values are reserved, but the
languages they represent are not well supported. 
Table \refersec{tab:languageencodings}
also shows the 
\addtoindexx{lower bound attribute!default}
default lower bound, if any, assumed for
an omitted \DWATlowerbound{} attribute in the context of a
\DWTAGsubrangetype{} debugging information entry for each
defined language.

\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c|c}
  \caption{Language encodings} \label{tab:languageencodings}\\
  \hline \bfseries Language name&\bfseries Value &\bfseries Default Lower Bound \\ \hline
\endfirsthead
  \bfseries Language name&\bfseries Value &\bfseries Default Lower Bound\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
  \dag \ \textit{See text} \\ \ddag \ \textit{New in \addtoindex{DWARF Version 5}}
\endlastfoot

\DWLANGCeightynine &0x0001 &0       \\
\DWLANGC{} &0x0002 &0  \\
\DWLANGAdaeightythree{} \dag &0x0003 &1  \addtoindexx{Ada}     \\
\DWLANGCplusplus{} &0x0004 &0       \\
\DWLANGCobolseventyfour{} \dag &0x0005 &1       \\
\DWLANGCoboleightyfive{} \dag &0x0006 &1       \\
\DWLANGFortranseventyseven &0x0007 &1       \\
\DWLANGFortranninety &0x0008 &1       \\
\DWLANGPascaleightythree &0x0009 &1       \\
\DWLANGModulatwo &0x000a &1       \\
\DWLANGJava &0x000b &0       \\
\DWLANGCninetynine &0x000c &0       \\
\DWLANGAdaninetyfive{} \dag &0x000d &1 \addtoindexx{Ada}      \\
\DWLANGFortranninetyfive &0x000e &1       \\
\DWLANGPLI{} \dag &0x000f &1 \\
\DWLANGObjC{} &0x0010 &0 \\
\DWLANGObjCplusplus{} &0x0011 &0 \\
\DWLANGUPC{} &0x0012 &0 \\
\DWLANGD{} &0x0013 &0 \\
\DWLANGPython{} \dag &0x0014 &0 \\
\DWLANGOpenCL{} \dag \ddag &0x0015 &0 \\
\DWLANGGo{} \dag \ddag &0x0016 &0 \\
\DWLANGModulathree{} \dag \ddag &0x0017 &1 \\
\DWLANGHaskell{} \dag \ddag &0x0018 &0 \\
\DWLANGCpluspluszerothree{} \ddag &0x0019 &0 \\
\DWLANGCpluspluseleven{} \ddag &0x001a &0 \\
\DWLANGOCaml{} \ddag &0x001b &0	\\
\DWLANGlouser{} &0x8000 & \\
\DWLANGhiuser{} &\xffff & \\

\end{longtable}
\end{centering}

\section{Address Class Encodings}
\label{datarep:addressclassencodings}

The value of the common 
\addtoindexi{address}{address class!attribute encoding}
class encoding 
\DWADDRnone{} is 0.

\needlines{7}
\section{Identifier Case}
\label{datarep:identifiercase}

The encodings of the constants used in the 
\DWATidentifiercase{} attribute are given in 
Table \refersec{tab:identifiercaseencodings}.

\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Identifier case encodings} \label{tab:identifiercaseencodings}\\
  \hline \bfseries Identifier case name&\bfseries Value \\ \hline
\endfirsthead
  \bfseries Identifier case name&\bfseries Value\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot
\DWIDcasesensitive&0x00     \\
\DWIDupcase&0x01     \\
\DWIDdowncase&0x02     \\
\DWIDcaseinsensitive&0x03     \\
\end{longtable}
\end{centering}

\section{Calling Convention Encodings}
\label{datarep:callingconventionencodings}
The encodings of the constants used in the 
\DWATcallingconvention{} attribute are given in
Table \refersec{tab:callingconventionencodings}.

\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Calling convention encodings} \label{tab:callingconventionencodings}\\
  \hline \bfseries Calling convention name&\bfseries Value \\ \hline
\endfirsthead
  \bfseries Calling convention name&\bfseries Value\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot

\DWCCnormal&0x01     \\
\DWCCprogram&0x02     \\
\DWCCnocall&0x03     \\
\DWCClouser&0x40     \\
\DWCChiuser&\xff     \\

\end{longtable}
\end{centering}

\section{Inline Codes}
\label{datarep:inlinecodes}

The encodings of the constants used in 
\addtoindexx{inline attribute!encoding}
the 
\DWATinline{} attribute are given in 
Table \refersec{tab:inlineencodings}.

\needlines{8}
\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Inline encodings} \label{tab:inlineencodings}\\
  \hline \bfseries Inline code name&\bfseries Value \\ \hline
\endfirsthead
  \bfseries Inline Code name&\bfseries Value\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot

\DWINLnotinlined&0x00      \\
\DWINLinlined&0x01      \\
\DWINLdeclarednotinlined&0x02      \\
\DWINLdeclaredinlined&0x03      \\

\end{longtable}
\end{centering}

% this clearpage is ugly, but the following table came
% out oddly without it.

\section{Array Ordering}
\label{datarep:arrayordering}

The encodings of the constants used in the 
\DWATordering{} attribute are given in 
Table \refersec{tab:orderingencodings}.

\needlines{8}
\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Ordering encodings} \label{tab:orderingencodings}\\
  \hline \bfseries Ordering name&\bfseries Value \\ \hline
\endfirsthead
  \bfseries Ordering name&\bfseries Value\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot

\DWORDrowmajor&0x00  \\
\DWORDcolmajor&0x01  \\

\end{longtable}
\end{centering}


\section{Discriminant Lists}
\label{datarep:discriminantlists}

The descriptors used in 
\addtoindexx{discriminant list attribute!encoding}
the 
\DWATdiscrlist{} attribute are 
encoded as 1\dash byte constants. The
defined values are given in 
Table \refersec{tab:discriminantdescriptorencodings}.

% Odd that the 'Name' field capitalized here, it is not caps elsewhere.
\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Discriminant descriptor encodings} \label{tab:discriminantdescriptorencodings}\\
  \hline \bfseries Descriptor name&\bfseries Value \\ \hline
\endfirsthead
  \bfseries Descriptor name&\bfseries Value\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot

\DWDSClabel&0x00 \\
\DWDSCrange&0x01 \\

\end{longtable}
\end{centering}

\needlines{6}
\section{Name Lookup Tables}
\label{datarep:namelookuptables}

Each set of entries in the table of global names contained
in the \dotdebugpubnames{} and 
\dotdebugpubtypes{} sections begins
with a header consisting of:
\begin{enumerate}[1. ]

\item \texttt{unit\_length} (\livelink{datarep:initiallengthvalues}{initial length}) \\
\addttindexx{unit\_length}
A 4\dash byte or 12\dash byte unsigned integer 
\addtoindexx{initial length}
representing the length
of the \dotdebuginfo{}
contribution for that compilation unit,
not including the length field itself. In the 
\thirtytwobitdwarfformat, this is a 4\dash byte unsigned integer (which must be less
than \xfffffffzero); in the \sixtyfourbitdwarfformat, this consists
of the 4\dash byte value \wffffffff followed by an 8\dash byte unsigned
integer that gives the actual length
(see Section \refersec{datarep:32bitand64bitdwarfformats}).

\item  version (\addtoindex{uhalf}) \\
A 2\dash byte unsigned integer representing the version of the
DWARF information for the name lookup table
\addtoindexx{version number!name lookup table}
(see Appendix \refersec{app:dwarfsectionversionnumbersinformative}).
The value in this field is 2.

\needlines{4}
\item \addtoindex{debug\_info\_offset} (section offset) \\
A 
\addtoindexx{section offset!in name lookup table set of entries}
4\dash byte or 8\dash byte 
offset into the 
\dotdebuginfo{}
section of the compilation unit header.
In the \thirtytwobitdwarfformat, this is a 4\dash byte unsigned offset;
in the \sixtyfourbitdwarfformat, this is an 8\dash byte unsigned offsets
(see Section \refersec{datarep:32bitand64bitdwarfformats}).

\item  \addtoindex{debug\_info\_length} (\livelink{datarep:sectionoffsetlength}{section length}) \\
\addtoindexx{section length!in .debug\_pubnames header}
A 
\addtoindexx{section length!in .debug\_pubtypes header}
4\dash byte or 8\dash byte length containing the size in bytes of the
contents of the \dotdebuginfo{}
section generated to represent
this compilation unit. In the \thirtytwobitdwarfformat, this is
a 4\dash byte unsigned length; in the \sixtyfourbitdwarfformat, this
is an 8-byte unsigned length 
(see Section \refersec{datarep:32bitand64bitdwarfformats}).


\end{enumerate}

This header is followed by a series of tuples. Each tuple
consists of a 4\dash byte or 8\dash byte offset followed by a string
of non\dash null bytes terminated by one null byte. 
In the 32\dash bit
DWARF format, this is a 4\dash byte offset; in the 64\dash bit DWARF
format, it is an 8\dash byte offset. 
Each set is terminated by an
offset containing the value 0.


\needlines{6}
\section{Address Range Table}
\label{datarep:addrssrangetable}

Each set of entries in the table of address ranges contained
in the \dotdebugaranges{}
section begins with a header containing:
\begin{enumerate}[1. ]
% FIXME The unit length text is not fully consistent across
% these tables.

\item \texttt{unit\_length} (\livelink{datarep:initiallengthvalues}{initial length}) \\
\addttindexx{unit\_length}
A 4-byte or 12-byte length containing the length of the
\addtoindexx{initial length}
set of entries for this compilation unit, not including the
length field itself. In the \thirtytwobitdwarfformat, this is a
4-byte unsigned integer (which must be less than \xfffffffzero);
in the \sixtyfourbitdwarfformat, this consists of the 4-byte value
\wffffffff followed by an 8-byte unsigned integer that gives
the actual length 
(see Section \refersec{datarep:32bitand64bitdwarfformats}).

\item version (\addtoindex{uhalf}) \\
A 2\dash byte version identifier representing the version of the
DWARF information for the address range table
(see Appendix \refersec{app:dwarfsectionversionnumbersinformative}).
This value in this field \addtoindexx{version number!address range table} is 2. 
 

\item debug\_info\_offset (\livelink{datarep:sectionoffsetlength}{section offset}) \\
A 
\addtoindexx{section offset!in .debug\_aranges header}
4\dash byte or 8\dash byte offset into the 
\dotdebuginfo{} section of
the compilation unit header. In the \thirtytwobitdwarfformat,
this is a 4\dash byte unsigned offset; in the \sixtyfourbitdwarfformat,
this is an 8\dash byte unsigned offset 
(see Section \refersec{datarep:32bitand64bitdwarfformats}).

\item address\_size (ubyte) \\
A 1\dash byte unsigned integer containing the size in bytes of an
\addtoindexx{address\_size}
address 
\addtoindexx{size of an address}
(or the offset portion of an address for segmented
\addtoindexx{address space!segmented}
addressing) on the target system.

\item segment\_size (ubyte) \\
A 
\addtoindexx{segment\_size}
1\dash byte unsigned integer containing the size in bytes of a
segment selector on the target system.

\end{enumerate}

This header is followed by a series of tuples. Each tuple
consists of a segment, an address and a length. 
The segment
size is given by the \addtoindex{segment\_size} field of the header; the
address and length size are each given by the address\_size
field of the header. 
The first tuple following the header in
each set begins at an offset that is a multiple of the size
of a single tuple (that is, the size of a segment selector
plus twice the \addtoindex{size of an address}). 
The header is padded, if
necessary, to that boundary. Each set of tuples is terminated
by a 0 for the segment, a 0 for the address and 0 for the
length. If the \addtoindex{segment\_size} field in the header is zero,
the segment selectors are omitted from all tuples, including
the terminating tuple.


\section{Line Number Information}
\label{datarep:linenumberinformation}

The \addtoindexi{version number}{version number!line number information}
in the line number program header is \versiondotdebugline{}
(see Appendix \refersec{app:dwarfsectionversionnumbersinformative}). 

The boolean values \doublequote{true} and \doublequote{false} 
used by the line number information program are encoded
as a single byte containing the value 0 
for \doublequote{false,} and a non-zero value for \doublequote{true.}

The encodings for the standard opcodes are given in 
\addtoindexx{line number opcodes!standard opcode encoding}
Table \refersec{tab:linenumberstandardopcodeencodings}.

% Odd that the 'Name' field capitalized here, it is not caps elsewhere.
\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Line number standard opcode encodings} \label{tab:linenumberstandardopcodeencodings}\\
  \hline \bfseries Opcode name&\bfseries Value \\ \hline
\endfirsthead
  \bfseries Opcode name&\bfseries Value\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot

\DWLNScopy&0x01 \\
\DWLNSadvancepc&0x02 \\
\DWLNSadvanceline&0x03 \\
\DWLNSsetfile&0x04 \\
\DWLNSsetcolumn&0x05 \\
\DWLNSnegatestmt&0x06 \\
\DWLNSsetbasicblock&0x07 \\
\DWLNSconstaddpc&0x08 \\
\DWLNSfixedadvancepc&0x09 \\
\DWLNSsetprologueend&0x0a \\*
\DWLNSsetepiloguebegin&0x0b \\*
\DWLNSsetisa&0x0c \\*

\end{longtable}
\end{centering}


\needspace{10cm}
The encodings for the extended opcodes are given in 
\addtoindexx{line number opcodes!extended opcode encoding}
Table \refersec{tab:linenumberextendedopcodeencodings}.

\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Line number extended opcode encodings} \label{tab:linenumberextendedopcodeencodings}\\
  \hline \bfseries Opcode name&\bfseries Value \\ \hline
\endfirsthead
  \bfseries Opcode name&\bfseries Value\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot

\DWLNEendsequence	&0x01 \\
\DWLNEsetaddress	&0x02 \\
\DWLNEdefinefile	&0x03 \\
\DWLNEsetdiscriminator &0x04 \\
\DWLNEdefinefileMDfive &0c05 \\
\DWLNElouser		&0x80 \\
\DWLNEhiuser		&\xff \\

\end{longtable}
\end{centering}

\needspace{10cm}
The encodings for the file entry format are given in 
\addtoindexx{line number opcodes!file entry format encoding}
Table \refersec{tab:linenumberfileentryformatencodings}.

\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Line number file entry format \mbox{encodings}} \label{tab:linenumberfileentryformatencodings}\\
  \hline \bfseries File entry format name&\bfseries Value \\ \hline
\endfirsthead
  \bfseries File entry format name&\bfseries Value\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot

\DWLNFtimestampsize	& 0x01	\\
\DWLNFMDfive		& 0x02	\\

\end{longtable}
\end{centering}

\section{Macro Information}
\label{datarep:macroinformation}

The source line numbers and source file indices encoded in the
macro information section are represented as unsigned LEB128
numbers as are the constants in a 
\DWMACINFOvendorext{} entry.

The macinfo type is encoded as a single byte. 
The encodings 
\addtoindexx{macinfo types!encoding}
are given in 
Table \refersec{tab:macinfotypeencodings}.


\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Macinfo type encodings} \label{tab:macinfotypeencodings}\\
  \hline \bfseries Macinfo type name&\bfseries Value \\ \hline
\endfirsthead
  \bfseries Macinfo type name&\bfseries Value\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot

\DWMACINFOdefine&0x01 \\
\DWMACINFOundef&0x02 \\
\DWMACINFOstartfile&0x03 \\
\DWMACINFOendfile&0x04 \\
\DWMACINFOvendorext&\xff \\

\end{longtable}
\end{centering}

\needlines{7}
\section{Call Frame Information}
\label{datarep:callframeinformation}

In the \thirtytwobitdwarfformat, the value of the CIE id in the
CIE header is \xffffffff; in the \sixtyfourbitdwarfformat, the
value is \xffffffffffffffff.

The value of the CIE \addtoindexi{version number}{version number!call frame information}
is 4 (see Appendix \refersec{app:dwarfsectionversionnumbersinformative}). 

Call frame instructions are encoded in one or more bytes. The
primary opcode is encoded in the high order two bits of
the first byte (that is, opcode = byte $\gg$ 6). An operand
or extended opcode may be encoded in the low order 6
bits. Additional operands are encoded in subsequent bytes.
The instructions and their encodings are presented in
Table \refersec{tab:callframeinstructionencodings}.

\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c|c|l|l}
  \caption{Call frame instruction encodings} \label{tab:callframeinstructionencodings} \\
  \hline &\bfseries High 2 &\bfseries Low 6 &  & \\
  \bfseries Instruction&\bfseries Bits &\bfseries Bits &\bfseries Operand 1 &\bfseries Operand 2\\ \hline
\endfirsthead
   & \bfseries High 2 &\bfseries Low 6 &  &\\
  \bfseries Instruction&\bfseries Bits &\bfseries Bits &\bfseries Operand 1 &\bfseries Operand 2\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot

\DWCFAadvanceloc&0x1&delta & \\
\DWCFAoffset&0x2&register&ULEB128 offset \\
\DWCFArestore&0x3&register & & \\
\DWCFAnop&0&0 & & \\
\DWCFAsetloc&0&0x01&address & \\
\DWCFAadvancelocone&0&0x02&1\dash byte delta & \\
\DWCFAadvanceloctwo&0&0x03&2\dash byte delta & \\
\DWCFAadvancelocfour&0&0x04&4\dash byte delta & \\
\DWCFAoffsetextended&0&0x05&ULEB128 register&ULEB128 offset \\
\DWCFArestoreextended&0&0x06&ULEB128 register & \\
\DWCFAundefined&0&0x07&ULEB128 register & \\
\DWCFAsamevalue&0&0x08 &ULEB128 register & \\
\DWCFAregister&0&0x09&ULEB128 register &ULEB128 offset \\
\DWCFArememberstate&0&0x0a & & \\
\DWCFArestorestate&0&0x0b & & \\
\DWCFAdefcfa&0&0x0c &ULEB128 register&ULEB128 offset \\
\DWCFAdefcfaregister&0&0x0d&ULEB128 register & \\
\DWCFAdefcfaoffset&0&0x0e &ULEB128 offset & \\
\DWCFAdefcfaexpression&0&0x0f &BLOCK  \\
\DWCFAexpression&0&0x10&ULEB128 register & BLOCK \\

\DWCFAoffsetextendedsf&0&0x11&ULEB128 register&SLEB128 offset \\
\DWCFAdefcfasf&0&0x12&ULEB128 register&SLEB128 offset \\
\DWCFAdefcfaoffsetsf&0&0x13&SLEB128 offset & \\
\DWCFAvaloffset&0&0x14&ULEB128&ULEB128 \\
\DWCFAvaloffsetsf&0&0x15&ULEB128&SLEB128 \\
\DWCFAvalexpression&0&0x16&ULEB128&BLOCK  \\
\DWCFAlouser&0&0x1c   & & \\
\DWCFAhiuser&0&\xiiif & & \\
\end{longtable}
\end{centering}

\section{Non-contiguous Address Ranges}
\label{datarep:noncontiguousaddressranges}

Each entry in a \addtoindex{range list}
(see Section \refersec{chap:noncontiguousaddressranges})
is either a
\addtoindexx{base address selection entry!in range list}
range list entry, 
\addtoindexx{range list}
a base address selection entry, or an end
of list entry.

A \addtoindex{range list} entry consists of two relative addresses. The
addresses are the same size as addresses on the target machine.

A base address selection entry and an 
\addtoindexx{end of list entry!in range list}
end of list entry each
\addtoindexx{base address selection entry!in range list}
consist of two (constant or relocated) addresses. The two
addresses are the same size as addresses on the target machine.

For a \addtoindex{range list} to be specified, the base address of the
\addtoindexx{base address selection entry!in range list}
corresponding compilation unit must be defined 
(see Section \refersec{chap:normalandpartialcompilationunitentries}).

\section{String Offsets Table}
\label{chap:stringoffsetstable}
Each set of entries in the string offsets table contained in the
\dotdebugstroffsets{} section begins with a header containing:
\begin{enumerate}[1. ]
\item \texttt{unit\_length} (\livelink{datarep:initiallengthvalues}{initial length}) \\
A 4-byte or 12-byte length containing the length of
the set of entries for this compilation unit, not
including the length field itself. In the 32-bit
DWARF format, this is a 4-byte unsigned integer
(which must be less than \xfffffffzero); in the 64-bit
DWARF format, this consists of the 4-byte value
\wffffffff followed by an 8-byte unsigned integer
that gives the actual length (see 
Section \refersec{datarep:32bitand64bitdwarfformats}).

\item  \texttt{version} (\addtoindex{uhalf}) \\
A 2-byte version identifier containing the value
\versiondotdebugstroffsets{} 
(see Appendix \refersec{app:dwarfsectionversionnumbersinformative}).
\item \texttt{padding} (\addtoindex{uhalf}) \\
\end{enumerate}

This header is followed by a series of string table offsets.
For the 32-bit DWARF format, each offset is 4 bytes long; for
the 64-bit DWARF format, each offset is 8 bytes long.

The \DWATstroffsetsbase{} attribute points to the first
entry following the header. The entries are indexed
sequentially from this base entry, starting from 0.

\section{Address Table}
\label{chap:addresstable}
Each set of entries in the address table contained in the
\dotdebugaddr{} section begins with a header containing:
\begin{enumerate}[1. ]
\item \texttt{unit\_length} (\livelink{datarep:initiallengthvalues}{initial length}) \\
A 4-byte or 12-byte length containing the length of
the set of entries for this compilation unit, not
including the length field itself. In the 32-bit
DWARF format, this is a 4-byte unsigned integer
(which must be less than \xfffffffzero); in the 64-bit
DWARF format, this consists of the 4-byte value
\wffffffff followed by an 8-byte unsigned integer
that gives the actual length (see 
Section \refersec{datarep:32bitand64bitdwarfformats}).

\needlines{4}
\item  \texttt{version} (\addtoindex{uhalf}) \\
A 2-byte version identifier containing the value
\versiondotdebugaddr{} 
(see Appendix \refersec{app:dwarfsectionversionnumbersinformative}).

\needlines{4}
\item	\texttt{address\_size} (\addtoindex{ubyte}) \\
A 1-byte unsigned integer containing the size in
bytes of an address (or the offset portion of an
address for segmented addressing) on the target
system.

\needlines{4}
\item	\texttt{segment\_size} (\addtoindex{ubyte}) \\
A 1-byte unsigned integer containing the size in
bytes of a segment selector on the target system.
\end{enumerate}

This header is followed by a series of segment/address pairs.
The segment size is given by the \texttt{segment\_size} field of the
header, and the address size is given by the \texttt{address\_size}
field of the header. If the \texttt{segment\_size} field in the header
is zero, the entries consist only of an addresses.

The \DWATaddrbase{} attribute points to the first entry
following the header. The entries are indexed sequentially
from this base entry, starting from 0.

\section{Range List Table}
\label{app:rangelisttable}
Each set of entries in the range list table contained in the
\dotdebugranges{} section begins with a header containing:
\begin{enumerate}[1. ]
\item \texttt{unit\_length} (\livelink{datarep:initiallengthvalues}{initial length}) \\
A 4-byte or 12-byte length containing the length of
the set of entries for this compilation unit, not
including the length field itself. In the 32-bit
DWARF format, this is a 4-byte unsigned integer
(which must be less than \xfffffffzero); in the 64-bit
DWARF format, this consists of the 4-byte value
\wffffffff followed by an 8-byte unsigned integer
that gives the actual length (see 
Section \refersec{datarep:32bitand64bitdwarfformats}).

\needlines{4}
\item  \texttt{version} (\addtoindex{uhalf}) \\
A 2-byte version identifier containing the value
\versiondotdebugranges{} 
(see Appendix \refersec{app:dwarfsectionversionnumbersinformative}).

\needlines{4}
\item	\texttt{address\_size} (\addtoindex{ubyte}) \\
A 1-byte unsigned integer containing the size in
bytes of an address (or the offset portion of an
address for segmented addressing) on the target
system.

\needlines{4}
\item	\texttt{segment\_size} (\addtoindex{ubyte}) \\
A 1-byte unsigned integer containing the size in
bytes of a segment selector on the target system.
\end{enumerate}

This header is followed by a series of range list entries as
described in Section \refersec{chap:locationlists}.
The segment size is given by the
\texttt{segment\_size} field of the header, and the address size is
given by the \texttt{address\_size} field of the header. If the
\texttt{segment\_size} field in the header is zero, the segment
selector is omitted from the range list entries.

The \DWATrangesbase{} attribute points to the first entry
following the header. The entries are referenced by a byte
offset relative to this base address.


\section{Location List Table}
\label{datarep:locationlisttable}
Each set of entries in the location list table contained in the
\dotdebugloc{} or \dotdebuglocdwo{}sections begins with a header containing:
\begin{enumerate}[1. ]
\item \texttt{unit\_length} (\livelink{datarep:initiallengthvalues}{initial length}) \\
A 4-byte or 12-byte length containing the length of
the set of entries for this compilation unit, not
including the length field itself. In the 32-bit
DWARF format, this is a 4-byte unsigned integer
(which must be less than \xfffffffzero); in the 64-bit
DWARF format, this consists of the 4-byte value
\wffffffff followed by an 8-byte unsigned integer
that gives the actual length (see 
Section \refersec{datarep:32bitand64bitdwarfformats}).

\needlines{4}
\item  \texttt{version} (\addtoindex{uhalf}) \\
A 2-byte version identifier containing the value
\versiondotdebugloc{} 
(see Appendix \refersec{app:dwarfsectionversionnumbersinformative}).

\needlines{4}
\item	\texttt{address\_size} (\addtoindex{ubyte}) \\
A 1-byte unsigned integer containing the size in
bytes of an address (or the offset portion of an
address for segmented addressing) on the target
system.

\needlines{4}
\item	\texttt{segment\_size} (\addtoindex{ubyte}) \\
A 1-byte unsigned integer containing the size in
bytes of a segment selector on the target system.
\end{enumerate}

This header is followed by a series of location list entries as
described in Section \refersec{chap:locationlists}.
The segment size is given by the
\texttt{segment\_size} field of the header, and the address size is
given by the \texttt{address\_size} field of the header. If the
\texttt{segment\_size} field in the header is zero, the segment
selector is omitted from the range list entries.

The entries are referenced by a byte offset relative to the first
location list following this header.


\section{Dependencies and Constraints}
\label{datarep:dependenciesandconstraints}

The debugging information in this format is intended to
exist 
\addtoindexx{DWARF section names!list of}
in the
\dotdebugabbrev{},
\dotdebugaddr{}, 
\dotdebugaranges{}, 
\dotdebugframe{},
\dotdebuginfo{}, 
\dotdebugline{}, 
\dotdebugloc{}, 
\dotdebugmacinfo{},
\dotdebugpubnames{}, 
\dotdebugpubtypes{}, 
\dotdebugranges{}, 
\dotdebugstr{},
\dotdebugstroffsets{}
and 
\dotdebugtypes{}
sections of an object file, or equivalent
separate file or database. The information is not 
word\dash aligned. Consequently:

\begin{itemize}
\item For the \thirtytwobitdwarfformat{} and a target architecture with
32\dash bit addresses, an assembler or compiler must provide a way
to produce 2\dash byte and 4\dash byte quantities without alignment
restrictions, and the linker must be able to relocate a
4\dash byte address or 
\addtoindexx{section offset!alignment of}
section offset that occurs at an arbitrary
alignment.

\item For the \thirtytwobitdwarfformat{} and a target architecture with
64\dash bit addresses, an assembler or compiler must provide a
way to produce 2\dash byte, 4\dash byte and 8\dash byte quantities without
alignment restrictions, and the linker must be able to relocate
an 8\dash byte address or 4\dash byte 
\addtoindexx{section offset!alignment of}
section offset that occurs at an
arbitrary alignment.

\item For the \sixtyfourbitdwarfformat{} and a target architecture with
32\dash bit addresses, an assembler or compiler must provide a
way to produce 2\dash byte, 4\dash byte and 8\dash byte quantities without
alignment restrictions, and the linker must be able to relocate
a 4\dash byte address or 8\dash byte 
\addtoindexx{section offset!alignment of}
section offset that occurs at an
arbitrary alignment.

\textit{It is expected that this will be required only for very large
32\dash bit programs or by those architectures which support
a mix of 32\dash bit and 64\dash bit code and data within the same
executable object.}

\item For the \sixtyfourbitdwarfformat{} and a target architecture with
64\dash bit addresses, an assembler or compiler must provide a
way to produce 2\dash byte, 4\dash byte and 8\dash byte quantities without
alignment restrictions, and the linker must be able to
relocate an 8\dash byte address or 
\addtoindexx{section offset!alignment of}
section offset that occurs at
an arbitrary alignment.
\end{itemize}

\section{Integer Representation Names}
\label{datarep:integerrepresentationnames}

The sizes of the integers used in the lookup by name, lookup
by address, line number and call frame information sections
are given in
Table \ref{tab:integerrepresentationnames}.

\needlines{8}
\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{c|l}
  \caption{Integer representation names} \label{tab:integerrepresentationnames}\\
  \hline \bfseries Representation name&\bfseries Representation \\ \hline
\endfirsthead
  \bfseries Representation name&\bfseries Representation\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot

\addtoindex{sbyte}&  signed, 1\dash byte integer \\
\addtoindex{ubyte}&unsigned, 1\dash byte integer \\
\addtoindex{uhalf}&unsigned, 2\dash byte integer \\
\addtoindex{uword}&unsigned, 4\dash byte integer \\

\end{longtable}
\end{centering}

\needlines{6}
\section{Type Signature Computation}
\label{datarep:typesignaturecomputation}

A type signature is computed only by the DWARF producer;
\addtoindexx{type signature computation}
it is used by a DWARF consumer to resolve type references to
the type definitions that are contained in 
\addtoindexx{type unit}
type units.

The type signature for a type T0 is formed from the 
\addtoindex{MD5 hash}
of a flattened description of the type. The flattened
description of the type is a byte sequence derived from the
DWARF encoding of the type as follows:
\begin{enumerate}[1. ]

\item Start with an empty sequence S and a list V of visited
types, where V is initialized to a list containing the type
T0 as its single element. Elements in V are indexed from 1,
so that V[1] is T0.

\item If the debugging information entry represents a type that
is nested inside another type or a namespace, append to S
the type\textquoteright s context as follows: For each surrounding type
or namespace, beginning with the outermost such construct,
append the letter 'C', the DWARF tag of the construct, and
the name (taken from 
\addtoindexx{name attribute}
the \DWATname{} attribute) of the type
\addtoindexx{name attribute}
or namespace (including its trailing null byte).

\item  Append to S the letter 'D', followed by the DWARF tag of
the debugging information entry.

\item For each of the attributes in
Table \refersec{tab:attributesusedintypesignaturecomputation}
that are present in
the debugging information entry, in the order listed,
append to S a marker letter (see below), the DWARF attribute
code, and the attribute value.

\begin{table}[ht]
\caption{Attributes used in type signature computation}
\label{tab:attributesusedintypesignaturecomputation}
\simplerule[\textwidth]
\begin{center}
\autocols[0pt]{c}{2}{l}{
\DWATname,
\DWATaccessibility,
\DWATaddressclass,
\DWATallocated,
\DWATartificial,
\DWATassociated,
\DWATbinaryscale,
\DWATbitoffset,
\DWATbitsize,
\DWATbitstride,
\DWATbytesize,
\DWATbytestride,
\DWATconstexpr,
\DWATconstvalue,
\DWATcontainingtype,
\DWATcount,
\DWATdatabitoffset,
\DWATdatalocation,
\DWATdatamemberlocation,
\DWATdecimalscale,
\DWATdecimalsign,
\DWATdefaultvalue,
\DWATdigitcount,
\DWATdiscr,
\DWATdiscrlist,
\DWATdiscrvalue,
\DWATencoding,
\DWATenumclass,
\DWATendianity,
\DWATexplicit,
\DWATisoptional,
\DWATlocation,
\DWATlowerbound,
\DWATmutable,
\DWATordering,
\DWATpicturestring,
\DWATprototyped,
\DWATsmall,
\DWATsegment,
\DWATstringlength,
\DWATstringlengthbitsize,
\DWATstringlengthbytesize,
\DWATthreadsscaled,
\DWATupperbound,
\DWATuselocation,
\DWATuseUTFeight,
\DWATvariableparameter,
\DWATvirtuality,
\DWATvisibility,
\DWATvtableelemlocation
}
\end{center}
\simplerule[\textwidth]
\end{table}

Note that except for the initial 
\DWATname{} attribute,
\addtoindexx{name attribute}
attributes are appended in order according to the alphabetical
spelling of their identifier.

If an implementation defines any vendor-specific attributes,
any such attributes that are essential to the definition of
the type should also be included at the end of the above list,
in their own alphabetical suborder.

An attribute that refers to another type entry T is processed
as follows: (a) If T is in the list V at some V[x], use the
letter 'R' as the marker and use the unsigned LEB128 encoding
of x as the attribute value; otherwise, (b) use the letter 'T'
as the marker, process the type T recursively by performing
Steps 2 through 7, and use the result as the attribute value.

Other attribute values use the letter 'A' as the marker, and
the value consists of the form code (encoded as an unsigned
LEB128 value) followed by the encoding of the value according
to the form code. To ensure reproducibility of the signature,
the set of forms used in the signature computation is limited
to the following: \DWFORMsdata, 
\DWFORMflag, 
\DWFORMstring,
and \DWFORMblock.

\item If the tag in Step 3 is one of \DWTAGpointertype,
\DWTAGreferencetype, 
\DWTAGrvaluereferencetype,
\DWTAGptrtomembertype, 
or \DWTAGfriend, and the referenced
type (via the \DWATtype{} or 
\DWATfriend{} attribute) has a
\DWATname{} attribute, append to S the letter 'N', the DWARF
attribute code (\DWATtype{} or 
\DWATfriend), the context of
the type (according to the method in Step 2), the letter 'E',
and the name of the type. For \DWTAGfriend, if the referenced
entry is a \DWTAGsubprogram, the context is omitted and the
name to be used is the ABI-specific name of the subprogram
(e.g., the mangled linker name).


\item If the tag in Step 3 is not one of \DWTAGpointertype,
\DWTAGreferencetype, 
\DWTAGrvaluereferencetype,
\DWTAGptrtomembertype, or 
\DWTAGfriend, but has
a \DWATtype{} attribute, or if the referenced type (via
the \DWATtype{} or 
\DWATfriend{} attribute) does not have a
\DWATname{} attribute, the attribute is processed according to
the method in Step 4 for an attribute that refers to another
type entry.


\item Visit each child C of the debugging information
entry as follows: If C is a nested type entry or a member
function entry, and has 
a \DWATname{} attribute, append to
\addtoindexx{name attribute}
S the letter 'S', the tag of C, and its name; otherwise,
process C recursively by performing Steps 3 through 7,
appending the result to S. Following the last child (or if
there are no children), append a zero byte.
\end{enumerate}



For the purposes of this algorithm, if a debugging information
entry S has a 
\DWATspecification{} 
attribute that refers to
another entry D (which has a 
\DWATdeclaration{} 
attribute),
then S inherits the attributes and children of D, and S is
processed as if those attributes and children were present in
the entry S. Exception: if a particular attribute is found in
both S and D, the attribute in S is used and the corresponding
one in D is ignored.

DWARF tag and attribute codes are appended to the sequence
as unsigned LEB128 values, using the values defined earlier
in this chapter.

\textit{A grammar describing this computation may be found in
Appendix \refersec{app:typesignaturecomputationgrammar}.
}

\textit{An attribute that refers to another type entry should
be recursively processed or replaced with the name of the
referent (in Step 4, 5 or 6). If neither treatment applies to
an attribute that references another type entry, the entry
that contains that attribute should not be considered for a
separate \addtoindex{type unit}.}

\textit{If a debugging information entry contains an attribute from
the list above that would require an unsupported form, that
entry should not be considered for a separate 
\addtoindex{type unit}.}

\textit{A type should be considered for a separate 
\addtoindex{type unit} only
if all of the type entries that it contains or refers to in
Steps 6 and 7 can themselves each be considered for a separate
\addtoindex{type unit}.}

\needlines{4}
Where the DWARF producer may reasonably choose two or more
different forms for a given attribute, it should choose
the simplest possible form in computing the signature. (For
example, a constant value should be preferred to a location
expression when possible.)

Once the string S has been formed from the DWARF encoding,
an \addtoindex{MD5 hash} is computed for the string and the 
least significant 64 bits are taken as the type signature.

\textit{The string S is intended to be a flattened representation of
the type that uniquely identifies that type (i.e., a different
type is highly unlikely to produce the same string).}

\textit{A debugging information entry should not be placed in a
separate \addtoindex{type unit}
if any of the following apply:}

\begin{itemize}

\item \textit{The entry has an attribute whose value is a location
expression, and the location expression contains a reference to
another debugging information entry (e.g., a \DWOPcallref{}
operator), as it is unlikely that the entry will remain
identical across compilation units.}

\item \textit{The entry has an attribute whose value refers
to a code location or a \addtoindex{location list}.}

\item \textit{The entry has an attribute whose value refers
to another debugging information entry that does not represent
a type.}
\end{itemize}


\needlines{4}
\textit{Certain attributes are not included in the type signature:}

\begin{itemize}
\item \textit{The \DWATdeclaration{} attribute is not included because it
indicates that the debugging information entry represents an
incomplete declaration, and incomplete declarations should
not be placed in 
\addtoindexx{type unit}
separate type units.}

\item \textit{The \DWATdescription{} attribute is not included because
it does not provide any information unique to the defining
declaration of the type.}

\item \textit{The \DWATdeclfile, 
\DWATdeclline, and
\DWATdeclcolumn{} attributes are not included because they
may vary from one source file to the next, and would prevent
two otherwise identical type declarations from producing the
\addtoindexx{MD5 hash}
same hash.}

\item \textit{The \DWATobjectpointer{} attribute is not included 
because the information it provides is not necessary for the 
computation of a unique type signature.}

\end{itemize}

\textit{Nested types and some types referred to by a debugging 
information entry are encoded by name rather than by recursively 
encoding the type to allow for cases where a complete definition 
of the type might not be available in all compilation units.}

\textit{If a type definition contains the definition of a member function, 
it cannot be moved as is into a type unit, because the member function 
contains attributes that are unique to that compilation unit. 
Such a type definition can be moved to a type unit by rewriting the DIE tree, 
moving the member function declaration into a separate declaration tree, 
and replacing the function definition in the type with a non-defining 
declaration of the function (as if the function had been defined out of 
line).}

An example that illustrates the computation of an MD5 hash may be found in 
Appendix \refersec{app:usingtypeunits}.

