\chapter{Data Representation}
\label{datarep:datarepresentation}

This section describes the binary representation of the
debugging information entry itself, of the attribute types
and of other fundamental elements described above.

\section{Vendor Extensibility}
\label{datarep:vendorextensibility}
\addtoindexx{vendor extensibility}
\addtoindexx{vendor specific extensions|see{vendor extensibility}}

To 
\addtoindexx{extensibility|see{vendor extensibility}}
reserve a portion of the DWARF name space and ranges of
enumeration values for use for vendor specific extensions,
special labels are reserved for tag names, attribute names,
base type encodings, location operations, language names,
calling conventions and call frame instructions.

The labels denoting the beginning and end of the 
\hypertarget{chap:DWXXXlohiuser}{reserved value range}
for vendor specific extensions consist of the
appropriate prefix 
(\DWATlouserMARK{}\DWAThiuserMARK{}DW\_AT, 
\DWATElouserMARK{}\DWATEhiuserMARK{}DW\_ATE, 
\DWCClouserMARK{}\DWCChiuserMARK{}DW\_CC, 
\DWCFAlouserMARK{}\DWCFAhiuserMARK{}DW\_CFA, 
\DWENDlouserMARK{}\DWENDhiuserMARK{}DW\_END, 
\DWIDXlouserMARK{}\DWIDXhiuserMARK{}DW\_IDX, 
\DWLANGlouserMARK{}\DWLANGhiuserMARK{}DW\_LANG, 
\DWLNCTlouserMARK{}\DWLNCThiuserMARK{}DW\_LNCT, 
\DWLNElouserMARK{}\DWLNEhiuserMARK{}DW\_LNE, 
\DWMACROlouserMARK{}\DWMACROhiuserMARK{}DW\_MACRO, 
\DWOPlouserMARK{}\DWOPhiuserMARK{}DW\_OP or 
\DWTAGlouserMARK{}\DWTAGhiuserMARK{}DW\_TAG) 
followed by \_lo\_user or \_hi\_user. 
Values in the  range between \textit{prefix}\_lo\_user 
and \textit{prefix}\_hi\_user inclusive,
are reserved for vendor specific extensions. Vendors may
use values in this range without conflicting with current or
future system\dash defined values. All other values are reserved
for use by the system.

\textit{For example, for debugging information entry
tags, the special labels are \DWTAGlouserNAME{} and \DWTAGhiuserNAME.}

\textit{There may also be codes for vendor specific extensions
between the number of standard line number opcodes and
the first special line number opcode. However, since the
number of standard opcodes varies with the DWARF version,
the range for extensions is also version dependent. Thus,
\DWLNSlouserTARG{} and 
\DWLNShiuserTARG{} symbols are not defined.}

Vendor defined tags, attributes, base type encodings, location
atoms, language names, line number actions, calling conventions
and call frame instructions, conventionally use the form
\text{prefix\_vendor\_id\_name}, where 
\textit{vendor\_id}\addtoindexx{vendor id} is some identifying
character sequence chosen so as to avoid conflicts with
other vendors.

To ensure that extensions added by one vendor may be safely
ignored by consumers that do not understand those extensions,
the following rules must be followed:
\begin{enumerate}[1. ]

\item New attributes are added in such a way that a
debugger may recognize the format of a new attribute value
without knowing the content of that attribute value.

\item The semantics of any new attributes do not alter
the semantics of previously existing attributes.

\item The semantics of any new tags do not conflict with
the semantics of previously existing tags.

\item New forms of attribute value are not added.

\end{enumerate}


\section{Reserved Values}
\label{datarep:reservedvalues}
\subsection{Error Values}
\label{datarep:errorvalues}
\addtoindexx{reserved values!error}

As 
\addtoindexx{error value}
a convenience for consumers of DWARF information, the value
0 is reserved in the encodings for attribute names, attribute
forms, base type encodings, location operations, languages,
line number program opcodes, macro information entries and tag
names to represent an error condition or unknown value. DWARF
does not specify names for these reserved values, because they
do not represent valid encodings for the given type and do
not appear in DWARF debugging information.


\subsection{Initial Length Values}
\label{datarep:initiallengthvalues}
\addtoindexx{reserved values!initial length}

An \livetarg{datarep:initiallengthvalues}{initial length} field 
\addtoindexx{initial length field|see{initial length}}
is one of the fields that occur at the beginning 
of those DWARF sections that have a header
(\dotdebugaranges{}, 
\dotdebuginfo{}, 
\dotdebugline{} and
\dotdebugnames{}) or the length field
that occurs at the beginning of the CIE and FDE structures
in the \dotdebugframe{} section.

\needlines{4}
In an \addtoindex{initial length} field, the values \wfffffffzero through
\wffffffff are reserved by DWARF to indicate some form of
extension relative to \DWARFVersionII; such values must not
be interpreted as a length field. The use of one such value,
\xffffffff, is defined in
Section \refersec{datarep:32bitand64bitdwarfformats}); 
the use of
the other values is reserved for possible future extensions.


\section{Relocatable, Split, Executable, Shared and Package Object Files} 
\label{datarep:executableobjectsandsharedobjects}

\subsection{Relocatable Object Files}
\label{datarep:relocatableobjectfiles}
A DWARF producer (for example, a compiler) typically generates its
debugging information as part of a relocatable object file.
Relocatable object files are then combined by a linker to form an
executable file. During the linking process, the linker resolves
(binds) symbolic references between the various object files, and
relocates the contents of each object file into a combined virtual
address space.

The DWARF debugging information is placed in several sections (see
Appendix \refersec{app:debugsectionrelationshipsinformative}), and 
requires an object file format capable of
representing these separate sections. There are symbolic references
between these sections, and also between the debugging information
sections and the other sections that contain the text and data of the
program itself. Many of these references require relocation, and the
producer must emit the relocation information appropriate to the
object file format and the target processor architecture. These
references include the following:

\begin{itemize}
\item The compilation unit header (see Section 
\refersec{datarep:unitheaders}) in the \dotdebuginfo{}
section contains a reference to the \dotdebugabbrev{} table. This
reference requires a relocation so that after linking, it refers to
that contribution to the combined \dotdebugabbrev{} section in the
executable file.

\item Debugging information entries may have attributes with the form
\DWFORMaddr{} (see Section \refersec{datarep:attributeencodings}). 
These attributes represent locations
within the virtual address space of the program, and require
relocation.

\item A DWARF expression may contain a \DWOPaddr{} (see Section 
\refersec{chap:literalencodings}) which contains a location within 
the virtual address space of the program, and require relocation.

\needlines{4}
\item Debugging information entries may have attributes with the form
\DWFORMsecoffset{} (see Section \refersec{datarep:attributeencodings}). 
These attributes refer to
debugging information in other debugging information sections within
the object file, and must be relocated during the linking process.
\par
However, if a \DWATrangesbase{} attribute is present, the offset in
a \DWATranges{} attribute (which uses form \DWFORMsecoffset) is
relative to the given base offset--no relocation is involved.

\item Debugging information entries may have attributes with the form
\DWFORMrefaddr{} (see Section \refersec{datarep:attributeencodings}). 
These attributes refer to
debugging information entries that may be outside the current
compilation unit. These values require both symbolic binding and
relocation.

\item Debugging information entries may have attributes with the form
\DWFORMstrp{} (see Section \refersec{datarep:attributeencodings}). 
These attributes refer to strings in
the \dotdebugstr{} section. These values require relocation.

\item Entries in the \dotdebugaddr, \dotdebugloc{}, \dotdebugranges{} 
and \dotdebugaranges{}
sections contain references to locations within the virtual address
space of the program, and require relocation.

\item In the \dotdebugline{} section, the operand of the \DWLNEsetaddress{}
opcode is a reference to a location within the virtual address space
of the program, and requires relocation.

\item The \dotdebugstroffsets{} section contains a list of string offsets,
each of which is an offset of a string in the \dotdebugstr{} section. Each
of these offsets requires relocation. Depending on the implementation,
these relocations may be implicit (that is, the producer may not need to
emit any explicit relocation information for these offsets).

\item The \HFNdebuginfooffset{} field in the \dotdebugaranges{} header and 
the list of compilation units following the \dotdebugnames{} header contain 
references to the \dotdebuginfo{} section.  These references require relocation 
so that after linking they refer to the correct contribution in the combined 
\dotdebuginfo{} section in the executable file.

\item Frame descriptor entries in the \dotdebugframe{} section 
(see Section \refersec{chap:structureofcallframeinformation}) contain an 
\HFNinitiallocation{} field value within the virtual address 
space of the program and require relocation. 

\end{itemize}

\needlines{4}
\textit{Note that operands of classes 
\CLASSconstant{} and 
\CLASSflag{} do not require relocation. Attribute operands that use 
forms \DWFORMstring{},
\DWFORMrefone, \DWFORMreftwo, \DWFORMreffour, \DWFORMrefeight, or
\DWFORMrefudata{} also do not need relocation.}

\subsection{Split DWARF Object Files}
\label{datarep:splitdwarfobjectfiles}
\addtoindexx{split DWARF object file}
A DWARF producer may partition the debugging
information such that the majority of the debugging
information can remain in individual object files without
being processed by the linker. 

\textit{This reduces link time by reducing the amount of information
the linker must process.}

\needlines{6}
\subsubsection{First Partition (with Skeleton Unit)}
The first partition contains
debugging information that must still be processed by the linker,
and includes the following:
\begin{itemize}
\item
The line number tables, range tables, frame tables, and
accelerated access tables, in the usual sections:
\dotdebugline, \dotdebuglinestr, \dotdebugranges, \dotdebugframe,
\dotdebugnames{} and \dotdebugaranges,
respectively.
\needlines{4}
\item
An address table, in the \dotdebugaddr{} section. This table
contains all addresses and constants that require
link-time relocation, and items in the table can be
referenced indirectly from the debugging information via
the \DWFORMaddrx{} form, and by the \DWOPaddrx{} and
\DWOPconstx{} operators.
\item
A skeleton compilation unit, as described in Section
\refersec{chap:skeletoncompilationunitentries}, 
in the \dotdebuginfo{} section.
\item
An abbreviations table for the skeleton compilation unit,
in the \dotdebugabbrev{} section.
\item
A string table, in the \dotdebugstr{} section. The string
table is necessary only if the skeleton compilation unit
uses either indirect string form, \DWFORMstrp{} or
\DWFORMstrx.
\item
A string offsets table, in the \dotdebugstroffsets{}
section. The string offsets table is necessary only if
the skeleton compilation unit uses the \DWFORMstrx{} form.
\end{itemize}
The attributes contained in the skeleton compilation
unit can be used by a DWARF consumer to find the 
DWARF object file that contains the second partition.

\subsubsection{Second Partition (Unlinked or in a \texttt{.dwo} File)}
The second partition contains the debugging information that
does not need to be processed by the linker. These sections
may be left in the object files and ignored by the linker
(that is, not combined and copied to the executable object file), or
they may be placed by the producer in a separate DWARF object
file. This partition includes the following:
\begin{itemize}
\item
The full compilation unit, in the \dotdebuginfodwo{} section.
\begin{itemize}
\item
The full compilation unit entry includes a \DWATdwoid{} 
attribute whose form and value is the same as that of the \DWATdwoid{} 
attribute of the associated skeleton unit.

\needlines{4}
\item
Attributes contained in the full compilation unit
may refer to machine addresses indirectly using the \DWFORMaddrx{} 
form, which accesses the table of addresses specified by the
\DWATaddrbase{} attribute in the associated skeleton unit.
Location descriptions may similarly do so using the \DWOPaddrx{} and
\DWOPconstx{} operations. 

\item
\DWATranges{} attributes contained in the full compilation unit
may refer to range table entries with a \DWFORMsecoffset{} offset 
relative to the base offset specified by the \DWATrangesbase{}
attribute in the associated skeleton unit.
\end{itemize}

\item Separate type units, in the \dotdebuginfodwo{} section.

\item
Abbreviations table(s) for the compilation unit and type
units, in the \dotdebugabbrevdwo{} section.

\item Location lists, in the \dotdebuglocdwo{} section.

\item
A \addtoindex{specialized line number table} (for the type units), 
in the \dotdebuglinedwo{} section. This table
contains only the directory and filename lists needed to
interpret \DWATdeclfile{} attributes in the debugging
information entries.

\item Macro information, in the \dotdebugmacrodwo{} section.

\item A string table, in the \dotdebugstrdwo{} section.

\item A string offsets table, in the \dotdebugstroffsetsdwo{}
section.
\end{itemize}

Except where noted otherwise, all references in this document
to a debugging information section (for example, \dotdebuginfo),
apply also to the corresponding split DWARF section (for example,
\dotdebuginfodwo).

\needlines{4}
Split DWARF object files do not get linked with any other files,
therefore references between sections must not make use of
normal object file relocation information. As a result, symbolic
references within or between sections are not possible.

\subsection{Executable Objects}
\label{chap:executableobjects}
The relocated addresses in the debugging information for an
executable object are virtual addresses.

The sections containing the debugging information are typically
not loaded as part of the memory image of the program (in ELF
terminology, the sections are not "allocatable" and are not part
of a loadable segment). Therefore, the debugging information
sections described in this document are typically linked as if
they were each to be loaded at virtual address 0, and references
within the debugging information always implicitly indicate which
section a particular offset refers to. (For example, a reference
of form \DWFORMsecoffset{} may refer to one of several sections,
depending on the class allowed by a particular attribute of a
debugging information entry, as shown in 
Table \refersec{tab:attributeencodings}.)

\needlines{6}
\subsection{Shared Object Files}
\label{datarep:sharedobjectfiles}
The relocated
addresses in the debugging information for a shared object file
are offsets relative to the start of the lowest region of
memory loaded from that shared object file.

\needlines{4}
\textit{This requirement makes the debugging information for
shared object files position independent.  Virtual addresses in a
shared object file may be calculated by adding the offset to the
base address at which the object file was attached. This offset
is available in the run\dash time linker\textquoteright s data structures.}

As with executable objects, the sections containing debugging
information are typically not loaded as part of the memory image
of the shared object, and are typically linked as if they were
each to be loaded at virtual address 0.

\subsection{DWARF Package Files}
\label{datarep:dwarfpackagefiles}
\textit{Using \splitDWARFobjectfile{s} allows the developer to compile, 
link, and debug an application quickly with less link-time overhead,
but a more convenient format is needed for saving the debug
information for later debugging of a deployed application. A
DWARF package file can be used to collect the debugging
information from the object (or separate DWARF object) files
produced during the compilation of an application.}

\textit{The package file is typically placed in the same directory as the
application, and is given the same name with a \doublequote{\texttt{.dwp}}
extension.\addtoindexx{\texttt{.dwp} file extension}}

A DWARF package file is itself an object file, using the
\addtoindexx{package files}
\addtoindexx{DWARF package files}
same object file format (including \byteorder) as the
corresponding application binary. It consists only of a file
header, a section table, a number of DWARF debug information
sections, and two index sections.

\needlines{10}
Each DWARF package file contains no more than one of each of the
following sections, copied from a set of object or DWARF object
files, and combined, section by section:
\begin{alltt}
    \dotdebuginfodwo
    \dotdebugabbrevdwo
    \dotdebuglinedwo
    \dotdebuglocdwo
    \dotdebugstroffsetsdwo
    \dotdebugstrdwo
    \dotdebugmacrodwo
\end{alltt}

The string table section in \dotdebugstrdwo{} contains all the
strings referenced from DWARF attributes using the form
\DWFORMstrx. Any attribute in a compilation unit or a type
unit using this form refers to an entry in that unit's
contribution to the \dotdebugstroffsetsdwo{} section, which in turn
provides the offset of a string in the \dotdebugstrdwo{}
section.

The DWARF package file also contains two index sections that
provide a fast way to locate debug information by compilation
unit ID (\DWATdwoid) for compilation units, or by type
signature for type units:
\begin{alltt}
    \dotdebugcuindex
    \dotdebugtuindex
\end{alltt}

\subsubsection{The Compilation Unit (CU) Index Section}
The \dotdebugcuindex{} section is a hashed lookup table that maps a
compilation unit ID to a set of contributions in the
various debug information sections. Each contribution is stored
as an offset within its corresponding section and a size.

Each \compunitset{} may contain contributions from the
following sections:
\begin{alltt}
    \dotdebuginfodwo{} (required)
    \dotdebugabbrevdwo{} (required)
    \dotdebuglinedwo
    \dotdebuglocdwo
    \dotdebugstroffsetsdwo
    \dotdebugmacrodwo
\end{alltt}

\textit{Note that a \compunitset{} is not able to represent \dotdebugmacinfo{}
information from \DWARFVersionIV{} or earlier formats.}

\subsubsection{The Type Unit (TU) Index Section}
The \dotdebugtuindex{} section is a hashed lookup table that maps a
type signature to a set of offsets into the various debug
information sections. Each contribution is stored as an offset
within its corresponding section and a size.

Each \typeunitset{} may contain contributions from the following
sections:
\begin{alltt}
    \dotdebuginfodwo{} (required) 
    \dotdebugabbrevdwo{} (required)
    \dotdebuglinedwo
    \dotdebugstroffsetsdwo
\end{alltt}

\subsubsection{Format of the CU and TU Index Sections}
Both index sections have the same format, and serve to map an
8-byte signature to a set of contributions to the debug sections.
Each index section begins with a header, followed by a hash table of
signatures, a parallel table of indexes, a table of offsets, and
a table of sizes. The index sections are aligned at 8-byte
boundaries in the DWARF package file.

\needlines{6}
The index section header contains the following fields:
\begin{enumerate}[1. ]
\item \texttt{version} (\HFTuhalf) \\
A version number.
\addtoindexx{version number!CU index information} 
\addtoindexx{version number!TU index information}
This number is specific to the CU and TU index information
and is independent of the DWARF version number.

The version number is \versiondotdebugcuindex.

\item \textit{padding} (\HFTuhalf) \\
Reserved to DWARF (must be zero).
\item \texttt{section\_count} (\HFTuword) \\
The number of entries in the table of section counts that follows.
For brevity, the contents of this field is referred to as $N$ below.

\item \texttt{unit\_count} (\HFTuword) \\
The number of compilation units or type units in the index.
For brevity, the contents of this field is referred to as $U$ below.

\item \texttt{slot\_count} (\HFTuword) \\
The number of slots in the hash table.
For brevity, the contents of this field is referred to as $S$ below.

\end{enumerate}

\textit{We assume that $U$ and $S$ do not exceed $2^{32}$.}

The size of the hash table, $S$, must be $2^k$ such that:
\hspace{0.3cm}$2^k\ \ >\ \ 3*U/2$

The hash table begins at offset 16 in the section, and consists
of an array of $S$ 8-byte slots. Each slot contains a 64-bit
signature.
% (using the \byteorder{} of the application binary).

The parallel table of indices begins immediately after the hash table 
(at offset \mbox{$16 + 8 * S$} from the beginning of the section), and
consists of an array of $S$ 4-byte slots,
% (using the byte order of the application binary), 
corresponding 1-1 with slots in the hash
table. Each entry in the parallel table contains a row index into
the tables of offsets and sizes.

Unused slots in the hash table have 0 in both the hash table
entry and the parallel table entry. While 0 is a valid hash
value, the row index in a used slot will always be non-zero.

Given an 8-byte compilation unit ID or type signature $X$,
an entry in the hash table is located as follows:
\begin{enumerate}[1. ]
\item Define $REP(X)$ to be the value of $X$ interpreted as an 
      unsigned 64-bit integer in the target byte order.
\item Calculate a primary hash $H = REP(X)\ \&\ MASK(k)$, where
      $MASK(k)$ is a mask with the low-order $k$ bits all set to 1.
\item Calculate a secondary hash $H' = (((REP(X)>>32)\ \&\ MASK(k))\ |\ 1)$.
\item If the hash table entry at index $H$ matches the signature, use
      that entry. If the hash table entry at index $H$ is unused (all
      zeroes), terminate the search: the signature is not present
      in the table.
\item Let $H = (H + H')\ modulo\ S$. Repeat at Step 4.
\end{enumerate}

Because $S > U$, and $H'$ and $S$ are relatively prime, the search is
guaranteed to stop at an unused slot or find the match.

\needlines{4}
The table of offsets begins immediately following the parallel
table (at offset \mbox{$16 + 12 * S$} from the beginning of the section).
The table is a two-dimensional array of 4-byte words, 
%(using the byte order of the application binary),
with $N$ sections and $U + 1$
rows, in row-major order. Each row in the array is indexed
starting from 0. The first row provides a key to the columns:
each column in this row provides a section identifier for a debug
section, and the offsets in the same column of subsequent rows
refer to that section. The section identifiers are shown in
Table \referfol{tab:dwarfpackagefilesectionidentifierencodings}.

\textit{Not all sections listed in the table need be included.}

\needlines{12}
\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c|l}
  \caption{DWARF package file section identifier \mbox{encodings}}
  \label{tab:dwarfpackagefilesectionidentifierencodings}
  \addtoindexx{DWARF package files!section identifier encodings} \\
  \hline \bfseries Section identifier &\bfseries Value &\bfseries Section \\ \hline
\endfirsthead
  \bfseries Section identifier &\bfseries Value &\bfseries Section\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot
\DWSECTINFOTARG         & 1 & \dotdebuginfodwo \\
\textit{Reserved}       & 2 & \\
\DWSECTABBREVTARG       & 3 & \dotdebugabbrevdwo \\
\DWSECTLINETARG         & 4 & \dotdebuglinedwo \\
\DWSECTLOCTARG          & 5 & \dotdebuglocdwo \\
\DWSECTSTROFFSETSTARG   & 6 & \dotdebugstroffsetsdwo \\
%DWSECTMACINFO          &   & \dotdebugmacinfodwo \\
\DWSECTMACROTARG        & 7 & \dotdebugmacrodwo \\
\end{longtable}
\end{centering}

The offsets provided by the CU and TU index sections are the 
base offsets for the contributions made by each CU or TU to the
corresponding section in the package file. Each CU and TU header
contains a \HFNdebugabbrevoffset{} field, used to find the abbreviations
table for that CU or TU within the contribution to the
\dotdebugabbrevdwo{} section for that CU or TU, and are
interpreted as relative to the base offset given in the index
section. Likewise, offsets into \dotdebuglinedwo{} from
\DWATstmtlist{} attributes are interpreted as relative to
the base offset for \dotdebuglinedwo{}, and offsets into other debug
sections obtained from DWARF attributes are also 
interpreted as relative to the corresponding base offset.

The table of sizes begins immediately following the table of
offsets, and provides the sizes of the contributions made by each
CU or TU to the corresponding section in the package file. Like
the table of offsets, it is a two-dimensional array of 4-byte
words, with $N$ 
entries and $U$ rows, in row-major order. Each row in
the array is indexed starting from 1 (row 0 of the table of
offsets also serves as the key for the table of sizes).

For an example, see Figure \refersec{fig:examplecuindexsection}.

\subsection{DWARF Supplementary Object Files}
\label{datarep:dwarfsupplemetaryobjectfiles}
In order to minimize the size of debugging information, 
it is possible to move duplicate debug information entries, 
strings and macro entries from several executables or shared 
object files into a separate 
\addtoindexi{\textit{supplementary object file}}{supplementary object file} 
by some post-linking utility; the moved entries and strings can 
then be referenced
from the debugging information of each of those executable or 
shared object files.

This facilitates distribution of separate consolidated debug files in
a simple manner.

\needlines{4}
A DWARF \addtoindex{supplementary object file} is itself an object file, 
using the same object
file format, \byteorder{}, and size as the corresponding application executables
or shared libraries. It consists only of a file header, section table, and
a number of DWARF debug information sections.  Both the 
\addtoindex{supplementary object file}
and all the executable or shared object files that reference entries or strings in that
file must contain a \dotdebugsup{} section that establishes the relationship.

The \dotdebugsup{} section contains:
\begin{enumerate}[1. ]
\item \texttt{version} (\HFTuhalf) \\
\addttindexx{version}
A 2-byte unsigned integer representing the version of the DWARF
information for the compilation unit. 

The value in this field is \versiondotdebugsup.

\item \texttt{is\_supplementary} (\HFTubyte) \\
\addttindexx{is\_supplementary}
A 1-byte unsigned integer, which contains the value 1 if it is
in the \addtoindex{supplementary object file} that other executable or 
shared object files refer to, or 0 if it is an executable or shared object 
referring to a \addtoindex{supplementary object file}.

\needlines{4}
\item \texttt{sup\_filename} (null terminated filename string) \\
\addttindexx{sup\_filename}
If \addttindex{is\_supplementary} is 0, this contains either an absolute 
filename for the \addtoindex{supplementary object file}, or a filename 
relative to the object file containing the \dotdebugsup{} section.  
If \addttindex{is\_supplementary} is 1, then \addttindex{sup\_filename}
is not needed and must be an empty string (a single null byte).

\needlines{4}
\item \texttt{sup\_checksum\_len} (unsigned LEB128) \\
\addttindexx{sup\_checksum\_len}
Length of the following \addttindex{sup\_checksum} field; 
this value can be 0 if no checksum is provided.

\item \texttt{sup\_checksum} (array of \HFTubyte) \\
\addttindexx{sup\_checksum}
An implementation-defined integer constant value that
provides unique identification of the supplementary file.

\end{enumerate}

Debug information entries that refer to an executable's or shared
object's addresses must \emph{not} be moved to supplementary files 
(the addesses will likely not be the same). Similarly,
entries referenced from within location descriptions or using loclistptr
form attributes must not be moved to a \addtoindex{supplementary object file}.

Executable or shared object file compilation units can use
\DWTAGimportedunit{} with \DWFORMrefsup{} form \DWATimport{} attribute
to import entries from the \addtoindex{supplementary object file}, other \DWFORMrefsup{}
attributes to refer to them and \DWFORMstrpsup{} form attributes to
refer to strings that are used by debug information of multiple
executables or shared object files.  Within the \addtoindex{supplementary object file}'s
debugging sections, form \DWFORMrefsup{} or \DWFORMstrpsup{} are
not used, and all reference forms referring to some other sections
refer to the local sections in the \addtoindex{supplementary object file}.

In macro information, \DWMACROdefinesup{} or
\DWMACROundefsup{} opcodes can refer to strings in the 
\dotdebugstr{} section of the \addtoindex{supplementary object file}, 
or \DWMACROimportsup{} 
can refer to \dotdebugmacro{} section entries.  Within the 
\dotdebugmacro{} section of a \addtoindex{supplementary object file}, 
\DWMACROdefinestrp{} and \DWMACROundefstrp{}
opcodes refer to the local \dotdebugstr{} section in that
supplementary file, not the one in
the executable or shared object file.


\needlines{6}
\section{32-Bit and 64-Bit DWARF Formats}
\label{datarep:32bitand64bitdwarfformats}
\hypertarget{datarep:xxbitdwffmt}{}
\addtoindexx{32-bit DWARF format}
\addtoindexx{64-bit DWARF format}
There are two closely-related DWARF
formats. In the 32-bit DWARF
format, all values that represent lengths of DWARF sections
and offsets relative to the beginning of DWARF sections are
represented using four bytes. In the 64-bit DWARF format, all
values that represent lengths of DWARF sections and offsets
relative to the beginning of DWARF sections are represented
using eight bytes. A special convention applies to the initial
length field of certain DWARF sections, as well as the CIE and
FDE structures, so that the 32-bit and 64-bit DWARF formats
can coexist and be distinguished within a single linked object.

Except where noted otherwise, all references in this document
to a debugging information section (for example, \dotdebuginfo),
apply also to the corresponding split DWARF section (for example,
\dotdebuginfodwo).

The differences between the 32- and 64-bit DWARF formats are
detailed in the following:
\begin{enumerate}[1. ]

\item  In the 32-bit DWARF format, an 
\addtoindex{initial length} field (see 
\addtoindexx{initial length!encoding}
Section \ref{datarep:initiallengthvalues} on page \pageref{datarep:initiallengthvalues})
is an unsigned 4-byte integer (which
must be less than \xfffffffzero); in the 64-bit DWARF format,
an \addtoindex{initial length} field is 12 bytes in size,
and has two parts:
\begin{itemize}
\item The first four bytes have the value \xffffffff.

\item  The following eight bytes contain the actual length
represented as an unsigned 8-byte integer.
\end{itemize}

\textit{This representation allows a DWARF consumer to dynamically
detect that a DWARF section contribution is using the 64-bit
format and to adapt its processing accordingly.}

\needlines{4}
\item \hypertarget{datarep:sectionoffsetlength}{}
Section offset and section length
\addtoindexx{section length!use in headers}
fields that occur
\addtoindexx{section offset!use in headers}
in the headers of DWARF sections (other than initial length
\addtoindexx{initial length}
fields) are listed following. In the 32-bit DWARF format these
are 4-byte unsigned integer values; in the 64-bit DWARF format,
they are 8-byte unsigned integer values.

\begin{center}
\begin{tabular}{lll}
Section &Name & Role  \\ \hline
\dotdebugaranges{}   & \addttindex{debug\_info\_offset}   & offset in \dotdebuginfo{} \\
\dotdebugframe{}/CIE & \addttindex{CIE\_id}               & CIE distinguished value \\
\dotdebugframe{}/FDE & \addttindex{CIE\_pointer}          & offset in \dotdebugframe{} \\
\dotdebuginfo{}      & \addttindex{debug\_abbrev\_offset} & offset in \dotdebugabbrev{} \\
\dotdebugline{}      & \addttindex{header\_length}        & length of header itself \\
\dotdebugnames{}     & entry in array of CUs              & offset in \dotdebuginfo{} \\
                     & or local TUs                       & \\
\end{tabular}
\end{center}

\needlines{4}
The \texttt{CIE\_id} field in a CIE structure must be 64 bits because
it overlays the \texttt{CIE\_pointer} in a FDE structure; this implicit
union must be accessed to distinguish whether a CIE or FDE is
present, consequently, these two fields must exactly overlay
each other (both offset and size).

\item Within the body of the \dotdebuginfo{}
section, certain forms of attribute value depend on the choice
of DWARF format as follows. For the 32-bit DWARF format,
the value is a 4-byte unsigned integer; for the 64-bit DWARF
format, the value is an 8-byte unsigned integer.
\begin{center}
\begin{tabular}{lp{6cm}}
Form             & Role  \\ \hline
\DWFORMlinestrp  & offset in \dotdebuglinestr \\
\DWFORMrefaddr   & offset in \dotdebuginfo{} \\
\DWFORMrefsup    & offset in \dotdebuginfo{} section of a \mbox{supplementary} object file \\
                   \addtoindexx{supplementary object file}
\DWFORMsecoffset & offset in a section other than \\
		 & \dotdebuginfo{} or \dotdebugstr{} \\
\DWFORMstrp      & offset in \dotdebugstr{} \\
\DWFORMstrpsup   & offset in \dotdebugstr{} section of a \mbox{supplementary} object file \\
\DWOPcallref     & offset in \dotdebuginfo{} \\
\end{tabular}
\end{center}

\needlines{5}
\item Within the body of the \dotdebugline{} section, certain forms of content
description depend on the choice of DWARF format as follows: for the
32-bit DWARF format, the value is a 4-byte unsigned integer; for the
64-bit DWARF format, the value is a 8-byte unsigned integer.
\begin{center}
\begin{tabular}{lp{6cm}}
Form             & Role  \\ \hline
\DWFORMlinestrp  & offset in \dotdebuglinestr
\end{tabular}
\end{center}

\item Within the body of the \dotdebugnames{} 
sections, the representation of each entry in the array of
compilation units (CUs) and the array of local type units
(TUs), which represents an offset in the 
\dotdebuginfo{}
section, depends on the DWARF format as follows: in the
32-bit DWARF format, each entry is a 4-byte unsigned integer;
in the 64-bit DWARF format, it is a 8-byte unsigned integer.

\needlines{4}
\item In the body of the \dotdebugstroffsets{} 
sections, the size of entries in the body depend on the DWARF
format as follows: in the 32-bit DWARF format, entries are 4-byte
unsigned integer values; in the 64-bit DWARF format, they are
8-byte unsigned integers.

\item In the body of the \dotdebugaddr{}, \dotdebugloc{} and \dotdebugranges{}
sections, the contents of the address size fields depends on the
DWARF format as follows: in the 32-bit DWARF format, these fields
contain 4; in the 64-bit DWARF format these fields contain 8.
\end{enumerate}


The 32-bit and 64-bit DWARF format conventions must \emph{not} be
intermixed within a single compilation unit.

\textit{Attribute values and section header fields that represent
addresses in the target program are not affected by these
rules.}

A DWARF consumer that supports the 64-bit DWARF format must
support executables in which some compilation units use the
32-bit format and others use the 64-bit format provided that
the combination links correctly (that is, provided that there
are no link\dash time errors due to truncation or overflow). (An
implementation is not required to guarantee detection and
reporting of all such errors.)

\textit{It is expected that DWARF producing compilers will \emph{not} use
the 64-bit format \emph{by default}. In most cases, the division of
even very large applications into a number of executable and
shared object files will suffice to assure that the DWARF sections
within each individual linked object are less than 4 GBytes
in size. However, for those cases where needed, the 64-bit
format allows the unusual case to be handled as well. Even
in this case, it is expected that only application supplied
objects will need to be compiled using the 64-bit format;
separate 32-bit format versions of system supplied shared
executable libraries can still be used.}


\section{Format of Debugging Information}
\label{datarep:formatofdebugginginformation}

For each compilation unit compiled with a DWARF producer,
a contribution is made to the \dotdebuginfo{} section of
the object file. Each such contribution consists of a
compilation unit header 
(see Section \refersec{datarep:compilationunitheader}) 
followed by a
single \DWTAGcompileunit{} or 
\DWTAGpartialunit{} debugging
information entry, together with its children.

For each type defined in a compilation unit, a separate
contribution may also be made to the 
\dotdebuginfo{} 
section of the object file. Each
such contribution consists of a 
\addtoindex{type unit} header 
(see Section \refersec{datarep:typeunitheader}) 
followed by a \DWTAGtypeunit{} entry, together with
its children.

Each debugging information entry begins with a code that
represents an entry in a separate 
\addtoindex{abbreviations table}. This
code is followed directly by a series of attribute values.

The appropriate entry in the 
\addtoindex{abbreviations table} guides the
interpretation of the information contained directly in the
\dotdebuginfo{} section.

\needlines{4}
Multiple debugging information entries may share the same
abbreviation table entry. Each compilation unit is associated
with a particular abbreviation table, but multiple compilation
units may share the same table.

\subsection{Unit Headers}
\label{datarep:unitheaders}
Unit headers contain a field, \addttindex{unit\_type}, whose value indicates the kind of
compilation unit that follows. The encodings for the unit type 
enumeration are shown in Table \refersec{tab:unitheaderunitkindencodings}.

\needlines{6}
\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Unit header unit type encodings}
  \label{tab:unitheaderunitkindencodings}
  \addtoindexx{unit header unit type encodings} \\
  \hline \bfseries Unit header unit type encodings&\bfseries Value \\ \hline
\endfirsthead
  \bfseries Unit header unit type encodings&\bfseries Value \\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline \ddag\ \textit{New in DWARF Version 5}
\endlastfoot
\DWUTcompileTARG~\ddag    &0x01 \\ 
\DWUTtypeTARG~\ddag       &0x02 \\ 
\DWUTpartialTARG~\ddag    &0x03 \\ \hline
\end{longtable}
\end{centering}

\needlines{5}
\subsubsection{Compilation and Partial Unit Headers}
\label{datarep:compilationunitheader}
\begin{enumerate}[1. ]

\item \texttt{unit\_length} (\livelink{datarep:initiallengthvalues}{initial length}) \\
\addttindexx{unit\_length}
A 4-byte or 12-byte 
\addtoindexx{initial length}
unsigned integer representing the length
of the \dotdebuginfo{}
contribution for that compilation unit,
not including the length field itself. In the \thirtytwobitdwarfformat,
 this is a 4-byte unsigned integer (which must be less
than \xfffffffzero); in the \sixtyfourbitdwarfformat, this consists
of the 4-byte value \wffffffff followed by an 8-byte unsigned
integer that gives the actual length 
(see Section \refersec{datarep:32bitand64bitdwarfformats}).

\item  \texttt{version} (\HFTuhalf) \\
\addttindexx{version}
\addtoindexx{version number!compilation unit}
A 2-byte unsigned integer representing the version of the
DWARF information for the compilation unit.
 
The value in this field is \versiondotdebuginfo.

\textit{See also Appendix \refersec{app:dwarfsectionversionnumbersinformative}
for a summary of all version numbers that apply to DWARF sections.}

\needlines{4}
\item \texttt{unit\_type} (\HFTubyte) \\
\addttindexx{unit\_type}
A 1-byte unsigned integer identifying this unit as a compilation unit.
The value of this field is 
\DWUTcompile{} for a full compilation unit or
\DWUTpartial{} for a partial compilation unit
(see Section \refersec{chap:fullandpartialcompilationunitentries}).

\textit{This field is new in \DWARFVersionV.}

\needlines{4}
\item \texttt{address\_size} (\HFTubyte) \\
\addttindexx{address\_size}
A 1-byte unsigned integer representing the size in bytes of
an address on the target architecture. If the system uses
\addtoindexx{address space!segmented}
segmented addressing, this value represents the size of the
offset portion of an address.

\item \HFNdebugabbrevoffset{} (\livelink{datarep:sectionoffsetlength}{section offset}) \\
A 
\addtoindexx{section offset!in .debug\_info header}
4-byte or 8-byte unsigned offset into the 
\dotdebugabbrev{}
section. This offset associates the compilation unit with a
particular set of debugging information entry abbreviations. In
the \thirtytwobitdwarfformat, this is a 4-byte unsigned length;
in the \sixtyfourbitdwarfformat, this is an 8-byte unsigned length
(see Section \refersec{datarep:32bitand64bitdwarfformats}).

\end{enumerate}

\needlines{8}
\subsubsection{Type Unit Header}
\label{datarep:typeunitheader}
The header for the series of debugging information entries
contributing to the description of a type that has been
placed in its own \addtoindex{type unit}, within the 
\dotdebuginfo{} section,
consists of the following information:
\begin{enumerate}[1. ]
\item \texttt{unit\_length} (\livelink{datarep:initiallengthvalues}{initial length}) \\
\addttindexx{unit\_length}
A 4-byte or 12-byte unsigned integer 
\addtoindexx{initial length}
representing the length
of the \dotdebuginfo{} contribution for that type unit,
not including the length field itself. In the \thirtytwobitdwarfformat, 
this is a 4-byte unsigned integer (which must be
less than \xfffffffzero); in the \sixtyfourbitdwarfformat, this
consists of the 4-byte value \wffffffff followed by an 
8-byte unsigned integer that gives the actual length
(see Section \refersec{datarep:32bitand64bitdwarfformats}).

\needlines{4}
\item  \texttt{version} (\HFTuhalf) \\
\addttindexx{version}
\addtoindexx{version number!type unit}
A 2-byte unsigned integer representing the version of the
DWARF information for the type unit.
 
The value in this field is \versiondotdebuginfo.

\item \texttt{unit\_type} (\HFTubyte) \\
\addttindexx{unit\_type}
A 1-byte unsigned integer identifying this unit as a type unit.
The value of this field is \DWUTtype{} for a type unit
(see Section \refersec{chap:typeunitentries}).

\textit{This field is new in \DWARFVersionV.}

\needlines{4}
\item \texttt{address\_size} (\HFTubyte) \\
\addttindexx{address\_size}
A 1-byte unsigned integer representing the size 
\addtoindexx{size of an address}
in bytes of
an address on the target architecture. If the system uses
\addtoindexx{address space!segmented}
segmented addressing, this value represents the size of the
offset portion of an address.

\item \HFNdebugabbrevoffset{} (\livelink{datarep:sectionoffsetlength}{section offset}) \\
A 
\addtoindexx{section offset!in .debug\_info header}
4-byte or 8-byte unsigned offset into the 
\dotdebugabbrev{}
section. This offset associates the type unit with a
particular set of debugging information entry abbreviations. In
the \thirtytwobitdwarfformat, this is a 4-byte unsigned length;
in the \sixtyfourbitdwarfformat, this is an 8-byte unsigned length
(see Section \refersec{datarep:32bitand64bitdwarfformats}).

\item \texttt{type\_signature} (8-byte unsigned integer) \\
\addttindexx{type\_signature}
\addtoindexx{type signature}
A unique 8-byte signature (see Section 
\refersec{datarep:typesignaturecomputation})
of the type described in this type
unit.  

\textit{An attribute that refers (using 
\DWFORMrefsigeight{}) to
the primary type contained in this 
\addtoindex{type unit} uses this value.}

\needlines{4}
\item \texttt{type\_offset} (\livelink{datarep:sectionoffsetlength}{section offset}) \\
\addttindexx{type\_offset}
A 4-byte or 8-byte unsigned offset 
\addtoindexx{section offset!in .debug\_info header}
relative to the beginning
of the \addtoindex{type unit} header.
This offset refers to the debugging
information entry that describes the type. Because the type
may be nested inside a namespace or other structures, and may
contain references to other types that have not been placed in
separate type units, it is not necessarily either the first or
the only entry in the type unit. In the \thirtytwobitdwarfformat,
this is a 4-byte unsigned length; in the \sixtyfourbitdwarfformat,
this is an 8-byte unsigned length
(see Section \refersec{datarep:32bitand64bitdwarfformats}).

\end{enumerate}

\subsection{Debugging Information Entry}
\label{datarep:debugginginformationentry}

Each debugging information entry begins with an 
unsigned LEB128\addtoindexx{LEB128!unsigned}
number containing the abbreviation code for the entry. This
code represents an entry within the abbreviations table
associated with the compilation unit containing this entry. The
abbreviation code is followed by a series of attribute values.

On some architectures, there are alignment constraints on
section boundaries. To make it easier to pad debugging
information sections to satisfy such constraints, the
abbreviation code 0 is reserved. Debugging information entries
consisting of only the abbreviation code 0 are considered
null entries.

\subsection{Abbreviations Tables}
\label{datarep:abbreviationstables}

The abbreviations tables for all compilation units
are contained in a separate object file section called
\dotdebugabbrev{}.
As mentioned before, multiple compilation
units may share the same abbreviations table.

The abbreviations table for a single compilation unit consists
of a series of abbreviation declarations. Each declaration
specifies the tag and attributes for a particular form of
debugging information entry. Each declaration begins with
an unsigned LEB128\addtoindexx{LEB128!unsigned}
number representing the abbreviation
code itself. It is this code that appears at the beginning
of a debugging information entry in the 
\dotdebuginfo{}
section. As described above, the abbreviation
code 0 is reserved for null debugging information entries. The
abbreviation code is followed by another unsigned LEB128\addtoindexx{LEB128!unsigned}
number that encodes the entry\textquoteright s tag. The encodings for the
tag names are given in 
Table \refersec{tab:tagencodings}.

\needlines{6}
\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Tag encodings} \label{tab:tagencodings} \\
  \hline \bfseries Tag name&\bfseries Value\\ \hline
\endfirsthead
  \bfseries Tag name&\bfseries Value \\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline \ddag\ \textit{New in DWARF Version 5}
\endlastfoot
\DWTAGarraytype{} &0x01 \\
\DWTAGclasstype&0x02 \\
\DWTAGentrypoint&0x03 \\
\DWTAGenumerationtype&0x04 \\
\DWTAGformalparameter&0x05 \\
\DWTAGimporteddeclaration&0x08 \\
\DWTAGlabel&0x0a \\
\DWTAGlexicalblock&0x0b \\
\DWTAGmember&0x0d \\
\DWTAGpointertype&0x0f \\
\DWTAGreferencetype&0x10 \\
\DWTAGcompileunit&0x11 \\
\DWTAGstringtype&0x12 \\
\DWTAGstructuretype&0x13 \\
\DWTAGsubroutinetype&0x15 \\
\DWTAGtypedef&0x16 \\
\DWTAGuniontype&0x17 \\
\DWTAGunspecifiedparameters&0x18  \\
\DWTAGvariant&0x19  \\
\DWTAGcommonblock&0x1a  \\
\DWTAGcommoninclusion&0x1b  \\
\DWTAGinheritance&0x1c  \\
\DWTAGinlinedsubroutine&0x1d  \\
\DWTAGmodule&0x1e  \\
\DWTAGptrtomembertype&0x1f  \\
\DWTAGsettype&0x20  \\
\DWTAGsubrangetype&0x21  \\
\DWTAGwithstmt&0x22  \\
\DWTAGaccessdeclaration&0x23  \\
\DWTAGbasetype&0x24  \\
\DWTAGcatchblock&0x25  \\
\DWTAGconsttype&0x26  \\
\DWTAGconstant&0x27  \\
\DWTAGenumerator&0x28  \\
\DWTAGfiletype&0x29  \\
\DWTAGfriend&0x2a  \\
\DWTAGnamelist&0x2b    \\
\DWTAGnamelistitem&0x2c    \\
\DWTAGpackedtype&0x2d    \\
\DWTAGsubprogram&0x2e    \\
\DWTAGtemplatetypeparameter&0x2f    \\
\DWTAGtemplatevalueparameter&0x30    \\
\DWTAGthrowntype&0x31    \\
\DWTAGtryblock&0x32    \\
\DWTAGvariantpart&0x33    \\
\DWTAGvariable&0x34    \\
\DWTAGvolatiletype&0x35    \\
\DWTAGdwarfprocedure&0x36     \\
\DWTAGrestricttype&0x37      \\
\DWTAGinterfacetype&0x38      \\
\DWTAGnamespace&0x39      \\
\DWTAGimportedmodule&0x3a      \\
\DWTAGunspecifiedtype&0x3b      \\
\DWTAGpartialunit&0x3c      \\
\DWTAGimportedunit&0x3d      \\
\DWTAGcondition&\xiiif      \\
\DWTAGsharedtype&0x40      \\
\DWTAGtypeunit & 0x41      \\
\DWTAGrvaluereferencetype & 0x42      \\
\DWTAGtemplatealias & 0x43      \\
\DWTAGcoarraytype~\ddag & 0x44 \\
\DWTAGgenericsubrange~\ddag & 0x45 \\
\DWTAGdynamictype~\ddag & 0x46 \\
\DWTAGatomictype~\ddag & 0x47 \\
\DWTAGcallsite~\ddag & 0x48 \\
\DWTAGcallsiteparameter~\ddag & 0x49 \\
\DWTAGlouser&0x4080      \\
\DWTAGhiuser&\xffff      \\
\end{longtable}
\end{centering}

\needlines{8}
Following the tag encoding is a 1-byte value that determines
whether a debugging information entry using this abbreviation
has child entries or not. If the value is 
\DWCHILDRENyesTARG,
the next physically succeeding entry of any debugging
information entry using this abbreviation is the first
child of that entry. If the 1-byte value following the
abbreviation\textquoteright s tag encoding is 
\DWCHILDRENnoTARG, the next
physically succeeding entry of any debugging information entry
using this abbreviation is a sibling of that entry. (Either
the first child or sibling entries may be null entries). The
encodings for the child determination byte are given in 
Table \refersec{tab:childdeterminationencodings}
(As mentioned in 
Section \refersec{chap:relationshipofdebugginginformationentries}, 
each chain of sibling entries is terminated by a null entry.)

\needlines{6}
\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Child determination encodings}
  \label{tab:childdeterminationencodings}
  \addtoindexx{Child determination encodings} \\
  \hline \bfseries Children determination name&\bfseries Value \\ \hline
\endfirsthead
  \bfseries Children determination name&\bfseries Value \\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot
\DWCHILDRENno&0x00 \\ 
\DWCHILDRENyes&0x01 \\ \hline
\end{longtable}
\end{centering}

\needlines{4}
Finally, the child encoding is followed by a series of
attribute specifications. Each attribute specification
consists of two parts. The first part is an 
unsigned LEB128\addtoindexx{LEB128!unsigned}
number representing the attribute\textquoteright s name. 
The second part is an 
unsigned LEB128\addtoindexx{LEB128!unsigned} 
number representing the attribute\textquoteright s form. 
The series of attribute specifications ends with an
entry containing 0 for the name and 0 for the form.

\needlines{4}
The attribute form 
\DWFORMindirectTARG{} is a special case. For
attributes with this form, the attribute value itself in the
\dotdebuginfo{}
section begins with an unsigned
LEB128 number that represents its form. This allows producers
to choose forms for particular attributes 
\addtoindexx{abbreviations table!dynamic forms in}
dynamically,
without having to add a new entry to the abbreviations table.

The attribute form \DWFORMimplicitconstTARG{} is another special case.
For attributes with this form, the attribute specification contains 
a third part, which is a signed LEB128\addtoindexx{LEB128!signed} 
number. The value of this number is used as the value of the 
attribute, and no value is stored in the \dotdebuginfo{} section.

The abbreviations for a given compilation unit end with an
entry consisting of a 0 byte for the abbreviation code.

\textit{See 
Appendix \refersec{app:compilationunitsandabbreviationstableexample} 
for a depiction of the organization of the
debugging information.}

\needlines{12}
\subsection{Attribute Encodings}
\label{datarep:attributeencodings}

The encodings for the attribute names are given in 
Table \referfol{tab:attributeencodings}.

\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c|l}
  \caption{Attribute encodings} 
  \label{tab:attributeencodings} 
  \addtoindexx{attribute encodings} \\
  \hline \bfseries Attribute name&\bfseries Value &\bfseries Classes \\ \hline
\endfirsthead
  \bfseries Attribute name&\bfseries Value &\bfseries Classes\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline \ddag\ \textit{New in DWARF Version 5}
\endlastfoot
\DWATsibling&0x01&\livelink{chap:classreference}{reference} 
            \addtoindexx{sibling attribute} \\
\DWATlocation&0x02&\livelink{chap:classexprloc}{exprloc}, 
        \livelink{chap:classloclistptr}{loclistptr}
            \addtoindexx{location attribute}   \\
\DWATname&0x03&\livelink{chap:classstring}{string} 
            \addtoindexx{name attribute} \\
\DWATordering&0x09&\livelink{chap:classconstant}{constant} 
            \addtoindexx{ordering attribute}  \\
\DWATbytesize&0x0b&\livelink{chap:classconstant}{constant}, 
        \livelink{chap:classexprloc}{exprloc}, 
        \livelink{chap:classreference}{reference}
            \addtoindexx{byte size attribute} \\
\textit{Reserved}&0x0c\footnote{Code 0x0c is reserved to allow backward compatible support of the 
             DW\_AT\_bit\_offset \mbox{attribute} which was 
             defined in \DWARFVersionIII{} and earlier.}
       &\livelink{chap:classconstant}{constant}, 
        \livelink{chap:classexprloc}{exprloc}, 
        \livelink{chap:classreference}{reference}
            \addtoindexx{bit offset attribute (Version 3)}
            \addtoindexx{DW\_AT\_bit\_offset (deprecated)}  \\
\DWATbitsize&0x0d&\livelink{chap:classconstant}{constant}, 
        \livelink{chap:classexprloc}{exprloc}, 
        \livelink{chap:classreference}{reference}   
            \addtoindexx{bit size attribute} \\
\DWATstmtlist&0x10&\livelink{chap:classlineptr}{lineptr} 
            \addtoindexx{statement list attribute} \\
\DWATlowpc&0x11&\livelink{chap:classaddress}{address} 
            \addtoindexx{low PC attribute}  \\
\DWAThighpc&0x12&\livelink{chap:classaddress}{address}, 
        \livelink{chap:classconstant}{constant}
            \addtoindexx{high PC attribute}  \\
\DWATlanguage&0x13&\livelink{chap:classconstant}{constant} 
            \addtoindexx{language attribute}  \\
\DWATdiscr&0x15&\livelink{chap:classreference}{reference} 
            \addtoindexx{discriminant attribute}  \\
\DWATdiscrvalue&0x16&\livelink{chap:classconstant}{constant} 
            \addtoindexx{discriminant value attribute}  \\
\DWATvisibility&0x17&\livelink{chap:classconstant}{constant} 
            \addtoindexx{visibility attribute} \\
\DWATimport&0x18&\livelink{chap:classreference}{reference} 
            \addtoindexx{import attribute}  \\
\DWATstringlength&0x19&\livelink{chap:classexprloc}{exprloc}, 
        \livelink{chap:classloclistptr}{loclistptr}
            \addtoindexx{string length attribute}  \\
\DWATcommonreference&0x1a&\livelink{chap:classreference}{reference} 
            \addtoindexx{common reference attribute}  \\
\DWATcompdir&0x1b&\livelink{chap:classstring}{string} 
            \addtoindexx{compilation directory attribute}  \\
\DWATconstvalue&0x1c&\livelink{chap:classblock}{block}, 
        \livelink{chap:classconstant}{constant}, 
        \livelink{chap:classstring}{string}
            \addtoindexx{constant value attribute} \\
\DWATcontainingtype&0x1d&\livelink{chap:classreference}{reference} 
            \addtoindexx{containing type attribute} \\
\DWATdefaultvalue&0x1e&\livelink{chap:classconstant}{constant}, 
        \livelink{chap:classreference}{reference}, 
        \livelink{chap:classflag}{flag}
            \addtoindexx{default value attribute} \\
\DWATinline&0x20&\livelink{chap:classconstant}{constant} 
            \addtoindexx{inline attribute}  \\
\DWATisoptional&0x21&\livelink{chap:classflag}{flag} 
            \addtoindexx{is optional attribute} \\
\DWATlowerbound&0x22&\livelink{chap:classconstant}{constant}, 
        \livelink{chap:classexprloc}{exprloc}, 
        \livelink{chap:classreference}{reference}
            \addtoindexx{lower bound attribute}  \\
\DWATproducer&0x25&\livelink{chap:classstring}{string}
            \addtoindexx{producer attribute}  \\
\DWATprototyped&0x27&\livelink{chap:classflag}{flag}
            \addtoindexx{prototyped attribute}  \\
\DWATreturnaddr&0x2a&\livelink{chap:classexprloc}{exprloc},
        \livelink{chap:classloclistptr}{loclistptr}
            \addtoindexx{return address attribute}  \\
\DWATstartscope&0x2c&\livelink{chap:classconstant}{constant}, 
        \livelink{chap:classrangelistptr}{rangelistptr}
            \addtoindexx{start scope attribute}  \\
\DWATbitstride&0x2e&\livelink{chap:classconstant}{constant},
        \livelink{chap:classexprloc}{exprloc}, 
        \livelink{chap:classreference}{reference}
            \addtoindexx{bit stride attribute}  \\
\DWATupperbound&0x2f&\livelink{chap:classconstant}{constant},
        \livelink{chap:classexprloc}{exprloc}, 
        \livelink{chap:classreference}{reference}
            \addtoindexx{upper bound attribute}  \\
\DWATabstractorigin&0x31&\livelink{chap:classreference}{reference} 
            \addtoindexx{abstract origin attribute}  \\
\DWATaccessibility&0x32&\livelink{chap:classconstant}{constant} 
            \addtoindexx{accessibility attribute}  \\
\DWATaddressclass&0x33&\livelink{chap:classconstant}{constant} 
            \addtoindexx{address class attribute}  \\
\DWATartificial&0x34&\livelink{chap:classflag}{flag} 
            \addtoindexx{artificial attribute}  \\
\DWATbasetypes&0x35&\livelink{chap:classreference}{reference} 
            \addtoindexx{base types attribute}  \\
\DWATcallingconvention&0x36&\livelink{chap:classconstant}{constant} 
        \addtoindexx{calling convention attribute} \\
\DWATcount&0x37&\livelink{chap:classconstant}{constant}, 
        \livelink{chap:classexprloc}{exprloc}, 
        \livelink{chap:classreference}{reference} 
            \addtoindexx{count attribute}  \\
\DWATdatamemberlocation&0x38&\livelink{chap:classconstant}{constant}, 
        \livelink{chap:classexprloc}{exprloc}, 
        \livelink{chap:classloclistptr}{loclistptr} 
            \addtoindexx{data member attribute}  \\
\DWATdeclcolumn&0x39&\livelink{chap:classconstant}{constant} 
            \addtoindexx{declaration column attribute}  \\
\DWATdeclfile&0x3a&\livelink{chap:classconstant}{constant} 
            \addtoindexx{declaration file attribute}  \\
\DWATdeclline&0x3b&\livelink{chap:classconstant}{constant} 
            \addtoindexx{declaration line attribute}  \\
\DWATdeclaration&0x3c&\livelink{chap:classflag}{flag} 
            \addtoindexx{declaration attribute}  \\
\DWATdiscrlist&0x3d&\livelink{chap:classblock}{block} 
            \addtoindexx{discriminant list attribute}  \\
\DWATencoding&0x3e&\livelink{chap:classconstant}{constant} 
            \addtoindexx{encoding attribute}  \\
\DWATexternal&\xiiif&\livelink{chap:classflag}{flag} 
            \addtoindexx{external attribute}  \\
\DWATframebase&0x40&\livelink{chap:classexprloc}{exprloc}, 
        \livelink{chap:classloclistptr}{loclistptr} 
            \addtoindexx{frame base attribute}  \\
\DWATfriend&0x41&\livelink{chap:classreference}{reference} 
            \addtoindexx{friend attribute}  \\
\DWATidentifiercase&0x42&\livelink{chap:classconstant}{constant} 
            \addtoindexx{identifier case attribute}  \\
\textit{Reserved}&0x43\footnote{Code 0x43 is reserved to allow backward compatible support of the 
             DW\_AT\_macro\_info \mbox{attribute} which was 
             defined in \DWARFVersionIV{} and earlier.}
            &\livelink{chap:classmacptr}{macptr} 
            \addtoindexx{macro information attribute (legacy)!encoding}  \\
\DWATnamelistitem&0x44&\livelink{chap:classreference}{reference} 
            \addtoindexx{name list item attribute}  \\
\DWATpriority&0x45&\livelink{chap:classreference}{reference} 
            \addtoindexx{priority attribute}  \\
\DWATsegment&0x46&\livelink{chap:classexprloc}{exprloc}, 
        \livelink{chap:classloclistptr}{loclistptr} 
            \addtoindexx{segment attribute}  \\
\DWATspecification&0x47&\livelink{chap:classreference}{reference} 
        \addtoindexx{specification attribute}  \\
\DWATstaticlink&0x48&\livelink{chap:classexprloc}{exprloc}, 
        \livelink{chap:classloclistptr}{loclistptr} 
            \addtoindexx{static link attribute}  \\
\DWATtype&0x49&\livelink{chap:classreference}{reference} 
            \addtoindexx{type attribute}  \\
\DWATuselocation&0x4a&\livelink{chap:classexprloc}{exprloc}, 
        \livelink{chap:classloclistptr}{loclistptr} 
            \addtoindexx{location list attribute}  \\
\DWATvariableparameter&0x4b&\livelink{chap:classflag}{flag} 
            \addtoindexx{variable parameter attribute}  \\
\DWATvirtuality&0x4c&\livelink{chap:classconstant}{constant} 
            \addtoindexx{virtuality attribute}  \\
\DWATvtableelemlocation&0x4d&\livelink{chap:classexprloc}{exprloc}, 
        \livelink{chap:classloclistptr}{loclistptr} 
            \addtoindexx{vtable element location attribute}  \\
\DWATallocated&0x4e&\livelink{chap:classconstant}{constant}, 
        \livelink{chap:classexprloc}{exprloc}, 
        \livelink{chap:classreference}{reference} 
            \addtoindexx{allocated attribute}  \\
\DWATassociated&0x4f&\livelink{chap:classconstant}{constant}, 
        \livelink{chap:classexprloc}{exprloc}, 
        \livelink{chap:classreference}{reference} 
            \addtoindexx{associated attribute}  \\
\DWATdatalocation&0x50&\livelink{chap:classexprloc}{exprloc} 
        \addtoindexx{data location attribute}  \\
\DWATbytestride&0x51&\livelink{chap:classconstant}{constant}, 
        \livelink{chap:classexprloc}{exprloc}, 
        \livelink{chap:classreference}{reference} 
            \addtoindexx{byte stride attribute}  \\
\DWATentrypc&0x52&\livelink{chap:classaddress}{address}, 
        \livelink{chap:classconstant}{constant} 
            \addtoindexx{entry PC attribute}  \\
\DWATuseUTFeight&0x53&\livelink{chap:classflag}{flag} 
            \addtoindexx{use UTF8 attribute}\addtoindexx{UTF-8}  \\
\DWATextension&0x54&\livelink{chap:classreference}{reference} 
            \addtoindexx{extension attribute}  \\
\DWATranges&0x55&\livelink{chap:classrangelistptr}{rangelistptr} 
            \addtoindexx{ranges attribute}  \\
\DWATtrampoline&0x56&\livelink{chap:classaddress}{address}, 
        \livelink{chap:classflag}{flag}, 
        \livelink{chap:classreference}{reference}, 
        \livelink{chap:classstring}{string} 
            \addtoindexx{trampoline attribute}  \\
\DWATcallcolumn&0x57&\livelink{chap:classconstant}{constant} 
            \addtoindexx{call column attribute}  \\
\DWATcallfile&0x58&\livelink{chap:classconstant}{constant} 
            \addtoindexx{call file attribute}  \\
\DWATcallline&0x59&\livelink{chap:classconstant}{constant} 
            \addtoindexx{call line attribute}  \\
\DWATdescription&0x5a&\livelink{chap:classstring}{string} 
            \addtoindexx{description attribute}  \\
\DWATbinaryscale&0x5b&\livelink{chap:classconstant}{constant} 
            \addtoindexx{binary scale attribute}  \\
\DWATdecimalscale&0x5c&\livelink{chap:classconstant}{constant} 
            \addtoindexx{decimal scale attribute}  \\
\DWATsmall{} &0x5d&\livelink{chap:classreference}{reference} 
            \addtoindexx{small attribute}  \\
\DWATdecimalsign&0x5e&\livelink{chap:classconstant}{constant} 
            \addtoindexx{decimal scale attribute}  \\
\DWATdigitcount&0x5f&\livelink{chap:classconstant}{constant} 
            \addtoindexx{digit count attribute}  \\
\DWATpicturestring&0x60&\livelink{chap:classstring}{string} 
            \addtoindexx{picture string attribute}  \\
\DWATmutable&0x61&\livelink{chap:classflag}{flag} 
            \addtoindexx{mutable attribute}  \\
\DWATthreadsscaled&0x62&\livelink{chap:classflag}{flag} 
            \addtoindexx{thread scaled attribute}  \\
\DWATexplicit&0x63&\livelink{chap:classflag}{flag} 
            \addtoindexx{explicit attribute}  \\
\DWATobjectpointer&0x64&\livelink{chap:classreference}{reference} 
            \addtoindexx{object pointer attribute}  \\
\DWATendianity&0x65&\livelink{chap:classconstant}{constant} 
            \addtoindexx{endianity attribute}  \\
\DWATelemental&0x66&\livelink{chap:classflag}{flag} 
            \addtoindexx{elemental attribute}  \\
\DWATpure&0x67&\livelink{chap:classflag}{flag} 
            \addtoindexx{pure attribute}  \\
\DWATrecursive&0x68&\livelink{chap:classflag}{flag} 
            \addtoindexx{recursive attribute}  \\
\DWATsignature{} &0x69&\livelink{chap:classreference}{reference} 
            \addtoindexx{signature attribute}  \\ 
\DWATmainsubprogram{} &0x6a&\livelink{chap:classflag}{flag} 
            \addtoindexx{main subprogram attribute}  \\
\DWATdatabitoffset{} &0x6b&\livelink{chap:classconstant}{constant} 
            \addtoindexx{data bit offset attribute}  \\
\DWATconstexpr{} &0x6c&\livelink{chap:classflag}{flag} 
            \addtoindexx{constant expression attribute}  \\
\DWATenumclass{} &0x6d&\livelink{chap:classflag}{flag} 
            \addtoindexx{enumeration class attribute}  \\
\DWATlinkagename{} &0x6e&\livelink{chap:classstring}{string} 
            \addtoindexx{linkage name attribute}  \\
\DWATstringlengthbitsize{}~\ddag&0x6f&
		\livelink{chap:classconstant}{constant}
            \addtoindexx{string length attribute!size of length}  \\
\DWATstringlengthbytesize{}~\ddag&0x70&
		\livelink{chap:classconstant}{constant}
            \addtoindexx{string length attribute!size of length}  \\
\DWATrank~\ddag&0x71&
        \livelink{chap:classconstant}{constant},
        \livelink{chap:classexprloc}{exprloc}
            \addtoindexx{rank attribute}  \\
\DWATstroffsetsbase~\ddag&0x72&
		\livelinki{chap:classstroffsetsptr}{stroffsetsptr}{stroffsetsptr class}
            \addtoindexx{string offsets base!encoding}	\\
\DWATaddrbase~\ddag &0x73&
		\livelinki{chap:classaddrptr}{addrptr}{addrptr class}
            \addtoindexx{address table base!encoding} \\
\DWATrangesbase~\ddag&0x74&
		\livelinki{chap:classrangelistptr}{rangelistptr}{rangelistptr class}
            \addtoindexx{ranges base!encoding} \\
\DWATdwoid~\ddag &0x75&
		\livelink{chap:classconstant}{constant}
            \addtoindexx{split DWARF object file id!encoding} \\
\DWATdwoname~\ddag &0x76&
		\livelink{chap:classstring}{string}
            \addtoindexx{split DWARF object file name!encoding} \\
\DWATreference~\ddag &0x77&
        \livelink{chap:classflag}{flag} \\
\DWATrvaluereference~\ddag &0x78&
        \livelink{chap:classflag}{flag} \\
\DWATmacros~\ddag &0x79&\livelink{chap:classmacptr}{macptr} 
        \addtoindexx{macro information attribute}  \\
\DWATcallallcalls~\ddag &0x7a&\CLASSflag
        \addtoindexx{all calls summary attribute} \\
\DWATcallallsourcecalls~\ddag &0x7b &\CLASSflag
        \addtoindexx{all source calls summary attribute} \\
\DWATcallalltailcalls~\ddag &0x7c&\CLASSflag
        \addtoindexx{all tail calls summary attribute} \\
\DWATcallreturnpc~\ddag &0x7d &\CLASSaddress
        \addtoindexx{call return PC attribute} \\
\DWATcallvalue~\ddag &0x7e &\CLASSexprloc
        \addtoindexx{call value attribute} \\
\DWATcallorigin~\ddag &0x7f &\CLASSexprloc
        \addtoindexx{call origin attribute} \\
\DWATcallparameter~\ddag &0x80 &\CLASSreference
        \addtoindexx{call parameter attribute} \\
\DWATcallpc~\ddag &0x81 &\CLASSaddress
        \addtoindexx{call PC attribute} \\
\DWATcalltailcall~\ddag &0x82 &\CLASSflag
        \addtoindexx{call tail call attribute} \\
\DWATcalltarget~\ddag &0x83 &\CLASSexprloc
        \addtoindexx{call target attribute} \\
\DWATcalltargetclobbered~\ddag &0x84 &\CLASSexprloc
        \addtoindexx{call target clobbered attribute} \\
\DWATcalldatalocation~\ddag &0x85 &\CLASSexprloc
        \addtoindexx{call data location attribute} \\
\DWATcalldatavalue~\ddag &0x86 &\CLASSexprloc
        \addtoindexx{call data value attribute} \\
\DWATnoreturn~\ddag &0x87 &\CLASSflag 
        \addtoindexx{noreturn attribute} \\
\DWATalignment~\ddag &0x88 &\CLASSconstant 
        \addtoindexx{alignment attribute} \\
\DWATexportsymbols~\ddag &0x89 &\CLASSflag
        \addtoindexx{export symbols attribute} \\
\DWATdeleted~\ddag &0x8a &\CLASSflag \addtoindexx{deleted attribute} \\
\DWATdefaulted~\ddag &0x8b &\CLASSconstant \addtoindexx{defaulted attribute} \\
\DWATlouser&0x2000 & --- \addtoindexx{low user attribute encoding}  \\
\DWAThiuser&\xiiifff& --- \addtoindexx{high user attribute encoding}  \\

\end{longtable} 
\end{centering}

The attribute form governs how the value of the attribute is
encoded. There are nine classes of form, listed below. Each
class is a set of forms which have related representations
and which are given a common interpretation according to the
attribute in which the form is used.

Form \DWFORMsecoffsetTARG{} 
is a member of more 
\addtoindexx{rangelistptr class}
than 
\addtoindexx{macptr class}
one 
\addtoindexx{loclistptr class}
class,
\addtoindexx{lineptr class}
namely 
\CLASSaddrptr, 
\CLASSlineptr, 
\CLASSloclistptr, 
\CLASSmacptr,  
\CLASSrangelistptr{} or
\CLASSstroffsetsptr; 
the list of classes allowed by the applicable attribute in 
Table \refersec{tab:attributeencodings}
determines the class of the form.

\needlines{4}
In the form descriptions that follow, some forms are said
to depend in part on the value of an attribute of the
\definition{\associatedcompilationunit}:
\begin{itemize}
\item
In the case of a \splitDWARFobjectfile{}, the associated
compilation unit is the skeleton compilation unit corresponding 
to the containing unit.
\item Otherwise, the associated compilation unit 
is the containing unit.
\end{itemize}

\needlines{4}
Each possible form belongs to one or more of the following classes
(see Table \refersec{tab:classesofattributevalue} for a summary of
the purpose and general usage of each class):

\begin{itemize}
\item \livelinki{chap:classaddress}{address}{address class} \\
\livetarg{datarep:classaddress}{}
Represented as either:
\begin{itemize}
\item An object of appropriate size to hold an
address on the target machine 
(\DWFORMaddrTARG). 
The size is encoded in the compilation unit header 
(see Section \refersec{datarep:compilationunitheader}).
This address is relocatable in a relocatable object file and
is relocated in an executable file or shared object file.

\item An indirect index into a table of addresses (as 
described in the previous bullet) in the
\dotdebugaddr{} section (\DWFORMaddrxTARG). 
The representation of a \DWFORMaddrxNAME{} value is an unsigned
\addtoindex{LEB128} value, which is interpreted as a zero-based 
index into an array of addresses in the \dotdebugaddr{} section.
The index is relative to the value of the \DWATaddrbase{} attribute 
of the associated compilation unit.

\end{itemize}

\needlines{5}
\item \livelink{chap:classaddrptr}{addrptr} \\
\livetarg{datarep:classaddrptr}{}
This is an offset into the \dotdebugaddr{} section (\DWFORMsecoffset). It
consists of an offset from the beginning of the \dotdebugaddr{} section to the
beginning of the list of machine addresses information for the
referencing entity. It is relocatable in
a relocatable object file, and relocated in an executable or
shared object file. In the \thirtytwobitdwarfformat, this offset
is a 4-byte unsigned value; in the 64-bit DWARF
format, it is an 8-byte unsigned value (see Section
\refersec{datarep:32bitand64bitdwarfformats}).

\textit{This class is new in \DWARFVersionV.}

\needlines{4}
\item \livelink{chap:classblock}{block} \\
\livetarg{datarep:classblock}{}
Blocks come in four forms:
\begin{itemize}
\item
A 1-byte length followed by 0 to 255 contiguous information
bytes (\DWFORMblockoneTARG).

\item
A 2-byte length followed by 0 to 65,535 contiguous information
bytes (\DWFORMblocktwoTARG).

\item
A 4-byte length followed by 0 to 4,294,967,295 contiguous
information bytes (\DWFORMblockfourTARG).

\item
An unsigned LEB128\addtoindexx{LEB128!unsigned}
length followed by the number of bytes
specified by the length (\DWFORMblockTARG).
\end{itemize}

In all forms, the length is the number of information bytes
that follow. The information bytes may contain any mixture
of relocated (or relocatable) addresses, references to other
debugging information entries or data bytes.

\item \livelinki{chap:classconstant}{constant}{constant class} \\
\livetarg{datarep:classconstant}{}
There are eight forms of constants. There are fixed length
constant data forms for one-, two-, four-, eight- and sixteen-byte values
(respectively, 
\DWFORMdataoneTARG, 
\DWFORMdatatwoTARG, 
\DWFORMdatafourTARG,
\DWFORMdataeightTARG{} and
\DWFORMdatasixteenTARG). 
There are variable length constant
data forms encoded using 
signed LEB128 numbers (\DWFORMsdataTARG) and unsigned 
LEB128 numbers (\DWFORMudataTARG).
There is also an implicit constant (\DWFORMimplicitconst),
whose value is provided as part of the abbreviation
declaration.

\needlines{4}
The data in \DWFORMdataone, 
\DWFORMdatatwo, 
\DWFORMdatafour{}, 
\DWFORMdataeight{} and
\DWFORMdatasixteen{} 
can be anything. Depending on context, it may
be a signed integer, an unsigned integer, a floating\dash point
constant, or anything else. A consumer must use context to
know how to interpret the bits, which if they are target
machine data (such as an integer or floating-point constant)
will be in target machine \byteorder.

\textit{If one of the \DWFORMdataTARG\textless n\textgreater 
forms is used to represent a
signed or unsigned integer, it can be hard for a consumer
to discover the context necessary to determine which
interpretation is intended. Producers are therefore strongly
encouraged to use \DWFORMsdata{} or 
\DWFORMudata{} for signed and
unsigned integers respectively, rather than 
\DWFORMdata\textless n\textgreater.}

\needlines{4}
\item \livelinki{chap:classexprloc}{exprloc}{exprloc class} \\
\livetarg{datarep:classexprloc}{}
This is an unsigned LEB128\addtoindexx{LEB128!unsigned} length followed by the
number of information bytes specified by the length
(\DWFORMexprlocTARG). 
The information bytes contain a DWARF expression 
(see Section \refersec{chap:dwarfexpressions}) 
or location description 
(see Section \refersec{chap:locationdescriptions}).

\needlines{4}
\item \livelinki{chap:classflag}{flag}{flag class} \\
\livetarg{datarep:classflag}{}
A flag \addtoindexx{flag class}
is represented explicitly as a single byte of data
(\DWFORMflagTARG) or 
implicitly (\DWFORMflagpresentTARG). 
In the
first case, if the \nolink{flag} has value zero, it indicates the
absence of the attribute; if the \nolink{flag} has a non-zero value,
it indicates the presence of the attribute. In the second
case, the attribute is implicitly indicated as present, and
no value is encoded in the debugging information entry itself.

\needlines{4}
\item \livelinki{chap:classlineptr}{lineptr}{lineptr class} \\
\livetarg{datarep:classlineptr}{}
This is an offset into 
\addtoindexx{section offset!in class lineptr value}
the 
\dotdebugline{} or \dotdebuglinedwo{} section
(\DWFORMsecoffset).
It consists of an offset from the beginning of the 
\dotdebugline{}
section to the first byte of
the data making up the line number list for the compilation
unit. 
It is relocatable in a relocatable object file, and
relocated in an executable or shared object file. In the 
\thirtytwobitdwarfformat, this offset is a 4-byte unsigned value;
in the \sixtyfourbitdwarfformat, it is an 8-byte unsigned value
(see Section \refersec{datarep:32bitand64bitdwarfformats}).


\item \livelinki{chap:classloclistptr}{loclistptr}{loclistptr class} \\
\livetarg{datarep:classloclistptr}{}
This is an offset into the 
\dotdebugloc{}
section
(\DWFORMsecoffset). 
It consists of an offset from the
\addtoindexx{section offset!in class loclistptr value}
beginning of the 
\dotdebugloc{}
section to the first byte of
the data making up the 
\addtoindex{location list} for the compilation unit. 
It is relocatable in a relocatable object file, and
relocated in an executable or shared object file. In the 
\thirtytwobitdwarfformat, this offset is a 4-byte unsigned value;
in the \sixtyfourbitdwarfformat, it is an 8-byte unsigned value
(see Section \refersec{datarep:32bitand64bitdwarfformats}).


\item \livelinki{chap:classmacptr}{macptr}{macptr class} \\
\livetarg{datarep:classmacptr}{}
This is an 
\addtoindexx{section offset!in class macptr value}
offset into the 
\dotdebugmacro{} or \dotdebugmacrodwo{} section
(\DWFORMsecoffset). 
It consists of an offset from the beginning of the 
\dotdebugmacro{} or \dotdebugmacrodwo{} 
section to the the header making up the 
macro information list for the compilation unit. 
It is relocatable in a relocatable object file, and
relocated in an executable or shared object file. In the 
\thirtytwobitdwarfformat, this offset is a 4-byte unsigned value;
in the \sixtyfourbitdwarfformat, it is an 8-byte unsigned value
(see Section \refersec{datarep:32bitand64bitdwarfformats}).

\needlines{4}
\item \livelinki{chap:classrangelistptr}{rangelistptr}{rangelistptr class} \\
\livetarg{datarep:classrangelistptr}{}
This is an 
\addtoindexx{section offset!in class rangelistptr value}
offset into the \dotdebugranges{} section
(\DWFORMsecoffset). 
It consists of an
offset from the beginning of the 
\dotdebugranges{} section
to the beginning of the non-contiguous address ranges
information for the referencing entity.  
It is relocatable in
a relocatable object file, and relocated in an executable or
shared object file. 
However, if a \DWATrangesbase{} attribute applies, the offset
is relative to the base offset given by \DWATrangesbase.
In the \thirtytwobitdwarfformat, this offset
is a 4-byte unsigned value; in the 64-bit DWARF
format, it is an 8-byte unsigned value (see Section
\refersec{datarep:32bitand64bitdwarfformats}).
\end{itemize}

\textit{Because classes
\CLASSaddrptr, 
\CLASSlineptr, 
\CLASSloclistptr, 
\CLASSmacptr, 
\CLASSrangelistptr{} and
\CLASSstroffsetsptr{}
share a common representation, it is not possible for an
attribute to allow more than one of these classes}

\needlines{4}
\begin{itemize}
\item \livelinki{chap:classreference}{reference}{reference class} \\
\livetarg{datarep:classreference}{}
There are four types of reference.

The 
\addtoindexx{reference class}
first type of reference can identify any debugging
information entry within the containing unit. 
This type of
reference is an 
\addtoindexx{section offset!in class reference value}
offset from the first byte of the compilation
header for the compilation unit containing the reference. There
are five forms for this type of reference. There are fixed
length forms for one, two, four and eight byte offsets
(respectively,
\DWFORMrefnMARK 
\DWFORMrefoneTARG, 
\DWFORMreftwoTARG, 
\DWFORMreffourTARG,
and \DWFORMrefeightTARG). 
There is also an unsigned variable
length offset encoded form that uses 
unsigned LEB128\addtoindexx{LEB128!unsigned} numbers
(\DWFORMrefudataTARG). 
Because this type of reference is within
the containing compilation unit no relocation of the value
is required.

The second type of reference can identify any debugging
information entry within a 
\dotdebuginfo{} section; in particular,
it may refer to an entry in a different compilation unit
from the unit containing the reference, and may refer to an
entry in a different shared object file.  This type of reference
(\DWFORMrefaddrTARG) 
is an offset from the beginning of the
\dotdebuginfo{} 
section of the target executable or shared object file, or, for
references within a \addtoindex{supplementary object file}, 
an offset from the beginning of the local \dotdebuginfo{} section;
it is relocatable in a relocatable object file and frequently
relocated in an executable or shared object file. For
references from one shared object or static executable file
to another, the relocation and identification of the target
object must be performed by the consumer. In the 
\thirtytwobitdwarfformat, this offset is a 4-byte unsigned value; 
in the \sixtyfourbitdwarfformat, it is an 8-byte
unsigned value 
(see Section \refersec{datarep:32bitand64bitdwarfformats}).

\textit{A debugging information entry that may be referenced by
another compilation unit using 
\DWFORMrefaddr{} must have a global symbolic name.}

\textit{For a reference from one executable or shared object file to
another, the reference is resolved by the debugger to identify
the executable or shared object file and the offset into that
file\textquoteright s \dotdebuginfo{}
section in the same fashion as the run
time loader, either when the debug information is first read,
or when the reference is used.}

The third type of reference can identify any debugging
information type entry that has been placed in its own
\addtoindex{type unit}. This type of 
reference (\DWFORMrefsigeightTARG) is the
\addtoindexx{type signature}
8-byte type signature 
(see Section \refersec{datarep:typesignaturecomputation}) 
that was computed for the type. 

The fourth type of reference is a reference from within the 
\dotdebuginfo{} section of the executable or shared object file to
a debugging information entry in the \dotdebuginfo{} section of 
a \addtoindex{supplementary object file}.
This type of reference (\DWFORMrefsupTARG) is an offset from the 
beginning of the \dotdebuginfo{} section in the 
\addtoindex{supplementary object file}.

\textit{The use of compilation unit relative references will reduce the
number of link\dash time relocations and so speed up linking. The
use of the second, third and fourth type of reference allows for the
sharing of information, such as types, across compilation
units, while the fourth type further allows for sharing of information 
across compilation units from different executables or shared object files.}

\textit{A reference to any kind of compilation unit identifies the
debugging information entry for that unit, not the preceding
header.}

\needlines{4}
\item \livelinki{chap:classstring}{string}{string class} \\
\livetarg{datarep:classstring}{}
A string is a sequence of contiguous non\dash null bytes followed by
one null byte. 
\addtoindexx{string class}
A string may be represented: 
\begin{itemize}
\setlength{\itemsep}{0em}
\item immediately in the debugging information entry itself 
(\DWFORMstringTARG), 

\item as an 
\addtoindexx{section offset!in class string value}
offset into a string table contained in
the \dotdebugstr{} section of the object file (\DWFORMstrpTARG), 
the \dotdebuglinestr{} section of the object file (\DWFORMlinestrpTARG),
or as an offset into a string table contained in the
\dotdebugstr{} section of a \addtoindex{supplementary object file} 
(\DWFORMstrpsupTARG).  \DWFORMstrpsupNAME{} offsets from the \dotdebuginfo{}  
section of a \addtoindex{supplementary object file}
refer to the local \dotdebugstr{} section of that same file.
In the \thirtytwobitdwarfformat, the representation of a 
\DWFORMstrpNAME{}, \DWFORMstrpNAME{} or \DWFORMstrpsupNAME{}
value is a 4-byte unsigned offset; in the \sixtyfourbitdwarfformat,
it is an 8-byte unsigned offset 
(see Section \refersec{datarep:32bitand64bitdwarfformats}).

\needlines{6}
\item as an indirect offset into the string table using an 
index into a table of offsets contained in the 
\dotdebugstroffsets{} section of the object file (\DWFORMstrxTARG).
The representation of a \DWFORMstrxNAME{} value is an unsigned 
\addtoindex{LEB128} value, which is interpreted as a zero-based 
index into an array of offsets in the \dotdebugstroffsets{} section. 
The offset entries in the \dotdebugstroffsets{} section have the 
same representation as \DWFORMstrp{} values.
\end{itemize}
Any combination of these three forms may be used within a single compilation.

If the \DWATuseUTFeight{}
\addtoindexx{use UTF8 attribute}\addtoindexx{UTF-8} attribute is specified for the
compilation, partial, skeleton or type unit entry, string values are encoded using the
UTF\dash 8 (\addtoindex{Unicode} Transformation Format\dash 8) from the Universal
Character Set standard (ISO/IEC 10646\dash 1:1993).
\addtoindexx{ISO 10646 character set standard}
Otherwise, the string representation is unspecified.

\textit{The \addtoindex{Unicode} Standard Version 3 is fully compatible with
ISO/IEC 10646\dash 1:1993. 
\addtoindexx{ISO 10646 character set standard}
It contains all the same characters
and encoding points as ISO/IEC 10646, as well as additional
information about the characters and their use.}

\textit{Earlier versions of DWARF did not specify the representation
of strings; for compatibility, this version also does
not. However, the UTF\dash 8 representation is strongly recommended.}

\needlines{4}
\item \livelinki{chap:classstroffsetsptr}{stroffsetsptr}{stroffsetsptr class} \\
\livetarg{datarep:classstroffsetsptr}{}
This is an offset into the \dotdebugstroffsets{} section 
(\DWFORMsecoffset). It consists of an offset from the beginning of the 
\dotdebugstroffsets{} section to the
beginning of the string offsets information for the
referencing entity. It is relocatable in
a relocatable object file, and relocated in an executable or
shared object file. In the \thirtytwobitdwarfformat, this offset
is a 4-byte unsigned value; in the \sixtyfourbitdwarfformat,
it is an 8-byte unsigned value (see Section
\refersec{datarep:32bitand64bitdwarfformats}).

\textit{This class is new in \DWARFVersionV.}

\end{itemize}

In no case does an attribute use one of the classes 
\CLASSaddrptr,
\CLASSlineptr,
\CLASSloclistptr, 
\CLASSmacptr, 
\CLASSrangelistptr{} or 
\CLASSstroffsetsptr{}
to point into either the
\dotdebuginfo{} or \dotdebugstr{} section.

The form encodings are listed in 
Table \referfol{tab:attributeformencodings}.

\needlines{8}
\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c|l}
  \caption{Attribute form encodings} \label{tab:attributeformencodings} \\
  \hline \bfseries Form name&\bfseries Value &\bfseries Classes \\ \hline
\endfirsthead
  \bfseries Form name&\bfseries Value &\bfseries Classes\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline \ddag\ \textit{New in DWARF Version 5}
\endlastfoot

\DWFORMaddr &0x01&\livelink{chap:classaddress}{address}  \\
\textit{Reserved} &0x02& \\
\DWFORMblocktwo &0x03&\livelink{chap:classblock}{block} \\
\DWFORMblockfour &0x04&\livelink{chap:classblock}{block}  \\
\DWFORMdatatwo &0x05&\livelink{chap:classconstant}{constant} \\
\DWFORMdatafour &0x06&\livelink{chap:classconstant}{constant} \\
\DWFORMdataeight &0x07&\livelink{chap:classconstant}{constant} \\
\DWFORMstring&0x08&\livelink{chap:classstring}{string} \\
\DWFORMblock&0x09&\livelink{chap:classblock}{block} \\
\DWFORMblockone &0x0a&\livelink{chap:classblock}{block} \\
\DWFORMdataone &0x0b&\livelink{chap:classconstant}{constant} \\
\DWFORMflag&0x0c&\livelink{chap:classflag}{flag} \\
\DWFORMsdata&0x0d&\livelink{chap:classconstant}{constant}    \\
\DWFORMstrp&0x0e&\livelink{chap:classstring}{string}         \\
\DWFORMudata&0x0f&\livelink{chap:classconstant}{constant}         \\
\DWFORMrefaddr&0x10&\livelink{chap:classreference}{reference}         \\
\DWFORMrefone&0x11&\livelink{chap:classreference}{reference}          \\
\DWFORMreftwo&0x12&\livelink{chap:classreference}{reference}         \\
\DWFORMreffour&0x13&\livelink{chap:classreference}{reference}         \\
\DWFORMrefeight&0x14&\livelink{chap:classreference}{reference} \\
\DWFORMrefudata&0x15&\livelink{chap:classreference}{reference}  \\
\DWFORMindirect&0x16&(see Section \refersec{datarep:abbreviationstables}) \\
\DWFORMsecoffset{} &0x17& \CLASSaddrptr, \CLASSlineptr, \CLASSloclistptr, \\
                   &    & \CLASSmacptr, \CLASSrangelistptr, \CLASSstroffsetsptr \\
\DWFORMexprloc{} &0x18&\livelink{chap:classexprloc}{exprloc} \\
\DWFORMflagpresent{} &0x19&\livelink{chap:classflag}{flag} \\
\DWFORMstrx{} \ddag &0x1a&\livelink{chap:classstring}{string} \\
\DWFORMaddrx{} \ddag &0x1b&\livelink{chap:classaddress}{address} \\
\DWFORMrefsup{}~\ddag &0x1c &\livelink{chap:classreference}{reference} \\
\DWFORMstrpsup{}~\ddag &0x1d &\livelink{chap:classstring}{string} \\
\DWFORMdatasixteen~\ddag &0x1e &\CLASSconstant \\
\DWFORMlinestrp~\ddag &0x1f &\CLASSstring \\
\DWFORMrefsigeight &0x20 &\livelink{chap:classreference}{reference} \\
\DWFORMimplicitconst~\ddag &0x21 &\CLASSconstant \\
\end{longtable}
\end{centering}


\needlines{6}
\section{Variable Length Data}
\label{datarep:variablelengthdata}
\addtoindexx{variable length data|see {LEB128}}
Integers may be 
\addtoindexx{Little-Endian Base 128|see{LEB128}}
encoded using \doublequote{Little-Endian Base 128}
\addtoindexx{little-endian encoding|see{endian attribute}}
(LEB128) numbers. 
\addtoindexx{LEB128}
LEB128 is a scheme for encoding integers
densely that exploits the assumption that most integers are
small in magnitude.

\textit{This encoding is equally suitable whether the target machine
architecture represents data in big-endian or little-endian
\byteorder. It is \doublequote{little-endian} only in the sense that it
avoids using space to represent the \doublequote{big} end of an
unsigned integer, when the big end is all zeroes or sign
extension bits.}

Unsigned LEB128\addtoindexx{LEB128!unsigned} (\addtoindex{ULEB128}) 
numbers are encoded as follows:
\addtoindexx{LEB128!unsigned, encoding as}
start at the low order end of an unsigned integer and chop
it into 7-bit chunks. Place each chunk into the low order 7
bits of a byte. Typically, several of the high order bytes
will be zero; discard them. Emit the remaining bytes in a
stream, starting with the low order byte; set the high order
bit on each byte except the last emitted byte. The high bit
of zero on the last byte indicates to the decoder that it
has encountered the last byte.

The integer zero is a special case, consisting of a single
zero byte.

Table \refersec{tab:examplesofunsignedleb128encodings}
gives some examples of unsigned LEB128\addtoindexx{LEB128!unsigned}
numbers. The
0x80 in each case is the high order bit of the byte, indicating
that an additional byte follows.


The encoding for signed, two\textquoteright{s} complement LEB128 
(\addtoindex{SLEB128}) \addtoindexx{LEB128!signed, encoding as}
numbers is similar, except that the criterion for discarding
high order bytes is not whether they are zero, but whether
they consist entirely of sign extension bits. Consider the
4-byte integer -2. The three high level bytes of the number
are sign extension, thus LEB128 would represent it as a single
byte containing the low order 7 bits, with the high order
bit cleared to indicate the end of the byte stream. Note
that there is nothing within the LEB128 representation that
indicates whether an encoded number is signed or unsigned. The
decoder must know what type of number to expect. 
Table \refersec{tab:examplesofunsignedleb128encodings}
gives some examples of unsigned LEB128\addtoindexx{LEB128!unsigned}
numbers and Table \refersec{tab:examplesofsignedleb128encodings}
gives some examples of signed LEB128\addtoindexx{LEB128!signed} 
numbers.

\textit{Appendix \refersec{app:variablelengthdataencodingdecodinginformative} 
\addtoindexx{LEB128!examples}
gives algorithms for encoding and decoding these forms.}

\needlines{8}
\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{c|c|c}
  \caption{Examples of unsigned LEB128 encodings}
  \label{tab:examplesofunsignedleb128encodings} 
  \addtoindexx{LEB128 encoding!examples}\addtoindexx{LEB128!unsigned} \\
  \hline \bfseries Number&\bfseries First byte &\bfseries Second byte \\ \hline
\endfirsthead
  \bfseries Number&\bfseries First Byte &\bfseries Second byte\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot
2&2& --- \\
127&127& ---\\
128& 0 + 0x80 & 1 \\
129& 1 + 0x80 & 1 \\
%130& 2 + 0x80 & 1 \\
12857& 57 + 0x80 & 100 \\
\end{longtable}
\end{centering}



\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{c|c|c}
  \caption{Examples of signed LEB128 encodings} 
  \label{tab:examplesofsignedleb128encodings} 
  \addtoindexx{LEB128!signed} \\
  \hline \bfseries Number&\bfseries First byte &\bfseries Second byte \\ \hline
\endfirsthead
  \bfseries Number&\bfseries First Byte &\bfseries Second byte\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot
2&2& --- \\
-2&0x7e& ---\\
127& 127 + 0x80 & 0 \\
-127& 1 + 0x80 & 0x7f \\
128& 0 + 0x80 & 1 \\
-128& 0 + 0x80 & 0x7f \\
129& 1 + 0x80 & 1 \\
-129& 0x7f + 0x80 & 0x7e \\

\end{longtable}
\end{centering}



\section{DWARF Expressions and Location Descriptions}
\label{datarep:dwarfexpressionsandlocationdescriptions}
\subsection{DWARF Expressions}
\label{datarep:dwarfexpressions}

A 
\addtoindexx{DWARF expression!operator encoding}
DWARF expression is stored in a \nolink{block} of contiguous
bytes. The bytes form a sequence of operations. Each operation
is a 1-byte code that identifies that operation, followed by
zero or more bytes of additional data. The encodings for the
operations are described in 
Table \refersec{tab:dwarfoperationencodings}. 

\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c|c|l}
  \caption{DWARF operation encodings} \label{tab:dwarfoperationencodings} \\
  \hline & &\bfseries No. of  &\\ 
  \bfseries Operation&\bfseries Code &\bfseries Operands &\bfseries Notes\\ \hline
\endfirsthead
   & &\bfseries No. of &\\ 
  \bfseries Operation&\bfseries Code &\bfseries  Operands &\bfseries Notes\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline \ddag\ \textit{New in DWARF Version 5}
\endlastfoot

\DWOPaddr&0x03&1 & constant address  \\ 
& & &(size is target specific) \\

\DWOPderef&0x06&0 & \\

\DWOPconstoneu&0x08&1&1-byte constant  \\
\DWOPconstones&0x09&1&1-byte constant   \\
\DWOPconsttwou&0x0a&1&2-byte constant   \\
\DWOPconsttwos&0x0b&1&2-byte constant   \\
\DWOPconstfouru&0x0c&1&4-byte constant    \\
\DWOPconstfours&0x0d&1&4-byte constant   \\
\DWOPconsteightu&0x0e&1&8-byte constant   \\
\DWOPconsteights&0x0f&1&8-byte constant   \\
\DWOPconstu&0x10&1&ULEB128 constant   \\
\DWOPconsts&0x11&1&SLEB128 constant   \\
\DWOPdup&0x12&0 &   \\
\DWOPdrop&0x13&0  &   \\
\DWOPover&0x14&0 &   \\
\DWOPpick&0x15&1&1-byte stack index   \\
\DWOPswap&0x16&0 &   \\
\DWOProt&0x17&0 &   \\
\DWOPxderef&0x18&0 &   \\
\DWOPabs&0x19&0 &   \\
\DWOPand&0x1a&0 &   \\
\DWOPdiv&0x1b&0 &   \\
\DWOPminus&0x1c&0 & \\
\DWOPmod&0x1d&0 & \\
\DWOPmul&0x1e&0 & \\
\DWOPneg&0x1f&0 & \\
\DWOPnot&0x20&0 & \\
\DWOPor&0x21&0 & \\
\DWOPplus&0x22&0 & \\
\DWOPplusuconst&0x23&1&ULEB128 addend \\
\DWOPshl&0x24&0 & \\
\DWOPshr&0x25&0 & \\
\DWOPshra&0x26&0 & \\
\DWOPxor&0x27&0 & \\

\DWOPbra&0x28&1 & signed 2-byte constant \\
\DWOPeq&0x29&0 & \\
\DWOPge&0x2a&0 & \\
\DWOPgt&0x2b&0 & \\
\DWOPle&0x2c&0 & \\
\DWOPlt&0x2d&0  & \\
\DWOPne&0x2e&0 & \\
\DWOPskip&0x2f&1&signed 2-byte constant \\ \hline

\DWOPlitzero & 0x30 & 0 & \\
\DWOPlitone  & 0x31 & 0& literals 0 .. 31 = \\
\ldots & & &\hspace{0.3cm}(\DWOPlitzero{} + literal) \\
\DWOPlitthirtyone & 0x4f & 0 & \\ \hline

\DWOPregzero & 0x50 & 0 & \\*
\DWOPregone  & 0x51 & 0&reg 0 .. 31 = \\*
\ldots & & &\hspace{0.3cm}(\DWOPregzero{} + regnum) \\*
\DWOPregthirtyone & 0x6f & 0 & \\ \hline

\DWOPbregzero & 0x70 &1 & SLEB128 offset \\*
\DWOPbregone  & 0x71 & 1 &base register 0 .. 31 = \\*
... & &              &\hspace{0.3cm}(\DWOPbregzero{} + regnum) \\*
\DWOPbregthirtyone & 0x8f & 1 & \\ \hline

\DWOPregx{} & 0x90 &1&ULEB128 register \\
\DWOPfbreg{} & 0x91&1&SLEB128 offset \\
\DWOPbregx{} & 0x92&2 &ULEB128 register, \\*
                  & & &SLEB128 offset \\
\DWOPpiece{} & 0x93 &1& ULEB128 size of piece \\
\DWOPderefsize{} & 0x94 &1& 1-byte size of data retrieved \\
\DWOPxderefsize{} & 0x95&1&1-byte size of data retrieved \\
\DWOPnop{} & 0x96 &0& \\

\DWOPpushobjectaddress&0x97&0 &  \\
\DWOPcalltwo&0x98&1& 2-byte offset of DIE \\
\DWOPcallfour&0x99&1& 4-byte offset of DIE \\
\DWOPcallref&0x9a&1& 4\dash\  or 8-byte offset of DIE \\
\DWOPformtlsaddress&0x9b &0& \\
\DWOPcallframecfa{} &0x9c &0& \\
\DWOPbitpiece&0x9d &2&ULEB128 size, \\*
                   &&&ULEB128 offset\\
\DWOPimplicitvalue{} &0x9e &2&ULEB128 size, \\*
                   &&&\nolink{block} of that size\\
\DWOPstackvalue{} &0x9f &0& \\
\DWOPimplicitpointer{}~\ddag &0xa0& 2 &4- or 8-byte offset of DIE, \\*
                              &&&SLEB128 constant offset \\
\DWOPaddrx~\ddag&0xa1&1&ULEB128 indirect address \\
\DWOPconstx~\ddag&0xa2&1&ULEB128 indirect constant   \\
\DWOPentryvalue~\ddag&0xa3&2&ULEB128 size, \\*
                   &&&\nolink{block} of that size\\
\DWOPconsttype~\ddag    & 0xa4 & 3 & ULEB128 type entry offset,\\*
                               & & & 1-byte size, \\*
                               & & & constant value \\
\DWOPregvaltype~\ddag   & 0xa5 & 2 & ULEB128 register number, \\*
                                 &&& ULEB128 constant offset \\
\DWOPdereftype~\ddag    & 0xa6 & 2 & 1-byte size, \\*
                                 &&& ULEB128 type entry offset \\
\DWOPxdereftype~\ddag   & 0xa7 & 2 & 1-byte size, \\*
                                 &&& ULEB128 type entry offset \\
\DWOPconvert~\ddag      & 0xa8 & 1 & ULEB128 type entry offset \\
\DWOPreinterpret~\ddag  & 0xa9 & 1 & ULEB128 type entry offset \\
\DWOPlouser{} &0xe0 && \\
\DWOPhiuser{} &\xff && \\

\end{longtable}
\end{centering}


\subsection{Location Descriptions}
\label{datarep:locationdescriptions}

A location description is used to compute the 
location of a variable or other entity.

\subsection{Location Lists}
\label{datarep:locationlists}

Each entry in a \addtoindex{location list} is either a location list entry,
a base address selection entry, or an 
\addtoindexx{end-of-list entry!in location list}
end-of-list entry.

\needlines{6}
\subsubsection{Location List Entries in Non-Split Objects}
A \addtoindex{location list} entry consists of two address offsets followed
by an unsigned 2-byte length, followed by a block of contiguous bytes
that contains a DWARF location description. The length
specifies the number of bytes in that block. The two offsets
are the same size as an address on the target machine.

\needlines{5}
A base address selection entry and an 
\addtoindexx{end-of-list entry!in location list}
end-of-list entry each
consist of two (constant or relocated) address offsets. The two
offsets are the same size as an address on the target machine.

For a \addtoindex{location list} to be specified, the base address of
\addtoindexx{base address selection entry!in location list}
the corresponding compilation unit must be defined 
(see Section \refersec{chap:fullandpartialcompilationunitentries}).

\subsubsection{Location List Entries in Split Objects}
\label{datarep:locationlistentriesinsplitobjects}
An alternate form for location list entries is used in split objects. 
Each entry begins with an unsigned 1-byte code that indicates the kind of entry
that follows. The encodings for these constants are given in
Table \refersec{tab:locationlistentryencodingvalues}.

\needlines{10}
\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Location list entry encoding values} \label{tab:locationlistentryencodingvalues} \\
  \hline \bfseries Location list entry encoding name&\bfseries Value \\ \hline
\endfirsthead
  \bfseries Location list entry encoding name&\bfseries Value\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot
\DWLLEendoflistentry & 0x0 \\
\DWLLEbaseaddressselectionentry & 0x01 \\
\DWLLEstartendentry & 0x02 \\
\DWLLEstartlengthentry & 0x03 \\
\DWLLEoffsetpairentry & 0x04 \\
\end{longtable}
\end{centering}

\section{Base Type Attribute Encodings}
\label{datarep:basetypeattributeencodings}

The\hypertarget{chap:DWATencodingencodingofbasetype}{}
encodings of the constants used in the 
\DWATencodingDEFN{} attribute\addtoindexx{encoding attribute} 
are given in 
Table \refersec{tab:basetypeencodingvalues}

\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Base type encoding values} \label{tab:basetypeencodingvalues} \\
  \hline \bfseries Base type encoding name&\bfseries Value \\ \hline
\endfirsthead
  \bfseries Base type encoding name&\bfseries Value\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
  \ddag \ \textit{New in \DWARFVersionV}
\endlastfoot
\DWATEaddress&0x01 \\
\DWATEboolean&0x02 \\
\DWATEcomplexfloat&0x03 \\
\DWATEfloat&0x04 \\
\DWATEsigned&0x05 \\
\DWATEsignedchar&0x06 \\
\DWATEunsigned&0x07 \\
\DWATEunsignedchar&0x08 \\
\DWATEimaginaryfloat&0x09 \\
\DWATEpackeddecimal&0x0a \\
\DWATEnumericstring&0x0b \\
\DWATEedited&0x0c \\
\DWATEsignedfixed&0x0d \\
\DWATEunsignedfixed&0x0e \\
\DWATEdecimalfloat & 0x0f \\
\DWATEUTF{} & 0x10 \\
\DWATEUCS~\ddag   & 0x11 \\
\DWATEASCII~\ddag & 0x12 \\
\DWATElouser{} & 0x80 \\
\DWATEhiuser{} & \xff \\
\end{longtable}
\end{centering}

\vspace*{1cm}
The encodings of the constants used in the 
\DWATdecimalsign{} attribute 
are given in 
Table \refersec{tab:decimalsignencodings}.

\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Decimal sign encodings} \label{tab:decimalsignencodings} \\
  \hline \bfseries Decimal sign code name&\bfseries Value \\ \hline
\endfirsthead
  \bfseries Decimal sign code name&\bfseries Value\\ \hline
\endhead
%  \hline \emph{Continued on next page}
%\endfoot
  \hline
\endlastfoot
\DWDSunsigned{}          & 0x01  \\
\DWDSleadingoverpunch{}  & 0x02  \\
\DWDStrailingoverpunch{} & 0x03  \\
\DWDSleadingseparate{}   & 0x04  \\
\DWDStrailingseparate{}  & 0x05 \\ 
\end{longtable}
\end{centering}

\needlines{9}
The encodings of the constants used in the 
\DWATendianity{} attribute are given in 
Table \refersec{tab:endianityencodings}.

\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Endianity encodings} \label{tab:endianityencodings}\\
  \hline \bfseries Endian code name&\bfseries Value \\ \hline
\endfirsthead
  \bfseries Endian code name&\bfseries Value\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot

\DWENDdefault{}  & 0x00 \\
\DWENDbig{} & 0x01 \\
\DWENDlittle{} & 0x02 \\
\DWENDlouser{} & 0x40 \\
\DWENDhiuser{} & \xff \\

\end{longtable}
\end{centering}

\needlines{10}
\section{Accessibility Codes}
\label{datarep:accessibilitycodes}
The encodings of the constants used in the 
\DWATaccessibility{}
attribute 
\addtoindexx{accessibility attribute}
are given in 
Table \refersec{tab:accessibilityencodings}.

\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Accessibility encodings} \label{tab:accessibilityencodings}\\
  \hline \bfseries Accessibility code name&\bfseries Value \\ \hline
\endfirsthead
  \bfseries Accessibility code name&\bfseries Value\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot

\DWACCESSpublic&0x01  \\
\DWACCESSprotected&0x02 \\
\DWACCESSprivate&0x03 \\

\end{longtable}
\end{centering}


\section{Visibility Codes}
\label{datarep:visibilitycodes}
The encodings of the constants used in the 
\DWATvisibility{} attribute are given in 
Table \refersec{tab:visibilityencodings}. 

\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Visibility encodings} \label{tab:visibilityencodings}\\
  \hline \bfseries Visibility code name&\bfseries Value \\ \hline
\endfirsthead
  \bfseries Visibility code name&\bfseries Value\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot

\DWVISlocal&0x01 \\
\DWVISexported&0x02 \\
\DWVISqualified&0x03 \\

\end{longtable}
\end{centering}

\section{Virtuality Codes}
\label{datarep:vitualitycodes}

The encodings of the constants used in the 
\DWATvirtuality{} attribute are given in 
Table \refersec{tab:virtualityencodings}.

\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Virtuality encodings} \label{tab:virtualityencodings}\\
  \hline \bfseries Virtuality code name&\bfseries Value \\ \hline
\endfirsthead
  \bfseries Virtuality code name&\bfseries Value\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot

\DWVIRTUALITYnone&0x00 \\
\DWVIRTUALITYvirtual&0x01 \\
\DWVIRTUALITYpurevirtual&0x02 \\

\end{longtable}
\end{centering}

\needlines{4}
The value 
\DWVIRTUALITYnone{} is equivalent to the absence of the 
\DWATvirtuality{}
attribute.

\section{Source Languages}
\label{datarep:sourcelanguages}

The encodings of the constants used 
\addtoindexx{language attribute, encoding}
in 
\addtoindexx{language name encoding}
the 
\DWATlanguage{}
attribute are given in 
Table \refersec{tab:languageencodings}.
Names marked with
% If we don't force a following space it looks odd
\dag \  
and their associated values are reserved, but the
languages they represent are not well supported. 
Table \refersec{tab:languageencodings}
also shows the 
\addtoindexx{lower bound attribute!default}
default lower bound, if any, assumed for
an omitted \DWATlowerbound{} attribute in the context of a
\DWTAGsubrangetype{} debugging information entry for each
defined language.

\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c|c}
  \caption{Language encodings} \label{tab:languageencodings}\\
  \hline \bfseries Language name&\bfseries Value &\bfseries Default Lower Bound \\ \hline
\endfirsthead
  \bfseries Language name&\bfseries Value &\bfseries Default Lower Bound\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
  \dag \ \textit{See text} \\ \ddag \ \textit{New in \DWARFVersionV}
\endlastfoot
\addtoindexx{ISO-defined language names}

\DWLANGCeightynine &0x0001 &0 \addtoindexx{C:1989 (ISO)}      \\
\DWLANGC{} &0x0002 &0  \addtoindexx{C!non-standard} \\
\DWLANGAdaeightythree{} \dag &0x0003 &1  \addtoindexx{Ada:1983 (ISO)}     \\
\DWLANGCplusplus{} &0x0004 &0 \addtoindexx{C++98 (ISO)} \\
\DWLANGCobolseventyfour{} \dag &0x0005 &1 \addtoindexx{COBOL:1974 (ISO)}      \\
\DWLANGCoboleightyfive{} \dag &0x0006 &1 \addtoindexx{COBOL:1985 (ISO)}      \\
\DWLANGFortranseventyseven &0x0007 &1 \addtoindexx{FORTRAN:1977 (ISO)}      \\
\DWLANGFortranninety &0x0008 &1 \addtoindexx{Fortran:1990 (ISO)}      \\
\DWLANGPascaleightythree &0x0009 &1 \addtoindexx{Pascal:1983 (ISO)}      \\
\DWLANGModulatwo &0x000a &1 \addtoindexx{Modula-2:1996 (ISO)}      \\
\DWLANGJava &0x000b &0 \addtoindexx{Java}      \\
\DWLANGCninetynine &0x000c &0 \addtoindexx{C:1999 (ISO)}      \\
\DWLANGAdaninetyfive{} \dag &0x000d &1 \addtoindexx{Ada:1995 (ISO)}      \\
\DWLANGFortranninetyfive &0x000e &1 \addtoindexx{Fortran:1995 (ISO)}      \\
\DWLANGPLI{} \dag &0x000f &1 \addtoindexx{PL/I:1976 (ANSI)}\\
\DWLANGObjC{} &0x0010 &0 \addtoindexx{Objective C}\\
\DWLANGObjCplusplus{} &0x0011 &0 \addtoindexx{Objective C++}\\
\DWLANGUPC{} &0x0012 &0 \addtoindexx{UPC}\\
\DWLANGD{} &0x0013 &0 \addtoindexx{D language}\\
\DWLANGPython{} \dag &0x0014 &0 \addtoindexx{Python}\\
\DWLANGOpenCL{} \dag \ddag &0x0015 &0 \addtoindexx{OpenCL}\\
\DWLANGGo{} \dag \ddag &0x0016 &0 \addtoindexx{Go}\\
\DWLANGModulathree{} \dag \ddag &0x0017 &1 \addtoindexx{Modula-3}\\
\DWLANGHaskell{} \dag \ddag &0x0018 &0 \addtoindexx{Haskell}\\
\DWLANGCpluspluszerothree{} \ddag &0x0019 &0 \addtoindexx{C++03 (ISO)}\\
\DWLANGCpluspluseleven{} \ddag &0x001a &0 \addtoindexx{C++11 (ISO)} \\
\DWLANGOCaml{} \ddag &0x001b &0	\addtoindexx{OCaml}\\
\DWLANGRust{} \ddag &0x001c &0 \addtoindexx{Rust}\\
\DWLANGCeleven{} \ddag &0x001d &0 \addtoindexx{C:2011 (ISO)}\\
\DWLANGSwift{} \ddag &0x001e &0 \addtoindexx{Swift} \\
\DWLANGJulia{} \ddag &0x001f &1 \addtoindexx{Julia} \\
\DWLANGDylan{} \ddag &0x0020 &0 \addtoindexx{Dylan} \\
\DWLANGCplusplusfourteen{}~\ddag &0x0021 &0 \addtoindexx{C++14 (ISO)} \\
\DWLANGFortranzerothree{}~\ddag  &0x0022 &1 \addtoindexx{Fortran:2004 (ISO)} \\
\DWLANGFortranzeroeight{}~\ddag  &0x0023 &1 \addtoindexx{Fortran:2010 (ISO)} \\
\DWLANGlouser{} &0x8000 & \\
\DWLANGhiuser{} &\xffff & \\

\end{longtable}
\end{centering}

\section{Address Class Encodings}
\label{datarep:addressclassencodings}

The value of the common 
\addtoindex{address class} encoding 
\DWADDRnone{} is 0.

\needlines{16}
\section{Identifier Case}
\label{datarep:identifiercase}

The encodings of the constants used in the 
\DWATidentifiercase{} attribute are given in 
Table \refersec{tab:identifiercaseencodings}.

\needlines{8}
\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Identifier case encodings} \label{tab:identifiercaseencodings}\\
  \hline \bfseries Identifier case name&\bfseries Value \\ \hline
\endfirsthead
  \bfseries Identifier case name&\bfseries Value\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot
\DWIDcasesensitive&0x00     \\
\DWIDupcase&0x01     \\
\DWIDdowncase&0x02     \\
\DWIDcaseinsensitive&0x03     \\
\end{longtable}
\end{centering}

\section{Calling Convention Encodings}
\label{datarep:callingconventionencodings}
The encodings of the constants used in the 
\DWATcallingconvention{} attribute are given in
Table \refersec{tab:callingconventionencodings}.

\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Calling convention encodings} \label{tab:callingconventionencodings}\\
  \hline \bfseries Calling convention name&\bfseries Value \\ \hline
\endfirsthead
  \bfseries Calling convention name&\bfseries Value\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline \ddag\ \textit{New in DWARF Version 5}
\endlastfoot

\DWCCnormal &0x01     \\
\DWCCprogram&0x02     \\
\DWCCnocall &0x03     \\
\DWCCpassbyreference~\ddag &0x04 \\
\DWCCpassbyvalue~\ddag     &0x05 \\
\DWCClouser &0x40     \\
\DWCChiuser&\xff     \\

\end{longtable}
\end{centering}

\needlines{12}
\section{Inline Codes}
\label{datarep:inlinecodes}

The encodings of the constants used in 
\addtoindexx{inline attribute}
the 
\DWATinline{} attribute are given in 
Table \refersec{tab:inlineencodings}.

\needlines{8}
\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Inline encodings} \label{tab:inlineencodings}\\
  \hline \bfseries Inline code name&\bfseries Value \\ \hline
\endfirsthead
  \bfseries Inline Code name&\bfseries Value\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot

\DWINLnotinlined&0x00      \\
\DWINLinlined&0x01      \\
\DWINLdeclarednotinlined&0x02      \\
\DWINLdeclaredinlined&0x03      \\

\end{longtable}
\end{centering}

% this clearpage is ugly, but the following table came
% out oddly without it.

\section{Array Ordering}
\label{datarep:arrayordering}

The encodings of the constants used in the 
\DWATordering{} attribute are given in 
Table \refersec{tab:orderingencodings}.

\needlines{8}
\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Ordering encodings} \label{tab:orderingencodings}\\
  \hline \bfseries Ordering name&\bfseries Value \\ \hline
\endfirsthead
  \bfseries Ordering name&\bfseries Value\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot

\DWORDrowmajor&0x00  \\
\DWORDcolmajor&0x01  \\

\end{longtable}
\end{centering}


\section{Discriminant Lists}
\label{datarep:discriminantlists}

The descriptors used in 
\addtoindexx{discriminant list attribute}
the 
\DWATdiscrlist{} attribute are 
encoded as 1-byte constants. The
defined values are given in 
Table \refersec{tab:discriminantdescriptorencodings}.

% Odd that the 'Name' field capitalized here, it is not caps elsewhere.
\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Discriminant descriptor encodings} \label{tab:discriminantdescriptorencodings}\\
  \hline \bfseries Descriptor name&\bfseries Value \\ \hline
\endfirsthead
  \bfseries Descriptor name&\bfseries Value\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot

\DWDSClabel&0x00 \\
\DWDSCrange&0x01 \\

\end{longtable}
\end{centering}

\needlines{6}
\section{Name Index Table}
\label{datarep:nameindextable}
The \addtoindexi{version number}{version number!name index table}
in the name index table header is \versiondotdebugnames{}.

The name index attributes and their encodings are listed in Table \referfol{datarep:indexattributeencodings}.

\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c|l}
  \caption{Name index attribute encodings} \label{datarep:indexattributeencodings}\\
  \hline \bfseries Attribute name &\bfseries Value &\bfseries Form/Class \\ \hline
\endfirsthead
  \bfseries Attribute name &\bfseries Value &\bfseries Form/Class \\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
  \ddag~\textit{New in \DWARFVersionV}
\endlastfoot
\DWIDXcompileunit~\ddag & 1        & \CLASSconstant \\
\DWIDXtypeunit~\ddag    & 2        & \CLASSconstant \\
\DWIDXdieoffset~\ddag   & 3        & \CLASSreference \\
\DWIDXparent~\ddag      & 4        & \CLASSconstant \\
\DWIDXtypehash~\ddag    & 5        & \DWFORMdataeight \\
\DWIDXlouser~\ddag      & 0x2000   & \\
\DWIDXhiuser~\ddag      & \xiiifff & \\
\end{longtable}
\end{centering}

The abbreviations table ends with an entry consisting of a single 0
byte for the abbreviation code. The size of the table given by
\texttt{abbrev\_table\_size} may include optional padding following the
terminating 0 byte.

\section{Defaulted Member Encodings}
\hypertarget{datarep:defaultedmemberencodings}{}

The encodings of the constants used in the \DWATdefaulted{} attribute
are given in Table \referfol{datarep:defaultedattributeencodings}.

\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Defaulted attribute encodings} \label{datarep:defaultedattributeencodings} \\
  \hline \bfseries Defaulted name &\bfseries Value \\ \hline
\endfirsthead
  \bfseries Defaulted name &\bfseries Value \\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
  \ddag~\textit{New in \DWARFVersionV}
\endlastfoot
\DWDEFAULTEDno~\ddag   & 0x00 \\
\DWDEFAULTEDinclass~\ddag       & 0x01 \\
\DWDEFAULTEDoutofclass~\ddag    & 0x02 \\
\end{longtable}
\end{centering}

\needlines{10}
\section{Address Range Table}
\label{datarep:addrssrangetable}

Each set of entries in the table of address ranges contained
in the \dotdebugaranges{}
section begins with a header containing:
\begin{enumerate}[1. ]
% FIXME The unit length text is not fully consistent across
% these tables.

\item \texttt{unit\_length} (\livelink{datarep:initiallengthvalues}{initial length}) \\
\addttindexx{unit\_length}
A 4-byte or 12-byte length containing the length of the
\addtoindexx{initial length}
set of entries for this compilation unit, not including the
length field itself. In the \thirtytwobitdwarfformat, this is a
4-byte unsigned integer (which must be less than \xfffffffzero);
in the \sixtyfourbitdwarfformat, this consists of the 4-byte value
\wffffffff followed by an 8-byte unsigned integer that gives
the actual length 
(see Section \refersec{datarep:32bitand64bitdwarfformats}).

\item version (\HFTuhalf) \\
A 2-byte version identifier representing the version of the
DWARF information for the address range table.

This value in this field \addtoindexx{version number!address range table} is 2. 
 
\item debug\_info\_offset (\livelink{datarep:sectionoffsetlength}{section offset}) \\
A 
\addtoindexx{section offset!in .debug\_aranges header}
4-byte or 8-byte offset into the 
\dotdebuginfo{} section of
the compilation unit header. In the \thirtytwobitdwarfformat,
this is a 4-byte unsigned offset; in the \sixtyfourbitdwarfformat,
this is an 8-byte unsigned offset 
(see Section \refersec{datarep:32bitand64bitdwarfformats}).

\item \texttt{address\_size} (\HFTubyte) \\
A 1-byte unsigned integer containing the size in bytes of an
\addttindexx{address\_size}
address 
\addtoindexx{size of an address}
(or the offset portion of an address for segmented
\addtoindexx{address space!segmented}
addressing) on the target system.

\item \HFNsegmentselectorsize{} (\HFTubyte) \\
A 1-byte unsigned integer containing the size in bytes of a
segment selector on the target system.

\end{enumerate}

This header is followed by a series of tuples. Each tuple
consists of a segment, an address and a length. 
The segment selector
size is given by the \HFNsegmentselectorsize{} field of the header; the
address and length size are each given by the \addttindex{address\_size}
field of the header. 
The first tuple following the header in
each set begins at an offset that is a multiple of the size
of a single tuple (that is, the size of a segment selector
plus twice the \addtoindex{size of an address}). 
The header is padded, if
necessary, to that boundary. Each set of tuples is terminated
by a 0 for the segment, a 0 for the address and 0 for the
length. If the \HFNsegmentselectorsize{} field in the header is zero,
the segment selectors are omitted from all tuples, including
the terminating tuple.


\section{Line Number Information}
\label{datarep:linenumberinformation}

The \addtoindexi{version number}{version number!line number information}
in the line number program header is \versiondotdebugline{}.

The boolean values \doublequote{true} and \doublequote{false} 
used by the line number information program are encoded
as a single byte containing the value 0 
for \doublequote{false,} and a non-zero value for \doublequote{true.}

\needlines{10}
The encodings for the standard opcodes are given in 
\addtoindexx{line number opcodes!standard opcode encoding}
Table \refersec{tab:linenumberstandardopcodeencodings}.

\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Line number standard opcode encodings} \label{tab:linenumberstandardopcodeencodings}\\
  \hline \bfseries Opcode name&\bfseries Value \\ \hline
\endfirsthead
  \bfseries Opcode name&\bfseries Value\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot

\DWLNScopy&0x01 \\
\DWLNSadvancepc&0x02 \\
\DWLNSadvanceline&0x03 \\
\DWLNSsetfile&0x04 \\
\DWLNSsetcolumn&0x05 \\
\DWLNSnegatestmt&0x06 \\
\DWLNSsetbasicblock&0x07 \\
\DWLNSconstaddpc&0x08 \\
\DWLNSfixedadvancepc&0x09 \\
\DWLNSsetprologueend&0x0a \\*
\DWLNSsetepiloguebegin&0x0b \\*
\DWLNSsetisa&0x0c \\*
\end{longtable}
\end{centering}

\clearpage
\needlines{12}
The encodings for the extended opcodes are given in 
\addtoindexx{line number opcodes!extended opcode encoding}
Table \refersec{tab:linenumberextendedopcodeencodings}.

\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Line number extended opcode encodings} \label{tab:linenumberextendedopcodeencodings}\\
  \hline \bfseries Opcode name&\bfseries Value \\ \hline
\endfirsthead
  \bfseries Opcode name&\bfseries Value\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline %\ddag~\textit{New in DWARF Version 5}
\endlastfoot

\DWLNEendsequence	&0x01 \\
\DWLNEsetaddress	&0x02 \\
\textit{Reserved}	&0x03\footnote{Code 0x03 is reserved to allow backward compatible support of the 
                                       DW\_LNE\_define\_file operation which was defined in \DWARFVersionIV{} 
                                       and earlier.} \\
\DWLNEsetdiscriminator  &0x04 \\
\DWLNElouser		&0x80 \\
\DWLNEhiuser		&\xff \\

\end{longtable}
\end{centering}

\needlines{6}
The encodings for the line number header entry formats are given in 
\addtoindexx{line number opcodes!file entry format encoding}
Table \refersec{tab:linenumberheaderentryformatencodings}.

\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Line number header entry format \mbox{encodings}} \label{tab:linenumberheaderentryformatencodings}\\
  \hline \bfseries Line number header entry format name&\bfseries Value \\ \hline
\endfirsthead
  \bfseries Line number header entry format name&\bfseries Value\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline \ddag~\textit{New in DWARF Version 5}
\endlastfoot
\DWLNCTpath~\ddag           & 0x1 \\
\DWLNCTdirectoryindex~\ddag & 0x2 \\
\DWLNCTtimestamp~\ddag      & 0x3 \\
\DWLNCTsize~\ddag           & 0x4 \\
\DWLNCTMDfive~\ddag         & 0x5 \\
\DWLNCTlouser~\ddag         & 0x2000 \\
\DWLNCThiuser~\ddag         & \xiiifff \\
\end{longtable}
\end{centering}

\needlines{6}
\section{Macro Information}
\label{datarep:macroinformation}
The \addtoindexi{version number}{version number!macro information}
in the macro information header is \versiondotdebugmacro{}.

The source line numbers and source file indices encoded in the
macro information section are represented as 
unsigned LEB128\addtoindexx{LEB128!unsigned} numbers.

\needlines{4}
The macro information entry type is encoded as a single unsigned byte. 
The encodings 
\addtoindexx{macro information entry types!encoding}
are given in 
Table \refersec{tab:macroinfoentrytypeencodings}.

\needlines{10}
\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c}
  \caption{Macro information entry type encodings} \label{tab:macroinfoentrytypeencodings}\\
  \hline \bfseries Macro information entry type name&\bfseries Value \\ \hline
\endfirsthead
  \bfseries Macro information entry type name&\bfseries Value\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline \ddag~\textit{New in DWARF Version 5}
\endlastfoot

\DWMACROdefine~\ddag          &0x01 \\
\DWMACROundef~\ddag           &0x02 \\
\DWMACROstartfile~\ddag       &0x03 \\
\DWMACROendfile~\ddag         &0x04 \\
\DWMACROdefinestrp~\ddag      &0x05 \\
\DWMACROundefstrp~\ddag       &0x06 \\
\DWMACROimport~\ddag          &0x07 \\
\DWMACROdefinesup~\ddag       &0x08 \\
\DWMACROundefsup~\ddag        &0x09 \\
\DWMACROimportsup~\ddag       &0x0a \\
\DWMACROdefinestrx~\ddag      &0x0b \\
\DWMACROundefstrx~\ddag       &0x0c \\
\DWMACROlouser~\ddag          &0xe0 \\
\DWMACROhiuser~\ddag          &\xff \\

\end{longtable}
\end{centering}

\needlines{7}
\section{Call Frame Information}
\label{datarep:callframeinformation}

In the \thirtytwobitdwarfformat, the value of the CIE id in the
CIE header is \xffffffff; in the \sixtyfourbitdwarfformat, the
value is \xffffffffffffffff.

The value of the CIE \addtoindexi{version number}{version number!call frame information}
is \versiondotdebugframe.

Call frame instructions are encoded in one or more bytes. The
primary opcode is encoded in the high order two bits of
the first byte (that is, opcode = byte $\gg$ 6). An operand
or extended opcode may be encoded in the low order 6
bits. Additional operands are encoded in subsequent bytes.
The instructions and their encodings are presented in
Table \refersec{tab:callframeinstructionencodings}.

\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|c|c|l|l}
  \caption{Call frame instruction encodings} \label{tab:callframeinstructionencodings} \\
  \hline &\bfseries High 2 &\bfseries Low 6 &  & \\
  \bfseries Instruction&\bfseries Bits &\bfseries Bits &\bfseries Operand 1 &\bfseries Operand 2\\ \hline
\endfirsthead
   & \bfseries High 2 &\bfseries Low 6 &  &\\
  \bfseries Instruction&\bfseries Bits &\bfseries Bits &\bfseries Operand 1 &\bfseries Operand 2\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot

\DWCFAadvanceloc&0x1&delta & \\
\DWCFAoffset&0x2&register&ULEB128 offset \\
\DWCFArestore&0x3&register & & \\
\DWCFAnop&0&0 & & \\
\DWCFAsetloc&0&0x01&address & \\
\DWCFAadvancelocone&0&0x02&1-byte delta & \\
\DWCFAadvanceloctwo&0&0x03&2-byte delta & \\
\DWCFAadvancelocfour&0&0x04&4-byte delta & \\
\DWCFAoffsetextended&0&0x05&ULEB128 register&ULEB128 offset \\
\DWCFArestoreextended&0&0x06&ULEB128 register & \\
\DWCFAundefined&0&0x07&ULEB128 register & \\
\DWCFAsamevalue&0&0x08 &ULEB128 register & \\
\DWCFAregister&0&0x09&ULEB128 register &ULEB128 offset \\
\DWCFArememberstate&0&0x0a & & \\
\DWCFArestorestate&0&0x0b & & \\
\DWCFAdefcfa&0&0x0c &ULEB128 register&ULEB128 offset \\
\DWCFAdefcfaregister&0&0x0d&ULEB128 register & \\
\DWCFAdefcfaoffset&0&0x0e &ULEB128 offset & \\
\DWCFAdefcfaexpression&0&0x0f &BLOCK  \\
\DWCFAexpression&0&0x10&ULEB128 register & BLOCK \\

\DWCFAoffsetextendedsf&0&0x11&ULEB128 register&SLEB128 offset \\
\DWCFAdefcfasf&0&0x12&ULEB128 register&SLEB128 offset \\
\DWCFAdefcfaoffsetsf&0&0x13&SLEB128 offset & \\
\DWCFAvaloffset&0&0x14&ULEB128&ULEB128 \\
\DWCFAvaloffsetsf&0&0x15&ULEB128&SLEB128 \\
\DWCFAvalexpression&0&0x16&ULEB128&BLOCK  \\
\DWCFAlouser&0&0x1c   & & \\
\DWCFAhiuser&0&\xiiif & & \\
\end{longtable}
\end{centering}

\section{Non-contiguous Address Ranges}
\label{datarep:noncontiguousaddressranges}

Each entry in a \addtoindex{range list}
(see Section \refersec{chap:noncontiguousaddressranges})
is either a
\addtoindexx{base address selection entry!in range list}
range list entry, 
\addtoindexx{range list}
a base address selection entry, or an end-of-list entry.

A \addtoindex{range list} entry consists of two relative addresses. The
addresses are the same size as addresses on the target machine.

\needlines{4}
A base address selection entry and an 
\addtoindexx{end-of-list entry!in range list}
end-of-list entry each
\addtoindexx{base address selection entry!in range list}
consist of two (constant or relocated) addresses. The two
addresses are the same size as addresses on the target machine.

For a \addtoindex{range list} to be specified, the base address of the
\addtoindexx{base address selection entry!in range list}
corresponding compilation unit must be defined 
(see Section \refersec{chap:fullandpartialcompilationunitentries}).

\needlines{6}
\section{String Offsets Table}
\label{chap:stringoffsetstable}
Each set of entries in the string offsets table contained in the
\dotdebugstroffsets{} or \dotdebugstroffsetsdwo{}
section begins with a header containing:
\begin{enumerate}[1. ]
\item \texttt{unit\_length} (\livelink{datarep:initiallengthvalues}{initial length}) \\
\addttindexx{unit\_length}
A 4-byte or 12-byte length containing the length of
the set of entries for this compilation unit, not
including the length field itself. In the 32-bit
DWARF format, this is a 4-byte unsigned integer
(which must be less than \xfffffffzero); in the 64-bit
DWARF format, this consists of the 4-byte value
\wffffffff followed by an 8-byte unsigned integer
that gives the actual length (see 
Section \refersec{datarep:32bitand64bitdwarfformats}).

%\needlines{4}
\item  \texttt{version} (\HFTuhalf) \\
\addtoindexx{version number!string offsets table}
A 2-byte version identifier containing the value
\versiondotdebugstroffsets{}.

\item \textit{padding} (\HFTuhalf) \\
Reserved to DWARF (must be zero).
\end{enumerate}

This header is followed by a series of string table offsets
that have the same representation as \DWFORMstrp.
For the 32-bit DWARF format, each offset is 4 bytes long; for
the 64-bit DWARF format, each offset is 8 bytes long.

The \DWATstroffsetsbase{} attribute points to the first
entry following the header. The entries are indexed
sequentially from this base entry, starting from 0.

\section{Address Table}
\label{chap:addresstable}
Each set of entries in the address table contained in the
\dotdebugaddr{} section begins with a header containing:
\begin{enumerate}[1. ]
\item \texttt{unit\_length} (\livelink{datarep:initiallengthvalues}{initial length}) \\
\addttindexx{unit\_length}
A 4-byte or 12-byte length containing the length of
the set of entries for this compilation unit, not
including the length field itself. In the 32-bit
DWARF format, this is a 4-byte unsigned integer
(which must be less than \xfffffffzero); in the 64-bit
DWARF format, this consists of the 4-byte value
\wffffffff followed by an 8-byte unsigned integer
that gives the actual length (see 
Section \refersec{datarep:32bitand64bitdwarfformats}).

\needlines{4}
\item  \texttt{version} (\HFTuhalf) \\
\addtoindexx{version number!address table}
A 2-byte version identifier containing the value
\versiondotdebugaddr{}.

\needlines{4}
\item	\texttt{address\_size} (\HFTubyte) \\
A 1-byte unsigned integer containing the size in
bytes of an address (or the offset portion of an
address for segmented addressing) on the target
system.

\needlines{4}
\item	\HFNsegmentselectorsize{} (\HFTubyte) \\
A 1-byte unsigned integer containing the size in
bytes of a segment selector on the target system.
\end{enumerate}

This header is followed by a series of segment/address pairs.
The segment size is given by the \HFNsegmentselectorsize{} field of the
header, and the address size is given by the \addttindex{address\_size}
field of the header. If the \HFNsegmentselectorsize{} field in the header
is zero, the entries consist only of an addresses.

The \DWATaddrbase{} attribute points to the first entry
following the header. The entries are indexed sequentially
from this base entry, starting from 0.

\needlines{10}
\section{Range List Table}
\label{app:rangelisttable}
Each set of entries in the range list table contained in the
\dotdebugranges{} section begins with a header containing:
\begin{enumerate}[1. ]
\item \texttt{unit\_length} (\livelink{datarep:initiallengthvalues}{initial length}) \\
\addttindexx{unit\_length}
A 4-byte or 12-byte length containing the length of
the set of entries for this compilation unit, not
including the length field itself. In the 32-bit
DWARF format, this is a 4-byte unsigned integer
(which must be less than \xfffffffzero); in the 64-bit
DWARF format, this consists of the 4-byte value
\wffffffff followed by an 8-byte unsigned integer
that gives the actual length (see 
Section \refersec{datarep:32bitand64bitdwarfformats}).

\needlines{4}
\item  \texttt{version} (\HFTuhalf) \\
\addtoindexx{version number!range list table}
A 2-byte version identifier containing the value
\versiondotdebugranges{}. 

\needlines{4}
\item	\texttt{address\_size} (\HFTubyte) \\
A 1-byte unsigned integer containing the size in
bytes of an address (or the offset portion of an
address for segmented addressing) on the target
system.

\needlines{4}
\item	\HFNsegmentselectorsize{} (\HFTubyte) \\
A 1-byte unsigned integer containing the size in
bytes of a segment selector on the target system.
\end{enumerate}

This header is followed by a series of range list entries as
described in Section \refersec{chap:noncontiguousaddressranges}.
The segment size is given by the
\HFNsegmentselectorsize{} field of the header, and the address size is
given by the \addttindex{address\_size} field of the header. If the
\HFNsegmentselectorsize{} field in the header is zero, the segment
selector is omitted from the range list entries.

The \DWATrangesbase{} attribute points to the first entry
following the header. The entries are referenced by a byte
offset relative to this base address.

\needlines{12}
\section{Location List Table}
\label{datarep:locationlisttable}
Each set of entries in the location list table contained in the
\dotdebugloc{} or \dotdebuglocdwo{} sections begins with a header containing:
\begin{enumerate}[1. ]
\item \texttt{unit\_length} (\livelink{datarep:initiallengthvalues}{initial length}) \\
\addttindexx{unit\_length}
A 4-byte or 12-byte length containing the length of
the set of entries for this compilation unit, not
including the length field itself. In the 32-bit
DWARF format, this is a 4-byte unsigned integer
(which must be less than \xfffffffzero); in the 64-bit
DWARF format, this consists of the 4-byte value
\wffffffff followed by an 8-byte unsigned integer
that gives the actual length (see 
Section \refersec{datarep:32bitand64bitdwarfformats}).

\needlines{4}
\item  \texttt{version} (\HFTuhalf) \\
\addtoindexx{version number!location list table}
A 2-byte version identifier containing the value
\versiondotdebugloc{}.

\needlines{5}
\item	\texttt{address\_size} (\HFTubyte) \\
A 1-byte unsigned integer containing the size in
bytes of an address (or the offset portion of an
address for segmented addressing) on the target
system.

\needlines{4}
\item	\HFNsegmentselectorsize{} (\HFTubyte) \\
A 1-byte unsigned integer containing the size in
bytes of a segment selector on the target system.
\end{enumerate}

This header is followed by a series of location list entries as
described in Section \refersec{chap:locationlists}.
The segment size is given by the
\HFNsegmentselectorsize{} field of the header, and the address size is
given by the \HFNaddresssize{} field of the header. If the
\HFNsegmentselectorsize{} field in the header is zero, the segment
selector is omitted from range list entries.

The entries are referenced by a byte offset relative to the first
location list following this header.

\needlines{6}
\section{Dependencies and Constraints}
\label{datarep:dependenciesandconstraints}
The debugging information in this format is intended to
exist in sections of an object file, or an equivalent
separate file or database, having names beginning with
the prefix ".debug\_" (see Appendix 
\refersec{app:dwarfsectionversionnumbersinformative}
for a complete list of such names). 
Except as specifically specified, this information is not 
aligned on 2-, 4- or 8-byte boundaries. Consequently:

\begin{itemize}
\item For the \thirtytwobitdwarfformat{} and a target architecture with
32-bit addresses, an assembler or compiler must provide a way
to produce 2-byte and 4-byte quantities without alignment
restrictions, and the linker must be able to relocate a
4-byte address or 
\addtoindexx{section offset!alignment of}
section offset that occurs at an arbitrary
alignment.

\item For the \thirtytwobitdwarfformat{} and a target architecture with
64-bit addresses, an assembler or compiler must provide a
way to produce 2-byte, 4-byte and 8-byte quantities without
alignment restrictions, and the linker must be able to relocate
an 8-byte address or 4-byte 
\addtoindexx{section offset!alignment of}
section offset that occurs at an
arbitrary alignment.

\item For the \sixtyfourbitdwarfformat{} and a target architecture with
32-bit addresses, an assembler or compiler must provide a
way to produce 2-byte, 4-byte and 8-byte quantities without
alignment restrictions, and the linker must be able to relocate
a 4-byte address or 8-byte 
\addtoindexx{section offset!alignment of}
section offset that occurs at an
arbitrary alignment.

\textit{It is expected that this will be required only for very large
32-bit programs or by those architectures which support
a mix of 32-bit and 64-bit code and data within the same
executable object.}

\item For the \sixtyfourbitdwarfformat{} and a target architecture with
64-bit addresses, an assembler or compiler must provide a
way to produce 2-byte, 4-byte and 8-byte quantities without
alignment restrictions, and the linker must be able to
relocate an 8-byte address or 
\addtoindexx{section offset!alignment of}
section offset that occurs at
an arbitrary alignment.
\end{itemize}

\needlines{10}
\section{Integer Representation Names}
\label{datarep:integerrepresentationnames}
The sizes of the integers used in the lookup by name, lookup
by address, line number, call frame information and other sections
are given in
Table \ref{tab:integerrepresentationnames}.

\needlines{12}
\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{c|l}
  \caption{Integer representation names} \label{tab:integerrepresentationnames}\\
  \hline \bfseries Representation name&\bfseries Representation \\ \hline
\endfirsthead
  \bfseries Representation name&\bfseries Representation\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot

\HFTsbyte&  signed, 1-byte integer \\
\HFTubyte&unsigned, 1-byte integer \\
\HFTuhalf&unsigned, 2-byte integer \\
\HFTuword&unsigned, 4-byte integer \\

\end{longtable}
\end{centering}

\needlines{6}
\section{Type Signature Computation}
\label{datarep:typesignaturecomputation}

A \addtoindex{type signature} is used by a DWARF consumer 
to resolve type references to the type definitions that 
are contained in \addtoindex{type unit}s (see Section
\refersec{chap:typeunitentries}).

\textit{A type signature is computed only by a DWARF producer;
\addtoindexx{type signature!computation} a consumer need
\bb
only
\eb
compare two type signatures to check for equality.}

\needlines{4}
The type signature for a type T0 is formed from the 
\MDfive{}\footnote{\livetarg{def:MDfive}{MD5} Message Digest Algorithm, 
R.L. Rivest, RFC 1321, April 1992}
digest of a flattened description of the type. The flattened
description of the type is a byte sequence derived from the
DWARF encoding of the type as follows:
\begin{enumerate}[1. ]

\item Start with an empty sequence S and a list V of visited
types, where V is initialized to a list containing the type
T0 as its single element. Elements in V are indexed from 1,
so that V[1] is T0.

\item If the debugging information entry represents a type that
is nested inside another type or a namespace, append to S
the type\textquoteright s context as follows: For each surrounding type
or namespace, beginning with the outermost such construct,
append the letter 'C', the DWARF tag of the construct, and
the name (taken from 
\addtoindexx{name attribute}
the \DWATname{} attribute) of the type
\addtoindexx{name attribute}
or namespace (including its trailing null byte).

\item  Append to S the letter 'D', followed by the DWARF tag of
the debugging information entry.

\item For each of the attributes in
Table \refersec{tab:attributesusedintypesignaturecomputation}
that are present in
the debugging information entry, in the order listed,
append to S a marker letter (see below), the DWARF attribute
code, and the attribute value.

\begin{table}[ht]
\caption{Attributes used in type signature computation}
\label{tab:attributesusedintypesignaturecomputation}
\simplerule[\textwidth]
\begin{center}
\autocols[0pt]{c}{2}{l}{
\DWATname,
\DWATaccessibility,
\DWATaddressclass,
\DWATalignment,
\DWATallocated,
\DWATartificial,
\DWATassociated,
\DWATbinaryscale,
%\DWATbitoffset,
\DWATbitsize,
\DWATbitstride,
\DWATbytesize,
\DWATbytestride,
\DWATconstexpr,
\DWATconstvalue,
\DWATcontainingtype,
\DWATcount,
\DWATdatabitoffset,
\DWATdatalocation,
\DWATdatamemberlocation,
\DWATdecimalscale,
\DWATdecimalsign,
\DWATdefaultvalue,
\DWATdigitcount,
\DWATdiscr,
\DWATdiscrlist,
\DWATdiscrvalue,
\DWATencoding,
\DWATendianity,
\DWATenumclass,
\DWATexplicit,
\DWATisoptional,
\DWATlocation,
\DWATlowerbound,
\DWATmutable,
\DWATordering,
\DWATpicturestring,
\DWATprototyped,
\DWATrank,
\DWATreference,
\DWATrvaluereference,
\DWATsmall,
\DWATsegment,
\DWATstringlength,
\DWATstringlengthbitsize,
\DWATstringlengthbytesize,
\DWATthreadsscaled,
\DWATupperbound,
\DWATuselocation,
\DWATuseUTFeight,
\DWATvariableparameter,
\DWATvirtuality,
\DWATvisibility,
\DWATvtableelemlocation
}
\end{center}
\simplerule[\textwidth]
\end{table}

Note that except for the initial 
\DWATname{} attribute,
\addtoindexx{name attribute}
attributes are appended in order according to the alphabetical
spelling of their identifier.

If an implementation defines any vendor-specific attributes,
any such attributes that are essential to the definition of
the type are also included at the end of the above list,
in their own alphabetical suborder.

An attribute that refers to another type entry T is processed
as follows: 
\begin{enumerate}[ a)]
\item
\bb
If 
\eb
T is in the list V at some V[x], use the
letter 'R' as the marker and use the unsigned LEB128\addtoindexx{LEB128!unsigned}
encoding of x as the attribute value.

\item
\bb
Otherwise, append type T to the list V, then
\eb
use the letter 'T'
as the marker, process the type T recursively by performing
Steps 2 through 7, and use the result as the attribute value.
\end{enumerate}

\needlines{4}
Other attribute values use the letter 'A' as the marker, and
the value consists of the form code (encoded as an unsigned
LEB128 value) followed by the encoding of the value according
to the form code. To ensure reproducibility of the signature,
the set of forms used in the signature computation is limited
to the following: 
\DWFORMsdata, 
\DWFORMflag, 
\DWFORMstring,
\DWFORMexprloc,
and \DWFORMblock.

\item If the tag in Step 3 is one of \DWTAGpointertype,
\DWTAGreferencetype, 
\DWTAGrvaluereferencetype,
\DWTAGptrtomembertype, 
or \DWTAGfriend, and the referenced
type (via the \DWATtype{} or 
\DWATfriend{} attribute) has a
\DWATname{} attribute, append to S the letter 'N', the DWARF
attribute code (\DWATtype{} or 
\DWATfriend), the context of
the type (according to the method in Step 2), the letter 'E',
and the name of the type. For \DWTAGfriend, if the referenced
entry is a \DWTAGsubprogram, the context is omitted and the
name to be used is the ABI-specific name of the subprogram
(for example, the mangled linker name).

\needlines{6}
\item If the tag in Step 3 is not one of \DWTAGpointertype,
\DWTAGreferencetype, 
\DWTAGrvaluereferencetype,
\DWTAGptrtomembertype, or 
\DWTAGfriend, but has
a \DWATtype{} attribute, or if the referenced type (via
the \DWATtype{} or 
\DWATfriend{} attribute) does not have a
\DWATname{} attribute, the attribute is processed according to
the method in Step 4 for an attribute that refers to another
type entry.


\item Visit each child C of the debugging information
entry as follows: If C is a nested type entry or a member
function entry, and has 
a \DWATname{} attribute, append to
\addtoindexx{name attribute}
S the letter 'S', the tag of C, and its name; otherwise,
process C recursively by performing Steps 3 through 7,
appending the result to S. Following the last child (or if
there are no children), append a zero byte.
\end{enumerate}



For the purposes of this algorithm, if a debugging information
entry S has a 
\DWATspecification{} 
attribute that refers to
another entry D (which has a 
\DWATdeclaration{} 
attribute),
then S inherits the attributes and children of D, and S is
processed as if those attributes and children were present in
the entry S. Exception: if a particular attribute is found in
both S and D, the attribute in S is used and the corresponding
one in D is ignored.

\needlines{4}
DWARF tag and attribute codes are appended to the sequence
as unsigned LEB128\addtoindexx{LEB128!unsigned} values, 
using the values defined earlier in this chapter.

\textit{A grammar describing this computation may be found in
Appendix \refersec{app:typesignaturecomputationgrammar}.
}

\textit{An attribute that refers to another type entry is
recursively processed or replaced with the name of the
referent (in Step 4, 5 or 6). If neither treatment applies to
an attribute that references another type entry, the entry
that contains that attribute is not suitable for a
separate \addtoindex{type unit}.}

\textit{If a debugging information entry contains an attribute from
the list above that would require an unsupported form, that
entry is not suitable for a separate 
\addtoindex{type unit}.}

\textit{A type is suitable for a separate 
\addtoindex{type unit} only
if all of the type entries that it contains or refers to in
Steps 6 and 7 are themselves suitable for a separate
\addtoindex{type unit}.}

\needlines{4}
Where the DWARF producer may reasonably choose two or more
different forms for a given attribute, it should choose
the simplest possible form in computing the signature. (For
example, a constant value should be preferred to a location
expression when possible.)

Once the string S has been formed from the DWARF encoding,
an 16-byte \MDfive{} digest is computed for the string and the 
last eight bytes are taken as the type signature.

\textit{The string S is intended to be a flattened representation of
the type that uniquely identifies that type (that is, a different
type is highly unlikely to produce the same string).}

\needlines{6}
\textit{A debugging information entry is not be placed in a
separate \addtoindex{type unit}
if any of the following apply:}

\begin{itemize}

\item \textit{The entry has an attribute whose value is a location
description, and the location description 
contains a reference to
another debugging information entry (for example, a \DWOPcallref{}
operator), as it is unlikely that the entry will remain
identical across compilation units.}

\item \textit{The entry has an attribute whose value refers
to a code location or a \addtoindex{location list}.}

\item \textit{The entry has an attribute whose value refers
to another debugging information entry that does not represent
a type.}
\end{itemize}


\needlines{4}
\textit{Certain attributes are not included in the type signature:}

\begin{itemize}
\item \textit{The \DWATdeclaration{} attribute is not included because it
indicates that the debugging information entry represents an
incomplete declaration, and incomplete declarations should
not be placed in 
\addtoindexx{type unit}
separate type units.}

\item \textit{The \DWATdescription{} attribute is not included because
it does not provide any information unique to the defining
declaration of the type.}

\item \textit{The \DWATdeclfile, 
\DWATdeclline, and
\DWATdeclcolumn{} attributes are not included because they
may vary from one source file to the next, and would prevent
two otherwise identical type declarations from producing the
same \MDfive{} digest.}

\item \textit{The \DWATobjectpointer{} attribute is not included 
because the information it provides is not necessary for the 
computation of a unique type signature.}

\end{itemize}

\textit{Nested types and some types referred to by a debugging 
information entry are encoded by name rather than by recursively 
encoding the type to allow for cases where a complete definition 
of the type might not be available in all compilation units.}

%\needlines{4}
\textit{If a type definition contains the definition of a member function, 
it cannot be moved as is into a type unit, because the member function 
contains attributes that are unique to that compilation unit. 
Such a type definition can be moved to a type unit by rewriting the 
debugging information entry tree, 
moving the member function declaration into a separate declaration tree, 
and replacing the function definition in the type with a non-defining 
declaration of the function (as if the function had been defined out of 
line).}

An example that illustrates the computation of an \MDfive{} digest may be found in 
Appendix \refersec{app:usingtypeunits}.

\section{Name Table Hash Function}
\label{datarep:nametablehashfunction}
The hash function used for hashing name strings in the accelerated 
access name index table (see Section \refersec{chap:acceleratedaccess})
is defined in \addtoindex{C} as shown in 
Figure \referfol{fig:nametablehashfunctiondefinition}.\footnoteRR{
This hash function is sometimes known as the 
"\addtoindex{Bernstein hash function}" or the
"\addtoindex{DJB hash function}"  
(see, for example, 
\hrefself{http://en.wikipedia.org/wiki/List\_of\_hash\_functions} or
\hrefself{http://stackoverflow.com/questions/10696223/reason-for-5381-number-in-djb-hash-function)}.} 

\begin{figure}[ht]
\begin{lstlisting}

uint32_t /* must be a 32-bit integer type */
    hash(unsigned char *str)
    {
        uint32_t hash = 5381;
        int c;

        while (c = *str++)
            hash = hash * 33 + c;

        return hash;
    }

\end{lstlisting}
\caption{Name Table Hash Function Definition}
\label{fig:nametablehashfunctiondefinition}
\end{figure}

