\chapter{Examples (Informative)}
\label{app:examplesinformative}F

The following sections provide examples that illustrate
various aspects of the DWARF debugging information format.


\section{ Compilation Units and Abbreviations Table Example}F
\label{app:compilationunitsandabbreviationstableexample}


Figure \refersec{fig:compilationunitsandabbreviationstable}
depicts the relationship of the abbreviations tables contained
\addtoindexx{abbreviations table!example}
\addtoindexx{\texttt{.debug\_abbrev}!example}
\addtoindexx{\texttt{.debug\_info}!example}
in the \dotdebugabbrev{}
section to the information contained in
the \dotdebuginfo{}
section. Values are given in symbolic form,
where possible.

The figure corresponds to the following two trivial source files:

File myfile.c
\begin{lstlisting}[numbers=none]
typedef char* POINTER;
\end{lstlisting}
File myfile2.c
\begin{lstlisting}[numbers=none]
typedef char* strp;
\end{lstlisting}

% Ensures we get the following float out before we go on.
\clearpage
\begin{figure}[here]
%\centering
%\setlength{\linewidth}{1.1\linewidth}
\begin{minipage}[t]{0.03\linewidth}
\flushright
\scriptsize
% Note: alltt is used to step down the needed number of lines to the labels
\begin{alltt}




















\textit{e1:}




\textit{e2:}
\end{alltt}
\end{minipage}
%
\begin{minipage}[t]{0.38\linewidth}
\centering
Compilation Unit \#1: \dotdebuginfo{}
\begin{framed}
\scriptsize
\begin{alltt}
\textit{length}
4
\textit{a1 (abbreviations table offset)}
4
\vspace{0.01cm}
\hrule
1
"myfile.c"
"Best Compiler Corp, V1.3"
"/home/mydir/src"
\livelink{chap:DWLANGC89}{DW\_LANG\_C89}
0x0
0x55
\livelink{chap:DWFORMsecoffset}{DW\_FORM\_sec\_offset}
0x0
\vspace{0.01cm}
\hrule
2
"char"
\livelink{chap:DWATEunsignedchar}{DW\_ATE\_unsigned\_char}
1
\vspace{0.01cm}
\hrule
3
\textit{e1  (debug info offset)}
\vspace{0.01cm}
\hrule
4
"POINTER"
\textit{e2  (debug info offset)}
\vspace{0.01cm}
\hrule
0
\end{alltt}
%
%
\end{framed}
Compilation Unit \#2: \dotdebuginfo{}
\begin{framed}
\scriptsize
\begin{alltt}
\textit{length}
4
\textit{a1 (abbreviations table offset)}
4
\vspace{0.01cm}
\hrule
...
\vspace{0.01cm}
\hrule
4
"strp"
\textit{e2  (debug info offset)}
\vspace{0.01cm}
\hrule
...
\end{alltt}
%
%
\end{framed}
\end{minipage}
\hfill 
% Place the label for the abbreviation table
\begin{minipage}[t]{0.03\linewidth}
\flushright
\scriptsize
% Note: alltt is used to step down the needed number of lines to the label
\begin{alltt}





\textit{a1:}
\end{alltt}
\end{minipage}
%
\begin{minipage}[t]{0.41\linewidth}
\centering
Abbreviation Table: \dotdebugabbrev{}
\begin{framed}
\scriptsize
\begin{alltt}\vspace{0.06cm}
1
\livelink{chap:DWTAGcompileunit}{DW\_TAG\_compile\_unit}
\livelink{chap:DWCHILDRENyes}{DW\_CHILDREN\_yes}
\livelink{chap:DWATname}{DW\_AT\_name}       \livelink{chap:DWFORMstring}{DW\_FORM\_string}
\livelink{chap:DWATproducer}{DW\_AT\_producer}   \livelink{chap:DWFORMstring}{DW\_FORM\_string}
\livelink{chap:DWATcompdir}{DW\_AT\_comp\_dir}   \livelink{chap:DWFORMstring}{DW\_FORM\_string}
\livelink{chap:DWATlanguage}{DW\_AT\_language}   \livelink{chap:DWFORMdata1}{DW\_FORM\_data1}
\livelink{chap:DWATlowpc}{DW\_AT\_low\_pc}     \livelink{chap:DWFORMaddr}{DW\_FORM\_addr}
\livelink{chap:DWAThighpc}{DW\_AT\_high\_pc}    \livelink{chap:DWFORMdata1}{DW\_FORM\_data1}
\livelink{chap:DWATstmtlist}{DW\_AT\_stmt\_list}  \livelink{chap:DWFORMindirect}{DW\_FORM\_indirect}
0
\vspace{0.01cm}
\hrule
2
\livelink{chap:DWTAGbasetype}{DW\_TAG\_base\_type}
\livelink{chap:DWCHILDRENno}{DW\_CHILDREN\_no}
\livelink{chap:DWATname}{DW\_AT\_name}       \livelink{chap:DWFORMstring}{DW\_FORM\_string}
\livelink{chap:DWATencoding}{DW\_AT\_encoding}   \livelink{chap:DWFORMdata1}{DW\_FORM\_data1}
\livelink{chap:DWATbytesize}{DW\_AT\_byte\_size}  \livelink{chap:DWFORMdata1}{DW\_FORM\_data1}
0
\vspace{0.01cm}
\hrule
3
\livelink{chap:DWTAGpointertype}{DW\_TAG\_pointer\_type}
\livelink{chap:DWCHILDRENno}{DW\_CHILDREN\_no}
\livelink{chap:DWATtype}{DW\_AT\_type}       \livelink{chap:DWFORMref4}{DW\_FORM\_ref4}
0
\vspace{0.01cm}
\hrule
4
\livelink{chap:DWTAGtypedef}{DW\_TAG\_typedef}
\livelink{chap:DWCHILDRENno}{DW\_CHILDREN\_no}
\livelink{chap:DWATname}{DW\_AT\_name}      \livelink{chap:DWFORMstring}{DW\_FORM\_string}
\livelink{chap:DWATtype}{DW\_AT\_type}      \livelink{chap:DWFORMrefaddr}{DW\_FORM\_ref\_addr}
0
\vspace{0.01cm}
\hrule
0
\end{alltt}
\end{framed}
\end{minipage}

\vspace{0.2cm}
\caption{Compilation units and abbreviations table} \label{fig:compilationunitsandabbreviationstable}
\end{figure}

% Ensures we get the above float out before we go on.
\clearpage

\section{Aggregate Examples}
\label{app:aggregateexamples}

The following examples illustrate how to represent some of
the more complicated forms of array and record aggregates
using DWARF.

\subsection{Fortran Array Example}
\label{app:fortranarrayexample}
Consider the \addtoindex{Fortran array}\addtoindexx{Fortran 90} source fragment in 
\addtoindexx{array type entry!examples}
Figure \referfol{fig:fortranarrayexamplesourcefragment}.

\begin{figure}[here]
\begin{lstlisting}
type array_ptr
real :: myvar
real, dimension (:), pointer :: ap
end type array_ptr
type(array_ptr), allocatable, dimension(:) :: arrayvar
allocate(arrayvar(20))
do i = 1, 20
allocate(arrayvar(i)%ap(i+10))
end do
\end{lstlisting}
\caption{Fortran array example: source fragment} \label{fig:fortranarrayexamplesourcefragment}
\end{figure}

For allocatable and pointer arrays, it is essentially required
by the \addtoindex{Fortran array} semantics that each array consist of 
\addtoindexx{descriptor!array}
two
\addtoindexx{array!descriptor for}
parts, which we here call 1) the descriptor and 2) the raw
data. (A descriptor has often been called a dope vector in
other contexts, although it is often a structure of some kind
rather than a simple vector.) Because there are two parts,
and because the lifetime of the descriptor is necessarily
longer than and includes that of the raw data, there must be
an address somewhere in the descriptor that points to the
raw data when, in fact, there is some (that is, when 
the \doublequote{variable} is allocated or associated).

For concreteness, suppose that a descriptor looks something
like the C structure in 
Figure \refersec{fig:fortranarrayexampledescriptorrepresentation}.
Note, however, that it is
a property of the design that 1) a debugger needs no builtin
knowledge of this structure and 2) there does not need to
be an explicit representation of this structure in the DWARF
input to the debugger.

\begin{figure}[here]
\begin{lstlisting}
struct desc {
    long el_len;       // Element length
    void * base;       // Address of raw data
    int ptr_assoc : 1; // Pointer is associated flag
    int ptr_alloc : 1; // Pointer is allocated flag
    int num_dims  : 6; // Number of dimensions
    struct dims_str {  // For each dimension...  
        long low_bound;
        long upper_bound;
        long stride;
    } dims[63];
};
\end{lstlisting}
\caption{Fortran array example: descriptor representation}
\label{fig:fortranarrayexampledescriptorrepresentation}
\end{figure}


In practice, of course, a \doublequote{real} descriptor will have
dimension substructures only for as many dimensions as are
specified in the \texttt{num\_dims} component. Let us use the notation
\texttt{desc\textless n\textgreater}   
to indicate a specialization of the \texttt{desc} struct in
which \texttt{n} is the bound for the \texttt{dims} component as well as the
contents of the \texttt{num\_dims} component.

Because the arrays considered here come in two parts, it is
necessary to distinguish the parts carefully. In particular,
the \doublequote{address of the variable} or equivalently, the \doublequote{base
address of the object} \emph{always} refers to the descriptor. For
arrays that do not come in two parts, an implementation can
provide a descriptor anyway, thereby giving it two parts. (This
may be convenient for general runtime support unrelated to
debugging.) In this case the above vocabulary applies as
stated. Alternatively, an implementation can do without a
descriptor, in which case the \doublequote{address of the variable,}
or equivalently the \doublequote{base address of the object}, refers
to the \doublequote{raw data} (the real data, the only thing around
that can be the object).

If an object has a descriptor, then the DWARF type for that
object will have a 
\livelink{chap:DWATdatalocation}{DW\_AT\_data\_location} 
attribute. If an object
does not have a descriptor, then usually the DWARF type for the
object will not have a 
\livelink{chap:DWATdatalocation}{DW\_AT\_data\_location}. 
(See the following
\addtoindex{Ada} example for a case where the type for an object without
a descriptor does have a 
\livelink{chap:DWATdatalocation}{DW\_AT\_data\_location} attribute. In
that case the object doubles as its own descriptor.)

The \addtoindex{Fortran} derived type \texttt{array\_ptr} can now be redescribed
in C\dash like terms that expose some of the representation as in

\begin{lstlisting}[numbers=none]
struct array_ptr {
    float myvar;
    desc<1> ap;
};
\end{lstlisting}

Similarly for variable \texttt{arrayvar}:
\begin{lstlisting}[numbers=none]
desc<1> arrayvar;
\end{lstlisting}

(Recall that \texttt{desc\textless 1\textgreater} 
indicates the 1\dash dimensional version of \texttt{desc}.)

\newpage
Finally, the following notation is useful:
\begin{enumerate}[1. ]
\item  sizeof(type): size in bytes of entities of the given type
\item offset(type, comp): offset in bytes of the comp component
within an entity of the given type
\end{enumerate}

The DWARF description is shown 
\addtoindexx{Fortran 90}
in Figure \refersec{fig:fortranarrayexampledwarfdescription}.

\begin{figure}[h]
\figurepart{1}{2}
\begin{dwflisting}
\begin{alltt}
! Description for type of 'ap'
!
1\$: \livelink{chap:DWTAGarraytype}{DW\_TAG\_array\_type}
        ! No name, default (Fortran) ordering, default stride
        \livelink{chap:DWATtype}{DW\_AT\_type}(reference to REAL)
        \livelink{chap:DWATassociated}{DW\_AT\_associated}(expression= ! Test 'ptr\_assoc' \nolink{flag}
            \livelink{chap:DWOPpushobjectaddress}{DW\_OP\_push\_object\_address}
            \DWOPlitn              ! where n == offset(ptr\_assoc)
            \livelink{chap:DWOPplus}{DW\_OP\_plus}
            \livelink{chap:DWOPderef}{DW\_OP\_deref}
            \livelink{chap:DWOPlit1}{DW\_OP\_lit1}              ! mask for 'ptr\_assoc' \nolink{flag}
            \livelink{chap:DWOPand}{DW\_OP\_and})
        \livelink{chap:DWATdatalocation}{DW\_AT\_data\_location}(expression= ! Get raw data address
            \livelink{chap:DWOPpushobjectaddress}{DW\_OP\_push\_object\_address}
            \DWOPlitn              ! where n == offset(base)
            \livelink{chap:DWOPplus}{DW\_OP\_plus}
            \livelink{chap:DWOPderef}{DW\_OP\_deref})            ! Type of index of array 'ap'
2\$:     \livelink{chap:DWTAGsubrangetype}{DW\_TAG\_subrange\_type}
            ! No name, default stride
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to INTEGER)
            \livelink{chap:DWATlowerbound}{DW\_AT\_lower\_bound}(expression=
                \livelink{chap:DWOPpushobjectaddress}{DW\_OP\_push\_object\_address}
                \DWOPlitn          ! where n ==
                                    !   offset(desc, dims) +
                                    !   offset(dims\_str, lower\_bound)
                \livelink{chap:DWOPplus}{DW\_OP\_plus}
                \livelink{chap:DWOPderef}{DW\_OP\_deref})
            \livelink{chap:DWATupperbound}{DW\_AT\_upper\_bound}(expression=
                \livelink{chap:DWOPpushobjectaddress}{DW\_OP\_push\_object\_address}
                \DWOPlitn          ! where n ==
                                    !   offset(desc, dims) +
                                    !   offset(dims\_str, upper\_bound)
                \livelink{chap:DWOPplus}{DW\_OP\_plus}
                \livelink{chap:DWOPderef}{DW\_OP\_deref})
            !  Note: for the m'th dimension, the second operator becomes
            !  \DWOPlitn where
            !       n == offset(desc, dims)          +
            !                (m-1)*sizeof(dims\_str)  +
            !                 offset(dims\_str, [lower|upper]\_bound)
            !  That is, the expression does not get longer for each successive 
            !  dimension (other than to express the larger offsets involved).
\end{alltt}
\end{dwflisting}
\caption{Fortran array example: DWARF description}
\label{fig:fortranarrayexampledwarfdescription}
\end{figure}

\begin{figure}
\figurepart{2}{2}
\begin{dwflisting}
\begin{alltt}
3\$: \livelink{chap:DWTAGstructuretype}{DW\_TAG\_structure\_type}
        \livelink{chap:DWATname}{DW\_AT\_name}("array\_ptr")
        \livelink{chap:DWATbytesize}{DW\_AT\_byte\_size}(constant sizeof(REAL) + sizeof(desc<1>))
4\$:     \livelink{chap:DWTAGmember}{DW\_TAG\_member}
            \livelink{chap:DWATname}{DW\_AT\_name}("myvar")
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to REAL)
            \livelink{chap:DWATdatamemberlocation}{DW\_AT\_data\_member\_location}(constant 0)
5\$:     \livelink{chap:DWTAGmember}{DW\_TAG\_member}
            \livelink{chap:DWATname}{DW\_AT\_name}("ap");
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 1\$)
            \livelink{chap:DWATdatamemberlocation}{DW\_AT\_data\_member\_location}(constant sizeof(REAL))
6\$: \livelink{chap:DWTAGarraytype}{DW\_TAG\_array\_type}
        ! No name, default (Fortran) ordering, default stride
        \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 3\$)
        \livelink{chap:DWATallocated}{DW\_AT\_allocated}(expression=     ! Test 'ptr\_alloc' \nolink{flag}
            \livelink{chap:DWOPpushobjectaddress}{DW\_OP\_push\_object\_address}
            \DWOPlitn                  ! where n == offset(ptr\_alloc)
            \livelink{chap:DWOPplus}{DW\_OP\_plus}
            \livelink{chap:DWOPderef}{DW\_OP\_deref}
            \DWOPlittwo                  ! Mask for 'ptr\_alloc' \nolink{flag}
            \livelink{chap:DWOPand}{DW\_OP\_and})
        \livelink{chap:DWATdatalocation}{DW\_AT\_data\_location}(expression= ! Get raw data address
            \livelink{chap:DWOPpushobjectaddress}{DW\_OP\_push\_object\_address}
            \DWOPlitn                  ! where n == offset(base)
            \livelink{chap:DWOPplus}{DW\_OP\_plus}
            \livelink{chap:DWOPderef}{DW\_OP\_deref})
7\$:     \livelink{chap:DWTAGsubrangetype}{DW\_TAG\_subrange\_type}
            ! No name, default stride
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to INTEGER)
            \livelink{chap:DWATlowerbound}{DW\_AT\_lower\_bound}(expression=
                \livelink{chap:DWOPpushobjectaddress}{DW\_OP\_push\_object\_address}
                \DWOPlitn              ! where n == ...
                \livelink{chap:DWOPplus}{DW\_OP\_plus}
                \livelink{chap:DWOPderef}{DW\_OP\_deref})
            \livelink{chap:DWATupperbound}{DW\_AT\_upper\_bound}(expression=
                \livelink{chap:DWOPpushobjectaddress}{DW\_OP\_push\_object\_address}
                \DWOPlitn              ! where n == ...
                \livelink{chap:DWOPplus}{DW\_OP\_plus}
                \livelink{chap:DWOPderef}{DW\_OP\_deref})
8\$: \livelink{chap:DWTAGvariable}{DW\_TAG\_variable}
        \livelink{chap:DWATname}{DW\_AT\_name}("arrayvar")
        \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 6\$)
        \livelink{chap:DWATlocation}{DW\_AT\_location}(expression=
            ...as appropriate...)       ! Assume static allocation
\end{alltt}
\end{dwflisting}
\begin{center}

Figure~\ref{fig:fortranarrayexampledwarfdescription} Fortran array example: DWARF description \textit{(concluded)}
\end{center}
\end{figure}

Suppose 
\addtoindexx{Fortran array example}
the program is stopped immediately following completion
of the do loop. Suppose further that the user enters the
following debug command:

\begin{lstlisting}[numbers=none]
debug> print arrayvar(5)%ap(2)
\end{lstlisting}

Interpretation of this expression proceeds as follows:
\begin{enumerate}[1. ]

\item Lookup name \texttt{arrayvar}. We find that it is a variable,
whose type is given by the unnamed type at 6\$. Notice that
the type is an array type.


\item Find the 5$^{th}$ element of that array object. To do array
indexing requires several pieces of information:
\begin{enumerate}[a) ]

\item  the address of the array data

\item the lower bounds of the array \\
% Using plain [] here gives trouble.
\lbrack To check that 5 is within bounds would require the upper
bound too, but we will skip that for this example. \rbrack

\item the stride 

\end{enumerate}

For a), check for a 
\livelink{chap:DWATdatalocation}{DW\_AT\_data\_location} attribute. 
Since there is one, go execute the expression, whose result is
the address needed. The object address used in this case
is the object we are working on, namely the variable named
\texttt{arrayvar}, whose address was found in step 1. (Had there been
no \livelink{chap:DWATdatalocation}{DW\_AT\_data\_location} attribute, the desired address would
be the same as the address from step 1.)

For b), for each dimension of the array (only one
in this case), go interpret the usual lower bound
attribute. Again this is an expression, which again begins
with \livelink{chap:DWOPpushobjectaddress}{DW\_OP\_push\_object\_address}. This object is 
\textbf{still} \texttt{arrayvar},
from step 1, because we have not begun to actually perform
any indexing yet.

For c), the default stride applies. Since there is no
\livelink{chap:DWATbytestride}{DW\_AT\_byte\_stride} attribute, use the size of the array element
type, which is the size of type \texttt{array\_ptr} (at 3\$).

\clearpage

Having acquired all the necessary data, perform the indexing
operation in the usual manner--which has nothing to do with
any of the attributes involved up to now. Those just provide
the actual values used in the indexing step.

The result is an object within the memory that was dynamically
allocated for \texttt{arrayvar}.

\item  Find the \texttt{ap} component of the object just identified,
whose type is \texttt{array\_ptr}.

This is a conventional record component lookup and
interpretation. It happens that the \texttt{ap} component in this case
begins at offset 4 from the beginning of the containing object.
Component \texttt{ap} has the unnamed array type defined at 1\$ in the
symbol table.

\item  Find the second element of the array object found in step 3. To do array indexing requires
several pieces of information:
\begin{enumerate}[a) ]
\item  the address of the array storage

\item  the lower bounds of the array \\
% Using plain [] here gives trouble.
\lbrack To check that 2 is within bounds we would require the upper
bound too, but we will skip that for this example \rbrack

\item  the stride

\end{enumerate}
\end{enumerate}

This is just like step 2), so the details are omitted. Recall
that because the DWARF type 1\$ has a \livelink{chap:DWATdatalocation}{DW\_AT\_data\_location},
the address that results from step 4) is that of a
descriptor, and that address is the address pushed by the
\livelink{chap:DWOPpushobjectaddress}{DW\_OP\_push\_object\_address} operations in 1\$ and 2\$.

Note: we happen to be accessing a pointer array here instead
of an allocatable array; but because there is a common
underlying representation, the mechanics are the same. There
could be completely different descriptor arrangements and the
mechanics would still be the same---only the stack machines
would be different.

%\needlines{8}
\subsection{Fortran Coarray Examples}
\label{app:Fortrancoarrayexamples}

\subsubsection{Fortran Scalar Coarray Example}
The \addtoindex{Fortran} scalar coarray example
\addtoindexx{coarray!example}\addtoindexx{scalar coarray|see{coarray}}
in Figure \refersec{fig:Fortranscalarcoarraysourcefragment} can be described as 
illustrated in Figure \refersec{fig:FortranscalarcoarrayDWARFdescription}.

\begin{figure}[!h]
\begin{lstlisting}
        INTEGER X[*]
\end{lstlisting}
\caption{Fortran scalar coarray: source fragment}
\label{fig:Fortranscalarcoarraysourcefragment}
\end{figure}

\begin{figure}[!h]
\begin{dwflisting}
\begin{alltt}
10\$:  \DWTAGcoarraytype
        \DWATtype(reference to INTEGER)
        \DWTAGsubrangetype                ! Note omitted upper bound			
            \DWATlowerbound(constant 1)

11\$:  \DWTAGvariable
        \DWATname("X")
        \DWATtype(reference to coarray type at 10\$)
\end{alltt}
\end{dwflisting}
\caption{Fortran scalar coarray: DWARF description}
\label{fig:FortranscalarcoarrayDWARFdescription}
\end{figure}

\subsubsection{Fortran Array Coarray Example}
The \addtoindex{Fortran} (simple) array coarray example
\addtoindexx{coarray!example}\addtoindexx{array coarray|see{coarray}}
in Figure \refersec{fig:Fortranarraycoarraysourcefragment} can be described as 
illustrated in Figure \refersec{fig:FortranarraycoarrayDWARFdescription}.

\begin{figure}[here]
\begin{lstlisting}
        INTEGER X(10)[*]
\end{lstlisting}
\caption{Fortran array coarray: source fragment}
\label{fig:Fortranarraycoarraysourcefragment}
\end{figure}

\begin{figure}[here]
\begin{dwflisting}
\begin{alltt}
10\$: \DWTAGarraytype
        \DWATordering(\DWORDcolmajor)
        \DWATtype(reference to INTEGER)
11\$:    \DWTAGsubrangetype
            \DWATlowerbound(constant 1)
            \DWATupperbound(constant 10)

12\$: \DWTAGcoarraytype
        \DWATtype(reference to array type at 10\$)
13\$:    \DWTAGsubrangetype                ! Note omitted upper bound
            \DWATlowerbound(constant 1)

14$: \DWTAGvariable
        \DWATname("X")
        \DWATtype(reference to coarray type at 12\$)
\end{alltt}
\end{dwflisting}
\caption{Fortran array coarray: DWARF description}
\label{fig:FortranarraycoarrayDWARFdescription}
\end{figure}

\subsubsection{Fortran Multidimensional Coarray Example}
The \addtoindex{Fortran} multidimensional coarray of a multidimensional array example
\addtoindexx{coarray!example}\addtoindexx{array coarray|see{coarray}}
in Figure \refersec{fig:Fortranmultidimensionalcoarraysourcefragment} can be described as 
illustrated in Figure \refersec{fig:FortranmultidimensionalcoarrayDWARFdescription}.

\begin{figure}[here]
\begin{lstlisting}
        INTEGER X(10,11,12)[2,3,*]
\end{lstlisting}
\caption{Fortran multidimentional coarray: source fragment}
\label{fig:Fortranmultidimensionalcoarraysourcefragment}
\end{figure}

\begin{figure}[here]
\begin{dwflisting}
\begin{alltt}
10\$: \DWTAGarraytype
        \DWATordering(\DWORDcolmajor)
        \DWATtype(reference to INTEGER)
11\$:    \DWTAGsubrangetype
            \DWATlowerbound(constant 1)
            \DWATupperbound(constant 10)
12\$:    \DWTAGsubrangetype
            \DWATlowerbound(constant  1)
            \DWATupperbound(constant 11)
13\$:    \DWTAGsubrangetype
            \DWATlowerbound(constant  1)
            \DWATupperbound(constant 12)

14\$: \DWTAGcoarraytype
        \DWATtype(reference to array_type at 10\$)
15\$:    \DWTAGsubrangetype
            \DWATlowerbound(constant 1)
            \DWATupperbound(constant 2)
16\$:    \DWTAGsubrangetype
            \DWATlowerbound(constant 1)
            \DWATupperbound(constant 3)
17\$:    \DWTAGsubrangetype                ! Note omitted upper bound
            \DWATlowerbound(constant 1)

18\$: \DWTAGvariable
        \DWATname("X")
        \DWATtype(reference to coarray type at 14\$)
\end{alltt}
\end{dwflisting}
\caption{Fortran multidimensional coarray: DWARF description}
\label{fig:FortranmultidimensionalcoarrayDWARFdescription}
\end{figure}


\clearpage
\subsection{Fortran 2008 Assumed-rank Array Example}
\label{app:assumedrankexample}
\addtoindexx{array!assumed-rank}
Consider the example in Figure~\ref{fig:assumedrankdecl}, which shows
an assumed-rank array in Fortran~2008 with
supplement~29113:\footnote{Technical Specification ISO/IEC TS
  29113:2012 \emph{Further Interoperability of Fortran with C}}

\begin{figure}[!h]
\begin{lstlisting}
  subroutine foo(x)
    real :: x(..)

    ! x has n dimensions
  
  end subroutine
\end{lstlisting}
\caption{Declaration of a Fortran 2008 assumed-rank array}
\label{fig:assumedrankdecl}
\end{figure}

Let's assume the Fortran compiler used an array descriptor that
(in \addtoindex{C}) looks
like the one shown in Figure~\ref{fig:arraydesc}.

\begin{figure}[!h]
\begin{lstlisting}
  struct array_descriptor {
    void *base_addr;
    int rank;
    struct dim dims[]; 
  }

  struct dim {
     int lower_bound;
     int upper_bound;
     int stride;
     int flags;
  }
\end{lstlisting}
\caption{One of many possible layouts for an array descriptor}
\label{fig:arraydesc}
\end{figure}

The DWARF type for the array \emph{x} can be described as shown in
Figure~\refersec{fig:assumedrankdwarf}.

\begin{figure}[!h]
\begin{dwflisting}
\begin{alltt}
10\$:  \DWTAGarraytype
         \DWATtype(reference to real)
         \DWATrank(expression=
             \DWOPpushobjectaddress
             \DWOPlitn                ! offset of rank in descriptor>
             \DWOPplus
             \DWOPderef)
         \DWATdatalocation(expression=
             \DWOPpushobjectaddress
             \DWOPlitn                ! offset of data in descriptor>
             \DWOPplus
             \DWOPderef)
11\$:    \DWTAGgenericsubrange
             \DWATtype(reference to integer)
             \DWATlowerbound(expression=
             !   Looks up the lower bound of dimension i.
             !   Operation                           ! Stack effect
             !   (implicit)                          ! i                                                                     
                 \DWOPlitn                          ! i sizeof(dim)
                 \DWOPmul                           ! dim[i]
                 \DWOPlitn                          ! dim[i] offsetof(dim)
                 \DWOPplus                          ! dim[i]+offset
                 \DWOPpushobjectaddress           ! dim[i]+offsetof(dim) objptr
                 \DWOPplus                          ! objptr.dim[i]
                 \DWOPlitn                          ! objptr.dim[i] offsetof(lb)
                 \DWOPplus                          ! objptr.dim[i].lowerbound
                 \DWOPderef)                        ! *objptr.dim[i].lowerbound
             \DWATupperbound(expression=
             !   Looks up the upper bound of dimension i.
                 \DWOPlitn                          ! sizeof(dim)
                 \DWOPmul
                 \DWOPlitn                          ! offsetof(dim)
                 \DWOPplus
                 \DWOPpushobjectaddress
                 \DWOPplus
                 \DWOPlitn                          ! offset of upperbound in dim
                 \DWOPplus
                 \DWOPderef)
             \DWATbytestride(expression=
             !   Looks up the byte stride of dimension i.
                 ...
             !   (analogous to DW\_AT\_upper\_bound)
                 )
\end{alltt}
\end{dwflisting}
\caption{Sample DWARF for the array descriptor in Figure~\ref{fig:arraydesc}}
\label{fig:assumedrankdwarf}
\end{figure}

The layout of the array descriptor is not specified by the Fortran
standard unless the array is explicitly marked as \addtoindex{C-interoperable}. To
get the bounds of an assumed-rank array, the expressions in the
\DWTAGgenericsubrange
entry need to be evaluated for each of the
\DWATrank{} dimensions as shown by the pseudocode in
Figure~\refersec{fig:assumedrankdwarfparser}.

\begin{figure}[!h]
\begin{lstlisting}
    typedef struct {
        int lower, upper, stride;
    } dims_t;

    typedef struct {
        int rank;
    struct dims_t *dims;
    } array_t;

    array_t get_dynamic_array_dims(DW_TAG_array a) {
      array_t result;

      // Evaluate the DW_AT_rank expression to get the 
      //    number of dimensions.
      dwarf_stack_t stack;
      dwarf_eval(stack, a.rank_expr);
      result.rank = dwarf_pop(stack); 
      result.dims = new dims_t[rank];

      // Iterate over all dimensions and find their bounds.
      for (int i = 0; i < result.rank; i++) {
        // Evaluate the generic subrange's DW_AT_lower 
        //    expression for dimension i.
        dwarf_push(stack, i);
        assert( stack.size == 1 );
        dwarf_eval(stack, a.generic_subrange.lower_expr);
        result.dims[i].lower = dwarf_pop(stack);
        assert( stack.size == 0 );

        dwarf_push(stack, i);
        dwarf_eval(stack, a.generic_subrange.upper_expr);
        result.dims[i].upper = dwarf_pop(stack);
    
        dwarf_push(stack, i);
        dwarf_eval(stack, a.generic_subrange.byte_stride_expr);
        result.dims[i].stride = dwarf_pop(stack);
      }
      return result;
    }
\end{lstlisting}
\caption{How to interpret the DWARF from Figure~\ref{fig:assumedrankdwarf}}
\label{fig:assumedrankdwarfparser}
\end{figure}



\clearpage
\subsection{Ada Example}
\label{app:adaexample}
Figure \refersec{fig:adaexamplesourcefragment}
illustrates two kinds of \addtoindex{Ada} 
parameterized array, one embedded in a record.

\begin{figure}[here]
\begin{lstlisting}
M : INTEGER := <exp>;
VEC1 : array (1..M) of INTEGER;
subtype TEENY is INTEGER range 1..100;
type ARR is array (INTEGER range <>) of INTEGER;
type REC2(N : TEENY := 100) is record
    VEC2 : ARR(1..N);
end record;

OBJ2B : REC2;
\end{lstlisting}
\caption{Ada example: source fragment}
\label{fig:adaexamplesourcefragment}
\end{figure}

\texttt{VEC1} illustrates an (unnamed) array type where the upper bound
of the first and only dimension is determined at runtime. 
\addtoindex{Ada}
semantics require that the value of an array bound is fixed at
the time the array type is elaborated (where \textit{elaboration} refers
to the runtime executable aspects of type processing). For
the purposes of this example, we assume that there are no
other assignments to \texttt{M} so that it safe for the \texttt{REC1} type
description to refer directly to that variable (rather than
a compiler-generated copy).

\texttt{REC2} illustrates another array type (the unnamed type of
component \texttt{VEC2}) where the upper bound of the first and only
bound is also determined at runtime. In this case, the upper
bound is contained in a discriminant of the containing record
type. (A \textit{discriminant} is a component of a record whose value
cannot be changed independently of the rest of the record
because that value is potentially used in the specification
of other components of the record.)

The DWARF description is shown in 
Figure \refersec{fig:adaexampledwarfdescription}.


Interesting aspects about this example are:
\begin{enumerate}[1. ]
\item The array \texttt{VEC2} is \doublequote{immediately} contained within structure
\texttt{REC2} (there is no intermediate descriptor or indirection),
which is reflected in the absence of a \livelink{chap:DWATdatalocation}{DW\_AT\_data\_location}
attribute on the array type at 28\$.

\item One of the bounds of \texttt{VEC2} is nonetheless dynamic and part of
the same containing record. It is described as a reference to
a member, and the location of the upper bound is determined
as for any member. That is, the location is determined using
an address calculation relative to the base of the containing
object.  

A consumer must notice that the referenced bound is a
member of the same containing object and implicitly push the
base address of the containing object just as for accessing
a data member generally.

\item The lack of a subtype concept in DWARF means that DWARF types
serve the role of subtypes and must replicate information from
what should be the parent type. For this reason, DWARF for
the unconstrained array type \texttt{ARR} is not needed for the purposes
of this example and therefore is not shown.
\end{enumerate}

\begin{figure}[p]
\begin{dwflisting}
\begin{alltt}
11\$: \livelink{chap:DWTAGvariable}{DW\_TAG\_variable}
        \livelink{chap:DWATname}{DW\_AT\_name}("M")
        \livelink{chap:DWATtype}{DW\_AT\_type}(reference to INTEGER)
12\$: \livelink{chap:DWTAGarraytype}{DW\_TAG\_array\_type}
        ! No name, default (\addtoindex{Ada}) order, default stride
        \livelink{chap:DWATtype}{DW\_AT\_type}(reference to INTEGER)
13\$:    \livelink{chap:DWTAGsubrangetype}{DW\_TAG\_subrange\_type}
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to INTEGER)
            \livelink{chap:DWATlowerbound}{DW\_AT\_lower\_bound}(constant 1)
            \livelink{chap:DWATupperbound}{DW\_AT\_upper\_bound}(reference to variable M at 11\$)
14\$: \livelink{chap:DWTAGvariable}{DW\_TAG\_variable}
        \livelink{chap:DWATname}{DW\_AT\_name}("VEC1")
        \livelink{chap:DWATtype}{DW\_AT\_type}(reference to array type at 12\$)
     . . .
21\$: \livelink{chap:DWTAGsubrangetype}{DW\_TAG\_subrange\_type}
        \livelink{chap:DWATname}{DW\_AT\_name}("TEENY")
        \livelink{chap:DWATtype}{DW\_AT\_type}(reference to INTEGER)
        \livelink{chap:DWATlowerbound}{DW\_AT\_lower\_bound}(constant 1)
        \livelink{chap:DWATupperbound}{DW\_AT\_upper\_bound}(constant 100)
     . . .
26\$: \livelink{chap:DWTAGstructuretype}{DW\_TAG\_structure\_type}
        \livelink{chap:DWATname}{DW\_AT\_name}("REC2")
27\$:    \livelink{chap:DWTAGmember}{DW\_TAG\_member}
            \livelink{chap:DWATname}{DW\_AT\_name}("N")
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to subtype TEENY at 21\$)
            \livelink{chap:DWATdatamemberlocation}{DW\_AT\_data\_member\_location}(constant 0)
28\$:    \livelink{chap:DWTAGarraytype}{DW\_TAG\_array\_type}
            ! No name, default (\addtoindex{Ada}) order, default stride
            ! Default data location
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to INTEGER)
29\$:        \livelink{chap:DWTAGsubrangetype}{DW\_TAG\_subrange\_type}
                \livelink{chap:DWATtype}{DW\_AT\_type}(reference to subrange TEENY at 21\$)
                \livelink{chap:DWATlowerbound}{DW\_AT\_lower\_bound}(constant 1)
                \livelink{chap:DWATupperbound}{DW\_AT\_upper\_bound}(reference to member N at 27\$)
30\$:    \livelink{chap:DWTAGmember}{DW\_TAG\_member}
            \livelink{chap:DWATname}{DW\_AT\_name}("VEC2")
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to array "subtype" at 28\$)
            \livelink{chap:DWATdatamemberlocation}{DW\_AT\_data\_member\_location}(machine=
                \DWOPlitn                  ! where n == offset(REC2, VEC2)
                \livelink{chap:DWOPplus}{DW\_OP\_plus})
     . . .
41\$: \livelink{chap:DWTAGvariable}{DW\_TAG\_variable}
        \livelink{chap:DWATname}{DW\_AT\_name}("OBJ2B")
        \livelink{chap:DWATtype}{DW\_AT\_type}(reference to REC2 at 26\$)
        \livelink{chap:DWATlocation}{DW\_AT\_location}(...as appropriate...)
\end{alltt}
\end{dwflisting}
\caption{Ada example: DWARF description}
\label{fig:adaexampledwarfdescription}
\end{figure}

\clearpage

\subsection{Pascal Example}
\label{app:pascalexample}
The Pascal \addtoindexx{Pascal example} source in 
Figure \referfol{fig:packedrecordexamplesourcefragment}
is used to illustrate the representation of packed unaligned
\addtoindex{bit fields}.

\begin{figure}[here]
\begin{lstlisting}
TYPE T : PACKED RECORD                  ! bit size is 2
         F5 : BOOLEAN;                  ! bit offset is 0
         F6 : BOOLEAN;                  ! bit offset is 1
         END;
VAR V :  PACKED RECORD
         F1 : BOOLEAN;                  ! bit offset is 0
         F2 : PACKED RECORD             ! bit offset is 1
              F3 : INTEGER;             ! bit offset is 0 in F2, 1 in V
              END;
         F4 : PACKED ARRAY [0..1] OF T; ! bit offset is 33
         F7 : T;                        ! bit offset is 37
         END;
\end{lstlisting}
\caption{Packed record example: source fragment}
\label{fig:packedrecordexamplesourcefragment}
\end{figure}

The DWARF representation in 
Figure \refersec{fig:packedrecordexampledwarfdescription} 
is appropriate. 
\livelink{chap:DWTAGpackedtype}{DW\_TAG\_packed\_type} entries could be added to
better represent the source, but these do not otherwise affect
the example and are omitted for clarity. Note that this same
representation applies to both typical big\dash \ and 
little\dash endian
architectures using the conventions described in 
Section \refersec{chap:datamemberentries}.

\begin{figure}[p]
\figurepart{1}{2}
\begin{dwflisting}
\begin{alltt}
10\$: \livelink{chap:DWTAGbasetype}{DW\_TAG\_base\_type}
        \livelink{chap:DWATname}{DW\_AT\_name}("BOOLEAN")
            ...
11\$: \livelink{chap:DWTAGbasetype}{DW\_TAG\_base\_type}
        \livelink{chap:DWATname}{DW\_AT\_name}("INTEGER")
            ...
20\$: \livelink{chap:DWTAGstructuretype}{DW\_TAG\_structure\_type}
        \livelink{chap:DWATname}{DW\_AT\_name}("T")
        \livelink{chap:DWATbitsize}{DW\_AT\_bit\_size}(2)
        \livelink{chap:DWTAGmember}{DW\_TAG\_member}
            \livelink{chap:DWATname}{DW\_AT\_name}("F5")
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 10$)
            \livelink{chap:DWATdatabitoffset}{DW\_AT\_data\_bit\_offset}(0)        ! may be omitted
            \livelink{chap:DWATbitsize}{DW\_AT\_bit\_size}(1)
        \livelink{chap:DWTAGmember}{DW\_TAG\_member}
            \livelink{chap:DWATname}{DW\_AT\_name}("F6")
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 10$)
            \livelink{chap:DWATdatabitoffset}{DW\_AT\_data\_bit\_offset}(1)
            \livelink{chap:DWATbitsize}{DW\_AT\_bit\_size}(1)
21\$: \livelink{chap:DWTAGstructuretype}{DW\_TAG\_structure\_type}                  ! anonymous type for F2
        \livelink{chap:DWTAGmember}{DW\_TAG\_member}
            \livelink{chap:DWATname}{DW\_AT\_name}("F3")
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 11\$)
22\$: \livelink{chap:DWTAGarraytype}{DW\_TAG\_array\_type}                      ! anonymous type for F4
        \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 20\$)
        \livelink{chap:DWTAGsubrangetype}{DW\_TAG\_subrange\_type}
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 11\$)
            \livelink{chap:DWATlowerbound}{DW\_AT\_lower\_bound}(0)
            \livelink{chap:DWATupperbound}{DW\_AT\_upper\_bound}(1)
        \livelink{chap:DWATbitstride}{DW\_AT\_bit\_stride}(2)
        \livelink{chap:DWATbitsize}{DW\_AT\_bit\_size}(4) \addtoindexx{bit size attribute}
23\$: \livelink{chap:DWTAGstructuretype}{DW\_TAG\_structure\_type}                  ! anonymous type for V
        \livelink{chap:DWATbitsize}{DW\_AT\_bit\_size}(39) \addtoindexx{bit size attribute}
        \livelink{chap:DWTAGmember}{DW\_TAG\_member}
            \livelink{chap:DWATname}{DW\_AT\_name}("F1")
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 10\$)
            \livelink{chap:DWATdatabitoffset}{DW\_AT\_data\_bit\_offset}(0)        ! may be omitted
            \livelink{chap:DWATbitsize}{DW\_AT\_bit\_size}(1) ! may be omitted
        \livelink{chap:DWTAGmember}{DW\_TAG\_member}
            \livelink{chap:DWATname}{DW\_AT\_name}("F2")
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 21\$)
            \livelink{chap:DWATdatabitoffset}{DW\_AT\_data\_bit\_offset}(1)
            \livelink{chap:DWATbitsize}{DW\_AT\_bit\_size}(32) ! may be omitted
        \livelink{chap:DWTAGmember}{DW\_TAG\_member}
            \livelink{chap:DWATname}{DW\_AT\_name}("F4")
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 22\$)
            \livelink{chap:DWATdatabitoffset}{DW\_AT\_data\_bit\_offset}(33)
            \livelink{chap:DWATbitsize}{DW\_AT\_bit\_size}(4) ! may be omitted
\end{alltt}
\end{dwflisting}
\caption{Packed record example: DWARF description}
\label{fig:packedrecordexampledwarfdescription}
\end{figure}

\begin{figure}[p]
\figurepart{2}{2}
\begin{dwflisting}
\begin{alltt}
        \livelink{chap:DWTAGmember}{DW\_TAG\_member}
            \livelink{chap:DWATname}{DW\_AT\_name}("F7")
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 20\$)    ! type T
            \livelink{chap:DWATdatabitoffset}{DW\_AT\_data\_bit\_offset}(37)
            \livelink{chap:DWATbitsize}{DW\_AT\_bit\_size}(2) \addtoindexx{bit size attribute}              ! may be omitted
     \livelink{chap:DWTAGvariable}{DW\_TAG\_variable}
        \livelink{chap:DWATname}{DW\_AT\_name}("V")
        \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 23\$)
        \livelink{chap:DWATlocation}{DW\_AT\_location}(...)
        ...
\end{alltt}
\end{dwflisting}
\begin{center}
Figure~\ref{fig:packedrecordexampledwarfdescription}: Packed record example: DWARF description \textit{(concluded)}
\end{center}
\end{figure}

\section{Namespace Example}
\label{app:namespaceexample}

The \addtoindex{C++} example in 
Figure \refersec{fig:namespaceexamplesourcefragment}
is used 
\addtoindexx{namespace (C++)!example}
to illustrate the representation of namespaces.
The DWARF representation in 
Figure \refersec{fig:namespaceexampledwarfdescription}
is appropriate.

\begin{figure}[p]
\begin{lstlisting}
namespace {
    int i;
}
namespace A {
    namespace B {
        int j;
        int   myfunc (int a);
        float myfunc (float f) { return f - 2.0; }
        int   myfunc2(int a)   { return a + 2; }
    }
}
namespace Y {
    using A::B::j;         // (1) using declaration
    int foo;
}
using A::B::j;             // (2) using declaration
namespace Foo = A::B;      // (3) namespace alias
using Foo::myfunc;         // (4) using declaration
using namespace Foo;       // (5) using directive
namespace A {
    namespace B {
        using namespace Y; // (6) using directive
        int k;
    }
}
int Foo::myfunc(int a)
{
    i = 3;
    j = 4;
    return myfunc2(3) + j + i + a + 2;
}
\end{lstlisting}
\caption{Namespace example: source fragment}
\label{fig:namespaceexamplesourcefragment}
\end{figure}


\begin{figure}[p]
\figurepart{1}{2}
\begin{dwflisting}
\begin{alltt}

1\$:  \livelink{chap:DWTAGbasetype}{DW\_TAG\_base\_type}
        \livelink{chap:DWATname}{DW\_AT\_name}("int")
        ...
2\$:  \livelink{chap:DWTAGbasetype}{DW\_TAG\_base\_type}
        \livelink{chap:DWATname}{DW\_AT\_name}("float")
        ...
6\$:  \livelink{chap:DWTAGnamespace}{DW\_TAG\_namespace}
        ! no \livelink{chap:DWATname}{DW\_AT\_name} attribute
7\$:
        \livelink{chap:DWTAGvariable}{DW\_TAG\_variable}
            \livelink{chap:DWATname}{DW\_AT\_name}("i")
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 1\$)
            \livelink{chap:DWATlocation}{DW\_AT\_location} ...
            ...
10\$: \livelink{chap:DWTAGnamespace}{DW\_TAG\_namespace}
        \livelink{chap:DWATname}{DW\_AT\_name}("A")
20\$:    \livelink{chap:DWTAGnamespace}{DW\_TAG\_namespace}
            \livelink{chap:DWATname}{DW\_AT\_name}("B")
30\$:        \livelink{chap:DWTAGvariable}{DW\_TAG\_variable}
                \livelink{chap:DWATname}{DW\_AT\_name}("j")
                \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 1\$)
                \livelink{chap:DWATlocation}{DW\_AT\_location} ...
                ...
34\$:        \livelink{chap:DWTAGsubprogram}{DW\_TAG\_subprogram}
                \livelink{chap:DWATname}{DW\_AT\_name}("myfunc")
                \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 1\$)
                ...
36\$:        \livelink{chap:DWTAGsubprogram}{DW\_TAG\_subprogram}
                \livelink{chap:DWATname}{DW\_AT\_name}("myfunc")
                \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 2\$)
                ...
38\$:        \livelink{chap:DWTAGsubprogram}{DW\_TAG\_subprogram}
                \livelink{chap:DWATname}{DW\_AT\_name}("myfunc2")
                \livelink{chap:DWATlowpc}{DW\_AT\_low\_pc} ...
                \livelink{chap:DWAThighpc}{DW\_AT\_high\_pc} ...
                \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 1\$)
                ...
\end{alltt}
\end{dwflisting}
\caption{Namespace example: DWARF description}
\label{fig:namespaceexampledwarfdescription}
\end{figure}

\begin{figure}
\figurepart{2}{2}
\begin{dwflisting}
\begin{alltt}
40\$: \livelink{chap:DWTAGnamespace}{DW\_TAG\_namespace}
        \livelink{chap:DWATname}{DW\_AT\_name}("Y")
        \livelink{chap:DWTAGimporteddeclaration}{DW\_TAG\_imported\_declaration}            ! (1) using-declaration
            \livelink{chap:DWATimport}{DW\_AT\_import}(reference to 30\$)
        \livelink{chap:DWTAGvariable}{DW\_TAG\_variable}
            \livelink{chap:DWATname}{DW\_AT\_name}("foo")
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 1\$)
            \livelink{chap:DWATlocation}{DW\_AT\_location} ...
            ...
     \livelink{chap:DWTAGimporteddeclaration}{DW\_TAG\_imported\_declaration}               ! (2) using declaration
        \livelink{chap:DWATimport}{DW\_AT\_import}(reference to 30\$)
        \livelink{chap:DWTAGimporteddeclaration}{DW\_TAG\_imported\_declaration}            ! (3) namespace alias
            \livelink{chap:DWATname}{DW\_AT\_name}("Foo")
            \livelink{chap:DWATimport}{DW\_AT\_import}(reference to 20\$)
        \livelink{chap:DWTAGimporteddeclaration}{DW\_TAG\_imported\_declaration}            ! (4) using declaration
            \livelink{chap:DWATimport}{DW\_AT\_import}(reference to 34\$)     !     - part 1
        \livelink{chap:DWTAGimporteddeclaration}{DW\_TAG\_imported\_declaration}            ! (4) using declaration
            \livelink{chap:DWATimport}{DW\_AT\_import}(reference to 36\$)     !     - part 2
        \livelink{chap:DWTAGimportedmodule}{DW\_TAG\_imported\_module}                 ! (5) using directive
            \livelink{chap:DWATimport}{DW\_AT\_import}(reference to 20\$)
        \livelink{chap:DWTAGnamespace}{DW\_TAG\_namespace}
            \livelink{chap:DWATextension}{DW\_AT\_extension}(reference to 10\$)
            \livelink{chap:DWTAGnamespace}{DW\_TAG\_namespace}
                \livelink{chap:DWATextension}{DW\_AT\_extension}(reference to 20\$)
                \livelink{chap:DWTAGimportedmodule}{DW\_TAG\_imported\_module}         ! (6) using directive
                    \livelink{chap:DWATimport}{DW\_AT\_import}(reference to 40\$)
                \livelink{chap:DWTAGvariable}{DW\_TAG\_variable}
                    \livelink{chap:DWATname}{DW\_AT\_name}("k")
                    \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 1\$)
                    \livelink{chap:DWATlocation}{DW\_AT\_location} ...
                    ...
60\$: \livelink{chap:DWTAGsubprogram}{DW\_TAG\_subprogram}
        \livelink{chap:DWATspecification}{DW\_AT\_specification}(reference to 34\$)
        \livelink{chap:DWATlowpc}{DW\_AT\_low\_pc} ...
        \livelink{chap:DWAThighpc}{DW\_AT\_high\_pc} ...
        ...
\end{alltt}
\end{dwflisting}
\begin{center}
Figure~\ref{fig:namespaceexampledwarfdescription}: Namespace example: DWARF description \textit{(concluded)}
\end{center}
\end{figure}

\section{Member Function Example}
\label{app:memberfunctionexample}

Consider the member function example fragment in 
Figure \refersec{fig:memberfunctionexamplesourcefragment}.
The DWARF representation in 
Figure \refersec{fig:memberfunctionexampledwarfdescription}
is appropriate.

\begin{figure}[Here]
\begin{lstlisting}
class A
{
    void func1(int x1);
    void func2() const;
    static void func3(int x3);
};
void A::func1(int x) {}
\end{lstlisting}
\caption{Member function example: source fragment}
\label{fig:memberfunctionexamplesourcefragment}
\end{figure}

\begin{figure}[h]
\figurepart{1}{2}
\begin{dwflisting}
\begin{alltt}
1\$: \livelink{chap:DWTAGunspecifiedtype}{DW\_TAG\_unspecified\_type}
        \livelink{chap:DWATname}{DW\_AT\_name}("void")
                ...
2\$: \livelink{chap:DWTAGbasetype}{DW\_TAG\_base\_type}
        \livelink{chap:DWATname}{DW\_AT\_name}("int")
        ...
3\$: \livelink{chap:DWTAGclasstype}{DW\_TAG\_class\_type}
        \livelink{chap:DWATname}{DW\_AT\_name}("A")
        ...
4\$:    \livelink{chap:DWTAGpointertype}{DW\_TAG\_pointer\_type}
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 3\$)
            ...
5\$:    \livelink{chap:DWTAGconsttype}{DW\_TAG\_const\_type}
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 3\$)
            ...
6\$:    \livelink{chap:DWTAGpointertype}{DW\_TAG\_pointer\_type}
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 5\$)
            ...

7\$:    \livelink{chap:DWTAGsubprogram}{DW\_TAG\_subprogram}
            \livelink{chap:DWATdeclaration}{DW\_AT\_declaration}
            \livelink{chap:DWATname}{DW\_AT\_name}("func1")
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 1\$)
            \livelink{chap:DWATobjectpointer}{DW\_AT\_object\_pointer}(reference to 8\$) \addtoindexx{object pointer attribute}
                ! References a formal parameter in this 
                ! member function
            ...
\end{alltt}
\end{dwflisting}
\caption{Member function example: DWARF description}
\label{fig:memberfunctionexampledwarfdescription}
\end{figure}

\begin{figure}[p]
\figurepart{2}{2}
\begin{dwflisting}
\begin{alltt}
8\$:        \livelink{chap:DWTAGformalparameter}{DW\_TAG\_formal\_parameter}
                \livelink{chap:DWATartificial}{DW\_AT\_artificial}(true)
                \livelink{chap:DWATname}{DW\_AT\_name}("this")
                \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 4\$)
                    ! Makes type of 'this' as 'A*' =>
                    ! func1 has not been marked const 
                    ! or volatile
                \livelink{chap:DWATlocation}{DW\_AT\_location} ...
                ...
9\$:        \livelink{chap:DWTAGformalparameter}{DW\_TAG\_formal\_parameter}
                \livelink{chap:DWATname}{DW\_AT\_name}(x1)
                \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 2\$)
                ...
10\$:    \livelink{chap:DWTAGsubprogram}{DW\_TAG\_subprogram}
             \livelink{chap:DWATdeclaration}{DW\_AT\_declaration}
             \livelink{chap:DWATname}{DW\_AT\_name}("func2")
             \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 1\$)
             \livelink{chap:DWATobjectpointer}{DW\_AT\_object\_pointer}(reference to 11\$) \addtoindexx{object pointer attribute}
             ! References a formal parameter in this 
             ! member function
             ...
11\$:        \livelink{chap:DWTAGformalparameter}{DW\_TAG\_formal\_parameter}
                 \livelink{chap:DWATartificial}{DW\_AT\_artificial}(true)
                 \livelink{chap:DWATname}{DW\_AT\_name}("this")
                 \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 6\$)
                 ! Makes type of 'this' as 'A const*' =>
                 !     func2 marked as const
                 \livelink{chap:DWATlocation}{DW\_AT\_location} ...
                 ...
12\$:    \livelink{chap:DWTAGsubprogram}{DW\_TAG\_subprogram}
             \livelink{chap:DWATdeclaration}{DW\_AT\_declaration}
             \livelink{chap:DWATname}{DW\_AT\_name}("func3")
             \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 1\$)
             ...
                 ! No object pointer reference formal parameter
                 ! implies func3 is static
13\$:        \livelink{chap:DWTAGformalparameter}{DW\_TAG\_formal\_parameter}
                 \livelink{chap:DWATname}{DW\_AT\_name}(x3)
                 \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 2\$)
                 ...
\end{alltt}
\end{dwflisting}
\begin{center}
Figure~\ref{fig:memberfunctionexampledwarfdescription}: Member function example: DWARF description \textit{(concluded)}
\end{center}
\end{figure}

\clearpage
\section{Line Number Program Example}
\label{app:linenumberprogramexample}

Consider the simple source file and the resulting machine
code for the Intel 8086 processor in 
Figure \refersec{fig:linenumberprogramexamplemachinecode}.

\begin{figure}[here]
\begin{lstlisting}
1: int
2: main()
    0x239: push pb
    0x23a: mov bp,sp
3: {
4: printf("Omit needless words\n");
    0x23c: mov ax,0xaa
    0x23f: push ax
    0x240: call _printf
    0x243: pop cx
5: exit(0);
    0x244: xor ax,ax
    0x246: push ax
    0x247: call _exit
    0x24a: pop cx
6: }
    0x24b: pop bp
    0x24c: ret
7: 0x24d:
\end{lstlisting}
\caption{Line number program example: machine code}
\label{fig:linenumberprogramexamplemachinecode}
\end{figure}

Suppose the line number program header includes the following
(header fields not needed 
\addtoindexx{line\_base}
below 
\addtoindexx{line\_range}
are 
\addtoindexx{opcode\_base}
not 
\addtoindexx{minumum\_instruction\_length}
shown):
\begin{alltt}
    version                       4
    minimum_instruction_length    1
    opcode_base                  10   ! Opcodes 10-12 not needed
    line_base                     1
    line_range                   15
\end{alltt}


Table \refersec{tab:linenumberprogramexampleoneencoding}
shows one encoding of the line number program, which occupies
12 bytes (the opcode SPECIAL(\textit{m},\textit{n}) indicates the special opcode
generated for a line increment of \textit{m} and an address increment
of \textit{n}).

\newpage
\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|l|l}
  \caption{Line number program example: one \mbox{encoding}}
  \label{tab:linenumberprogramexampleoneencoding} \\
  \hline \bfseries Opcode &\bfseries Operand &\bfseries Byte Stream \\ \hline
\endfirsthead
  \bfseries Opcode &\bfseries Operand &\bfseries Byte Stream\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot
\livelink{chap:DWLNSadvancepc}{DW\_LNS\_advance\_pc}&LEB128(0x239)&0x2, 0xb9, 0x04 \\
SPECIAL(2, 0)& &0xb  \\
SPECIAL(2, 3)& &0x38 \\
SPECIAL(1, 8)& &0x82 \\
SPECIAL(1, 7)& &0x73 \\
\livelink{chap:DWLNSadvancepc}{DW\_LNS\_advance\_pc}&LEB128(2)&0x2, 0x2 \\
\livelink{chap:DWLNEendsequence}{DW\_LNE\_end\_sequence} &&0x0, 0x1, 0x1 \\
\end{longtable}
\end{centering}


Table \refersec{tab:linenumberprogramexamplealternateencoding}
shows an alternate 
encoding of the same program using 
standard opcodes to advance
the program counter; 
this encoding occupies 22 bytes.

\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|l|l}
  \caption{Line number program example: alternate encoding} 
  \label{tab:linenumberprogramexamplealternateencoding} \\
  \hline \bfseries Opcode &\bfseries Operand &\bfseries Byte Stream \\ \hline
\endfirsthead
  \bfseries Opcode &\bfseries Operand &\bfseries Byte Stream\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot
\livelink{chap:DWLNSfixedadvancepc}{DW\_LNS\_fixed\_advance\_pc}&0x239&0x9, 0x39, 0x2        \\
SPECIAL(2, 0)&& 0xb        \\
\livelink{chap:DWLNSfixedadvancepc}{DW\_LNS\_fixed\_advance\_pc}&0x3&0x9, 0x3, 0x0        \\
SPECIAL(2, 0)&&0xb        \\
\livelink{chap:DWLNSfixedadvancepc}{DW\_LNS\_fixed\_advance\_pc}&0x8&0x9, 0x8, 0x0        \\
SPECIAL(1, 0)&& 0xa        \\
\livelink{chap:DWLNSfixedadvancepc}{DW\_LNS\_fixed\_advance\_pc}&0x7&0x9, 0x7, 0x0        \\
SPECIAL(1, 0) && 0xa        \\
\livelink{chap:DWLNSfixedadvancepc}{DW\_LNS\_fixed\_advance\_pc}&0x2&0x9, 0x2, 0x0        \\
\livelink{chap:DWLNEendsequence}{DW\_LNE\_end\_sequence}&&0x0, 0x1, 0x1        \\
\end{longtable}
\end{centering}


\section{Call Frame Information Example}
\label{app:callframeinformationexample}

The following example uses a hypothetical RISC machine in
the style of the Motorola 88000.
\begin{itemize}
\item Memory is byte addressed.

\item Instructions are all 4 bytes each and word aligned.

\item Instruction operands are typically of the form:
\begin{alltt}
    <destination.reg>, <source.reg>, <constant>
\end{alltt}

\item The address for the load and store instructions is computed
by adding the contents of the
source register with the constant.

\item There are eight 4\dash byte registers:
\newline
\begin{tabular}{p{5mm}l}
   & R0 always 0 \\
   & R1 holds return address on call \\
   & R2-R3 temp registers (not preserved on call) \\
   & R4-R6 preserved on call \\
   & R7 stack pointer \\
\end{tabular}

\item  The stack grows in the negative direction.

\item The architectural ABI committee specifies that the
stack pointer (R7) is the same as the CFA

\end{itemize}

Figure \referfol{fig:callframeinformationexamplemachinecodefragments}
shows two code fragments from a subroutine called
foo that uses a frame pointer (in addition to the stack
pointer). The first column values are byte addresses. 
% The \space is so we get a space after >
\textless fs\textgreater\ denotes the stack frame size in bytes, namely 12.


\begin{figure}[here]
\begin{lstlisting}
       ;; start prologue
foo    sub   R7, R7, <fs>        ; Allocate frame
foo+4  store R1, R7, (<fs>-4)    ; Save the return address
foo+8  store R6, R7, (<fs>-8)    ; Save R6
foo+12 add   R6, R7, 0           ; R6 is now the Frame ptr
foo+16 store R4, R6, (<fs>-12)   ; Save a preserved reg
       ;; This subroutine does not change R5
       ...
       ;; Start epilogue (R7 is returned to entry value)
foo+64 load  R4, R6, (<fs>-12)   ; Restore R4
foo+68 load  R6, R7, (<fs>-8)    ; Restore R6
foo+72 load  R1, R7, (<fs>-4)    ; Restore return address
foo+76 add   R7, R7, <fs>        ; Deallocate frame
foo+80 jump  R1                  ; Return
foo+84
\end{lstlisting}
\caption{Call frame information example: machine code fragments}
\label{fig:callframeinformationexamplemachinecodefragments}
\end{figure}


An abstract table 
(see Section \refersec{chap:structureofcallframeinformation}) 
for the foo subroutine is shown in 
Table \referfol{tab:callframeinformationexampleconceptualmatrix}.
Corresponding fragments from the
\dotdebugframe{} section are shown in 
Table \refersec{tab:callframeinformationexamplecommoninformationentryencoding}.

The following notations apply in 
Table \refersec{tab:callframeinformationexampleconceptualmatrix}:
\newline
\begin{tabular}{p{5mm}l}
&1.  R8 is the return address \\
&2.  s = same\_value rule \\
&3.  u = undefined rule \\
&4.  rN = register(N) rule \\
&5.  cN = offset(N) rule \\
&6.  a = architectural rule \\
\end{tabular}

\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|llllllllll}
  \caption{Call frame information example: conceptual matrix} 
  \label{tab:callframeinformationexampleconceptualmatrix} \\
  \hline \bfseries Location & \bfseries CFA & \bfseries R0 & \bfseries R1 & \bfseries R2 & \bfseries R3 & \bfseries R4 & \bfseries R5 & \bfseries R6 & \bfseries R7 & \bfseries R8 \\ \hline
\endfirsthead
  \bfseries Location &\bfseries CFA &\bfseries R0 & \bfseries R1 & \bfseries R2 &\bfseries R3 &\bfseries R4 &\bfseries R5 &\bfseries R6 &\bfseries R7 &\bfseries R8\\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot
foo&[R7]+0&s&u&u&u&s&s&s&a&r1 \\
foo+4&[R7]+fs&s&u&u&u&s&s&s&a&r1 \\
foo+8&[R7]+fs&s&u&u&u&s&s&s&a&c-4 \\
foo+12&[R7]+fs&s&u&u&u&s&s&c-8&a&c-4 \\
foo+16&[R6]+fs&s&u&u&u&s&s&c-8&a&c-4 \\
foo+20&[R6]+fs&s&u&u&u&c-12&s&c-8&a&c-4 \\
...&&&&&&&&&& \\
foo+64&[R6]+fs&s&u&u&u&c-12&s&c-8&a&c-4 \\
foo+68&[R6]+fs&s&u&u&u&s&s&c-8&a&c-4  \\
foo+72&[R7]+fs&s&u&u&u&s&s&s&a&c-4  \\
foo+76&[R7]+fs&s&u&u&u&s&s&s&a&r1 \\
foo+80&[R7]+0&s&u&u&u&s&s&s&a&r1 \\
\end{longtable}
\end{centering}

\clearpage      % ?????

\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|ll}
  \caption{Call frame information example: common information entry encoding} 
  \label{tab:callframeinformationexamplecommoninformationentryencoding} 
  \\
  \hline \bfseries Address &\bfseries Value &\bfseries Comment \\ \hline
\endfirsthead
  \bfseries Address &\bfseries Value &\bfseries Comment \\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot
cie&36&length    \\
cie+4&\xffffffff&CIE\_id    \\
cie+8&4&version    \\
cie+9&0&augmentation     \\
cie+10&4&address size    \\
cie+11&0&segment size    \\
cie+12&4&code\_alignment\_factor, \textless caf \textgreater    \\
cie+13&-4&data\_alignment\_factor, \textless daf \textgreater    \\
cie+14&8&R8 is the return addr.    \\
cie+15&\livelink{chap:DWCFAdefcfa}{DW\_CFA\_def\_cfa} (7, 0)&CFA = [R7]+0    \\
cie+18&\livelink{chap:DWCFAsamevalue}{DW\_CFA\_same\_value} (0)&R0 not modified (=0)    \\
cie+20&\livelink{chap:DWCFAundefined}{DW\_CFA\_undefined} (1)&R1 scratch    \\
cie+22&\livelink{chap:DWCFAundefined}{DW\_CFA\_undefined} (2)&R2 scratch    \\
cie+24&\livelink{chap:DWCFAundefined}{DW\_CFA\_undefined} (3)&R3 scratch    \\
cie+26&\livelink{chap:DWCFAsamevalue}{DW\_CFA\_same\_value} (4)&R4 preserve    \\
cie+28&\livelink{chap:DWCFAsamevalue}{DW\_CFA\_same\_value} (5)&R5 preserve    \\
cie+30&\livelink{chap:DWCFAsamevalue}{DW\_CFA\_same\_value} (6)&R6 preserve    \\
cie+32&\livelink{chap:DWCFAsamevalue}{DW\_CFA\_same\_value} (7)&R7 preserve    \\
cie+34&\livelink{chap:DWCFAregister}{DW\_CFA\_register} (8, 1)&R8 is in R1    \\
cie+37&\livelink{chap:DWCFAnop}{DW\_CFA\_nop} &padding    \\
cie+38&\livelink{chap:DWCFAnop}{DW\_CFA\_nop} &padding \\
cie+39& \livelink{chap:DWCFAnop}{DW\_CFA\_nop}&padding  \\
cie+40 &&  \\
\end{longtable}
\end{centering}


The following notations apply in 
Table \refersec{tab:callframeinformationexampleframedescriptionentryencoding}:
\newline
\begin{tabular}{p{5mm}l}
&\texttt{<fs>  =} frame size \\
&\texttt{<caf> =} code alignment factor \\
&\texttt{<daf> =} data alignment factor \\
\end{tabular}


\begin{centering}
\setlength{\extrarowheight}{0.1cm}
\begin{longtable}{l|ll}
  \caption{Call frame information example: frame description entry encoding} 
  \label{tab:callframeinformationexampleframedescriptionentryencoding} \\
  \hline \bfseries Address &\bfseries Value &\bfseries Comment \\ \hline
\endfirsthead
  \bfseries Address &\bfseries Value &\bfseries Comment \\ \hline
\endhead
  \hline \emph{Continued on next page}
\endfoot
  \hline
\endlastfoot
fde&40&length \\
fde+4&cie&CIE\_ptr \\
fde+8&foo&initial\_location \\
fde+12&84&address\_range \\
fde+16&\livelink{chap:DWCFAadvanceloc}{DW\_CFA\_advance\_loc}(1)&instructions \\
fde+17&\livelink{chap:DWCFAdefcfaoffset}{DW\_CFA\_def\_cfa\_offset}(12)& \textless fs\textgreater \\
fde+19&\livelink{chap:DWCFAadvanceloc}{DW\_CFA\_advance\_loc}(1)&4/\textless caf\textgreater \\
fde+20&\livelink{chap:DWCFAoffset}{DW\_CFA\_offset}(8,1)&-4/\textless daf\textgreater (2nd parameter) \\
fde+22&\livelink{chap:DWCFAadvanceloc}{DW\_CFA\_advance\_loc}(1)& \\
fde+23&\livelink{chap:DWCFAoffset}{DW\_CFA\_offset}(6,2)&-8/\textless daf\textgreater (2nd parameter)  \\
fde+25&\livelink{chap:DWCFAadvanceloc}{DW\_CFA\_advance\_loc}(1) & \\
fde+26&\livelink{chap:DWCFAdefcfaregister}{DW\_CFA\_def\_cfa\_register}(6) & \\
fde+28&\livelink{chap:DWCFAadvanceloc}{DW\_CFA\_advance\_loc}(1) & \\
fde+29&\livelink{chap:DWCFAoffset}{DW\_CFA\_offset}(4,3)&-12/\textless daf\textgreater (2nd parameter) \\
fde+31&\livelink{chap:DWCFAadvanceloc}{DW\_CFA\_advance\_loc}(12)&44/\textless caf\textgreater \\
fde+32&\livelink{chap:DWCFArestore}{DW\_CFA\_restore}(4)& \\
fde+33&\livelink{chap:DWCFAadvanceloc}{DW\_CFA\_advance\_loc}(1) & \\
fde+34&\livelink{chap:DWCFArestore}{DW\_CFA\_restore}(6) & \\
fde+35&\livelink{chap:DWCFAdefcfaregister}{DW\_CFA\_def\_cfa\_register}(7)  & \\
fde+37&\livelink{chap:DWCFAadvanceloc}{DW\_CFA\_advance\_loc}(1) & \\
fde+38&\livelink{chap:DWCFArestore}{DW\_CFA\_restore}(8) &\\
fde+39&\livelink{chap:DWCFAadvanceloc}{DW\_CFA\_advance\_loc}(1) &\\
fde+40&\livelink{chap:DWCFAdefcfaoffset}{DW\_CFA\_def\_cfa\_offset}(0)  &\\
fde+42&\livelink{chap:DWCFAnop}{DW\_CFA\_nop}&padding \\
fde+43&\livelink{chap:DWCFAnop}{DW\_CFA\_nop}&padding \\
fde+44 && \\
\end{longtable}
\end{centering}

\section{Inlining Examples}
\label{app:inliningexamples}
The pseudo\dash source in 
Figure \referfol{fig:inliningexamplespseudosourcefragment}
is used to illustrate the
\addtoindexx{inlined subprogram call!examples}
use of DWARF to describe inlined subroutine calls. This
example involves a nested subprogram \texttt{INNER} that makes uplevel
references to the formal parameter and local variable of the
containing subprogram \texttt{OUTER}.

\begin{figure}[here]
\begin{lstlisting}
inline procedure OUTER (OUTER_FORMAL : integer) =
    begin
    OUTER_LOCAL : integer;
    procedure INNER (INNER_FORMAL : integer) =
        begin
        INNER_LOCAL : integer;
        print(INNER_FORMAL + OUTER_LOCAL);
        end;
    INNER(OUTER_LOCAL);
    ...
    INNER(31);
    end;
! Call OUTER
!
OUTER(7);
\end{lstlisting}
\caption{Inlining examples: pseudo-source fragmment} 
\label{fig:inliningexamplespseudosourcefragment}
\end{figure}


There are several approaches that a compiler might take to
inlining for this sort of example. This presentation considers
three such approaches, all of which involve inline expansion
of subprogram \texttt{OUTER}. (If \texttt{OUTER} is not inlined, the inlining
reduces to a simpler single level subset of the two level
approaches considered here.)

The approaches are:
\begin{enumerate}[1. ]
\item  Inline both \texttt{OUTER} and \texttt{INNER} in all cases

\item Inline \texttt{OUTER}, multiple \texttt{INNER}s \\
Treat \texttt{INNER} as a non\dash inlinable part of \texttt{OUTER}, compile and
call a distinct normal version of \texttt{INNER} defined within each
inlining of \texttt{OUTER}.

\item Inline \texttt{OUTER}, one \texttt{INNER} \\
Compile \texttt{INNER} as a single normal subprogram which is called
from every inlining of \texttt{OUTER}.
\end{enumerate}

This discussion does not consider why a compiler might choose
one of these approaches; it considers only how to describe
the result.

In the examples that follow in this section, the debugging
information entries are given mnemonic labels of the following
form
\begin{verbatim}
    <io>.<ac>.<n>.<s>
\end{verbatim}
where
\begin{description}
\item[\textless io\textgreater]
is either \texttt{INNER} or \texttt{OUTER} to indicate to which
subprogram the debugging information entry applies, 
\item[\textless ac\textgreater]
is either AI or CI to indicate \doublequote{abstract instance} or
\doublequote{concrete instance} respectively, 
\item[\textless n\textgreater]
is the number of the
alternative being considered, and 
\item[\textless s\textgreater]
is a sequence number that
distinguishes the individual entries. 
\end{description}
There is no implication
that symbolic labels, nor any particular naming convention,
are required in actual use.

For conciseness, declaration coordinates and call coordinates are omitted.

\subsection{Alternative \#1: inline both OUTER and INNER}
\label{app:inlinebothouterandinner}

A suitable abstract instance for an alternative where both
\texttt{OUTER} and \texttt{INNER} are always inlined is shown in 
Figure \refersec{fig:inliningexample1abstractinstance}.

Notice in 
Figure \ref{fig:inliningexample1abstractinstance} 
that the debugging information entry for
\texttt{INNER} (labelled \texttt{INNER.AI.1.1}) is nested in (is a child of)
that for \texttt{OUTER} (labelled \texttt{OUTER.AI.1.1}). Nonetheless, the
abstract instance tree for \texttt{INNER} is considered to be separate
and distinct from that for \texttt{OUTER}.

The call of \texttt{OUTER} shown in 
Figure \refersec{fig:inliningexamplespseudosourcefragment}
might be described as
shown in 
Figure \refersec{fig:inliningexample1concreteinstance}.


\begin{figure}[p]
\begin{dwflisting}
\begin{alltt}
    ! Abstract instance for OUTER
    ! \addtoindexx{abstract instance!example}
OUTER.AI.1.1:
    \livelink{chap:DWTAGsubprogram}{DW\_TAG\_subprogram}
        \livelink{chap:DWATname}{DW\_AT\_name}("OUTER")
        \livelink{chap:DWATinline}{DW\_AT\_inline}(\livelink{chap:DWINLdeclaredinlined}{DW\_INL\_declared\_inlined})
        ! No low/high PCs
OUTER.AI.1.2:
        \livelink{chap:DWTAGformalparameter}{DW\_TAG\_formal\_parameter}
            \livelink{chap:DWATname}{DW\_AT\_name}("OUTER\_FORMAL")
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to integer)
            ! No location
OUTER.AI.1.3:
        \livelink{chap:DWTAGvariable}{DW\_TAG\_variable}
            \livelink{chap:DWATname}{DW\_AT\_name}("OUTER\_LOCAL")
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to integer)
            ! No location
        !
        ! Abstract instance for INNER
        !
INNER.AI.1.1:
        \livelink{chap:DWTAGsubprogram}{DW\_TAG\_subprogram}
            \livelink{chap:DWATname}{DW\_AT\_name}("INNER")
            \livelink{chap:DWATinline}{DW\_AT\_inline}(\livelink{chap:DWINLdeclaredinlined}{DW\_INL\_declared\_inlined})
            ! No low/high PCs
INNER.AI.1.2:
            \livelink{chap:DWTAGformalparameter}{DW\_TAG\_formal\_parameter}
                \livelink{chap:DWATname}{DW\_AT\_name}("INNER\_FORMAL")
                \livelink{chap:DWATtype}{DW\_AT\_type}(reference to integer)
                ! No location
INNER.AI.1.3:
            \livelink{chap:DWTAGvariable}{DW\_TAG\_variable}
                \livelink{chap:DWATname}{DW\_AT\_name}("INNER\_LOCAL")
                \livelink{chap:DWATtype}{DW\_AT\_type}(reference to integer)
                ! No location
            ...
            0
        ! No \livelink{chap:DWTAGinlinedsubroutine}{DW\_TAG\_inlined\_subroutine} (concrete instance)
        ! for INNER corresponding to calls of INNER
        ...
        0
\end{alltt}
\end{dwflisting}
\caption{Inlining example \#1: abstract instance}
\label{fig:inliningexample1abstractinstance}
\end{figure}

\begin{figure}[p]
\begin{dwflisting}
\begin{alltt}
! Concrete instance for call "OUTER(7)"
! \addtoindexx{concrete instance!example}
OUTER.CI.1.1:
    \livelink{chap:DWTAGinlinedsubroutine}{DW\_TAG\_inlined\_subroutine}
        ! No name
        \livelink{chap:DWATabstractorigin}{DW\_AT\_abstract\_origin}(reference to OUTER.AI.1.1)
        \livelink{chap:DWATlowpc}{DW\_AT\_low\_pc}(...)
        \livelink{chap:DWAThighpc}{DW\_AT\_high\_pc}(...)
OUTER.CI.1.2:
        \livelink{chap:DWTAGformalparameter}{DW\_TAG\_formal\_parameter}
            ! No name
            \livelink{chap:DWATabstractorigin}{DW\_AT\_abstract\_origin}(reference to OUTER.AI.1.2)
            \livelink{chap:DWATconstvalue}{DW\_AT\_const\_value}(7)
OUTER.CI.1.3:
        \livelink{chap:DWTAGvariable}{DW\_TAG\_variable}
            ! No name
            \livelink{chap:DWATabstractorigin}{DW\_AT\_abstract\_origin}(reference to OUTER.AI.1.3)
            \livelink{chap:DWATlocation}{DW\_AT\_location}(...)
        !
        ! No \livelink{chap:DWTAGsubprogram}{DW\_TAG\_subprogram} (abstract instance) for INNER
        !
        ! Concrete instance for call INNER(OUTER\_LOCAL)
        !
INNER.CI.1.1:
        \livelink{chap:DWTAGinlinedsubroutine}{DW\_TAG\_inlined\_subroutine}
            ! No name
            \livelink{chap:DWATabstractorigin}{DW\_AT\_abstract\_origin}(reference to INNER.AI.1.1)
            \livelink{chap:DWATlowpc}{DW\_AT\_low\_pc}(...)
            \livelink{chap:DWAThighpc}{DW\_AT\_high\_pc}(...)
            \livelink{chap:DWATstaticlink}{DW\_AT\_static\_link}(...)
INNER.CI.1.2:
            \livelink{chap:DWTAGformalparameter}{DW\_TAG\_formal\_parameter}
                ! No name
                \livelink{chap:DWATabstractorigin}{DW\_AT\_abstract\_origin}(reference to INNER.AI.1.2)
                \livelink{chap:DWATlocation}{DW\_AT\_location}(...)
INNER.CI.1.3:
            \livelink{chap:DWTAGvariable}{DW\_TAG\_variable}
                ! No name
                \livelink{chap:DWATabstractorigin}{DW\_AT\_abstract\_origin}(reference to INNER.AI.1.3)
                \livelink{chap:DWATlocation}{DW\_AT\_location}(...)
            ...
            0
        ! Another concrete instance of INNER within OUTER
        ! for the call "INNER(31)"
        ...
        0
\end{alltt}
\end{dwflisting}
\caption{Inlining example \#1: concrete instance}
\label{fig:inliningexample1concreteinstance}
\end{figure}

\subsection{Alternative \#2: Inline OUTER, multiple INNERs}
\label{app:inlineoutermultiipleinners}


In the second alternative we assume that subprogram \texttt{INNER}
is not inlinable for some reason, but subprogram \texttt{OUTER} is
inlinable. 
\addtoindexx{concrete instance!example}
Each concrete inlined instance of \texttt{OUTER} has its
own normal instance of \texttt{INNER}. 
The abstract instance for \texttt{OUTER},
\addtoindexx{abstract instance!example}
which includes \texttt{INNER}, is shown in 
Figure \refersec{fig:inliningexample2abstractinstance}.

Note that the debugging information in 
Figure \ref{fig:inliningexample2abstractinstance}
differs from that in 
Figure \refersec{fig:inliningexample1abstractinstance}
in that \texttt{INNER} lacks a 
\livelink{chap:DWATinline}{DW\_AT\_inline} attribute
and therefore is not a distinct abstract instance. \texttt{INNER}
is merely an out\dash of\dash line routine that is part of \texttt{OUTER}\textquoteright s
abstract instance. This is reflected in the Figure by
\addtoindexx{abstract instance!example}
the fact that the labels for \texttt{INNER} use the substring \texttt{OUTER}
instead of \texttt{INNER}.

A resulting 
\addtoindexx{concrete instance!example}
concrete inlined instance of \texttt{OUTER} is shown in
Figure \refersec{fig:inliningexample2concreteinstance}.

Notice in 
Figure \ref{fig:inliningexample2concreteinstance}
that \texttt{OUTER} is expanded as a concrete
\addtoindexx{concrete instance!example}
inlined instance, and that \texttt{INNER} is nested within it as a
concrete out\dash of\dash line subprogram. Because \texttt{INNER} is cloned
for each inline expansion of \texttt{OUTER}, only the invariant
attributes of \texttt{INNER} 
(for example, \livelink{chap:DWATname}{DW\_AT\_name}) are specified
in the abstract instance of \texttt{OUTER}, and the low\dash level,
\addtoindexx{abstract instance!example}
instance\dash specific attributes of \texttt{INNER} (for example,
\livelink{chap:DWATlowpc}{DW\_AT\_low\_pc}) are specified in 
each concrete instance of \texttt{OUTER}.
\addtoindexx{concrete instance!example}

The several calls of \texttt{INNER} within \texttt{OUTER} are compiled as normal
calls to the instance of \texttt{INNER} that is specific to the same
instance of \texttt{OUTER} that contains the calls.

\begin{figure}[t]
\begin{dwflisting}
\begin{alltt}
    ! Abstract instance for OUTER
    ! \addtoindex{abstract instance}
OUTER.AI.2.1:
    \livelink{chap:DWTAGsubprogram}{DW\_TAG\_subprogram}
        \livelink{chap:DWATname}{DW\_AT\_name}("OUTER")
        \livelink{chap:DWATinline}{DW\_AT\_inline}(\livelink{chap:DWINLdeclaredinlined}{DW\_INL\_declared\_inlined})
        ! No low/high PCs
OUTER.AI.2.2:
        \livelink{chap:DWTAGformalparameter}{DW\_TAG\_formal\_parameter}
            \livelink{chap:DWATname}{DW\_AT\_name}("OUTER\_FORMAL")
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to integer)
            ! No location
OUTER.AI.2.3:
        \livelink{chap:DWTAGvariable}{DW\_TAG\_variable}
            \livelink{chap:DWATname}{DW\_AT\_name}("OUTER\_LOCAL")
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to integer)
            ! No location
        !
        ! Nested out-of-line INNER subprogram
        !
OUTER.AI.2.4:
        \livelink{chap:DWTAGsubprogram}{DW\_TAG\_subprogram}
            \livelink{chap:DWATname}{DW\_AT\_name}("INNER")
            ! No \livelink{chap:DWATinline}{DW\_AT\_inline}
            ! No low/high PCs, frame\_base, etc.
OUTER.AI.2.5:
            \livelink{chap:DWTAGformalparameter}{DW\_TAG\_formal\_parameter}
                \livelink{chap:DWATname}{DW\_AT\_name}("INNER\_FORMAL")
                \livelink{chap:DWATtype}{DW\_AT\_type}(reference to integer)
                ! No location
OUTER.AI.2.6:
            \livelink{chap:DWTAGvariable}{DW\_TAG\_variable}
                \livelink{chap:DWATname}{DW\_AT\_name}("INNER\_LOCAL")
                \livelink{chap:DWATtype}{DW\_AT\_type}(reference to integer)
                ! No location
            ...
            0
        ...
        0
\end{alltt}
\end{dwflisting}
\caption{Inlining example \#2: abstract instance}
\label{fig:inliningexample2abstractinstance}
\end{figure}

\begin{figure}[t]
\begin{dwflisting}
\begin{alltt}

    ! Concrete instance for call "OUTER(7)"
    !
OUTER.CI.2.1:
    \livelink{chap:DWTAGinlinedsubroutine}{DW\_TAG\_inlined\_subroutine}
        ! No name
        \livelink{chap:DWATabstractorigin}{DW\_AT\_abstract\_origin}(reference to OUTER.AI.2.1)
        \livelink{chap:DWATlowpc}{DW\_AT\_low\_pc}(...)
        \livelink{chap:DWAThighpc}{DW\_AT\_high\_pc}(...)
OUTER.CI.2.2:
        \livelink{chap:DWTAGformalparameter}{DW\_TAG\_formal\_parameter}
            ! No name
            \livelink{chap:DWATabstractorigin}{DW\_AT\_abstract\_origin}(reference to OUTER.AI.2.2)
            \livelink{chap:DWATlocation}{DW\_AT\_location}(...)
OUTER.CI.2.3:
        \livelink{chap:DWTAGvariable}{DW\_TAG\_variable}
            ! No name
            \livelink{chap:DWATabstractorigin}{DW\_AT\_abstract\_origin}(reference to OUTER.AI.2.3)
            \livelink{chap:DWATlocation}{DW\_AT\_location}(...)
        !
        ! Nested out-of-line INNER subprogram
        !
OUTER.CI.2.4:
        \livelink{chap:DWTAGsubprogram}{DW\_TAG\_subprogram}
            ! No name
            \livelink{chap:DWATabstractorigin}{DW\_AT\_abstract\_origin}(reference to OUTER.AI.2.4)
            \livelink{chap:DWATlowpc}{DW\_AT\_low\_pc}(...)
            \livelink{chap:DWAThighpc}{DW\_AT\_high\_pc}(...)
            \livelink{chap:DWATframebase}{DW\_AT\_frame\_base}(...)
            \livelink{chap:DWATstaticlink}{DW\_AT\_static\_link}(...)
OUTER.CI.2.5:
            \livelink{chap:DWTAGformalparameter}{DW\_TAG\_formal\_parameter}
                ! No name
                \livelink{chap:DWATabstractorigin}{DW\_AT\_abstract\_origin}(reference to OUTER.AI.2.5)
                \livelink{chap:DWATlocation}{DW\_AT\_location}(...)
OUTER.CI.2.6:
            \livelink{chap:DWTAGvariable}{DW\_TAG\_variable}
                ! No name
                \livelink{chap:DWATabstractorigin}{DW\_AT\_abstract\_origin}(reference to OUTER.AT.2.6)
                \livelink{chap:DWATlocation}{DW\_AT\_location}(...)
            ...
            0
        ...
        0
\end{alltt}
\end{dwflisting}
\caption{Inlining example \#2: concrete instance}
\label{fig:inliningexample2concreteinstance}
\end{figure}

\subsection{Alternative \#3: inline OUTER, one normal INNER}
\label{app:inlineouteronenormalinner}

In the third approach, one normal subprogram for \texttt{INNER} is
compiled which is called from all concrete inlined instances of
\addtoindexx{concrete instance!example}
\addtoindexx{abstract instance!example}
\texttt{OUTER}. The abstract instance for \texttt{OUTER} is shown in 
Figure \refersec{fig:inliningexample3abstractinstance}.

The most distinctive aspect of that Figure is that subprogram
\texttt{INNER} exists only within the abstract instance of \texttt{OUTER},
and not in \texttt{OUTER}\textquoteright s concrete instance. In the abstract
\addtoindexx{concrete instance!example}
\addtoindexx{abstract instance!example}
instance of \texttt{OUTER}, the description of \texttt{INNER} has the full
complement of attributes that would be expected for a
normal subprogram. 
While attributes such as 
\livelink{chap:DWATlowpc}{DW\_AT\_low\_pc},
\livelink{chap:DWAThighpc}{DW\_AT\_high\_pc}, 
\livelink{chap:DWATlocation}{DW\_AT\_location},
and so on, typically are omitted
\addtoindexx{high PC attribute}
from 
\addtoindexx{low PC attribute}
an 
\addtoindexx{location attribute}
abstract instance because they are not invariant across
instances of the containing abstract instance, in this case
those same attributes are included precisely because they are
invariant -- there is only one subprogram \texttt{INNER} to be described
and every description is the same.

A concrete inlined instance of \texttt{OUTER} is illustrated in
Figure \refersec{fig:inliningexample3concreteinstance}.

Notice in 
Figure \ref{fig:inliningexample3concreteinstance}
that there is no DWARF representation for
\texttt{INNER} at all; the representation of \texttt{INNER} does not vary across
instances of \texttt{OUTER} and the abstract instance of \texttt{OUTER} includes
the complete description of \texttt{INNER}, so that the description of
\texttt{INNER} may be (and for reasons of space efficiency, should be)
omitted from each 
\addtoindexx{concrete instance!example}
concrete instance of \texttt{OUTER}.

There is one aspect of this approach that is problematical from
the DWARF perspective. The single compiled instance of \texttt{INNER}
is assumed to access up\dash level variables of \texttt{OUTER}; however,
those variables may well occur at varying positions within
the frames that contain the 
\addtoindexx{concrete instance!example}
concrete inlined instances. A
compiler might implement this in several ways, including the
use of additional compiler-generated parameters that provide
reference parameters for the up\dash level variables, or a 
compiler-generated static link like parameter that points to the group
of up\dash level entities, among other possibilities. In either of
these cases, the DWARF description for the location attribute
of each uplevel variable needs to be different if accessed
from within \texttt{INNER} compared to when accessed from within the
instances of \texttt{OUTER}. An implementation is likely to require
vendor\dash specific DWARF attributes and/or debugging information
entries to describe such cases.

Note that in C++, a member function of a class defined within
a function definition does not require any vendor\dash specific
extensions because the C++ language disallows access to
entities that would give rise to this problem. (Neither \texttt{extern}
variables nor \texttt{static} members require any form of static link
for accessing purposes.)

\begin{figure}[t]
\begin{dwflisting}
\begin{alltt}
    ! Abstract instance for OUTER
    ! \addtoindexx{abstract instance!example}
OUTER.AI.3.1:
    \livelink{chap:DWTAGsubprogram}{DW\_TAG\_subprogram}
        \livelink{chap:DWATname}{DW\_AT\_name}("OUTER")
        \livelink{chap:DWATinline}{DW\_AT\_inline}(\livelink{chap:DWINLdeclaredinlined}{DW\_INL\_declared\_inlined})
        ! No low/high PCs
OUTER.AI.3.2:
        \livelink{chap:DWTAGformalparameter}{DW\_TAG\_formal\_parameter}
            \livelink{chap:DWATname}{DW\_AT\_name}("OUTER\_FORMAL")
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to integer)
            ! No location
OUTER.AI.3.3:
        \livelink{chap:DWTAGvariable}{DW\_TAG\_variable}
            \livelink{chap:DWATname}{DW\_AT\_name}("OUTER\_LOCAL")
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to integer)
            ! No location
        !
        ! Normal INNER
        !
OUTER.AI.3.4:
        \livelink{chap:DWTAGsubprogram}{DW\_TAG\_subprogram}
            \livelink{chap:DWATname}{DW\_AT\_name}("INNER")
            \livelink{chap:DWATlowpc}{DW\_AT\_low\_pc}(...)
            \livelink{chap:DWAThighpc}{DW\_AT\_high\_pc}(...)
            \livelink{chap:DWATframebase}{DW\_AT\_frame\_base}(...)
            \livelink{chap:DWATstaticlink}{DW\_AT\_static\_link}(...)
OUTER.AI.3.5:
            \livelink{chap:DWTAGformalparameter}{DW\_TAG\_formal\_parameter}
                \livelink{chap:DWATname}{DW\_AT\_name}("INNER\_FORMAL")
                \livelink{chap:DWATtype}{DW\_AT\_type}(reference to integer)
                \livelink{chap:DWATlocation}{DW\_AT\_location}(...)
OUTER.AI.3.6:
            \livelink{chap:DWTAGvariable}{DW\_TAG\_variable}
                \livelink{chap:DWATname}{DW\_AT\_name}("INNER\_LOCAL")
                \livelink{chap:DWATtype}{DW\_AT\_type}(reference to integer)
                \livelink{chap:DWATlocation}{DW\_AT\_location}(...)
            ...
            0
        ...
        0
\end{alltt}
\end{dwflisting}
\caption{Inlining example \#3: abstract instance}
\label{fig:inliningexample3abstractinstance}
\end{figure}

\begin{figure}[t]
\begin{dwflisting}
\begin{alltt}
    ! Concrete instance for call "OUTER(7)"
    ! \addtoindexx{concrete instance!example}
OUTER.CI.3.1:
    \livelink{chap:DWTAGinlinedsubroutine}{DW\_TAG\_inlined\_subroutine}
        ! No name
        \livelink{chap:DWATabstractorigin}{DW\_AT\_abstract\_origin}(reference to OUTER.AI.3.1)
        \livelink{chap:DWATlowpc}{DW\_AT\_low\_pc}(...)
        \livelink{chap:DWAThighpc}{DW\_AT\_high\_pc}(...)
        \livelink{chap:DWATframebase}{DW\_AT\_frame\_base}(...)
OUTER.CI.3.2:
        \livelink{chap:DWTAGformalparameter}{DW\_TAG\_formal\_parameter}
            ! No name
            \livelink{chap:DWATabstractorigin}{DW\_AT\_abstract\_origin}(reference to OUTER.AI.3.2)
            ! No type
            \livelink{chap:DWATlocation}{DW\_AT\_location}(...)
OUTER.CI.3.3:
        \livelink{chap:DWTAGvariable}{DW\_TAG\_variable}
            ! No name
            \livelink{chap:DWATabstractorigin}{DW\_AT\_abstract\_origin}(reference to OUTER.AI.3.3)
            ! No type
            \livelink{chap:DWATlocation}{DW\_AT\_location}(...)
        ! No \livelink{chap:DWTAGsubprogram}{DW\_TAG\_subprogram} for "INNER"
        ...
        0
\end{alltt}
\end{dwflisting}
\caption{Inlining example \#3: concrete instance}
\label{fig:inliningexample3concreteinstance}
\end{figure}

\clearpage
\section{Constant Expression Example}
\label{app:constantexpressionexample}
C++ generalizes the notion of constant expressions to include
constant expression user-defined literals and functions.
The constant declarations in Figure \refersec{fig:constantexpressionscsource}
can be represented as illustrated in 
Figure \refersec{fig:constantexpressionsdwarfdescription}.


\begin{figure}[here]
\begin{lstlisting}[numbers=none]
constexpr double mass = 9.8;
constexpr int square (int x) { return x * x; }
float arr[square(9)]; // square() called and inlined
\end{lstlisting}
\caption{Constant expressions: C++ source} \label{fig:constantexpressionscsource}
\end{figure}


\begin{figure}[!h]
\begin{dwflisting}
\begin{alltt}
        ! For variable mass
        !
1\$:     \livelink{chap:DWTAGconsttype}{DW\_TAG\_const\_type}
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to "double")
2\$:     \livelink{chap:DWTAGvariable}{DW\_TAG\_variable}
            \livelink{chap:DWATname}{DW\_AT\_name}("mass")
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 1\$)
            \livelink{chap:DWATconstexpr}{DW\_AT\_const\_expr}(true)
            \livelink{chap:DWATconstvalue}{DW\_AT\_const\_value}(9.8)
        ! Abstract instance for square
        !
10\$:    \livelink{chap:DWTAGsubprogram}{DW\_TAG\_subprogram}
            \livelink{chap:DWATname}{DW\_AT\_name}("square")
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to "int")
            \livelink{chap:DWATinline}{DW\_AT\_inline}(\livelink{chap:DWINLinlined}{DW\_INL\_inlined})
11\$:        \livelink{chap:DWTAGformalparameter}{DW\_TAG\_formal\_parameter}
                \livelink{chap:DWATname}{DW\_AT\_name}("x")
                \livelink{chap:DWATtype}{DW\_AT\_type}(reference to "int")
        ! Concrete instance for square(9)
        ! \addtoindexx{concrete instance!example}
20\$:    \livelink{chap:DWTAGinlinedsubroutine}{DW\_TAG\_inlined\_subroutine}
            \livelink{chap:DWATabstractorigin}{DW\_AT\_abstract\_origin}(reference to 10\$)
            \livelink{chap:DWATconstexpr}{DW\_AT\_const\_expr}(present)
            \livelink{chap:DWATconstvalue}{DW\_AT\_const\_value}(81)
            \livelink{chap:DWTAGformalparameter}{DW\_TAG\_formal\_parameter}
                \livelink{chap:DWATabstractorigin}{DW\_AT\_abstract\_origin}(reference to 11\$)
                \livelink{chap:DWATconstvalue}{DW\_AT\_const\_value}(9)
        ! Anonymous array type for arr
        !
30\$:    \livelink{chap:DWTAGarraytype}{DW\_TAG\_array\_type}
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to "float")
            \livelink{chap:DWATbytesize}{DW\_AT\_byte\_size}(324) ! 81*4
            \livelink{chap:DWTAGsubrangetype}{DW\_TAG\_subrange\_type}
                \livelink{chap:DWATtype}{DW\_AT\_type}(reference to "int")
                \livelink{chap:DWATupperbound}{DW\_AT\_upper\_bound}(reference to 20\$)
        ! Variable arr
        !
40\$:    \livelink{chap:DWTAGvariable}{DW\_TAG\_variable}
            \livelink{chap:DWATname}{DW\_AT\_name}("arr")
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 30\$)
\end{alltt}
\end{dwflisting}
\caption{Constant expressions: DWARF description}
\label{fig:constantexpressionsdwarfdescription}
\end{figure}

\section{Unicode Character Example}
\label{app:unicodecharacterexample}
\addtoindexx{Unicode|see {\textit{also} UTF-8}}
The \addtoindex{Unicode} character encodings in
Figure \refersec{fig:unicodecharacterexamplesource}
can be described in DWARF as illustrated in 
Figure \refersec{fig:unicodecharacterexampledwarfdescription}.

\begin{figure}[!h]
\begin{lstlisting}[numbers=none]
// C++ source
//
char16_t chr_a = u'h';
char32_t chr_b = U'h';
\end{lstlisting}
\caption{Unicode character example: source}
\label{fig:unicodecharacterexamplesource}
\end{figure}

\begin{figure}[h]
\begin{dwflisting}
\begin{alltt}

! DWARF description
!
1\$: \livelink{chap:DWTAGbasetype}{DW\_TAG\_base\_type}
        \livelink{chap:DWATname}{DW\_AT\_name}("char16\_t")
        \livelink{chap:DWATencoding}{DW\_AT\_encoding}(\livelink{chap:DWATEUTF}{DW\_ATE\_UTF})
        \livelink{chap:DWATbytesize}{DW\_AT\_byte\_size}(2)
2\$: \livelink{chap:DWTAGbasetype}{DW\_TAG\_base\_type}
        \livelink{chap:DWATname}{DW\_AT\_name}("char32\_t")
        \livelink{chap:DWATencoding}{DW\_AT\_encoding}(\livelink{chap:DWATEUTF}{DW\_ATE\_UTF})
        \livelink{chap:DWATbytesize}{DW\_AT\_byte\_size}(4)
3\$: \livelink{chap:DWTAGvariable}{DW\_TAG\_variable}
        \livelink{chap:DWATname}{DW\_AT\_name}("chr\_a")
        \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 1\$)
4\$: \livelink{chap:DWTAGvariable}{DW\_TAG\_variable}
        \livelink{chap:DWATname}{DW\_AT\_name}("chr\_b")
        \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 2\$)
\end{alltt}
\end{dwflisting}
\caption{Unicode character example: DWARF description}
\label{fig:unicodecharacterexampledwarfdescription}
\end{figure}


\section{Type-Safe Enumeration Example}
\label{app:typesafeenumerationexample}

The \addtoindex{C++} type\dash safe enumerations in
\addtoindexx{type-safe enumeration}
Figure \refersec{fig:ctypesafeenumerationexamplesource}
can be described in DWARF as illustrated in 
Figure \refersec{fig:ctypesafeenumerationexampledwarf}.

\clearpage	% Get following source and DWARF on same page

\begin{figure}[H]
\begin{lstlisting}[numbers=none]
// C++ source
//
enum class E { E1, E2=100 };
E e1;
\end{lstlisting}
\caption{Type-safe enumeration example: source}
\label{fig:ctypesafeenumerationexamplesource}
\end{figure}

\begin{figure}[H]
\begin{dwflisting}
\begin{alltt}
! DWARF description
!
11\$:  \livelink{chap:DWTAGenumerationtype}{DW\_TAG\_enumeration\_type}
          \livelink{chap:DWATname}{DW\_AT\_name}("E")
          \livelink{chap:DWATtype}{DW\_AT\_type}(reference to "int")
          \livelink{chap:DWATenumclass}{DW\_AT\_enum\_class}(present)
12\$:      \livelink{chap:DWTAGenumerator}{DW\_TAG\_enumerator}
              \livelink{chap:DWATname}{DW\_AT\_name}("E1")
              \livelink{chap:DWATconstvalue}{DW\_AT\_const\_value}(0)
13\$:      \livelink{chap:DWTAGenumerator}{DW\_TAG\_enumerator}
              \livelink{chap:DWATname}{DW\_AT\_name}("E2")
              \livelink{chap:DWATconstvalue}{DW\_AT\_const\_value}(100)
14\$:  \livelink{chap:DWTAGvariable}{DW\_TAG\_variable}
         \livelink{chap:DWATname}{DW\_AT\_name}("e1")
         \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 11\$)
\end{alltt}
\end{dwflisting}
\caption{Type-safe enumeration example: DWARF description}
\label{fig:ctypesafeenumerationexampledwarf}
\end{figure}


\clearpage
\section{Template Examples}
\label{app:templateexample}

The C++ template example in
Figure \refersec{fig:ctemplateexample1source}
can be described in DWARF as illustrated in 
Figure \refersec{fig:ctemplateexample1dwarf}.

\begin{figure}[h]
\begin{lstlisting}
// C++ source
//
template<class T>
struct wrapper {
    T comp;
};
wrapper<int> obj;
\end{lstlisting}
\caption{C++ template example \#1: source}
\label{fig:ctemplateexample1source}
\end{figure}

\begin{figure}[h]
\begin{dwflisting}
\begin{alltt}
! DWARF description
!
11\$: \livelink{chap:DWTAGstructuretype}{DW\_TAG\_structure\_type}
        \livelink{chap:DWATname}{DW\_AT\_name}("wrapper")
12\$:    \livelink{chap:DWTAGtemplatetypeparameter}{DW\_TAG\_template\_type\_parameter}
            \livelink{chap:DWATname}{DW\_AT\_name}("T")
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to "int")
13\$:    \livelink{chap:DWTAGmember}{DW\_TAG\_member}
            \livelink{chap:DWATname}{DW\_AT\_name}("comp")
            \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 12\$)
14\$: \livelink{chap:DWTAGvariable}{DW\_TAG\_variable}
        \livelink{chap:DWATname}{DW\_AT\_name}("obj")
        \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 11\$)
\end{alltt}
\end{dwflisting}
\caption{C++ template example \#1: DWARF description}
\label{fig:ctemplateexample1dwarf}
\end{figure}

The actual type of the component \texttt{comp} is \texttt{int}, but in the DWARF
the type references the
\livelink{chap:DWTAGtemplatetypeparameter}{DW\_TAG\_template\_type\_parameter}
for \texttt{T}, which in turn references \texttt{int}. This implies that in the
original template comp was of type \texttt{T} and that was replaced
with \texttt{int} in the instance. 

\needlines{10}
There exist situations where it is
not possible for the DWARF to imply anything about the nature
of the original template. 
Consider the C++ template source in
Figure \refersec{fig:ctemplateexample2source}
and the DWARF that can describe it in
Figure \refersec{fig:ctemplateexample2dwarf}.

\begin{figure}[!h]
\begin{lstlisting}
// C++ source
//
    template<class T>
    struct wrapper {
        T comp;
    };
    template<class U>
    void consume(wrapper<U> formal)
    {
        ...
    }
    wrapper<int> obj;
    consume(obj);
\end{lstlisting}
\caption{C++ template example \#2: source}
\label{fig:ctemplateexample2source}
\end{figure}

\begin{figure}[h]
\begin{dwflisting}
\begin{alltt}
! DWARF description
!
11\$:  \livelink{chap:DWTAGstructuretype}{DW\_TAG\_structure\_type}
          \livelink{chap:DWATname}{DW\_AT\_name}("wrapper")
12\$:      \livelink{chap:DWTAGtemplatetypeparameter}{DW\_TAG\_template\_type\_parameter}
              \livelink{chap:DWATname}{DW\_AT\_name}("T")
              \livelink{chap:DWATtype}{DW\_AT\_type}(reference to "int")
13\$:      \livelink{chap:DWTAGmember}{DW\_TAG\_member}
              \livelink{chap:DWATname}{DW\_AT\_name}("comp")
              \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 12\$)
14\$:  \livelink{chap:DWTAGvariable}{DW\_TAG\_variable}
          \livelink{chap:DWATname}{DW\_AT\_name}("obj")
          \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 11\$)
21\$:  \livelink{chap:DWTAGsubprogram}{DW\_TAG\_subprogram}
          \livelink{chap:DWATname}{DW\_AT\_name}("consume")
22\$:      \livelink{chap:DWTAGtemplatetypeparameter}{DW\_TAG\_template\_type\_parameter}
              \livelink{chap:DWATname}{DW\_AT\_name}("U")
              \livelink{chap:DWATtype}{DW\_AT\_type}(reference to "int")
23\$:      \livelink{chap:DWTAGformalparameter}{DW\_TAG\_formal\_parameter}
              \livelink{chap:DWATname}{DW\_AT\_name}("formal")
              \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 11\$)
\end{alltt}
\end{dwflisting}
\caption{C++ template example \#2: DWARF description}
\label{fig:ctemplateexample2dwarf}
\end{figure}

In the \livelink{chap:DWTAGsubprogram}{DW\_TAG\_subprogram} 
entry for the instance of consume, \texttt{U} is described as \texttt{int}. 
The type of formal is \texttt{wrapper\textless U\textgreater} in
the source. DWARF only represents instantiations of templates;
there is no entry which represents \texttt{wrapper\textless U\textgreater} 
which is neither
a template parameter nor a template instantiation. The type
of formal is described as \texttt{wrapper\textless int\textgreater},
the instantiation of \texttt{wrapper\textless U\textgreater},
in the \livelink{chap:DWATtype}{DW\_AT\_type} attribute at 
23\$. 
There is no
description of the relationship between template type parameter
\texttt{T} at 12\$ and \texttt{U} at 22\$ which was used to instantiate
\texttt{wrapper\textless U\textgreater}.

A consequence of this is that the DWARF information would
not distinguish between the existing example and one where
the formal parameter of \texttt{consume} were declared in the source to be
\texttt{wrapper\textless int\textgreater}.


\section{Template Alias Examples}
\label{app:templatealiasexample}

The \addtoindex{C++} template alias shown in
Figure \refersec{fig:ctemplatealiasexample1source}
can be described in DWARF as illustrated 
\addtoindexx{template alias example} in 
Figure \refersec{fig:ctemplatealiasexample1dwarf}.

\begin{figure}[h]
\begin{lstlisting}
// C++ source, template alias example 1
//
template<typename T, typename U>
struct Alpha {
    T tango;
    U uniform;
};
template<typename V> using Beta = Alpha<V,V>;
Beta<long> b;
\end{lstlisting}
\caption{C++ template alias example \#1: source}
\label{fig:ctemplatealiasexample1source}
\end{figure}

\begin{figure}[h]
\addtoindexx{template alias example 1}
\begin{dwflisting}
\begin{alltt}
! DWARF representation for variable 'b'
!
20\$:  \livelink{chap:DWTAGstructuretype}{DW\_TAG\_structure\_type}
          \livelink{chap:DWATname}{DW\_AT\_name}("Alpha")
21\$:      \livelink{chap:DWTAGtemplatetypeparameter}{DW\_TAG\_template\_type\_parameter}
              \livelink{chap:DWATname}{DW\_AT\_name}("T")
              \livelink{chap:DWATtype}{DW\_AT\_type}(reference to "long")
22\$:      \livelink{chap:DWTAGtemplatetypeparameter}{DW\_TAG\_template\_type\_parameter}
              \livelink{chap:DWATname}{DW\_AT\_name}("U")
              \livelink{chap:DWATtype}{DW\_AT\_type}(reference to "long")
23\$:      \livelink{chap:DWTAGmember}{DW\_TAG\_member}
              \livelink{chap:DWATname}{DW\_AT\_name}("tango")
              \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 21\$)
24\$:      \livelink{chap:DWTAGmember}{DW\_TAG\_member}
              \livelink{chap:DWATname}{DW\_AT\_name}("uniform")
              \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 22\$)
25\$:  \livelink{chap:DWTAGtemplatealias}{DW\_TAG\_template\_alias}
          \livelink{chap:DWATname}{DW\_AT\_name}("Beta")
          \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 20\$)
26\$:      \livelink{chap:DWTAGtemplatetypeparameter}{DW\_TAG\_template\_type\_parameter}
              \livelink{chap:DWATname}{DW\_AT\_name}("V")
              \livelink{chap:DWATtype}{DW\_AT\_type}(reference to "long")
27\$:  \livelink{chap:DWTAGvariable}{DW\_TAG\_variable}
          \livelink{chap:DWATname}{DW\_AT\_name}("b")
          \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 25\$)
\end{alltt}
\end{dwflisting}
\caption{C++ template alias example \#1: DWARF description}
\label{fig:ctemplatealiasexample1dwarf}
\end{figure}

Similarly, the \addtoindex{C++} template alias shown in
Figure \refersec{fig:ctemplatealiasexample2source}
can be described in DWARF as illustrated 
\addtoindexx{template alias example} in 
Figure \refersec{fig:ctemplatealiasexample2dwarf}.

\begin{figure}[h]
\begin{lstlisting}
// C++ source, template alias example 2
//
template<class TX> struct X { };
template<class TY> struct Y { };
template<class T> using Z = Y<T>;
X<Y<int>> y;
X<Z<int>> z;
\end{lstlisting}
\caption{C++ template alias example \#2: source}
\label{fig:ctemplatealiasexample2source}
\end{figure}

\begin{figure}[h]
\addtoindexx{template alias example 2}
\begin{dwflisting}
\begin{alltt}
! DWARF representation for X<Y<int>>
!
30\$:  \livelink{chap:DWTAGstructuretype}{DW\_TAG\_structure\_type}
          \livelink{chap:DWATname}{DW\_AT\_name}("Y")
31\$:      \livelink{chap:DWTAGtemplatetypeparameter}{DW\_TAG\_template\_type\_parameter}
              \livelink{chap:DWATname}{DW\_AT\_name}("TY")
              \livelink{chap:DWATtype}{DW\_AT\_type}(reference to "int")
32\$:  \livelink{chap:DWTAGstructuretype}{DW\_TAG\_structure\_type}
          \livelink{chap:DWATname}{DW\_AT\_name}("X")
33\$:      \livelink{chap:DWTAGtemplatetypeparameter}{DW\_TAG\_template\_type\_parameter}
              \livelink{chap:DWATname}{DW\_AT\_name}("TX")
              \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 30\$)
!
! DWARF representation for X<Z<int>>
!
40\$:  \livelink{chap:DWTAGtemplatealias}{DW\_TAG\_template\_alias}
          \livelink{chap:DWATname}{DW\_AT\_name}("Z")
          \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 30\$)
41\$:      \livelink{chap:DWTAGtemplatetypeparameter}{DW\_TAG\_template\_type\_parameter}
              \livelink{chap:DWATname}{DW\_AT\_name}("T")
              \livelink{chap:DWATtype}{DW\_AT\_type}(reference to "int")
42\$:  \livelink{chap:DWTAGstructuretype}{DW\_TAG\_structure\_type}
          \livelink{chap:DWATname}{DW\_AT\_name}("X")
43\$:      \livelink{chap:DWTAGtemplatetypeparameter}{DW\_TAG\_template\_type\_parameter}
              \livelink{chap:DWATname}{DW\_AT\_name}("TX")
              \livelink{chap:DWATtype}{DW\_AT\_type}(reference to 40\$)
!
! Note that 32\$ and 42\$ are actually the same type
!
50\$:  \livelink{chap:DWTAGvariable}{DW\_TAG\_variable}
          \livelink{chap:DWATname}{DW\_AT\_name}("y")
          \livelink{chap:DWATtype}{DW\_AT\_type}(reference to \$32)
51\$:  \livelink{chap:DWTAGvariable}{DW\_TAG\_variable}
          \livelink{chap:DWATname}{DW\_AT\_name}("z")
          \livelink{chap:DWATtype}{DW\_AT\_type}(reference to \$42)
\end{alltt}
\end{dwflisting}
\caption{C++ template alias example \#2: DWARF description}
\label{fig:ctemplatealiasexample2dwarf}
\end{figure}
