DWARF  Debugging  Information  Format
                                                Version  6
  DWARF  Debugging  Information  Format
                                              Committee
                        http://www.dwarfstd.org
                                        November  1,  2024
                         ***WORKING  DRAFT***

                                                          Copyright
                                 DWARF Debugging Information Format, Version 6
               Copyright #  2010, 2017, 2024 DWARF Debugging Information Format
                                                              Committee
          Permission is granted to copy, distribute and/or modify this document
          under the terms of the GNU Free Documentation License, Version 1.3; with
          no Invariant Sections, with no Front-Cover          Texts, and with no Back-Cover
          Texts.
          A copy of the license is included in the section entitled iGNU Free
          Documentation License.j
          This document is based in part on the DWARF Debugging Information
          Format, Version 2, which contained the following notice:
                   UNIX International
                   Programming Languages SIG
                   Revision: 2.0.0 (July 27, 1993)
                   Copyright # 1992, 1993 UNIX International, Inc.
                   Permission to use, copy, modify, and distribute this documentation for
                   any purpose and without fee is hereby granted, provided that the
                   above copyright notice appears in all copies and that both that
                   copyright notice and this permission notice appear in supporting
                   documentation, and that the name UNIX International not be used in
                   advertising or publicity pertaining to distribution of the software
                   without specioc, written prior permission. UNIX International makes
                   no representations about the suitability of this documentation for any
                   purpose. It is provided ias isj without express or implied warranty.
          This document is further based on the DWARF Debugging Information
          Format, Version 3 and Version 4, which are subject to the GNU Free
          Documentation License.
          Trademarks:
               #   Intel386 is a trademark of Intel Corporation.
               #   Java is a trademark of Oracle, Inc.
               #   All other trademarks found herein are property of their respective
                   owners.
November 1, 2024                                  ***WORKING DRAFT***                                                               Page ii

                                                          Foreword
          The DWARF Debugging Information Format Committee was originally
          organized in 1988 as the Programming Languages Special Interest Group
          (PLSIG) of Unix International, Inc., a trade group organized to promote Unix
          System V Release 4 (SVR4).
          PLSIG drafted a standard for DWARF Version 1, compatible with the
          DWARF debugging format used at the time by SVR4 compilers and
          debuggers from AT&T. This was published as Revision 1.1.0 on October 6,
          1992. PLSIG also designed the DWARF Version 2 format, which followed the
          same general philosophy as Version 1, but with signiocant new functionality
          and a more compact, though incompatible, encoding. An industry review
          draft of DWARF Version 2 was published as Revision 2.0.0 on July 27, 1993.
          Unix International dissolved shortly after the draft of Version 2 was released;
          no industry comments were received or addressed, and no onal standard
          was released. The committee mailing list was hosted by OpenGroup
          (formerly XOpen).
          The Committee reorganized in October, 1999, and met for the next several
          years to address issues that had been noted with DWARF Version 2 as well
          as to add a number of new features. In mid-2003, the Committee became a
          workgroup under the Free Standards Group (FSG), an industry consortium
          chartered to promote open standards. DWARF Version 3 was published on
          December 20, 2005, following industry review and comment.
          The DWARF Committee withdrew from the Free Standards Group in
          February, 2007, when FSG merged with the Open Source Development Labs
          to form The Linux Foundation, more narrowly focused on promoting Linux.
          The DWARF Committee has been independent since that time.
          It is the intention of the DWARF Committee that migrating from an earlier
          version of the DWARF standard to the current version should be
          straightforward and easily accomplished. Almost all constructs from
          DWARF Version 2 onward have been retained unchanged in DWARF
          Version 6, although a few have been compatibly superseded by improved
          constructs which are more compact and/or more expressive.
          This document was created using theALTEX document preparation system.
November 1, 2024                                  ***WORKING DRAFT***                                                              Page iii

          The DWARF Debugging Information Format Committee
          The DWARF Debugging Information Format Committee is open to compiler
          and debugger developers who have experience with source language
          debugging and debugging formats, and have an interest in promoting or
          extending the DWARF debugging format.
          DWARF Committee members contributing to Version 6 are:
                Todd Allen                                                                 Concurrent Real-Time
                Pedro Alves                                                                Pedro Alves Services
                David Anderson, Associate Editor
                David Blaikie                                                              Google
                Ron Brender, Editor
                Andrew Cagney
                Eric Christopher                                                           Google
                Cary Coutant, Chair (from March 2023)
                John DelSignore                                                            Perforce
                Jonas Devlieghere                                                          Apple
                Michael Eager, past Chair (to February 2023)                               Eager Consulting
                Jini Susan George                                                          AMD
                Tommy Hooener                                                              Untether AI
                Jakub Jel#nek                                                              Red Hat
                Simon Marchi                                                               EOEciOS
                Jason Merrill                                                              Red Hat
                Markus Metzger                                                             Intel
                Jeremy Morse                                                               Sony
                Adrian Prantl                                                              Apple
                Haoz Abid Qadeer                                                           Mentor Graphics
                Paul Robinson                                                              Sony
                Tom Russell                                                                Sony
                Fa#ng-rui S#ng                                                             Google
                Caroline Tice                                                              Google
                Tom Tromey                                                                 Adacore
                Tony Tye                                                                   AMD
                Keith Walker                                                               Arm
                Mark Wielaard                                                              Red Hat
                Brock Wyma                                                                 Intel
                Jian Xu                                                                    IBM
                Zoran Zaric                                                                AMD
          For further information about DWARF or the DWARF Committee, see:
                 http://www.dwarfstd.org
November 1, 2024                                  ***WORKING DRAFT***                                                              Page iv

          How to Use This Document
          This document is intended to be usable in online as well as traditional paper
          forms. Both online and paper forms include page numbers, a Table of
          Contents, a List of Figures, a List of Tables and an Index.
          Text in normal font describes required aspects of the DWARF format. Text in
          italics is explanatory or supplementary material, and not part of the format
          deonition itself.
          Online Form
          In the online form, blue text is used to indicate hyperlinks. Most hyperlinks
          link to the deonition of a term or construct, or to a cited Section or Figure.
          However, attributes in particular are often used in more than one way or
          context so that there is no single deonition; for attributes, hyperlinks link to
          the introductory table of all attributes which in turn contains hyperlinks for
          the multiple usages.
          The occurrence of a DWARF name in its deonition (or one of its deonitions
          in the case of some attributes) is shown in red text. Other occurrences of the
          same name in the same or possibly following paragraphs are generally in
          normal text color.)
          The Table of Contents, List of Figures, List of Tables and Index provide
          hyperlinks to the respective items and places.
          Paper Form
          In the traditional paper form, the appearance of the hyperlinks and
          deonitions on a page of paper does not distract the eye because the blue
          hyperlinks and the color used for deonitions are typically imaged by black
          and white printers in a manner nearly indistinguishable from other text.
          (Hyperlinks are not underlined for this same reason.)
November 1, 2024                                  ***WORKING DRAFT***                                                               Page v

November 1, 2024                                  ***WORKING DRAFT***                                                              Page vi
                                                             CONTENTS
Contents
Contents                                                                                                                         vii
List of Figures                                                                                                                xii
List of Tables                                                                                                                 xvi
1     Introduction                                                                                                                1
      1.1      Purpose and Scope    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .        1
      1.2      Overview  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .        2
      1.3      Objectives and Rationale   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .        2
      1.4      Changes from Version 5 to Version 6   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .        8
      1.5      Changes from Version 4 to Version 5   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .        8
      1.6      Changes from Version 3 to Version 4   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      10
      1.7      Changes from Version 2 to Version 3   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      11
      1.8      Changes from Version 1 to Version 2   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      12
2     General Description                                                                                                15
      2.1      The Debugging Information Entry (DIE)  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      15
      2.2      Attribute Types    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      17
      2.3      Relationship of Debugging Information Entries  .  .  .  .  .  .  .  .  .  .  .  .      25
      2.4      Target Addresses    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      26
      2.5      DWARF Expressions    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      26
      2.6      Location Descriptions  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      39
      2.7      Types of Program Entities    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      48
      2.8      Accessibility of Declarations  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      48
      2.9      Visibility of Declarations   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      48
      2.10     Virtuality of Declarations  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      49
      2.11     Artiocial Entries  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      49
      2.12     Address Classes   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      50
      2.13     Non-Deoning Declarations and Completions   .  .  .  .  .  .  .  .  .  .  .  .  .      50
      2.14     Declaration Coordinates   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      51
November 1, 2024                                  ***WORKING DRAFT***                                                             Page vii
                                                             CONTENTS
      2.15     Identioer Names .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      52
      2.16     Data Locations and DWARF Procedures   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      52
      2.17     Code Addresses, Ranges and Base Addresses  .  .  .  .  .  .  .  .  .  .  .  .  .      53
      2.18     Entry Address   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      57
      2.19     Static and Dynamic Values of Attributes   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      57
      2.20     Entity Descriptions   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      58
      2.21     Byte and Bit Sizes   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      58
      2.22     Linkage Names    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      58
      2.23     Template Parameters   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      59
      2.24     Alignment   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      60
3     Program Scope Entries                                                                                            61
      3.1      Unit Entries    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      61
      3.2      Module, Namespace and Importing Entries   .  .  .  .  .  .  .  .  .  .  .  .  .  .      73
      3.3      Subroutine and Entry Point Entries  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      78
      3.4      Call Site Entries and Parameters  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      93
      3.5      Lexical Block Entries    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      96
      3.6      Label Entries  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      97
      3.7      With Statement Entries   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      97
      3.8      Try and Catch Block Entries   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      98
      3.9      Declarations with Reduced Scope  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      99
4     Data Object and Object List                                                                                101
      4.1      Data Object Entries   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    101
      4.2      Common Block Entries   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    104
      4.3      Namelist Entries  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    105
5     Type Entries                                                                                                            106
      5.1      Base Type Entries   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    106
      5.2      Unspecioed Type Entries  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    112
      5.3      Type Modioer Entries  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    113
      5.4      Typedef Entries    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    115
      5.5      Array Type Entries    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    115
      5.6      Coarray Type Entries   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    117
      5.7      Structure, Union, Class and Interface Type Entries   .  .  .  .  .  .  .  .  .  .    118
      5.8      Condition Entries   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    129
      5.9      Enumeration Type Entries   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    129
      5.10     Subroutine Type Entries    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    131
      5.11     String Type Entries    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    132
      5.12     Set Type Entries   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    133
      5.13     Subrange Type Entries    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    133
November 1, 2024                                  ***WORKING DRAFT***                                                           Page viii
                                                             CONTENTS
      5.14     Pointer to Member Type Entries  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    135
      5.15     File Type Entries  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    136
      5.16     Dynamic Type Entries    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    136
      5.17     Template Alias Entries   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    137
      5.18     Dynamic Properties of Types .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    137
6     Other Debugging Information                                                                            140
      6.1      Accelerated Access   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    140
      6.2      Line Number Information   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    155
      6.3      Macro Information    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    172
      6.4      Call Frame Information  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    179
7     Data Representation                                                                                              191
      7.1      Extensibility   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    191
      7.2      Reserved Values  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    192
      7.3      Relocatable, Split, Executable, Shared, Package and Supplementary
               Object Files  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    193
      7.4      32-Bit and 64-Bit DWARF Formats    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    204
      7.5      Format of Debugging Information    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    208
      7.6      Variable Length Data   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    231
      7.7      DWARF Expressions and Location Descriptions    .  .  .  .  .  .  .  .  .  .  .    232
      7.8      Base Type Attribute Encodings    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    237
      7.9      Accessibility Codes   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    239
      7.10     Visibility Codes   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    239
      7.11     Virtuality Codes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    240
      7.12     Source Languages  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    240
      7.13     Address Class Encodings  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    242
      7.14     Identioer Case  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    243
      7.15     Calling Convention Encodings    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    243
      7.16     Inline Codes   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    244
      7.17     Array Ordering    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    244
      7.18     Discriminant Lists  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    244
      7.19     Name Index Table  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    245
      7.20     Defaulted Member Encodings  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    245
      7.21     Address Range Table   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    246
      7.22     Line Number Information   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    247
      7.23     Macro Information    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    249
      7.24     Call Frame Information  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    251
      7.25     Range List Entries for Non-contiguous Address Ranges   .  .  .  .  .  .  .    252
      7.26     String Ooesets Table   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    253
      7.27     Address Table   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    254
November 1, 2024                                  ***WORKING DRAFT***                                                              Page ix
                                                             CONTENTS
      7.28     Range List Table  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    255
      7.29     Value List and Location List Table  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    256
      7.30     Dependencies and Constraints .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    257
      7.31     Integer Representation Names  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    258
      7.32     Type Signature Computation    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    258
      7.33     Name Table Hash Function    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    262
      7.34     Contiguous Tables  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    263
A     Attributes by Tag (Informative)                                                                          265
B     Debug Section Relationships (Informative)                                                     287
      B.1      Normal DWARF Section Relationships  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    287
      B.2      Split DWARF Section Relationships  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    288
C     Encoding/Decoding (Informative)                                                                     297
D     Examples (Informative)                                                                                        301
      D.1      General Description Examples  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    301
      D.2      Aggregate Examples    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    307
      D.3      Namespace Examples  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    334
      D.4      Member Function Examples  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    338
      D.5      Line Number Examples .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    342
      D.6      Call Frame Information Example   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    346
      D.7      Inlining Examples  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    350
      D.8      Constant Expression Example  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    359
      D.9      Unicode Character Example   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    361
      D.10     Type-Safe Enumeration Example   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    362
      D.11     Template Examples   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    363
      D.12     Template Alias Examples  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    365
      D.13     Implicit Pointer Examples   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    368
      D.14     String Type Examples  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    372
      D.15     Call Site Examples .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    374
      D.16     Macro Example    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    382
      D.17     Parameter Default Value Examples   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    386
      D.18     SIMD Lane Example    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    388
E     Compression (Informative)                                                                                 391
      E.1      Using Compilation Units  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    391
      E.2      Using Type Units    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    401
      E.3      Summary of Compression Techniques   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    414
F     Split DWARF Object Files (Informative)                                                          417
November 1, 2024                                  ***WORKING DRAFT***                                                               Page x
                                                             CONTENTS
      F.1      Overview  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    417
      F.2      Split DWARF Object File Example    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    422
      F.3      DWARF Package File Example    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    435
G     Section Version Numbers (Informative)                                                           441
H     GNU Free Documentation License                                                                    445
      H.1      APPLICABILITY AND DEFINITIONS  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    446
      H.2      VERBATIM COPYING   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    447
      H.3      COPYING IN QUANTITY  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    448
      H.4      MODIFICATIONS .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    449
      H.5      COMBINING DOCUMENTS   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    451
      H.6      COLLECTIONS OF DOCUMENTS  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    451
      H.7      AGGREGATION WITH INDEPENDENT WORKS  .  .  .  .  .  .  .  .  .  .    451
      H.8      TRANSLATION  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    452
      H.9      TERMINATION  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    452
      H.10     FUTURE REVISIONS OF THIS LICENSE   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    453
      H.11     RELICENSING    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    453
Index                                                                                                                              457
November 1, 2024                                  ***WORKING DRAFT***                                                              Page xi
                                                        LIST OF FIGURES
List  of  Figures
5.1      Type modioer examples    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    114
6.1      Name Index Layout  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    144
7.1      Name Table Hash Function Deonition   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    263
B.1      Debug section relationships   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    289
B.2      Split DWARF section relationships   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    293
C.1      Algorithm to encode an unsigned integer   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    297
C.2      Algorithm to encode a signed integer .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    298
C.3      Algorithm to decode an unsigned LEB128 integer    .  .  .  .  .  .  .  .  .  .  .  .    298
C.4      Algorithm to decode a signed LEB128 integer  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    299
D.1      Compilation units and abbreviations table  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    302
D.2      Fortran array example: source fragment   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    307
D.3      Fortran array example: descriptor representation  .  .  .  .  .  .  .  .  .  .  .  .  .    308
D.4      Fortran array example: DWARF description  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    311
D.5      Fortran scalar coarray: source fragment    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    314
D.6      Fortran scalar coarray: DWARF description   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    314
D.7      Fortran array coarray: source fragment .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    314
D.8      Fortran array coarray: DWARF description   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    314
D.9      Fortran multidimensional coarray: source fragment   .  .  .  .  .  .  .  .  .  .  .    315
D.10     Fortran multidimensional coarray: DWARF description  .  .  .  .  .  .  .  .  .    315
D.11     Declaration of a Fortran 2008 assumed-rank array   .  .  .  .  .  .  .  .  .  .  .  .    316
D.12     One of many possible layouts for an array descriptor    .  .  .  .  .  .  .  .  .  .    316
D.13     Sample DWARF for the array descriptor in Figure D.12   .  .  .  .  .  .  .  .  .    317
D.14     How to interpret the DWARF from Figure D.13  .  .  .  .  .  .  .  .  .  .  .  .  .  .    318
D.15     Fortran dynamic type example: source  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    319
D.16     Fortran dynamic type example: DWARF description  .  .  .  .  .  .  .  .  .  .  .    320
D.17     Anonymous structure example: source fragment  .  .  .  .  .  .  .  .  .  .  .  .  .    321
D.18     Anonymous structure example: DWARF description .  .  .  .  .  .  .  .  .  .  .    321
D.19     Ada example: source fragment    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    322
November 1, 2024                                  ***WORKING DRAFT***                                                             Page xii
                                                        LIST OF FIGURES
D.20     Ada example: DWARF description   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    323
D.21     Packed record example: source fragment    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    324
D.22     Packed record example: DWARF description   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    324
D.23     Big-endian data bit ooesets   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    327
D.24     Little-endian data bit ooesets   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    327
D.25     Ada biased bit-oeld example: Ada source   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    328
D.26     Ada biased bit-oeld example: DWARF description  .  .  .  .  .  .  .  .  .  .  .  .    328
D.27     Pascal variant record example: source   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    329
D.28     Pascal variant record example: DWARF description   .  .  .  .  .  .  .  .  .  .  .    330
D.29     Ada variant record example: source    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    331
D.30     Ada variant record example: DWARF description    .  .  .  .  .  .  .  .  .  .  .  .    332
D.31     Rust enum example: source   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    332
D.32     Rust enum example: DWARF description   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    333
D.33     Namespace example #1: source fragment    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    334
D.34     Namespace example #1: DWARF description   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    335
D.35     Namespace example #2: source fragment    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    337
D.36     Namespace example #2: DWARF description   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    337
D.37     Member function example: source fragment  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    338
D.38     Member function example: DWARF description    .  .  .  .  .  .  .  .  .  .  .  .  .    338
D.39     Reference- and rvalue-reference-qualiocation example: source fragment          340
D.40     Reference- and rvalue-reference-qualiocation example: DWARF description
             .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    341
D.41     Example line number program header   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    342
D.42     Example line number special opcode mapping   .  .  .  .  .  .  .  .  .  .  .  .  .  .    343
D.43     Line number program example: machine code   .  .  .  .  .  .  .  .  .  .  .  .  .  .    344
D.44     Call frame information example: machine code fragments    .  .  .  .  .  .  .    347
D.45     Inlining examples: pseudo-source fragmment  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    350
D.46     Inlining example #1: abstract instance    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    352
D.47     Inlining example #1: concrete instance   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    353
D.48     Inlining example #2: abstract instance    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    355
D.49     Inlining example #2: concrete instance   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    357
D.50     Inlining example #3: abstract instance    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    358
D.51     Inlining example #3: concrete instance   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    359
D.52     Constant expressions: C++ source .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    359
D.53     Constant expressions: DWARF description    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    360
D.54     Unicode character example: source  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    361
D.55     Unicode character example: DWARF description  .  .  .  .  .  .  .  .  .  .  .  .  .    361
D.56     Type-safe enumeration example: source   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    362
D.57     Type-safe enumeration example: DWARF description   .  .  .  .  .  .  .  .  .  .    362
D.58     C++ template example #1: source  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    363
D.59     C++ template example #1: DWARF description  .  .  .  .  .  .  .  .  .  .  .  .  .  .    363
November 1, 2024                                  ***WORKING DRAFT***                                                            Page xiii
                                                        LIST OF FIGURES
D.60     C++ template example #2: source  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    364
D.61     C++ template example #2: DWARF description  .  .  .  .  .  .  .  .  .  .  .  .  .  .    364
D.62     C++ template alias example #1: source  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    365
D.63     C++ template alias example #1: DWARF description  .  .  .  .  .  .  .  .  .  .  .    366
D.64     C++ template alias example #2: source  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    366
D.65     C++ template alias example #2: DWARF description  .  .  .  .  .  .  .  .  .  .  .    367
D.66     C implicit pointer example #1: source    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    368
D.67     C implicit pointer example #1: DWARF description    .  .  .  .  .  .  .  .  .  .  .    369
D.68     C implicit pointer example #2: source    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    370
D.69     C implicit pointer example #2: DWARF description    .  .  .  .  .  .  .  .  .  .  .    371
D.70     String type example: source   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    372
D.71     String type example: DWARF representation   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    373
D.72     Call Site Example #1: Source  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    374
D.73     Call Site Example #1: Code .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    375
D.74     Call site example #1: DWARF encoding    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    377
D.75     Call site example #2: source   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    379
D.76     Call site example #2: code   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    380
D.77     Call site example #2: DWARF encoding    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    381
D.78     Macro example: source  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    382
D.79     Macro example: simple DWARF encoding  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    383
D.80     Macro example: sharable DWARF encoding  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    384
D.81     Default value example #1: C++ source   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    386
D.82     Default value example #1: DWARF encoding   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    386
D.83     Default value example #2: Ada source   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    387
D.84     Default value example #2: DWARF encoding   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    387
D.85     SIMD Lane Example: C OpenMP Source  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    388
D.86     SIMD Lane Example: Pseudo-Assembly Code    .  .  .  .  .  .  .  .  .  .  .  .  .  .    389
D.87     SIMD Lane Example: DWARF Encoding  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    390
E.1      Duplicate elimination example #1: C++ Source   .  .  .  .  .  .  .  .  .  .  .  .  .  .    398
E.2      Duplicate elimination example #1: DWARF section group  .  .  .  .  .  .  .  .    398
E.3      Duplicate elimination example #1: primary compilation unit   .  .  .  .  .  .    399
E.4      Duplicate elimination example #2: Fortran source    .  .  .  .  .  .  .  .  .  .  .  .    399
E.5      Duplicate elimination example #2: DWARF section group  .  .  .  .  .  .  .  .    400
E.6      Duplicate elimination example #2: primary unit    .  .  .  .  .  .  .  .  .  .  .  .  .    401
E.7      Duplicate elimination example #2: companion source   .  .  .  .  .  .  .  .  .  .    401
E.8      Duplicate elimination example #2: companion DWARF   .  .  .  .  .  .  .  .  .    402
E.9      Type signature examples: C++ source    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    403
E.10     Type signature computation #1: DWARF representation  .  .  .  .  .  .  .  .  .    404
E.11     Type signature computation #1: AEattened byte stream   .  .  .  .  .  .  .  .  .  .    405
E.12     Type signature computation #2: DWARF representation  .  .  .  .  .  .  .  .  .    406
November 1, 2024                                  ***WORKING DRAFT***                                                            Page xiv
                                                        LIST OF FIGURES
E.13     Type signature example #2: AEattened byte stream  .  .  .  .  .  .  .  .  .  .  .  .  .    408
E.14     Type signature example usage  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    411
E.15     Type signature computation grammar   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    412
E.16     Completing declaration of a member function: DWARF encoding           .  .  .    413
F.1      Split object example: source fragment #1  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    422
F.2      Split object example: source fragment #2  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    423
F.3      Split object example: source fragment #3  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    424
F.4      Split object example: skeleton DWARF description  .  .  .  .  .  .  .  .  .  .  .  .    425
F.5      Split object example: executable ole DWARF excerpts   .  .  .  .  .  .  .  .  .  .    427
F.6      Split object example: demo1.dwo excerpts .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    429
F.7      Split object example: demo2.dwo DWARF .debug_info.dwo excerpts         .  .    432
F.8      Split object example: demo2.dwo DWARF .debug_loclists.dwo excerpts        434
F.9      Sections and contributions in example package ole demo.dwp  .  .  .  .  .  .    436
F.10     Example CU index section  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    438
F.11     Example TU index section   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    439
November 1, 2024                                  ***WORKING DRAFT***                                                             Page xv
                                                         LIST OF TABLES
List  of  Tables
2.1      Tag names   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      16
2.2      Attribute names  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      17
2.3      Classes of attribute value  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      23
2.4      Accessibility codes    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      48
2.5      Visibility codes .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      49
2.6      Virtuality codes   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      49
3.1      Language names    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      64
3.2      Version Encoding Schemes  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      66
3.3      Identioer case codes .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      67
3.4      Calling convention codes for subroutines    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      79
3.5      Inline codes    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .      86
4.1      Endianity attribute values   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    104
5.1      Encoding attribute values    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    108
5.2      Decimal sign attribute values    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    111
5.3      Type modioer tags    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    113
5.4      Array ordering .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    116
5.5      Calling convention codes for types   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    120
5.6      Defaulted attribute names   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    126
5.7      Discriminant descriptor values    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    128
6.1      Index attribute encodings    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    153
6.3      State machine registers   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    157
6.4      Line number program initial state .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    159
7.1      DWARF package ole section identioer encodings           .  .  .  .  .  .  .  .  .  .  .  .  .    202
7.2      Unit header unit type encodings    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    208
7.3      Tag encodings   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    213
7.4      Child determination encodings   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    216
7.5      Attribute encodings  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    217
7.6      Attribute form encodings    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    229
November 1, 2024                                  ***WORKING DRAFT***                                                            Page xvi
                                                         LIST OF TABLES
7.7      Examples of unsigned LEB128 encodings    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    232
7.8      Examples of signed LEB128 encodings  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    232
7.9      DWARF operation encodings   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    233
7.10     Location list entry encoding values  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    237
7.11     Base type encoding values   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    237
7.12     Decimal sign encodings    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    239
7.13     Endianity encodings    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    239
7.14     Accessibility encodings  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    239
7.15     Visibility encodings  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    240
7.16     Virtuality encodings    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    240
7.17     Language encodings    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    241
7.18     Identioer case encodings  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    243
7.19     Calling convention encodings   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    243
7.20     Inline encodings  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    244
7.21     Ordering encodings  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    244
7.22     Discriminant descriptor encodings   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    244
7.23     Name index attribute encodings .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    245
7.24     Defaulted attribute encodings  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    245
7.25     Line number standard opcode encodings    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    247
7.26     Line number extended opcode encodings   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    248
7.27     Line number header entry format encodings             .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    248
7.28     Macro information entry type encodings  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    250
7.29     Call frame instruction encodings   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    251
7.30     Range list entry encoding values    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    253
7.31     Integer representation names    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    258
7.32     Attributes used in type signature computation   .  .  .  .  .  .  .  .  .  .  .  .  .  .    259
A.1      Attributes by tag value   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    266
D.2      Line number program example: one encoding            .  .  .  .  .  .  .  .  .  .  .  .  .  .    345
D.3      Line number program example: alternate encoding    .  .  .  .  .  .  .  .  .  .  .    345
D.4      Call frame information example: conceptual matrix   .  .  .  .  .  .  .  .  .  .  .    347
D.5      Call frame information example: common information entry encoding    348
D.6      Call frame information example: frame description entry encoding   .  .    349
F.1      Unit attributes by unit kind    .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    421
G.1      Section version numbers   .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .    442
November 1, 2024                                  ***WORKING DRAFT***                                                           Page xvii
                                                         LIST OF TABLES
                                                             (empty page)
November 1, 2024                                  ***WORKING DRAFT***                                                         Page xviii
                                                        Change Summary
                                            Change  Summary
                                                                   Note
                 This change summary is included only in draft versions of this document.
__Date________________________Issue_Incorporated_or_Other_Change_____________________________________________________________________________________*
 *______
  2/17/2021                   Begin DWARF Version 6. Update front matter.
  3/10/2021                   Remove change bars commands that were lingering from V5 (disabled in public
                              release). Remove "New in DWARF Version 5" annotations.
  3/11/2021                   Issue 180613.1, stop using horizontal space to suppress ligatures.
  3/14/2021                   Issues 171130.1, 200505.1, 200505.2 and 200505.3, minor editorial corrections.
  3/23/2021                   Issues 200505.4 and 200505.7, editorial corrections. Issue 161206.2, add
                              non-normative clariocation re DW.OP.piece vs DW.OP.bit.piece.
  4/14/2021                   Remove 2005 from Copyright statement (was then the Free Standards Group).
  4/25/2021                   Issue 170527.1 re DW.IDX.external for external symbols.
  5/2/2021                    Start V6 column in version numbers appendix.
  5/3/2021                    Cleanup some table formatting in theALTEX source.
  5/17/2021                   Issue 191025.1, DW.OP.bit.piece.
  5/21/2021                   Issue 180503.1, usage suggestions for LEB128 padding.
                              Issue 170427.2, extending loclists.
  6/17/2021                   Issue 200427.1, missing link and related notes for Figure B.1, and Issue 200519.1,
                              missing notes for Figure B.2. Issue 180426.2, add line number extended op
                              DW.LNE.padding.
  6/30/2021                   180326.1, clarify consistency of DWARF 32/64 format within a CU.
  7/12/2021                   210218.1, index entry shows up in PDF.
  8/14/2021                   210628.1, clariocation of relative paths in DW.AT.comp.dir. 200710.1,
                              inconsistent description of data representation for the range list table.
  9/28/2021                   180625.1, inconsistent initial length descriptions.
                              181019.1, inconsistency in DW.AT.import descriptions.
  10/9/2021                   171103.1, DW.AT.call.origin should be encoded as reference class.
                              180426.1, Add DW.FORM.strp.sup to forms allowed in .debug.line
                              vendor-deoned ['producer-deoned' per 231110.2] content descriptions.
  10/30/2021                  200505.4, Augmentation string is null-terminated. See 3/23/2021.
                              200505.7, Declarations with reduced scope. See 3/23/2021 and 5/7/2022.
  11/21/2021                  200709.1, DW.AT.rnglists.base in DW.TAG.skeleton.unit
                              181205.1, Clarify DW.OP.piece documentation for parts of values that are
                              optimized out.
November 1, 2024                                  ***WORKING DRAFT***                                                            Page xix
                                                        Change Summary
__Date_______________________Issue_Incorporated_or_Other_Change______________________________________________________________________________________*
 *______
  1/14/2022                  200602.1, .debug.macro.dwo refers to .debug.line.dwo? Also, tweak some member
                             names and aOEliations in the Foreword.
  1/20/2022                  210314.1, Eliminate all indeonite antecedents.
  3/12/2022                  210113.1, Allow zero-length entries in .debug.aranges.
                             200609.1, Reserve an address for "not present".
  3/26/2022                  201007.1, Wide registers in location description expressions.
                             210310.1, Clarify DW.AT.rnglists.base and DW.FORM.rnglistx in split
                             DWARF.
                             210429.1, Clarify description of line number extended opcodes.
  4/16/2022                  180517.1, Variant parts without a discriminant.
                             210622.1, Typo in .debug.rnglists section header description.
  5/7/2022                   210208.2, Standardize DW.AT.GNU.numerator and
                             DW.AT.GNU.denominator.
                             200505.4, Augmentation string. Reverses 10/30/2021.
  5/30/2022                  211101.1, Allow 64-bit string ooesets in DWARF-32.
  6/15/2022                  210419.1, Split DW.AT.language into DW.AT.language.name and
                             DW.AT.language.version.
  7/5/2022                   190809.1, Add DW.AT.bias.
  7/17/2022                  180201.1, Source text embedding.
  8/6/2022                   210713.1, Fix "ole 0".
  8/7/2022                   211108.2, Allow non-uniform record formats in the ole name table.
  8/8/2022                   211022.1, Empty range list entry.
                             181003.1, Forbid DW.OP.call.ref and DW.FORM.addr.ref in a .dwo ole.
  8/14/2022                  220427.1, Deprecate the DW.AT.segment attribute.
  9/4/2022                   181223.1, Add Microsoft SourceLink support.
                             211108.2, Rework example in D.5 to illustrate DW.LNCT.source and
                             DW.LNCT.URL.
                             Review and adjust pagination.
  10/12/2022                 211108.2, Further rework of the example in D.5.
  10/22/2022                 211102.1, No DW.FORM.strp in .dwo oles.
                             141117.1, Arbitrary expressions as formal parameter default values.
  11/7/2022                  220212.1, Disambiguate "ending address ooeset in location and range lists.
  11/8/2022                  211004.1, Replace DW.MACRO.deone/undeone.sup with sized versions.
  11/14/2022                 220708.1, Remove edge (fo) from Figure B.2.
                             220711.1, Name Table index attribute.
                             220711.2, Name Table Figure 6.1.
  11/14/2022                 211103.1, Call site entries for optimized out functions.
  11/30/2022                 Incorporate minor review tweaks.
  12/10/2022 et al           Additional minor review tweaks.
  1/29/2023                  210218.2, Generalize complex number support.
                             220708.2, .debug.c,tu.index missing/incomplete DWARF64 support.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page xx
                                                        Change Summary
__Date_______________________Issue_Incorporated_or_Other_Change______________________________________________________________________________________*
 *______
                             221031.1, Future-proof text from 211102.1.
                             220802.1, Introduce DW.FORM.addr.ooeset paired form.
  4/3/2023                   170427.3, Extending loclists with common sublists.
                             220713.1, Name Table Figure 6.1.
                             Update committee members list and roles.
  6/15/2023                  211108.1, Add DW.AT.artiocial for DW.TAG.typedef.
                             220824.1, Use uniform encoding of DWARF expressions in CFI instructions.
  6/27/2023                  180123,1, Layout of discriminant entries in variant parts.
                             181026.3, Don't forbid extensions to the dwp ole.
                             221118.1, Name Table 6.1.1.4.8.
                             221114.1, DW.FORM.implicit.const and DW.FORM.indirect.
  7/10/2023                  230223.1, Tidy up location description descriptions.
                             230414.1, Eliminate last use of "location expression".
  8/6/2023                   221203.1, Remove suggestion that DW.FORM.sec.ooeset may not be used for lists
                             in split units.
                             230103.1, Clarify that DW.CFA.remember.state includes the current CFA.
  10/24/2023                 230120.1, DW.OP.call.ref & DW.OP.implicit.pointer correction.
                             230616.1, New form classes for values vs. location descriptions.
                             210514.1, Add GPU shading and kernel languages.
                             210115.1, DW.lang.code for the Netwide Assembler (NASM).
                             230203.1, C# language ID.
                             230502.1, New language name Mojo.
  11/14/2023                 230808.1, DW.OP.entry.value description.
                             230413.1, Tensor types.
  12/3/2023                  230329.1, Tables which have a unit.length header oeld must be contiguous.
                             230529.1, Bit-precise integer types.
  1/15/2024                  231230.1, New language code for Ruby.
                             231013.1, Tombstoning TU entries in .debug.names.
                             230324.1, Expression operation vendor ['producer' per 231110.2] extensibility
                             opcode.
  2/18/2024                  230412.1, Ambiguity in static and dynamic values of attributes.
  3/7/2024                   230324.2, Expression operation standard extensibility opcode.
  4/24/2024                  230120.4, Add the HIP programming language.
                             240202.1, New language name for Move.
                             240213.1, New language code for Hylo.
                             240422.1, Add version scheme for Swift language.
                             230120.4, Add the HIP Programming Language.
                             240423.1, Duplicate DW.AT.LNAME 1d.
                             240424.1, Add versioning scheme for Fortran.
                             240424.2, C standard release dates for DW.AT.language.version, clarify
                             semantics.
November 1, 2024                                  ***WORKING DRAFT***                                                            Page xxi
                                                        Change Summary
__Date_______________________Issue_Incorporated_or_Other_Change______________________________________________________________________________________*
 *______
                             240429.0, Remove all "incomplete support" related indications from Table 3.1
                             Language Names.
                             240115.1, Add vallist class for list of DWARF expressions returning values.
  5/13/2024                  221203.1, Remove suggestion that DW.FORM.sec.ooeset may not be used for lists
                             in split units.
                             211206.1, Add lane support for SIMD/SIMT machines.
  6/14/2024                  240118.1, Allow padding in all tables.
                             231110.2, Change 'vendor' to 'producer' for DWARF extensions.
  7/5/2024                   240320.2, Clarify description of line table compression.
  7/9/2024                   240616.1, Add language codes for C++23 (no change in this document).
                             240627.1, Add language codes for Odin.
  7/15/2024                  Improve indexing of line number state register names.
  9/30/2024                  240725.1, Add language code for P4.
  10/6/2024                  240320.1, Add local and indirect strings to name index. Completion of edits to
                             Figure B.2 is pending.
  11/1/2024                  Apply trailing whitespace patch from Ben Woodward.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page xxii
                                                         LIST OF TABLES
                                                             (empty page)
November 1, 2024                                  ***WORKING DRAFT***                                                          Page xxiii

Chapter  1
Introduction
This document deones a format for describing programs to facilitate user source
level debugging. This description can be generated by compilers, assemblers and
linkage editors. It can be used by debuggers and other tools. The debugging
information format does not favor the design of any compiler or debugger.
Instead, the goal is to create a method of communicating an accurate picture of
the source program to any debugger in a form that is extensible to dioeerent
languages while retaining compatibility.
The design of the debugging information format is open-ended, allowing for the
addition of new debugging information to accommodate new languages or
debugger capabilities while remaining compatible with other languages or
dioeerent debuggers.
1.1          Purpose  and  Scope
The debugging information format described in this document is designed to
meet the symbolic, source-level debugging needs of dioeerent languages in a
unioed fashion by requiring language independent debugging information
whenever possible. Aspects of individual languages, such as C++ virtual
functions or Fortran common blocks, are accommodated by creating attributes
that are used only for those languages. This document is believed to cover most
debugging information needs of Ada, C, C++, COBOL, and Fortran; it also
covers the basic needs of various other languages.
This document describes DWARF Version 5, the ofth generation of debugging
information based on the DWARF format. DWARF Version 5 extends DWARF
Version 4 in a compatible manner.
November 1, 2024                                  ***WORKING DRAFT***                                                               Page 1
                                                   Chapter 1.  Introduction
The intended audience for this document is the developers of both producers
and consumers of debugging information, typically compilers, debuggers and
other tools that need to interpret a binary program in terms of its original source.
1.2          Overview
There are two major pieces to the description of the DWARF format in this
document. The orst piece is the informational content of the debugging entries.
The second piece is the way the debugging information is encoded and
represented in an object ole.
The informational content is described in Chapters 2 through 6. Chapter 2
describes the overall structure of the information and attributes that are common
to many or all of the dioeerent debugging information entries. Chapters 3, 4 and 5
describe the specioc debugging information entries and how they communicate
the necessary information about the source program to a debugger. Chapter 6
describes debugging information contained outside of the debugging
information entries. The encoding of the DWARF information is presented in
Chapter 7.
This organization closely follows that used in the DWARF Version 4 document.
Except where needed to incorporate new material or to correct errors, the
DWARF Version 4 text is generally reused in this document with little or no
modiocation.
In the following sections, text in normal font describes required aspects of the
DWARF format. Text in italics is explanatory or supplementary material, and not
part of the format deonition itself. The several appendices consist only of
explanatory or supplementary material, and are not part of the formal deonition.
1.3          Objectives  and  Rationale
DWARF has had a set of objectives since its inception which have guided the
design and evolution of the debugging format. A discussion of these objectives
and the rationale behind them may help with an understanding of the DWARF
Debugging Format.
Although DWARF Version 1 was developed in the late 1980's as a format to
support debugging C programs written for AT&T hardware running SVR4,
DWARF Version 2 and later has evolved far beyond this origin. One dioeerence
between DWARF and other formats is that the latter are often specioc to a
particular language, architecture, and/or operating system.
November 1, 2024                                  ***WORKING DRAFT***                                                               Page 2
                                                   Chapter 1.  Introduction
1.3.1          Language Independence
DWARF is applicable to a broad range of existing procedural languages and is
designed to be extensible to future languages. These languages may be
considered to be "C-like" but the characteristics of C are not incorporated into
DWARF Version 2 and later, unlike DWARF Version 1 and other debugging
formats. DWARF abstracts concepts as much as possible so that the description
can be used to describe a program in any language. As an example, the DWARF
descriptions used to describe C functions, Pascal subroutines, and Fortran
subprograms are all the same, with dioeerent attributes used to specify the
dioeerences between these similar programming language features.
On occasion, there is a feature which is specioc to one particular language and
which doesn't appear to have more general application. For these, DWARF has a
description designed to meet the language requirements, although, to the extent
possible, an eoeort is made to generalize the attribute. An example of this is the
DW.TAG.condition debugging information entry, used to describe COBOL level
88 conditions, which is described in abstract terms rather than COBOL-specioc
terms. Conceivably, this TAG might be used with a dioeerent language which had
similar functionality.
1.3.2          Architecture Independence
DWARF can be used with a wide range of processor architectures, whether byte
or word oriented, with any word or byte size. DWARF can be used with Von
Neumann architectures, using a single address space for both code and data;
Harvard architectures, with separate code and data address spaces; and
potentially for other architectures such as DSPs with their idiosyncratic memory
organizations. DWARF can be used with common register-oriented architectures
or with stack architectures.
DWARF assumes that memory has individual units (words or bytes) which have
unique addresses which are ordered. (Identifying aliases is an implementation
issue.)
1.3.3          Operating System Independence
DWARF is widely associated with SVR4 Unix and similar operating systems like
BSD and Linux. DWARF ots well with the section organization of the ELF object
ole format. Nonetheless, DWARF attempts to be independent of either the OS or
the object ole format. There have been implementations of DWARF debugging
data in COFF, Mach-O and other object ole formats.
November 1, 2024                                  ***WORKING DRAFT***                                                               Page 3
                                                   Chapter 1.  Introduction
DWARF assumes that any object ole format will be able to distinguish the
various DWARF data sections in some fashion, preferably by name.
DWARF makes a few assumptions about functionality provided by the
underlying operating system. DWARF data sections can be read sequentially and
independently. Each DWARF data section is a sequence of 8-bit bytes, numbered
starting with zero. The presence of ooesets from one DWARF data section into
other data sections does not imply that the underlying OS must be able to
position oles randomly; a data section could be read sequentially and indexed
using the ooeset.
1.3.4          Compact Data Representation
The DWARF description is designed to be a compact ole-oriented representation.
There are several encodings which achieve this goal, such as the TAG and
attribute abbreviations or the line number encoding. References from one section
to another, especially to refer to strings, allow these sections to be compacted to
eliminate duplicate data.
There are multiple schemes for eliminating duplicate data or reducing the size of
the DWARF debug data associated with a given ole. These include COMDAT,
used to eliminate duplicate function or data deonitions, the split DWARF object
oles which allow a consumer to ond DWARF data in oles other than the
executable, or the type units, which allow similar type deonitions from multiple
compilations to be combined.
In most cases, it is anticipated that DWARF debug data will be read by a
consumer (usually a debugger) and converted into a more eOEciently accessed
internal representation. For the most part, the DWARF data in a section is not the
same as this internal representation.
1.3.5          EOEcient Processing
DWARF is designed to be processed eOEciently, so that a producer (a compiler)
can generate the debug descriptions incrementally and a consumer can read only
the descriptions which it needs at a given time. The data formats are designed to
be eOEciently interpreted by a consumer.
As mentioned, there is a tension between this objective and the preceding one. A
DWARF data representation which resembles an internal data representation
may lead to faster processing, but at the expense of larger data oles. This may
also constrain the possible implementations.
November 1, 2024                                  ***WORKING DRAFT***                                                               Page 4
                                                   Chapter 1.  Introduction
1.3.6          Implementation Independence
DWARF attempts to allow developers the greatest AEexibility in designing
implementations, without mandating any particular design decisions. Issues
which can be described as quality-of-implementation are avoided.
1.3.7          Explicit Rather Than Implicit Description
DWARF describes the source to object translation explicitly rather than using
common practice or convention as an implicit understanding between producer
and consumer. For example, where other debugging formats assume that a
debugger knows how to virtually unwind the stack, moving from one stack
frame to the next using implicit knowledge about the architecture or operating
system, DWARF makes this explicit in the Call Frame Information description.
1.3.8          Avoid Duplication of Information
DWARF has a goal of describing characteristics of a program once, rather than
repeating the same information multiple times. The string sections can be
compacted to eliminate duplicate strings, for example. Other compaction
schemes or references between sections support this. Whether a particular
implementation is eoeective at eliminating duplicate data, or even attempts to, is
a quality-of-implementation issue.
1.3.9          Leverage Other Standards
Where another standard exists which describes how to interpret aspects of a
program, DWARF defers to that standard rather than attempting to duplicate the
description. For example, C++ has specioc rules for deciding which function to
call depending name, scope, argument types, and other factors. DWARF
describes the functions and arguments, but doesn't attempt to describe how one
would be selected by a consumer performing any particular operation.
1.3.10           Limited Dependence on Tools
DWARF data is designed so that it can be processed by commonly available
assemblers, linkers, and other support programs, without requiring additional
functionality speciocally to support DWARF data. This may require the
implementer to be careful that they do not generate DWARF data which cannot
be processed by these programs. Conversely, an assembler which can generate
LEB128 (Little-Endian Base 128) values may allow the compiler to generate more
November 1, 2024                                  ***WORKING DRAFT***                                                               Page 5
                                                   Chapter 1.  Introduction
compact descriptions, and a linker which understands the format of string
sections can merge these sections. Whether or not an implementation includes
these functions is a quality-of-implementation issue, not mandated by the
DWARF speciocation.
1.3.11           Separate Description From Implementation
DWARF intends to describe the translation of a program from source to object,
while neither mandating any particular design nor making any other design
diOEcult. For example, DWARF describes how the arguments and local variables
in a function are to be described, but doesn't specify how this data is collected or
organized by a producer. Where a particular DWARF feature anticipates that it
will be implemented in a certain fashion, informative text will suggest but not
require this design.
1.3.12           Permissive Rather Than Prescriptive
The DWARF Standard specioes the meaning of DWARF descriptions. It does not
specify in detail what a particular producer must generate for any source to
object conversion. One producer may generate a more complete description than
another, it may describe features in a dioeerent order (unless the standard
explicitly requires a particular order), or it may use dioeerent abbreviations or
compression methods. Similarly, DWARF does not specify exactly what a
particular consumer should do with each part of the description, although we
believe that the potential uses for each description should be evident.
DWARF is permissive, allowing dioeerent producers to generate dioeerent
descriptions for the same source to object conversion, and permitting dioeerent
consumers to provide more or less functionality or information to the user. This
may result in debugging information being larger or smaller, compilers or
debuggers which are faster or slower, and more or less functional. These are
described as dioeerences in quality-of-implementation.
Each producer conforming to the DWARF standard must follow the format and
meaning as specioed in the standard. As long as the DWARF description
generated follows this speciocation, the producer is generating valid DWARF.
For example, DWARF allows a producer to identify the end of a function
prologue in the Line Information so that a debugger can stop at this location. A
producer which does this is generating valid DWARF, as is another which
doesn't. As another example, one producer may generate descriptions for
variables which are moved from memory to a register in a certain range, while
another may only describe the variable's location in memory. Both are valid
November 1, 2024                                  ***WORKING DRAFT***                                                               Page 6
                                                   Chapter 1.  Introduction
DWARF descriptions, while a consumer using the former would be able to
provide more accurate values for the variable while executing in that range than
a consumer using the latter.
In this document, where the word imayj is used, the producer has the option to
follow the description or not. Where the text says imay notj, this is prohibited.
Where the text says ishouldj, this is advice about best practice, but is not a
requirement.
1.3.13           Extensibility
This document does not attempt to cover all interesting languages or even to
cover all of the possible debugging information needs for its primary target
languages. Therefore, the document provides producers and tool developers a
way to deone their owns debugging information tags, attributes, base type
encodings, location operations, language names, calling conventions and call
frame instructions by reserving a subset of the valid values for these constructs
for additions and for deoning related naming conventions. Producers may also
use debugging information entries and attributes deoned here in new situations.
Future versions of this document will not use names or values reserved for
producer-specioc additions. All names and values not reserved for producer
additions, however, are reserved for future versions of this document.
Where this speciocation provides a means for describing the source language,
implementors are expected to adhere to that speciocation. For language features
that are not supported, implementors may use existing attributes in novel ways
or add producer-deoned attributes. Implementors who make extensions are
strongly encouraged to design them to be compatible with this speciocation in
the absence of those extensions.
November 1, 2024                                  ***WORKING DRAFT***                                                               Page 7
                                                   Chapter 1.  Introduction
The DWARF format is organized so that a consumer can skip over data which it
does not recognize. This may allow a consumer to read and process oles
generated according to a later version of this standard or which contain producer
extensions, albeit possibly in a degraded manner.
1.4          Changes  from  Version  5  to  Version  6
To be written...
1.5          Changes  from  Version  4  to  Version  5
The following is a list of the major changes made to the DWARF Debugging
Information Format since Version 4 was published. The list is not meant to be
exhaustive.
     #    Eliminate the .debug_types section introduced in DWARF Version 4 and
          move its contents into the .debug_info section.
     #    Add support for collecting common DWARF information (debugging
          information entries and macro deonitions) across multiple executable and
          shared oles and keeping it in a single supplementary object ole.
     #    Replace the line number program header format with a new format that
          provides the ability to use an MD5 hash to validate the source ole version
          in use, allows pooling of directory and ole name strings and makes
          provision for producer-deoned extensions. Also add a string section
          specioc to the line number table (.debug_line_str) to properly support the
          common practice of stripping all DWARF sections except for line number
          information.
     #    Add a split object ole and package representations to allow most DWARF
          information to be kept separate from an executable or shared image. This
          includes new sections .debug_addr, .debug_str_offsets,
          .debug_abbrev.dwo, .debug_info.dwo, .debug_line.dwo,
          .debug_loclists.dwo, .debug_macro.dwo, .debug_str.dwo,
          .debug_str_offsets.dwo, .debug_cu_index and .debug_tu_index together
          with new forms of attribute value for referencing these sections. This
          enhances DWARF support by reducing executable program size and by
          improving link times.
     #    Replace the .debug_macinfo macro information representation with with a
          .debug_macro representation that can potentially be much more compact.
November 1, 2024                                  ***WORKING DRAFT***                                                               Page 8
                                                   Chapter 1.  Introduction
     #    Replace the .debug_pubnames and .debug_pubtypes sections with a single
          and more functional name index section, .debug_names.
     #    Replace the location list and range list sections (.debug_loc and
          .debug_ranges, respectively) with new sections (.debug_loclists and
          .debug_rnglists) and new representations that save space and processing
          time by eliminating most related object ole relocations.
     #    Add a new debugging information entry (DW.TAG.call.site), related
          attributes and DWARF expression operators to describe call site
          information, including identiocation of tail calls and tail recursion.
     #    Add improved support for FORTRAN assumed rank arrays
          (DW.TAG.generic.subrange), dynamic rank arrays (DW.AT.rank) and
          co-arrays (DW.TAG.coarray.type).
     #    Add new operations that allow support for a DWARF expression stack
          containing typed values.
     #    Add improved support for the C++: auto return type, deleted member
          functions (DW.AT.deleted), as well as defaulted constructors and
          destructors (DW.AT.defaulted).
     #    Add a new attribute (DW.AT.noreturn), to identify a subprogram that
          does not return to its caller.
     #    Add language codes for C 2011, C++ 2003, C++ 2011, C++ 2014, Dylan,
          Fortran 2003, Fortran 2008, Go, Haskell, Julia, Modula 3, Ocaml, OpenCL
          C1 , Rust and Swift.
     #    Numerous other more minor additions to improve functionality and
          performance.
DWARF Version 5 is compatible with DWARF Version 4 except as follows:
     #    The compilation unit header (in the .debug_info section) has a new
          unit_type oeld. In addition, the debug_abbrev_offset and address_size
          oelds are reordered.
     #    New operand forms for attribute values are deoned (DW.FORM.addrx,
          DW.FORM.addrx1, DW.FORM.addrx2, DW.FORM.addrx3,
          DW.FORM.addrx4, DW.FORM.data16, DW.FORM.implicit.const,
          DW.FORM.line.strp, DW.FORM.loclistx, DW.FORM.rnglistx,
          DW.FORM.ref.sup4, DW.FORM.ref.sup8, DW.FORM.strp.sup,
_________________________________________________________
      1called simply OpenCL in DWARF Version 5
November 1, 2024                                  ***WORKING DRAFT***                                                               Page 9
                                                   Chapter 1.  Introduction
          DW.FORM.strx, DW.FORM.strx1, DW.FORM.strx2, DW.FORM.strx3
          and DW.FORM.strx4.
          Because a pre-DWARF Version 5 consumer will not be able to interpret these even
          to ignore and skip over them, new forms must be considered incompatible additions.
     #    The line number table header is substantially revised.
     #    The .debug_loc and .debug_ranges sections are replaced by new
          .debug_loclists and .debug_rnglists sections, respectively. These new
          sections have a new (and more eOEcient) list structure. Attributes that
          reference the predecessor sections must be interpreted dioeerently to access
          the new sections. The new sections encode the same information as their
          predecessors, except that a new default location list entry is added.
     #    In a string type, the DW.AT.byte.size attribute is re-deoned to always
          describe the size of the string type. (Previously DW.AT.byte.size
          described the size of the optional string length data oeld if the
          DW.AT.string.length attribute was also present.) In addition, the
          DW.AT.string.length attribute may now refer directly to an object that
          contains the length value.
While not strictly an incompatibility, the macro information representation is
completely new; further, producers and consumers may optionally continue to
support the older representation. While the two representations cannot both be
used in the same compilation unit, they can co-exist in executable or shared
images.
Similar comments apply to replacement of the .debug_pubnames and
.debug_pubtypes sections with the new .debug_names section.
1.6          Changes  from  Version  3  to  Version  4
The following is a list of the major changes made to the DWARF Debugging
Information Format since Version 3 was published. The list is not meant to be
exhaustive.
     #    Reformulate Section 2.6 (Location Descriptions) to better distinguish
          DWARF location descriptions, which compute the location where a value is
          found (such as an address in memory or a register name) from DWARF
          expressions, which compute a onal value (such as an array bound).
     #    Add support for bundled instructions on machine architectures where
          instructions do not occupy a whole number of bytes.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 10
                                                   Chapter 1.  Introduction
     #    Add a new attribute form for section ooesets, DW.FORM.sec.ooeset, to
          replace the use of DW.FORM.data4 and DW.FORM.data8 for section
          ooesets.
     #    Add an attribute, DW.AT.main.subprogram, to identify the main
          subprogram of a program.
     #    Deone default array lower bound values for each supported language.
     #    Add a new technique using separate type units, type signatures and
          COMDAT sections to improve compression and duplicate elimination of
          DWARF information.
     #    Add support for new C++ language constructs, including rvalue references,
          generalized constant expressions, Unicode character types and template
          aliases.
     #    Clarify and generalize support for packed arrays and structures.
     #    Add new line number table support to facilitate proole based compiler
          optimization.
     #    Add additional support for template parameters in instantiations.
     #    Add support for strongly typed enumerations in languages (such as C++)
          that have two kinds of enumeration declarations.
     #    Add the option for the DW.AT.high.pc value of a program unit or scope
          to be specioed as a constant ooeset relative to the corresponding
          DW.AT.low.pc value.
DWARF Version 4 is compatible with DWARF Version 3 except as follows:
     #    DWARF attributes that use any of the new forms of attribute value
          representation (for section ooesets, AEag compression, type signature
          references, and so on) cannot be read by DWARF Version 3 consumers
          because the consumer will not know how to skip over the unexpected form
          of data.
     #    DWARF frame and line number table sections include additional oelds that
          aoeect the location and interpretation of other data in the section.
1.7          Changes  from  Version  2  to  Version  3
The following is a list of the major dioeerences between Version 2 and Version 3 of
the DWARF Debugging Information Format. The list is not meant to be
exhaustive.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 11
                                                   Chapter 1.  Introduction
     #    Make provision for DWARF information oles that are larger than 4 GBytes.
     #    Allow attributes to refer to debugging information entries in other shared
          libraries.
     #    Add support for Fortran 90 modules as well as allocatable array and
          pointer types.
     #    Add additional base types for C (as revised for 1999).
     #    Add support for Java and COBOL.
     #    Add namespace support for C++.
     #    Add an optional section for global type names (similar to the global section
          for objects and functions).
     #    Adopt UTF-8 as the preferred representation of program name strings.
     #    Add improved support for optimized code (discontiguous scopes, end of
          prologue determination, multiple section code generation).
     #    Improve the ability to eliminate duplicate DWARF information during
          linking.
DWARF Version 3 is compatible with DWARF Version 2 except as follows:
     #    Certain very large values of the initial length oelds that begin DWARF
          sections as well as certain structures are reserved to act as escape codes for
          future extension; one such extension is deoned to increase the possible size
          of DWARF descriptions (see Section 7.4 on page 204).
     #    References that use the attribute form DW.FORM.ref.addr are specioed to
          be four bytes in the DWARF 32-bit format and eight bytes in the DWARF
          64-bit format, while DWARF Version 2 specioes that such references have
          the same size as an address on the target system (see Sections 7.4 on
          page 204 and 7.5.4 on page 217).
     #    The return.address.register oeld in a Common Information Entry record
          for call frame information is changed to unsigned LEB representation (see
          Section 6.4.1 on page 180).
1.8          Changes  from  Version  1  to  Version  2
DWARF Version 2 describes the second generation of debugging information
based on the DWARF format. While DWARF Version 2 provides new debugging
information not available in Version 1, the primary focus of the changes for
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 12
                                                   Chapter 1.  Introduction
Version 2 is the representation of the information, rather than the information
content itself. The basic structure of the Version 2 format remains as in Version 1:
the debugging information is represented as a series of debugging information
entries, each containing one or more attributes (name/value pairs). The Version 2
representation, however, is much more compact than the Version 1
representation. In some cases, this greater density has been achieved at the
expense of additional complexity or greater diOEculty in producing and
processing the DWARF information. The deoners believe that the reduction in
I/O and in memory paging should more than make up for any increase in
processing time.
The representation of information changed from Version 1 to Version 2, so that
Version 2 DWARF information is not binary compatible with Version 1
information. To make it easier for consumers to support both Version 1 and
Version 2 DWARF information, the Version 2 information has been moved to a
dioeerent object ole section, .debug_info.
 A summary of the major changes made in DWARF Version 2 compared to the DWARF
Version 1 may be found in the DWARF Version 2 document.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 13
                                                   Chapter 1.  Introduction
                                                             (empty page)
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 14

Chapter  2
General  Description
2.1          The  Debugging  Information  Entry  (DIE)
DWARF uses a series of debugging information entries (DIEs) to deone a
low-level representation of a source program. Each debugging information entry
consists of an identifying tag and a series of attributes. An entry, or group of
entries together, provide a description of a corresponding entity in the source
program. The tag specioes the class to which an entry belongs and the attributes
deone the specioc characteristics of the entry.
The set of tag names is listed in Table 2.1 on the following page. The debugging
information entries they identify are described in Chapters 3, 4 and 5.
The debugging information entry descriptions in Chapters 3, 4 and 5 generally include
mention of most, but not necessarily all, of the attributes that are normally or possibly
used with the entry. Some attributes, whose applicability tends to be pervasive and
invariant across many kinds of debugging information entries, are described in this
section and not necessarily mentioned in all contexts where they may be appropriate.
Examples include DW.AT.artiocial, the declaration coordinates, and
DW.AT.description, among others.
The debugging information entries are contained in the .debug_info and/or
.debug_info.dwo sections of an object ole.
Optionally, debugging information may be partitioned such that the majority of
the debugging information can remain in individual object oles without being
processed by the linker. See Section 7.3.2 on page 195 and Appendix F on
page 417 for details.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 15
                                            Chapter 2.  General Description
                                                     Table 2.1: Tag names
________________________________________________________________________________________________________________________________________________
   DW.TAG.access.declaration                                            DW.TAG.module
   DW.TAG.array.type                                                    DW.TAG.namelist
   DW.TAG.atomic.type                                                   DW.TAG.namelist.item
   DW.TAG.base.type                                                     DW.TAG.namespace
   DW.TAG.call.site                                                     DW.TAG.packed.type
   DW.TAG.call.site.parameter                                           DW.TAG.partial.unit
   DW.TAG.catch.block                                                   DW.TAG.pointer.type
   DW.TAG.class.type                                                    DW.TAG.ptr.to.member.type
   DW.TAG.coarray.type                                                  DW.TAG.reference.type
   DW.TAG.common.block                                                  DW.TAG.restrict.type
   DW.TAG.common.inclusion                                              DW.TAG.rvalue.reference.type
   DW.TAG.compile.unit                                                  DW.TAG.set.type
   DW.TAG.condition                                                     DW.TAG.shared.type
   DW.TAG.const.type                                                    DW.TAG.skeleton.unit
   DW.TAG.constant                                                      DW.TAG.string.type
   DW.TAG.dwarf.procedure                                               DW.TAG.structure.type
   DW.TAG.dynamic.type                                                  DW.TAG.subprogram
   DW.TAG.entry.point                                                   DW.TAG.subrange.type
   DW.TAG.enumeration.type                                              DW.TAG.subroutine.type
   DW.TAG.enumerator                                                    DW.TAG.template.alias
   DW.TAG.ole.type                                                      DW.TAG.template.type.parameter
   DW.TAG.formal.parameter                                              DW.TAG.template.value.parameter
   DW.TAG.friend                                                        DW.TAG.thrown.type
   DW.TAG.generic.subrange                                              DW.TAG.try.block
   DW.TAG.immutable.type                                                DW.TAG.typedef
   DW.TAG.imported.declaration                                          DW.TAG.type.unit
   DW.TAG.imported.module                                               DW.TAG.union.type
   DW.TAG.imported.unit                                                 DW.TAG.unspecioed.parameters
   DW.TAG.inheritance                                                   DW.TAG.unspecioed.type
   DW.TAG.inlined.subroutine                                            DW.TAG.variable
   DW.TAG.interface.type                                                DW.TAG.variant
   DW.TAG.label                                                         DW.TAG.variant.part
   DW.TAG.lexical.block                                                 DW.TAG.volatile.type
   DW.TAG.member                                                        DW.TAG.with.stmt
________________________________________________________________________________________________________________________________________________
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 16
                                            Chapter 2.  General Description
As a further option, debugging information entries and other debugging
information that are the same in multiple executable or shared object oles may be
found in a separate supplementary object ole that contains supplementary debug
sections. See Section 7.3.6 on page 203 for further details.
2.2          Attribute  Types
Each attribute value is characterized by an attribute name. No more than one
attribute with a given name may appear in any debugging information entry.
There are no limitations on the ordering of attributes within a debugging
information entry.
The attributes are listed in Table 2.2 following.
                                                  Table 2.2: Attribute names
____________________________________________________________________________________________________________________________________________________
__Attribute*___________________________________________________||Usage______________________________________________________________________________
  DW.AT.abstract.origin                                        ||Inline instances of inline subprograms
                                                               | Out-of-line instances of inline subprograms
                                                               |
  DW.AT.accessibility                                          ||Access declaration (C++, Ada)
                                                               | Accessibility of base or inherited class (C++)
                                                               |
                                                               |
                                                               | Accessibility of data member or member
                                                               | function
                                                               |
  DW.AT.address.class                                          ||Pointer or reference types
                                                               | Subroutine or subroutine type
                                                               |
  DW.AT.addr.base                                              ||Base ooeset for address table
  DW.AT.alignment                                              ||Non-default alignment of type, subprogram
                                                               | or variable
                                                               |
  DW.AT.allocated                                              ||Allocation status of types
  DW.AT.artiocial                                              ||Objects or types that are not actually declared
                                                               | in the source
                                                               |
  DW.AT.associated                                             ||Association status of types
  DW.AT.base.types                                             ||Primitive data types of compilation unit
  DW.AT.bias                                                   ||Integer bias added to an encoded value
__DW.AT.binary.scale___________________________________________||Binary_scale_factor_for_oxed-point_type____________________________________________
  Continued on next page
  * Links for attributes come to the left column of this table; links in the right column "fan-out" to one or more descriptions.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 17
                                            Chapter 2.  General Description
__Attribute*__________________________________________________||Identioes_or_Specioes_______________________________________________________________
  DW.AT.bit.size                                              ||Size of a base type in bits
                                                              | Size of a data member in bits
                                                              |
  DW.AT.bit.stride                                            ||Array element stride (of array type)
                                                              | Subrange stride (dimension of array type)
                                                              |
                                                              | Enumeration stride (dimension of array type)
                                                              |
  DW.AT.byte.size                                             ||Size of a data object or data type in bytes
  DW.AT.byte.stride                                           ||Array element stride (of array type)
                                                              | Subrange stride (dimension of array type)
                                                              |
                                                              | Enumeration stride (dimension of array type)
                                                              |
  DW.AT.call.all.calls                                        ||All tail and normal calls in a subprogram are
                                                              | described by call site entries
                                                              |
  DW.AT.call.all.source.calls                                 ||All tail, normal and inlined calls in a
                                                              |
                                                              | subprogram are described by call site and
                                                              | inlined subprogram entries
                                                              |
  DW.AT.call.all.tail.calls                                   ||All tail calls in a subprogram are described
                                                              | by call site entries
                                                              |
  DW.AT.call.column                                           ||Column position of inlined subroutine call
                                                              |
                                                              | Column position of call site of non-inlined
                                                              | call
                                                              |
  DW.AT.call.data.location                                    ||Address of the value pointed to by an
                                                              | argument passed in a call
                                                              |
  DW.AT.call.data.value                                       ||Value pointed to by an argument passed in a
                                                              | call
                                                              |
  DW.AT.call.ole                                              ||File containing inlined subroutine call
                                                              | File containing call site of non-inlined call
                                                              |
  DW.AT.call.line                                             ||Line number of inlined subroutine call
                                                              | Line containing call site of non-inlined call
                                                              |
  DW.AT.call.origin                                           ||Subprogram called in a call
  DW.AT.call.parameter                                        ||Parameter entry in a call
  DW.AT.call.pc                                               ||Address of the call instruction in a call
  DW.AT.call.return.pc                                        ||Return address from a call
__DW.AT.call.tail.call________________________________________||Call_is_a_tail_call_________________________________________________________________
  Continued on next page
  *Links for attributes come to the left column of this table; links in the right column "fan-out" to one or more descriptions.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 18
                                            Chapter 2.  General Description
__Attribute*__________________________________________________||Identioes_or_Specioes_______________________________________________________________
  DW.AT.call.target                                           ||Address of called routine in a call
  DW.AT.call.target.clobbered                                 ||Address of called routine, which may be
                                                              | clobbered, in a call
                                                              |
  DW.AT.call.value                                            ||Argument value passed in a call
  DW.AT.calling.convention                                    ||Calling convention for subprograms
                                                              | Calling convention for types
                                                              |
  DW.AT.common.reference                                      ||Common block usage
  DW.AT.comp.dir                                              ||Compilation directory
  DW.AT.const.expr                                            ||Compile-time constant object
                                                              | Compile-time constant function
                                                              |
  DW.AT.const.value                                           ||Constant object
                                                              | Enumeration literal value
                                                              |
                                                              | Template value parameter
                                                              |
  DW.AT.containing.type                                       ||Containing type of pointer to member type
  DW.AT.count                                                 ||Elements of subrange type
  DW.AT.data.bit.ooeset                                       ||Base type bit location
                                                              | Data member bit location
                                                              |
  DW.AT.data.location                                         ||Indirection to actual data
  DW.AT.data.member.location                                  ||Data member location
                                                              | Inherited member location
                                                              |
  DW.AT.decimal.scale                                         ||Decimal scale factor
  DW.AT.decimal.sign                                          ||Decimal sign representation
  DW.AT.decl.column                                           ||Column position of source declaration
  DW.AT.decl.ole                                              ||File containing source declaration
  DW.AT.decl.line                                             ||Line number of source declaration
  DW.AT.declaration                                           ||Incomplete, non-deoning, or separate entity
                                                              | declaration
                                                              |
  DW.AT.defaulted                                             ||Whether a member function has been
                                                              | declared as default
                                                              |
  DW.AT.default.value                                         ||Default value of parameter
  DW.AT.deleted                                               ||Whether a member has been declared as
                                                              | deleted
______________________________________________________________|_____________________________________________________________________________________
  Continued on next page
  *Links for attributes come to the left column of this table; links in the right column "fan-out" to one or more descriptions.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 19
                                            Chapter 2.  General Description
__Attribute*__________________________________________________||Identioes_or_Specioes_______________________________________________________________
  DW.AT.description                                           ||Artiocial name or description
  DW.AT.digit.count                                           ||Digit count for packed decimal or numeric
                                                              | string type
                                                              |
  DW.AT.discr                                                 ||Discriminant of variant part
  DW.AT.discr.list                                            ||List of discriminant values
  DW.AT.discr.value                                           ||Discriminant value
  DW.AT.dwo.name                                              ||Name of split DWARF object ole
  DW.AT.elemental                                             ||Elemental property of a subroutine
  DW.AT.encoding                                              ||Encoding of base type
  DW.AT.endianity                                             ||Endianity of data
  DW.AT.entry.pc                                              ||Entry address of a scope (compilation unit,
                                                              | subprogram,             and so on)
                                                              |
  DW.AT.enum.class                                            ||Type safe enumeration deonition
  DW.AT.explicit                                              ||Explicit property of member function
  DW.AT.export.symbols                                        ||Export (inline) symbols of namespace
                                                              | Export symbols of a structure, union or class
                                                              |
  DW.AT.extension                                             ||Previous namespace extension or original
                                                              | namespace
                                                              |
  DW.AT.external                                              ||External subroutine
                                                              | External variable
                                                              |
  DW.AT.frame.base                                            ||Subroutine frame base address
  DW.AT.friend                                                ||Friend relationship
  DW.AT.high.pc                                               ||Contiguous range of code addresses
  DW.AT.identioer.case                                        ||Identioer case rule
  DW.AT.import                                                ||Imported declaration
                                                              | Imported unit
                                                              |
                                                              | Namespace alias
                                                              |
                                                              | Namespace using declaration
                                                              |
                                                              | Namespace using directive
                                                              |
  DW.AT.inline                                                ||Abstract instance
                                                              | Inlined subroutine
                                                              |
__DW.AT.is.optional___________________________________________||Optional_parameter__________________________________________________________________
  Continued on next page
  *Links for attributes come to the left column of this table; links in the right column "fan-out" to one or more descriptions.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 20
                                            Chapter 2.  General Description
__Attribute*__________________________________________________||Identioes_or_Specioes_______________________________________________________________
  DW.AT.language.name                                         ||Programming language name
  DW.AT.language.version                                      ||Programming language version
  DW.AT.linkage.name                                          ||Object ole linkage name of an entity
  DW.AT.location                                              ||Data object location
  DW.AT.loclists.base                                         ||Location lists base
  DW.AT.low.pc                                                ||Code address or range of addresses
                                                              | Base address of scope
                                                              |
  DW.AT.lower.bound                                           ||Lower bound of subrange
  DW.AT.macros                                                ||Macro preprocessor information
                                                              |
                                                              | (#define, #undef, and so on in C, C++ and
                                                              | similar languages)
                                                              |
  DW.AT.main.subprogram                                       ||Main or starting subprogram
                                                              | Unit containing main or starting subprogram
                                                              |
  DW.AT.mutable                                               ||Mutable property of member data
  DW.AT.name                                                  ||Name of declaration
                                                              | Path name of compilation source
                                                              |
  DW.AT.namelist.item                                         ||Namelist item
  DW.AT.noreturn                                              ||ino returnj property of a subprogram
  DW.AT.num.lanes                                             ||Number of implicitly parallel lanes
  DW.AT.object.pointer                                        ||Object (this, self) pointer of member
                                                              | function
                                                              |
  DW.AT.ordering                                              ||Array row/column ordering
  DW.AT.picture.string                                        ||Picture string for numeric string type
  DW.AT.priority                                              ||Module priority
  DW.AT.producer                                              ||Compiler identiocation
  DW.AT.prototyped                                            ||Subroutine prototype
  DW.AT.pure                                                  ||Pure property of a subroutine
  DW.AT.ranges                                                ||Non-contiguous range of code addresses
  DW.AT.rank                                                  ||Dynamic number of array dimensions
  DW.AT.recursive                                             ||Recursive property of a subroutine
  DW.AT.reference                                             ||&-qualioed non-static member function
                                                              | (C++)
______________________________________________________________|_____________________________________________________________________________________
  Continued on next page
  *Links for attributes come to the left column of this table; links in the right column "fan-out" to one or more descriptions.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 21
                                            Chapter 2.  General Description
__Attribute*__________________________________________________||Identioes_or_Specioes_______________________________________________________________
  DW.AT.return.addr                                           ||Subroutine return address save location
  DW.AT.rnglists.base                                         ||Base ooeset for range lists
  DW.AT.rvalue.reference                                      ||&&-qualioed non-static member function
                                                              | (C++)
                                                              |
  DW.AT.scale.divisor                                         ||Denominator of rational scale factor
  DW.AT.scale.multiplier                                      ||Numerator of rational scale factor
  DW.AT.sibling                                               ||Debugging information entry relationship
  DW.AT.signature                                             ||Type signature
  DW.AT.small                                                 ||Scale factor for oxed-point type
  DW.AT.speciocation                                          ||Incomplete, non-deoning, or separate
                                                              | declaration corresponding to a declaration
                                                              |
  DW.AT.start.scope                                           ||Reduced scope of declaration
  DW.AT.static.link                                           ||Location of uplevel frame
  DW.AT.stmt.list                                             ||Line number information for unit
  DW.AT.string.length                                         ||String length of string type
  DW.AT.string.length.bit.size                                ||Size of string length of string type
  DW.AT.string.length.byte.size                               ||Size of string length of string type
  DW.AT.str.ooesets1                                          ||String ooesets information for unit
  DW.AT.tensor                                                ||Tensor (array) type
  DW.AT.threads.scaled                                        ||Array bound THREADS scale factor (UPC)
  DW.AT.trampoline                                            ||Target subroutine
  DW.AT.type                                                  ||Type of call site
                                                              | Type of string type components
                                                              |
                                                              | Type of subroutine return
                                                              |
                                                              | Type of declaration
                                                              |
  DW.AT.upper.bound                                           ||Upper bound of subrange
  DW.AT.use.location                                          ||Member location for pointer to member type
  DW.AT.use.UTF8                                              ||Compilation unit uses UTF-8 strings
__DW.AT.variable.parameter____________________________________||Non-constant_parameter_AEag_________________________________________________________
  Continued on next page
  *Links for attributes come to the left column of this table; links in the right column "fan-out" to one or more descriptions.
_________________________________________________________
      1  DW.FORM.str.ooesets  is  new  in  DWARF  Version  6.   It  replaces  DW.AT.str.ooesets.base
which is deprecated.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 22
                                            Chapter 2.  General Description
__Attribute*__________________________________________________||Identioes_or_Specioes_______________________________________________________________
  DW.AT.virtuality                                            ||Virtuality attribute
  DW.AT.visibility                                            ||Visibility of declaration
__DW.AT.vtable.elem.location__________________________________||Virtual_function_vtable_slot________________________________________________________
  *Links for attributes come to the left column of this table; links in the right column "fan-out" to one or more descriptions.
The permissible values for an attribute belong to one or more classes of attribute
value forms. Each form class may be represented in one or more ways. For
example, some attribute values consist of a single piece of constant data.
iConstant dataj is the class of attribute value that those attributes may have.
There are several representations of constant data, including oxed length data of
one, two, four, eight or 16 bytes in size, and variable length data). The particular
representation for any given instance of an attribute is encoded along with the
attribute name as part of the information that guides the interpretation of a
debugging information entry.
Attribute value forms belong to one of the classes shown in Table 2.3 following.
                                        Table 2.3: Classes of attribute value
 _____________________________________________________________________________________________________________________________________________
 __Attribute_Class________________||General_Use_and_Encoding__________________________________________________________________________________
    address                       ||Refers to some location in the address space of the
                                  | described         program.
                                  |
    addrptr                       ||Specioes a location in the DWARF section that holds a
                                  |
                                  | series of machine address values. Certain attributes use
                                  | one of these addresses by indexing relative to this location.
                                  |
    block                         ||An arbitrary number of uninterpreted bytes of data. The
                                  |
                                  | number of data bytes may be implicit from context or
                                  |
                                  | explicitly specioed by an initial unsigned LEB128 value
                                  |
                                  | (see Section 7.6 on page 231) that precedes that number of
                                  | data bytes.
                                  |
    constant                      ||One, two, four, eight or sixteen bytes of uninterpreted data,
                                  |
                                  | or data encoded in the variable length format known as
                                  | LEB128 (see Section 7.6 on page 231).
                                  |
    exprval                       ||A DWARF expression yielding a value (see Section 2.5 on
                                  |
                                  | page 26). A leading unsigned ULEB128 value (see Section
                                  |
                                  | 7.6 on page 231) specioes the number of bytes in the
                                  | expression.
 _________________________________|___________________________________________________________________________________________________________
   Continued on next page
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 23
                                            Chapter 2.  General Description
 __Attribute_Class_______________||General_Use_and_Encoding___________________________________________________________________________________
    AEag                         ||A small constant that indicates the presence or absence of
                                 | an attribute.
                                 |
    lineptr                      ||Specioes a location in the DWARF section that holds line
                                 | number information.
                                 |
    locdesc                      ||A DWARF location description (see Section 2.6 on
                                 |
                                 | page 39). A leading unsigned ULEB128 value (see Section
                                 |
                                 | 7.6 on page 231) specioes the number of bytes in the
                                 | location description.
                                 |
    vallist,  loclist,           ||Specioes a location in the DWARF section that holds value
    loclistsptr                  ||lists and location lists, which describe objects whose
                                 | attributes or location can change during their lifetime.
                                 |
    macptr                       ||Specioes a location in the DWARF section that holds macro
                                 ||deonition information.
                                 ||
    reference                    ||Refers to one of the debugging information entries that
                                 | describe        the program. There are four types of reference       .
                                 |
                                 | The orst is an ooeset relative to the beginning of the
                                 |
                                 | compilation           unit in which the reference occurs and must
                                 |
                                 | refer to an entry within that same compilation unit. The
                                 |
                                 | second type of reference is the ooeset of a debugging
                                 |
                                 | information           entry in any compilation unit, including one
                                 |
                                 | dioeerent from the unit containing the reference. The third
                                 |
                                 | type of reference is an indirect reference to a type
                                 |
                                 | deonition using an 8-byte signature for that type. The
                                 |
                                 | fourth type of reference is a reference from within the
                                 |
                                 | .debug_info section of the executable or shared object ole
                                 |
                                 | to a debugging information entry in the .debug_info
                                 | section of a supplementary object ole.
                                 |
    rnglist,                     ||Specioes a location in the DWARF section that holds
    rnglistsptr                  ||non-contiguous address ranges.
    string                       ||A null-terminated sequence of zero or more (non-null)
                                 |
                                 | bytes. Data in this class are generally printable strings.
                                 |
                                 | Strings may be represented directly in the debugging
                                 | information           entry or as an ooeset in a separate string table.
 ________________________________|____________________________________________________________________________________________________________
   Continued on next page
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 24
                                            Chapter 2.  General Description
 __Attribute_Class_______________||General_Use_and_Encoding___________________________________________________________________________________
    strooesetsptr                ||Specioes a location in the DWARF section that holds a
                                 |
                                 | series of ooesets into the DWARF section that holds strings.
                                 |
                                 | Certain attributes use one of these ooesets by indexing
                                 |
                                 | relative to this location. The resulting ooeset is then used to
                                 | index into the DWARF string section.
 ________________________________|______________________________________________________________________________________________________________
2.3          Relationship  of  Debugging  Information  Entries
A variety of needs can be met by permitting a single debugging information entry to
iownj an arbitrary number of other debugging entries and by permitting the same
debugging information entry to be one of many owned by another debugging information
entry. This makes it possible, for example, to describe the static block structure within a
source ole, to show the members of a structure, union, or class, and to associate
declarations with source oles or source oles with shared object oles.
The ownership relationship of debugging information entries is achieved
naturally because the debugging information is represented as a tree. The nodes
of the tree are the debugging information entries themselves. The child entries of
any node are exactly those debugging information entries owned by that node.
While the ownership relation of the debugging information entries is represented as a
tree, other relations among the entries exist, for example, a reference from an entry
representing a variable to another entry representing the type of that variable. If all such
relations are taken into account, the debugging entries form a graph, not a tree.
The tree itself is represented by AEattening it in preox order. Each debugging
information entry is deoned either to have child entries or not to have child
entries (see Section 7.5.3 on page 212). If an entry is deoned not to have children,
the next physically succeeding entry is a sibling. If an entry is deoned to have
children, the next physically succeeding entry is its orst child. Additional
children are represented as siblings of the orst child. A chain of sibling entries is
terminated by a null entry.
In cases where a producer of debugging information feels that it will be
important for consumers of that information to quickly scan chains of sibling
entries, while ignoring the children of individual siblings, that producer may
attach a DW.AT.sibling attribute to any debugging information entry. The value
of this attribute is a reference to the sibling entry of the entry to which the
attribute is attached.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 25
                                            Chapter 2.  General Description
2.4          Target  Addresses
Addresses, bytes and bits in DWARF use the numbering and direction
conventions that are appropriate to the current language on the target system.
Many places in this document refer to the size of an address on the target
architecture (or equivalently, target machine) to which a DWARF description
applies. For processors which can be conogured to have dioeerent address sizes
or dioeerent instruction sets, the intent is to refer to the conoguration which is
either the default for that processor or which is specioed by the object ole or
executable ole which contains the DWARF information.
For example, if a particular target architecture supports both 32-bit and 64-bit addresses,
the compiler will generate an object ole which specioes that it contains executable code
generated for one or the other of these address sizes. In that case, the DWARF debugging
information contained in this object ole will use the same address size.
2.4.1          Reserved Target Address for Non-Existent Entity
The target address consisting of the largest representable address value (for
example, 0xffffffff for a 32-bit address) is reserved to indicate that there is no
entity designated by that address.
In some cases a producer may emit machine code or allocate storage for an entity, but a
linker or other subsequent processing step may remove that entity. In that case, rather
than be required to rewrite the DWARF description to eliminate the relevant DWARF
construct that contains the address of that entity, the processing step may simply update
the address value to the reserved value.
2.5          DWARF  Expressions
DWARF expressions describe how to compute a value or specify a location. They
are expressed in terms of DWARF operations that operate on a stack of values.
A DWARF expression is encoded as a stream of operations, each consisting of an
opcode followed by zero or more literal operands. The number of operands is
implied by the opcode.
In addition to the general operations that are deoned here, operations that are
specioc to location descriptions are deoned in Section 2.6 on page 39.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 26
                                            Chapter 2.  General Description
2.5.1          General Operations
Each general operation represents a postox operation on a simple stack machine.
Each element of the stack has a type and a value, and can represent a value of
any supported base type of the target machine. Instead of a base type, elements
can have a generic type, which is an integral type that has the size of an address
on the target machine and unspecioed signedness. The value on the top of the
stack after iexecutingj the DWARF expression is taken to be the result (the
address of the object, the value of the array bound, the length of a dynamic
string, the desired value itself, and so on).
The generic type is the same as the unspecioed type used for stack operations deoned in
DWARF Version 4 and before.
2.5.1.1        Literal Encodings
The following operations all push a value onto the DWARF stack. Operations
other than DW.OP.const.type push a value with the generic type, and if the
value of a constant in one of these operations is larger than can be stored in a
single stack element, the value is truncated to the element size and the low-order
bits are pushed on the stack.
1.    DW.OP.lit0, DW.OP.lit1, . . . , DW.OP.lit31
      The DW.OP.lit!n? operations encode the unsigned literal values from 0
      through 31, inclusive.
2.    DW.OP.addr
      The DW.OP.addr operation has a single operand that encodes a machine
      address and whose size is the size of an address on the target machine.
3.    DW.OP.const1u, DW.OP.const2u, DW.OP.const4u, DW.OP.const8u
      The single operand of a DW.OP.const!n?u operation provides a 1, 2, 4, or
      8-byte unsigned integer constant, respectively.
4.    DW.OP.const1s, DW.OP.const2s, DW.OP.const4s, DW.OP.const8s
      The single operand of a DW.OP.const!n?s operation provides a 1, 2, 4, or
      8-byte signed integer constant, respectively.
5.    DW.OP.constu
      The single operand of the DW.OP.constu operation provides an unsigned
      LEB128 integer constant.
6.    DW.OP.consts
      The single operand of the DW.OP.consts operation provides a signed
      LEB128 integer constant.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 27
                                            Chapter 2.  General Description
7.    DW.OP.addrx
      The DW.OP.addrx operation has a single operand that encodes an unsigned
      LEB128 value, which is a zero-based index into the .debug_addr section,
      where a machine address is stored. This index is relative to the value of the
      DW.AT.addr.base attribute of the associated compilation unit.
8.    DW.OP.constx
      The DW.OP.constx operation has a single operand that encodes an unsigned
      LEB128 value, which is a zero-based index into the .debug_addr section,
      where a constant, the size of a machine address, is stored. This index is
      relative to the value of the DW.AT.addr.base attribute of the associated
      compilation unit.
      The DW.OP.constx operation is provided for constants that require link-time
      relocation but should not be interpreted by the consumer as a relocatable address (for
      example, ooesets to thread-local storage).
9.    DW.OP.const.type
      The DW.OP.const.type operation takes three operands. The orst operand is
      an unsigned LEB128 integer that represents the ooeset of a debugging
      information entry in the current compilation unit, which must be a
      DW.TAG.base.type entry that provides the type of the constant provided.
      The second operand is 1-byte unsigned integer that specioes the size of the
      constant value, which is the same as the size of the base type referenced by
      the orst operand. The third operand is a sequence of bytes of the given size
      that is interpreted as a value of the referenced type.
      While the size of the constant can be inferred from the base type deonition, it is
      encoded explicitly into the operation so that the operation can be parsed easily
      without reference to the .debug_info section.
2.5.1.2        Register Values
The following operations push a value onto the stack that is either part or all of
the contents of a register or the result of adding the contents of a register to a
given signed ooeset. DW.OP.regval.type pushes the contents of a register
together with the given base type. DW.OP.regval.bits pushes the partial
contents of a register together with the generic type. The other operations push
the result of adding the contents of a register to a given signed ooeset together
with the generic type.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 28
                                            Chapter 2.  General Description
1.    DW.OP.fbreg
      The DW.OP.fbreg operation provides a signed LEB128 ooeset from the
      address specioed by the location description in the DW.AT.frame.base
      attribute of the current function.
      This is typically a stack pointer register plus or minus some ooeset.
2.    DW.OP.breg0, DW.OP.breg1, . . . , DW.OP.breg31
      The single operand of the DW.OP.breg!n? operations provides a signed
      LEB128 ooeset from the contents of the specioed register.
3.    DW.OP.bregx
      The DW.OP.bregx operation provides the sum of two values specioed by its
      two operands. The orst operand is a register number which is specioed by an
      unsigned LEB128 number. The second operand is a signed LEB128 ooeset.
4.    DW.OP.regval.type
      The DW.OP.regval.type operation pushes the contents of a given register
      interpreted as a value of a given type. The orst operand is an unsigned
      LEB128 number, which identioes a register whose contents is to be pushed
      onto the stack. The second operand is an unsigned LEB128 number that
      represents the ooeset of a debugging information entry in the current
      compilation unit, which must be a DW.TAG.base.type entry that provides
      the type of the value contained in the specioed register.
5.    DW.OP.regval.bits
      The DW.OP.regval.bits operation takes a single unsigned LEB128 integer
      operand, which gives the number of bits to read. This number must be
      smaller or equal to the bit size of the generic type. It pops the top two stack
      elements and interprets the top element as an unsigned bit ooeset from the
      least signiocant bit end and the other as a register number identifying the
      register from which to extract the value. If the extracted value is smaller than
      the size of the generic type, it is zero extended.
2.5.1.3        Stack Operations
The following operations manipulate the DWARF stack. Operations that index
the stack assume that the top of the stack (most recently added entry) has index 0.
Each entry on the stack has an associated type.
1.    DW.OP.dup
      The DW.OP.dup operation duplicates the value (including its type
      identioer) at the top of the stack.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 29
                                            Chapter 2.  General Description
2.    DW.OP.drop
      The DW.OP.drop operation pops the value (including its type identioer) at
      the top of the stack.
3.    DW.OP.pick
      The single operand of the DW.OP.pick operation provides a 1-byte index. A
      copy of the stack entry (including its type identioer) with the specioed index
      (0 through 255, inclusive) is pushed onto the stack.
4.    DW.OP.over
      The DW.OP.over operation duplicates the entry currently second in the
      stack at the top of the stack. This is equivalent to a DW.OP.pick operation,
      with index 1.
5.    DW.OP.swap
      The DW.OP.swap operation swaps the top two stack entries. The entry at
      the top of the stack (including its type identioer) becomes the second stack
      entry, and the second entry (including its type identioer) becomes the top of
      the stack.
6.    DW.OP.rot
      The DW.OP.rot operation rotates the orst three stack entries. The entry at the
      top of the stack (including its type identioer) becomes the third stack entry,
      the second entry (including its type identioer) becomes the top of the stack,
      and the third entry (including its type identioer) becomes the second entry.
7.    DW.OP.deref
      The DW.OP.deref operation pops the top stack entry and treats it as an
      address. The popped value must have an integral type. The value retrieved
      from that address is pushed, and has the generic type. The size of the data
      retrieved from the dereferenced address is the size of an address on the target
      machine.
8.    DW.OP.deref.size
      The DW.OP.deref.size operation behaves like the DW.OP.deref operation:
      it pops the top stack entry and treats it as an address. The popped value must
      have an integral type. The value retrieved from that address is pushed, and
      has the generic type. In the DW.OP.deref.size operation, however, the size
      in bytes of the data retrieved from the dereferenced address is specioed by
      the single operand. This operand is a 1-byte unsigned integral constant
      whose value may not be larger than the size of the generic type. The data
      retrieved is zero extended to the size of an address on the target machine
      before being pushed onto the expression stack.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 30
                                              Chapter 2.  General Description
  9.    DW.OP.deref.type
        The DW.OP.deref.type operation behaves like the DW.OP.deref.size
        operation: it pops the top stack entry and treats it as an address. The popped
        value must have an integral type. The value retrieved from that address is
        pushed together with a type identioer. In the DW.OP.deref.type operation,
        the size in bytes of the data retrieved from the dereferenced address is
        specioed by the orst operand. This operand is a 1-byte unsigned integral
        constant whose value which is the same as the size of the base type
        referenced by the second operand. The second operand is an unsigned
        LEB128 integer that represents the ooeset of a debugging information entry in
        the current compilation unit, which must be a DW.TAG.base.type entry that
        provides the type of the data pushed.
        While the size of the pushed value could be inferred from the base type deonition, it is
        encoded explicitly into the operation so that the operation can be parsed easily
        without reference to the .debug_info section.
10.     DW.OP.xderef
        The DW.OP.xderef operation provides an extended dereference mechanism.
        The entry at the top of the stack is treated as an address. The second stack
        entry is treated as an iaddress space identioerj for those architectures that
        support multiple address spaces. Both of these entries must have integral
        type identioers. The top two stack elements are popped, and a data item is
        retrieved through an implementation-deoned address calculation and pushed
        as the new stack top together with the generic type identioer. The size of the
        data retrieved from the dereferenced address is the size of the generic type.
11.     DW.OP.xderef.size
        The DW.OP.xderef.size operation behaves like the DW.OP.xderef
        operation. The entry at the top of the stack is treated as an address. The
        second stack entry is treated as an iaddress space identioerj for those
        architectures that support multiple address spaces. Both of these entries must
        have integral type identioers. The top two stack elements are popped, and a
        data item is retrieved through an implementation-deoned address calculation
        and pushed as the new stack top. In the DW.OP.xderef.size operation,
        however, the size in bytes of the data retrieved from the dereferenced address
        is specioed by the single operand. This operand is a 1-byte unsigned integral
        constant whose value may not be larger than the size of an address on the
        target machine. The data retrieved is zero extended to the size of an address
        on the target machine before being pushed onto the expression stack together
        with the generic type identioer.
  November 1, 2024                                  ***WORKING DRAFT***                                                             Page 31
                                              Chapter 2.  General Description
12.     DW.OP.xderef.type
        The DW.OP.xderef.type operation behaves like the DW.OP.xderef.size
        operation: it pops the top two stack entries, treats them as an address and an
        address space identioer, and pushes the value retrieved. In the
        DW.OP.xderef.type operation, the size in bytes of the data retrieved from
        the dereferenced address is specioed by the orst operand. This operand is a
        1-byte unsigned integral constant whose value value which is the same as the
        size of the base type referenced by the second operand. The second operand
        is an unsigned LEB128 integer that represents the ooeset of a debugging
        information entry in the current compilation unit, which must be a
        DW.TAG.base.type entry that provides the type of the data pushed.
13.     DW.OP.push.object.address
        The DW.OP.push.object.address operation pushes the address of the object
        currently being evaluated as part of evaluation of a user presented
        expression. This object may correspond to an independent variable described
        by its own debugging information entry or it may be a component of an
        array, structure, or class whose address has been dynamically determined by
        an earlier step during user expression evaluation.
        This operator provides explicit functionality (especially for arrays involving
        descriptors) that is analogous to the implicit push of the base address of a structure
        prior to evaluation of a DW.AT.data.member.location to access a data member of a
        structure. For an example, see Appendix D.2 on page 307.
14.     DW.OP.form.tls.address
        The DW.OP.form.tls.address operation pops a value from the stack, which
        must have an integral type identioer, translates this value into an address in
        the thread-local storage for a thread, and pushes the address onto the stack
        together with the generic type identioer. The meaning of the value on the top
        of the stack prior to this operation is deoned by the run-time environment. If
        the run-time environment supports multiple thread-local storage blocks for a
        single thread, then the block corresponding to the executable or shared
        library containing this DWARF expression is used.
        Some implementations of C, C++, Fortran, and other languages, support a
        thread-local storage class. Variables with this storage class have distinct values and
        addresses in distinct threads, much as automatic variables have distinct values and
        addresses in each function invocation. Typically, there is a single block of storage
        containing all thread-local variables declared in the main executable, and a separate
        block for the variables declared in each shared library. Each thread-local variable can
        then be accessed in its block using an identioer. This identioer is typically an ooeset
        into the block and pushed onto the DWARF stack by one of the
  November 1, 2024                                  ***WORKING DRAFT***                                                             Page 32
                                              Chapter 2.  General Description
        DW.OP.const!n?!x? operations prior to the DW.OP.form.tls.address
        operation. Computing the address of the appropriate block can be complex (in some
        cases, the compiler emits a function call to do it), and diOEcult to describe using
        ordinary DWARF location descriptions. Instead of forcing complex thread-local
        storage calculations into the DWARF expressions, the DW.OP.form.tls.address
        allows the consumer to perform the computation based on the run-time environment.
15.     DW.OP.call.frame.cfa
        The DW.OP.call.frame.cfa operation pushes the value of the CFA, obtained
        from the Call Frame Information (see Section 6.4 on page 179).
        Although the value of DW.AT.frame.base can be computed using other DWARF
        expression operators, in some cases this would require an extensive location list
        because the values of the registers used in computing the CFA change during a
        subroutine. If the Call Frame Information is present, then it already encodes such
        changes, and it is space eOEcient to reference that.
16.     DW.OP.push.lane
        The DW.OP.push.lane operation pushes a lane index value of the generic
        type, which provides the context of the lane in which the expression is being
        evaluated. See section 3.3.5 on page 83.
        Producers that widen source code into vectorized machine code may use this
        operation to describe the location of a source variable as function of a single lane in
        the widened machine code.
        Consumers supply the lane argument to obtain the location of the instance of that
        source variable that corresponds to the provided lane argument.
  Examples illustrating many of these stack operations are found in Appendix D.1.2 on
  page 303.
  2.5.1.4        Arithmetic and Logical Operations
  The following provide arithmetic and logical operations. Operands of an
  operation with two operands must have the same type, either the same base type
  or the generic type. The result of the operation which is pushed back has the
  same type as the type of the operand(s).
  If the type of the operands is the generic type, except as otherwise specioed, the
  arithmetic operations perform addressing arithmetic, that is, unsigned arithmetic
  that is performed modulo one plus the largest representable address.
  Operations other than DW.OP.abs, DW.OP.div, DW.OP.minus,
  DW.OP.mul, DW.OP.neg and DW.OP.plus require integral types of the
  November 1, 2024                                  ***WORKING DRAFT***                                                             Page 33
                                              Chapter 2.  General Description
  operand (either integral base type or the generic type). Operations do not cause
  an exception on overAEow.
  1.    DW.OP.abs
        The DW.OP.abs operation pops the top stack entry, interprets it as a signed
        value and pushes its absolute value. If the absolute value cannot be
        represented, the result is undeoned.
  2.    DW.OP.and
        The DW.OP.and operation pops the top two stack values, performs a
        bitwise and operation on the two, and pushes the result.
  3.    DW.OP.div
        The DW.OP.div operation pops the top two stack values, divides the former
        second entry by the former top of the stack using signed division, and pushes
        the result.
  4.    DW.OP.minus
        The DW.OP.minus operation pops the top two stack values, subtracts the
        former top of the stack from the former second entry, and pushes the result.
  5.    DW.OP.mod
        The DW.OP.mod operation pops the top two stack values and pushes the
        result of the calculation: former second stack entry modulo the former top of
        the stack.
  6.    DW.OP.mul
        The DW.OP.mul operation pops the top two stack entries, multiplies them
        together, and pushes the result.
  7.    DW.OP.neg
        The DW.OP.neg operation pops the top stack entry, interprets it as a signed
        value and pushes its negation. If the negation cannot be represented, the
        result is undeoned.
  8.    DW.OP.not
        The DW.OP.not operation pops the top stack entry, and pushes its bitwise
        complement.
  9.    DW.OP.or
        The DW.OP.or operation pops the top two stack entries, performs a bitwise
        or operation on the two, and pushes the result.
10.     DW.OP.plus
        The DW.OP.plus operation pops the top two stack entries, adds them
        together, and pushes the result.
  November 1, 2024                                  ***WORKING DRAFT***                                                             Page 34
                                              Chapter 2.  General Description
11.     DW.OP.plus.uconst
        The DW.OP.plus.uconst operation pops the top stack entry, adds it to the
        unsigned LEB128 constant operand interpreted as the same type as the
        operand popped from the top of the stack and pushes the result.
        This operation is supplied speciocally to be able to encode more oeld ooesets in two
        bytes than can be done with iDW.OP.lit!n? DW.OP.plus.j
12.     DW.OP.shl
        The DW.OP.shl operation pops the top two stack entries, shifts the former
        second entry left (olling with zero bits) by the number of bits specioed by the
        former top of the stack, and pushes the result.
13.     DW.OP.shr
        The DW.OP.shr operation pops the top two stack entries, shifts the former
        second entry right logically (olling with zero bits) by the number of bits
        specioed by the former top of the stack, and pushes the result.
14.     DW.OP.shra
        The DW.OP.shra operation pops the top two stack entries, shifts the former
        second entry right arithmetically (divide the magnitude by 2, keep the same
        sign for the result) by the number of bits specioed by the former top of the
        stack, and pushes the result.
15.     DW.OP.xor
        The DW.OP.xor operation pops the top two stack entries, performs a bitwise
        exclusive-or operation on the two, and pushes the result.
  2.5.1.5        Control Flow Operations
  The following operations provide simple control of the AEow of a DWARF
  expression.
  1.    DW.OP.le, DW.OP.ge, DW.OP.eq, DW.OP.lt, DW.OP.gt, DW.OP.ne
        The six relational operators each:
            #    pop the top two stack values, which have the same type, either the same
                 base type or the generic type,
            #    compare the operands:
                 ! former second entry ?! relational operator ?! former top entry ?
            #    push the constant value 1 onto the stack if the result of the operation is
                 true or the constant value 0 if the result of the operation is false. The
                 pushed value has the generic type.
  November 1, 2024                                  ***WORKING DRAFT***                                                             Page 35
                                            Chapter 2.  General Description
      If the operands have the generic type, the comparisons are performed as
      signed operations.
2.    DW.OP.skip
      DW.OP.skip is an unconditional branch. Its single operand is a 2-byte
      signed integer constant. The 2-byte constant is the number of bytes of the
      DWARF expression to skip forward or backward from the current operation,
      beginning after the 2-byte constant.
3.    DW.OP.bra
      DW.OP.bra is a conditional branch. Its single operand is a 2-byte signed
      integer constant. This operation pops the top of stack. If the value popped is
      not the constant 0, the 2-byte constant operand is the number of bytes of the
      DWARF expression to skip forward or backward from the current operation,
      beginning after the 2-byte constant.
4.    DW.OP.call2, DW.OP.call4, DW.OP.call.ref
      DW.OP.call2, DW.OP.call4, and DW.OP.call.ref perform DWARF
      procedure calls during evaluation of a DWARF expression or location
      description. For DW.OP.call2 and DW.OP.call4, the operand is the 2-  or
      4-byte unsigned ooeset, respectively, of a debugging information entry in the
      current compilation unit. The DW.OP.call.ref operator has a single operand.
      In the 32-bit DWARF format, the operand is a 4-byte unsigned value; in the
      64-bit DWARF format, it is an 8-byte unsigned value (see Section 7.4 on
      page 204). The operand is used as the ooeset of a debugging information entry
      in the .debug_info section of the current executable or shared object ole.
      Operand interpretation of DW.OP.call2, DW.OP.call4 and DW.OP.call.ref is
      exactly like that for DW.FORM.ref2, DW.FORM.ref4 and DW.FORM.ref.addr,
      respectively (see Section 7.5.4 on page 217).
      These operations transfer control of DWARF expression evaluation to the
      DW.AT.location attribute of the referenced debugging information entry. If
      there is no such attribute, then there is no eoeect. Execution of the DWARF
      expression of a DW.AT.location attribute may add to and/or remove from
      values on the stack. Execution returns to the point following the call when
      the end of the attribute is reached. Values on the stack at the time of the call
      may be used as parameters by the called expression and values left on the
      stack by the called expression may be used as return values by prior
      agreement between the calling and called expressions.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 36
                                            Chapter 2.  General Description
2.5.1.6        Type Conversions
The following operations provide for explicit type conversion.
1.    DW.OP.convert
      The DW.OP.convert operation pops the top stack entry, converts it to a
      dioeerent type, then pushes the result. It takes one operand, which is an
      unsigned LEB128 integer that represents the ooeset of a debugging
      information entry in the current compilation unit, or value 0 which represents
      the generic type. If the operand is non-zero, the referenced entry must be a
      DW.TAG.base.type entry that provides the type to which the value is
      converted.
2.    DW.OP.reinterpret
      The DW.OP.reinterpret operation pops the top stack entry, reinterprets the
      bits in its value as a value of a dioeerent type, then pushes the result. It takes
      one operand, which is an unsigned LEB128 integer that represents the ooeset
      of a debugging information entry in the current compilation unit, or value 0
      which represents the generic type. If the operand is non-zero, the referenced
      entry must be a DW.TAG.base.type entry that provides the type to which
      the value is converted. The type of the operand and result type must have the
      same size in bits.
2.5.1.7        Special Operations
There are these special operations currently deoned:
1.    DW.OP.nop
      The DW.OP.nop operation is a place holder. It has no eoeect on the location
      stack or any of its values.
2.    DW.OP.entry.value
      The DW.OP.entry.value operation pushes the value that an expression
      would have had, or a register location would have held, upon entering the
      current subprogram. It has two operands: an unsigned LEB128 length,
      followed by a block containing a DWARF expression or a register location
      description (see Section 2.6.1.1.3 on page 40). The length operand specioes
      the length in bytes of the block. If the block contains a DWARF expression,
      the DWARF expression is evaluated as if it had been evaluated upon entering
      the current subprogram. The DWARF expression assumes no values are
      present on the DWARF stack initially and results in exactly one value being
      pushed on the DWARF stack when completed. If the block contains a register
      location description, DW.OP.entry.value pushes the value that register held
      upon entering the current subprogram.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 37
                                            Chapter 2.  General Description
      DW.OP.push.object.address is not meaningful inside of this DWARF
      operation.
      The register location description provides a more compact form for the case where the
      value was in a register on entry to the subprogram.
      The values needed to evaluate DW.OP.entry.value could be obtained in several
      ways. The consumer could suspend execution on entry to the subprogram, record
      values needed by DW.OP.entry.value expressions within the subprogram, and then
      continue; when evaluating DW.OP.entry.value, the consumer would use these
      recorded values rather than the current values. Or, when evaluating
      DW.OP.entry.value, the consumer could virtually unwind using the Call Frame
      Information (see Section 6.4 on page 179) to recover register values that might have
      been clobbered since the subprogram entry point.
3.    DW.OP.extended
      The DW.OP.extended opcode encodes an extension operation. It has at least
      one operand: a ULEB128 constant identifying the extension operation. The
      remaining operands are deoned by the extension opcode, which are named
      using a preox of DW.OP.EXT. The extension opcode 0 is reserved.
4.    DW.OP.user.extended
      The DW.OP.user.extended opcode encodes a producer extension operation.
      It has at least one operand: a ULEB128 constant identifying a producer
      extension operation. The remaining operands are deoned by the producer
      extension. The producer extension opcode 0 is reserved and cannot be used
      by any producer extension.
      The DW.OP.user.extended encoding space can be understood to supplement the
      space deoned by DW.OP.lo.user and DW.OP.hi.user that is allocated by the
      standard for the same purpose.
2.5.2          Value Lists
Value lists are used in place of DWARF expressions whenever the value of an
object's attribute can change during the lifetime of that object.
Value lists are contained in a separate object ole section, along with location lists
(see 2.6.2 on page 44).
A value list is indicated by an attribute whose value is of class vallist (see Section
7.5.5 on page 222).
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 38
                                            Chapter 2.  General Description
A value list consists of a series of value list entries. The representation of a value
list is the same as for a location list (see 2.6.2 on page 44), except that bounded
location description and default location description entries are understood to
provide DWARF expressions that produce values rather than location
descriptions.
The DWARF expressions in value list entries, being expressions and not location
descriptions, may not contain any of the DWARF operations described in Section 2.6.
The address ranges deoned by the bounded expressions of a value list may
overlap. When they do, the meaning is undeoned if the overlapping expressions
do not produce the same value.
2.6          Location  Descriptions
Debugging information must provide consumers a way to ond the location of program
variables, determine the bounds of dynamic arrays and strings, and possibly to ond the
base address of a subroutine's stack frame or the return address of a subroutine.
Furthermore, to meet the needs of recent computer architectures and optimization
techniques, debugging information must be able to describe the location of an object
whose location changes over the object's lifetime.
Information about the location of program objects is provided by location
descriptions. Location descriptions can be either of two forms:
1.    Single location descriptions, which are a language independent representation
      of addressing rules of arbitrary complexity built from DWARF expressions
      (See Section 2.5 on page 26) and/or other DWARF operations specioc to
      describing locations. They are suOEcient for describing the location of any
      object as long as its lifetime is either static or the same as the lexical block that
      owns it, excluding any prologue or epilogue ranges, and it does not move
      during its lifetime.
2.    Location lists, which are used to describe objects that have a limited lifetime or
      change their location during their lifetime. Location lists are described in
      Section 2.6.2 on page 44 below.
Location descriptions are distinguished in a context sensitive manner. As the
value of an attribute, a single location description is encoded using class locdesc
and a location list is encoded using class loclist (which serves as an index into a
separate section containing location lists).
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 39
                                            Chapter 2.  General Description
2.6.1          Single Location Descriptions
A single location description is either:
1.    A simple location description, representing an object which exists in one
      contiguous piece at the given location, or
2.    A composite location description consisting of one or more simple location
      descriptions, each of which is followed by one composition operation. Each
      simple location description describes the location of one piece of the object;
      each composition operation describes which part of the object is located
      there. Each simple location description that is a DWARF expression is
      evaluated independently of any others.
2.6.1.1        Simple Location Descriptions
A simple location description represents one contiguous piece or all of an object
or value.
2.6.1.1.1    Empty Location Descriptions
An empty location description consists of a DWARF expression containing no
operations. It represents a piece or all of an object that is present in the source but
not in the object code (perhaps due to optimization).
2.6.1.1.2    Memory Location Descriptions
A memory location description consists of a non-empty DWARF expression (see
Section 2.5 on page 26), whose value is the address of a piece or all of an object or
other entity in memory.
2.6.1.1.3    Register Location Descriptions
A register location description consists of a register name operation, which
represents a piece or all of an object located in a given register.
Register location descriptions describe an object (or a piece of an object) that resides in a
register, while the opcodes listed in Section 2.5.1.2 on page 28 are used to describe an
object (or a piece of an object) that is located in memory at an address that is contained in
a register (possibly ooeset by some constant). A register location description must stand
alone as the entire description of an object or a piece of an object.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 40
                                            Chapter 2.  General Description
The following DWARF operations can be used to specify a register location.
Note that the register number represents a DWARF specioc mapping of numbers onto
the actual registers of a given architecture. The mapping should be chosen to gain optimal
density and should be shared by all users of a given architecture. It is recommended that
this mapping be deoned by the ABI authoring committee for each architecture.
1.    DW.OP.reg0, DW.OP.reg1, ..., DW.OP.reg31
      The DW.OP.reg!n? operations encode the names of up to 32 registers,
      numbered from 0 through 31, inclusive. The object addressed is in register n.
2.    DW.OP.regx
      The DW.OP.regx operation has a single unsigned LEB128 literal operand
      that encodes the name of a register.
These operations name a register location. To fetch the contents of a register, it is
necessary to use one of the register based addressing operations, such as DW.OP.bregx
(Section 2.5.1.2 on page 28).
2.6.1.1.4    Implicit Location Descriptions
An implicit location description represents a piece or all of an object which has
no actual location but whose contents are nonetheless either known or known to
be undeoned.
The following DWARF operations may be used to specify a value that has no
location in the program but is a known constant or is computed from other
locations and values in the program.
1.    DW.OP.implicit.value
      The DW.OP.implicit.value operation specioes an immediate value using
      two operands: an unsigned LEB128 length, followed by a sequence of bytes
      of the given length that contain the value.
2.    DW.OP.stack.value
      The DW.OP.stack.value operation specioes that the object does not exist in
      memory but its value is nonetheless known and is at the top of the DWARF
      expression stack. In this form of location description, the DWARF expression
      represents the actual value of the object, rather than its location. The
      DW.OP.stack.value operation terminates the expression.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 41
                                            Chapter 2.  General Description
3.    DW.OP.implicit.pointer
      An optimizing compiler may eliminate a pointer, while still retaining the value that
      the pointer addressed. DW.OP.implicit.pointer allows a producer to describe this
      value.
      The DW.OP.implicit.pointer operation specioes that the object is a pointer
      that cannot be represented as a real pointer, even though the value it would
      point to can be described. In this form of location description, the DWARF
      expression refers to a debugging information entry that represents the actual
      value of the object to which the pointer would point. Thus, a consumer of the
      debug information would be able to show the value of the dereferenced
      pointer, even when it cannot show the value of the pointer itself.
      The DW.OP.implicit.pointer operation has two operands: a reference to a
      debugging information entry that describes the dereferenced object's value,
      and a signed number that is treated as a byte ooeset from the start of that
      value. The orst operand is a 4-byte unsigned value in the 32-bit DWARF
      format, or an 8-byte unsigned value in the 64-bit DWARF format (see Section
      7.4 on page 204) that is used as the ooeset of a debugging information entry in
      the .debug_info section of the current executable or shared object ole. The
      second operand is a signed LEB128 number.
      The debugging information entry referenced by a DW.OP.implicit.pointer
      operation is typically a DW.TAG.variable or DW.TAG.formal.parameter entry
      whose DW.AT.location attribute gives a second DWARF expression or a location
      list that describes the value of the object, but the referenced entry may be any entry
      that contains a DW.AT.location or DW.AT.const.value attribute (for example,
      DW.TAG.dwarf.procedure). By using the second DWARF expression, a consumer
      can reconstruct the value of the object when asked to dereference the pointer described
      by the original DWARF expression containing the DW.OP.implicit.pointer
      operation.
DWARF location descriptions are intended to yield the location of a value rather than
the value itself. An optimizing compiler may perform a number of code transformations
where it becomes impossible to give a location for a value, but it remains possible to
describe the value itself. Section 2.6.1.1.3 on page 40 describes operators that can be used
to describe the location of a value when that value exists in a register but not in memory.
The operations in this section are used to describe values that exist neither in memory nor
in a single register.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 42
                                            Chapter 2.  General Description
2.6.1.2        Composite Location Descriptions
A composite location description describes an object or value which may be
contained in part of a register or stored in more than one location. Each piece is
described by a composition operation, which does not compute a value nor store
any result on the DWARF stack. There may be one or more composition
operations in a single composite location description. A series of such operations
describes the parts of a value in memory address order.
Each composition operation is immediately preceded by a simple location
description which describes the location where part of the resultant value is
contained.
1.    DW.OP.piece
      The DW.OP.piece operation takes a single operand, which is an unsigned
      LEB128 number. The number describes the size in bytes of the piece of the
      object referenced by the preceding simple location description. If the piece is
      located in a register, but does not occupy the entire register, the placement of
      the piece within that register is deoned by the ABI.
      Many compilers store a single variable in sets of registers, or store a variable partially
      in memory and partially in registers. DW.OP.piece provides a way of describing
      how large a part of a variable a particular DWARF location description refers to.
2.    DW.OP.bit.piece
      The DW.OP.bit.piece operation takes two operands. The orst is an unsigned
      LEB128 number that gives the size in bits of the piece. The second is an
      unsigned LEB128 number that gives the ooeset in bits from the location
      deoned by the preceding DWARF location description.
      Interpretation of the ooeset depends on the location description. If the location
      description is empty (see Section 2.6.1.1.1 on page 40), the DW.OP.bit.piece
      operation describes a piece consisting of the given number of bits whose
      values are undeoned, and the ooeset is ignored. If the location is a memory
      address (see Section 2.6.1.1.2 on page 40), the DW.OP.bit.piece operation
      describes a sequence of bits relative to the location whose address is on the
      top of the DWARF stack using the bit numbering and direction conventions
      that are appropriate to the current language on the target system. In all other
      cases, the source of the piece is given by either a register location (see Section
      2.6.1.1.3 on page 40) or an implicit value description (see Section 2.6.1.1.4 on
      page 41); the ooeset is from the least signiocant bit of the source value.
A composition operation that follows an empty location description indicates
that the piece is undeoned, for example because it has been optimized away.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 43
                                            Chapter 2.  General Description
DW.OP.bit.piece is used instead of DW.OP.piece when the piece to be assembled into
a value or assigned to is not byte-sized or is not at the start of a register or addressable
unit of memory.
Whether or not a DW.OP.piece operation is equivalent to any DW.OP.bit.piece
operation with an ooeset of 0 is ABI dependent.
2.6.2          Location Lists
Location lists are used in place of location descriptions whenever the object
whose location is being described can change location during its lifetime.
Location lists are contained in a separate object ole section called
.debug_loclists or .debug_loclists.dwo (for split DWARF object oles).
A location list is indicated by a location or other attribute whose value is of class
loclist (see Section 7.5.5 on page 222).
This location list representation, the loclist class, and the related DW.AT.loclists.base
attribute are new in DWARF Version 5. Together they eliminate most or all of the object
language relocations previously needed for location lists.
A location list consists of a series of location list entries. Each location list entry is
one of the following kinds:
     #    Bounded location description. This kind of entry provides a location
          description that specioes the location of an object that is valid over a
          lifetime bounded by a starting and ending address. The starting address is
          the lowest address of the address range over which the location is valid.
          The ending address is the address of the orst location past the highest
          address of the address range. When the current PC is within the given
          range, the location description may be used to locate the specioed object.
          The location description is valid even if the address range includes
          addresses within a prologue or epilogue range.
          There are several kinds of bounded location description entries which
          dioeer in the way that they specify the starting and ending addresses.
          The address ranges deoned by the bounded location descriptions of a
          location list may overlap. When they do, they describe a situation in which
          an object exists simultaneously in more than one place. If all of the address
          ranges in a given location list do not collectively cover the entire range over
          which the object in question is deoned, and there is no following default
          location description, it is assumed that the object is not available for the
          portion of the range that is not covered.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 44
                                            Chapter 2.  General Description
          In the case of a bounded location description where the range is deoned by
          a starting address and either an ending address or a length, a starting
          address consisting of the reserved address value (see Section 2.4.1 on
          page 26) indicates a non-existent range, which is equivalent to omitting the
          description.
     #    Default location description. This kind of entry provides a location
          description that specioes the location of an object that is valid when no
          bounded location description applies. As with simple location descriptions,
          the lifetime of a default location excludes any prologue or epilogue ranges.
     #    Base address. This kind of entry provides an address to be used as the base
          address for beginning and ending address ooesets given in certain kinds of
          bounded location description. The applicable base address of a bounded
          location description entry is the address specioed by the closest preceding
          base address entry in the same location list. If there is no preceding base
          address entry, then the applicable base address defaults to the base address
          of the compilation unit (see Section 3.1.1 on page 62).
          In the case of a compilation unit where all of the machine code is contained
          in a single contiguous section, no base address entry is needed.
          If the base address is the reserved target address, either explicitly or by
          default, then the range of any bounded location description deoned relative
          to that base address is non-existent, which is equivalent to omitting the
          description.
     #    End-of-list. This kind of entry marks the end of the location list.
A location list consists of a sequence of zero or more bounded location
description or base address entries, optionally followed by a default location
entry, and terminated by an end-of-list entry.
Each location list entry begins with a single byte identifying the kind of that
entry, followed by zero or more operands depending on the kind.
In the descriptions that follow, these terms are used for operands:
     #    A counted location description operand consists of an unsigned ULEB
          integer giving the length of the location description (see Section 2.6.1 on
          page 40) that immediately follows.
     #    An address index operand is the index of an address in the .debug_addr
          section. This index is relative to the value of the DW.AT.addr.base
          attribute of the associated compilation unit. The address given by this kind
          of operand is not relative to the compilation unit base address.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 45
                                            Chapter 2.  General Description
     #    A target address operand is an address on the target machine. (Its size is
          the same as used for attribute values of class address, speciocally,
          DW.FORM.addr.)
The following entry kinds are deoned for use in both split or non-split units:
1.    DW.LLE.end.of.list
      An end-of-list entry contains no further data.
      A series of this kind of entry may be used for padding or alignment purposes.
2.    DW.LLE.base.addressx
      This is a form of base address entry that has one unsigned LEB128 operand.
      The operand value is an address index (into the .debug_addr section) that
      indicates the applicable base address used by subsequent
      DW.LLE.ooeset.pair entries.
3.    DW.LLE.startx.endx
      This is a form of bounded location description entry (see page 44) that has
      two unsigned LEB128 operands. The operand values are address indices (into
      the .debug_addr section). These indicate the starting and ending addresses,
      respectively, that deone the address range for which this location is valid.
      These operands are followed by a counted location description.
4.    DW.LLE.startx.length
      This is a form of bounded location description entry (see page 44) that has
      two unsigned LEB128 operands. The orst value is an address index (into the
      .debug_addr section) that indicates the beginning of the address range over
      which the location is valid. The second value is the length of the range. These
      operands are followed by a counted location description.
5.    DW.LLE.ooeset.pair
      This is a form of bounded location description entry (see page 44) that has
      two unsigned LEB128 operands. The values of these operands are the starting
      and ending ooesets, respectively, relative to the applicable base address, that
      deone the address range for which this location is valid. These operands are
      followed by a counted location description.
6.    DW.LLE.default.location
      The operand is a counted location description which deones where an object
      is located if no prior location description is valid.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 46
                                              Chapter 2.  General Description
  7.    DW.LLE.include.loclistx
        This is a form of list inclusion, that has one unsigned LEB128 operand. The
        value is an index into the .debug_loclists section, interpreted the same way
        as the operand of DW.FORM.loclistx to ond a target list of entries, which
        will be regarded as part of the current location list, up to the
        DW.LLE.end.of.list entry.
  The following kinds of location list entries are deoned for use only in non-split
  DWARF units:
  7.    DW.LLE.base.address
        A base address entry has one target address operand. This address is used as
        the base address when interpreting ooesets in subsequent location list entries
        of kind DW.LLE.ooeset.pair.
  8.    DW.LLE.start.end
        This is a form of bounded location description entry (see page 44) that has
        two target address operands. These indicate the starting and ending
        addresses, respectively, that deone the address range for which the location is
        valid. These operands are followed by a counted location description.
  9.    DW.LLE.start.length
        This is a form of bounded location description entry (see page 44) that has
        one target address operand value and an unsigned LEB128 integer operand
        value. The address is the beginning address of the range over which the
        location description is valid, and the length is the number of bytes in that
        range. These operands are followed by a counted location description.
10.     DW.LLE.include.loclist
        This is a form of list inclusion, that has one ooeset operand. The value is an
        ooeset into the .debug_loclists section, like the operand of
        DW.FORM.sec.ooeset. The ooeset identioes the orst entry of a location list
        whose entries are to be regarded as part of the current location list, up to the
        DW.LLE.end.of.list entry.
  November 1, 2024                                  ***WORKING DRAFT***                                                             Page 47
                                            Chapter 2.  General Description
2.7          Types  of  Program  Entities
Any debugging information entry describing a declaration that has a type has a
DW.AT.type attribute, whose value is a reference to another debugging
information entry. The entry referenced may describe a base type, that is, a type
that is not deoned in terms of other data types, or it may describe a user-deoned
type, such as an array, structure or enumeration. Alternatively, the entry
referenced may describe a type modioer, such as constant, packed, pointer,
reference or volatile, which in turn will reference another entry describing a type
or type modioer (using a DW.AT.type attribute of its own). See Chapter 5
following for descriptions of the entries describing base types, user-deoned types
and type modioers.
2.8          Accessibility  of  Declarations
Some languages, notably C++ and Ada, have the concept of the accessibility of an object
or of some other program entity. The accessibility specioes which classes of other program
objects are permitted access to the object in question.
The accessibility of a declaration is represented by a DW.AT.accessibility
attribute, whose value is a constant drawn from the set of codes listed in Table
2.4.
                                              Table 2.4: Accessibility codes
                                                 ______________________________________________
                                                  DW.ACCESS.public
                                                  DW.ACCESS.private
                                                  DW.ACCESS.protected
                                                 ______________________________________________
2.9          Visibility  of  Declarations
Several languages (such as Modula-2) have the concept of the visibility of a declaration.
The visibility specioes which declarations are to be visible outside of the entity in which
they are declared.
The visibility of a declaration is represented by a DW.AT.visibility attribute,
whose value is a constant drawn from the set of codes listed in Table 2.5 on the
following page.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 48
                                            Chapter 2.  General Description
                                                 Table 2.5: Visibility codes
                                                     ____________________________________
                                                       DW.VIS.local
                                                       DW.VIS.exported
                                                       DW.VIS.qualioed
                                                     ____________________________________
2.10            Virtuality  of  Declarations
C++ provides for virtual and pure virtual structure or class member functions and for
virtual base classes.
The virtuality of a declaration is represented by a DW.AT.virtuality attribute,
whose value is a constant drawn from the set of codes listed in Table 2.6.
                                                 Table 2.6: Virtuality codes
                                         ____________________________________________________________
                                           DW.VIRTUALITY.none
                                           DW.VIRTUALITY.virtual
                                           DW.VIRTUALITY.pure.virtual
                                         ____________________________________________________________
2.11            Artiocial  Entries
A compiler may wish to generate debugging information entries for objects or types that
were not actually declared in the source of the application. An example is a formal
parameter entry to represent the hidden this parameter that most C++ implementations
pass as the orst argument to non-static member functions.
Any debugging information entry representing the declaration of an object or
type artiocially generated by a compiler and not explicitly declared by the source
program may have a DW.AT.artiocial attribute, which is a AEag.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 49
                                             Chapter 2.  General Description
 2.12            Address  Classes
 Some systems support dioeerent classes of addresses. The address class may aoeect the way
 a pointer is dereferenced or the way a subroutine is called.
 Any debugging information entry representing a pointer or reference type or a
 subroutine or subroutine type may have a DW.AT.address.class attribute,
 whose value is an integer constant. The set of permissible values is specioc to
 each target architecture. The value DW.ADDR.none, however, is common to all
 encodings, and means that no address class has been specioed.
 2.13            Non-Deoning  Declarations  and  Completions
 A debugging information entry representing a program entity typically
 represents the deoning declaration of that entity. In certain contexts, however, a
 debugger might need information about a declaration of an entity that is not also
 a deonition, or is otherwise incomplete, to evaluate an expression correctly.
 As an example, consider the following fragment of C code:
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||vm*
 *oyifdu(n)c
|||=============================================================================================================================================|||{
|||=============================================================================================================================================|||ix*
 *n;t
|||=============================================================================================================================================|||{
|||=============================================================================================================================================|||ef*
 *xltoeartnx;
|||=============================================================================================================================================|||g(*
 *x);
|||=============================================================================================================================================|||}
|||=============================================================================================================================================|||}_*
 *|_____|
 C scoping rules require that the value of the variable x passed to the function g is the
 value of the global float variable x rather than of the local int variable x.
 2.13.1           Non-Deoning Declarations
 A debugging information entry that represents a non-deoning or otherwise
 incomplete declaration of a program entity has a DW.AT.declaration attribute,
 which is a AEag.
 A non-deoning type declaration may nonetheless have children as illustrated in Section
 E.2.3 on page 413.
 November 1, 2024                                  ***WORKING DRAFT***                                                             Page 50
                                            Chapter 2.  General Description
2.13.2           Declarations Completing Non-Deoning Declarations
A debugging information entry that represents a declaration that completes
another (earlier) non-deoning declaration may have a DW.AT.speciocation
attribute whose value is a reference to the debugging information entry
representing the non-deoning declaration. A debugging information entry with a
DW.AT.speciocation attribute does not need to duplicate information provided
by the debugging information entry referenced by that speciocation attribute.
When the non-deoning declaration is contained within a type that has been
placed in a separate type unit (see Section 3.1.4 on page 72), the
DW.AT.speciocation attribute cannot refer directly to the entry in the type unit.
Instead, the current compilation unit may contain a iskeletonj declaration of the
type, which contains only the relevant declaration and its ancestors as necessary
to provide the context (including containing types and namespaces). The
DW.AT.speciocation attribute would then be a reference to the declaration entry
within the skeleton declaration tree. The debugging information entry for the
top-level type in the skeleton tree may contain a DW.AT.signature attribute
whose value is the type signature (see Section 7.32 on page 258).
Not all attributes of the debugging information entry referenced by a
DW.AT.speciocation attribute apply to the referring debugging information
entry. For example, DW.AT.sibling and DW.AT.declaration cannot apply to a
referring entry.
2.14            Declaration  Coordinates
It is sometimes useful in a debugger to be able to associate a declaration with its
occurrence in the program source.
Any debugging information entry representing the declaration of an object,
module, subprogram or type may have DW.AT.decl.ole, DW.AT.decl.line and
DW.AT.decl.column attributes, each of whose value is an unsigned integer
constant.
The value of the DW.AT.decl.ole attribute corresponds to a ole number from
the line number information table for the compilation unit containing the
debugging information entry and represents the source ole in which the
declaration appeared (see Section 6.2 on page 155).
The value of the DW.AT.decl.line attribute represents the source line number at
which the orst character of the identioer of the declared object appears. The
value 0 indicates that no source line has been specioed.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 51
                                            Chapter 2.  General Description
The value of the DW.AT.decl.column attribute represents the source column
number at which the orst character of the identioer of the declared object
appears. The value 0 indicates that no column has been specioed.
2.15            Identioer  Names
Any debugging information entry representing a program entity that has been
given a name may have a DW.AT.name attribute, whose value of class string
represents the name. A debugging information entry containing no name
attribute, or containing a name attribute whose value consists of a name
containing a single null byte, represents a program entity for which no name was
given in the source.
Because the names of program objects described by DWARF are the names as they appear
in the source program, implementations of language translators that use some form of
mangled name (as do many implementations of C++) should use the unmangled form of
the name in the DW.AT.name attribute, including the keyword operator (in names such
as ioperator +j), if present. See also Section 2.22 following regarding the use of
DW.AT.linkage.name for mangled names. Sequences of multiple whitespace characters
may be compressed.
For additional discussion, see the Best Practices section of the DWARF Wiki
(http: // wiki. dwarfstd. org/ index. php? title= Best_ Practices .)
2.16            Data  Locations  and  DWARF  Procedures
Any debugging information entry describing a data object (which includes
variables and parameters) or common blocks may have a DW.AT.location
attribute, whose value is a location description (see Section 2.6 on page 39).
A DWARF procedure is represented by any debugging information entry that
has a DW.AT.location attribute. If a suitable entry is not otherwise available, a
DWARF procedure can be represented using a debugging information entry with
the tag DW.TAG.dwarf.procedure together with a DW.AT.location attribute.
A DWARF procedure is called by a DW.OP.call2, DW.OP.call4 or
DW.OP.call.ref DWARF expression operator (see Section 2.5.1.5 on page 35).
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 52
                                            Chapter 2.  General Description
2.17            Code  Addresses,  Ranges  and  Base  Addresses
Any debugging information entry describing an entity that has a machine code
address or range of machine code addresses, which includes compilation units,
module initialization, subroutines, lexical blocks, try/catch blocks (see Section
3.8 on page 98), labels and the like, may have
     #    A DW.AT.low.pc attribute for a single address,
     #    A DW.AT.low.pc and DW.AT.high.pc pair of attributes for a single
          contiguous range of addresses, or
     #    A DW.AT.ranges attribute for a non-contiguous range of addresses.
If a producer emits no machine code for an entity, none of these attributes are
specioed. Equivalently, a producer may emit such an attribute using the reserved
target address (see Section 2.4.1 on page 26) for the non-existent entity.
The base address of the scope for any of the debugging information entries listed
above is given by either the DW.AT.low.pc attribute or the orst address in the
orst range entry in the list of ranges given by the DW.AT.ranges attribute. If
there is no such attribute, the base address is undeoned.
2.17.1           Single Address
When there is a single address associated with an entity, such as a label or
alternate entry point of a subprogram, the entry has a DW.AT.low.pc attribute
whose value is the address for the entity.
2.17.2           Contiguous Address Range
When the set of addresses of a debugging information entry can be described as
a single contiguous range, the entry may  have a DW.AT.low.pc and
DW.AT.high.pc pair of attributes. The value of the DW.AT.low.pc attribute is
the address of the orst instruction associated with the entity. If the value of the
DW.AT.high.pc is of class address, it is the address of the orst location past the
last instruction associated with the entity; if it is of class constant, the value is an
unsigned integer ooeset which when added to the low PC gives the address of the
orst location past the last instruction associated with the entity.
The high PC value may be beyond the last valid instruction in the executable.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 53
                                            Chapter 2.  General Description
2.17.3           Non-Contiguous Address Ranges
Range lists are used when the set of addresses for a debugging information entry
cannot be described as a single contiguous range. Range lists are contained in a
separate object ole section called .debug_rnglists or .debug_rnglists.dwo (in
split units).
A range list is identioed by a DW.AT.ranges or other attribute whose value is of
class rnglist (see Section 7.5.5 on page 222).
This range list representation, the rnglist class, and the related DW.AT.rnglists.base
attribute are new in DWARF Version 5. Together they eliminate most or all of the object
language relocations previously needed for range lists.
Each range list entry is one of the following kinds:
     #    Bounded range. This kind of entry deones an address range that is
          included in the range list. The starting address is the lowest address of the
          address range. The ending address is the address of the orst location past
          the highest address of the address range.
          There are several kinds of bounded range entries which specify the starting
          and ending addresses in dioeerent ways.
          In the case of a range list entry where the range is deoned by a starting
          address and either an ending address or a length, a starting address
          consisting of the reserved address value (see Section 2.4.1 on page 26)
          indicates a non-existent range, which is equivalent to omitting the
          description.
     #    Base address. This kind of entry provides an address to be used as the base
          address for the beginning and ending address ooesets given in certain
          bounded range entries. The applicable base address of a range list entry is
          determined by the closest preceding base address entry in the same range
          list. If there is no preceding base address entry, then the applicable base
          address defaults to the base address of the compilation unit (see Section
          3.1.1 on page 62).
          In the case of a compilation unit where all of the machine code is contained
          in a single contiguous section, no base address entry is needed.
          If the base address is the reserved target address, either explicitly or by
          default, then the range of any range list entry deoned relative to that base
          address is non-existent, which is equivalent to omitting the range list entry.
     #    End-of-list. This kind of entry marks the end of the range list.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 54
                                            Chapter 2.  General Description
Each range list consists of a sequence of zero or more bounded range or base
address entries, terminated by an end-of-list entry.
A range list containing only an end-of-list entry describes an empty scope (which
contains no instructions).
Bounded range entries in a range list may not overlap. There is no requirement
that the entries be ordered in any particular way.
 A bounded range entry whose beginning and ending addresses are equal (including zero)
indicates an empty range and may be ignored.
Each range list entry begins with a single byte identifying the kind of that entry,
followed by zero or more operands depending on the kind.
In the descriptions that follow, the term address index means the index of an
address in the .debug_addr section. This index is relative to the value of the
DW.AT.addr.base attribute of the associated compilation unit. The address
given by this kind of operand is not relative to the compilation unit base address.
The following entry kinds are deoned for use in both split or non-split units:
1.    DW.RLE.end.of.list
      An end-of-list entry contains no further data.
      A series of this kind of entry may be used for padding or alignment purposes.
2.    DW.RLE.base.addressx
      A base address entry has one unsigned LEB128 operand. The operand value
      is an address index (into the .debug_addr section) that indicates the
      applicable base address used by following DW.RLE.ooeset.pair entries.
3.    DW.RLE.startx.endx
      This is a form of bounded range (see page 54) entry that has two unsigned
      LEB128 operands. The operand values are address indices (into the
      .debug_addr section) that indicate the starting and ending addresses,
      respectively, that deone the address range.
4.    DW.RLE.startx.length
      This is a form of bounded range (see page 54) entry that has two unsigned
      ULEB operands. The orst value is an address index (into the .debug_addr
      section) that indicates the beginning of the address range. The second value is
      the length of the range.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 55
                                            Chapter 2.  General Description
5.    DW.RLE.ooeset.pair
      This is a form of bounded range (see page 54) entry that has two unsigned
      LEB128 operands. The values of these operands are the starting and ending
      ooesets, respectively, relative to the applicable base address, that deone the
      address range.
6.    DW.RLE.include.rnglistx
      This is a form of range inclusion, that has one unsigned LEB128 operand. The
      value is an index into the .debug_rnglists section, interpreted the same way
      as the operand of DW.FORM.rnglistx to ond a target list of entries, which
      will be regarded as part of the current range list, up to the
      DW.RLE.end.of.list entry.
The following kinds of range entry may be used only in non-split units:
6.    DW.RLE.base.address
      A base address entry has one target address operand. This operand is the
      same size as used in DW.FORM.addr. This address is used as the base
      address when interpreting ooesets in subsequent location list entries of kind
      DW.RLE.ooeset.pair.
7.    DW.RLE.start.end
      This is a form of bounded range (see page 54) entry that has two target
      address operands. Each operand is the same size as used in
      DW.FORM.addr. These indicate the starting and ending addresses,
      respectively, that deone the address range for which the following location is
      valid.
8.    DW.RLE.start.length
      This is a form of bounded range (see page 54) entry that has one target
      address operand value and an unsigned LEB128 integer length operand
      value. The address is the beginning address of the range over which the
      location description is valid, and the length is the number of bytes in that
      range.
9.    DW.RLE.include.rnglist
      This is a form of list inclusion, that has one ooeset operand. The value is an
      ooeset into the .debug_rnglists section, like the operand of a
      DW.FORM.sec.ooeset location list. The ooeset identioes the orst entry of a
      location list whose entries are to be regarded as part of the current location
      list, up to the DW.RLE.end.of.list entry.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 56
                                            Chapter 2.  General Description
2.18            Entry  Address
The entry or orst executable instruction generated for an entity, if applicable, is often the
lowest addressed instruction of a contiguous range of instructions. In other cases, the
entry address needs to be specioed explicitly.
Any debugging information entry describing an entity that has a range of code
addresses, which includes compilation units, module initialization, subroutines,
lexical blocks, try/catch blocks, and the like, may have a DW.AT.entry.pc
attribute to indicate the entry address which is the address of the instruction
where execution begins within that range of addresses. If the value of the
DW.AT.entry.pc attribute is of class address that address is the entry address;
or, if it is of class constant, the value is an unsigned integer ooeset which, when
added to the base address of the function, gives the entry address.
If no DW.AT.entry.pc attribute is present, then the entry address is assumed to
be the same as the base address of the containing scope.
2.19            Static  and  Dynamic  Values  of  Attributes
Some attributes that apply to types specify a property (such as the lower bound
of an array) that is an integer value, where the value may be known during
compilation or may be computed dynamically during execution.
The value of these attributes is determined based on the class as follows:
     #    For a constant, the value of the constant is the value of the attribute.
     #    For a reference, the value of the attribute is determined indirectly via a
          reference to another debugging information entry.
               ~   If the referenced entry describes a constant (e.g., has a
                   DW.AT.const.value attribute), the attribute value is the value of that
                   constant.
               ~   If the referenced entry describes a data object (see Section 4.1 on
                   page 101) or common block (see Section 4.2 on page 104), the attribute
                   value is the value of the data object or common block.
               ~   If the referenced entry represents a data member (e.g. has either a
                   DW.AT.data.member.location or a DW.AT.data.bit.ooeset
                   attribute), the attribute value is the value of the data member.
     #    For an exprval, the value is interpreted as a DWARF expression; evaluation
          of the expression yields the value of the attribute.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 57
                                            Chapter 2.  General Description
Prior to DWARF Version 6, a reference to a DWARF procedure (see Section 2.16 on
page 52) that is not a data object or common block was allowed. This type of reference
was removed in DWARF Version 6. Instead, a producer may use a form of class exprval
or locdesc with a DW.OP.call.ref operator to call the DWARF procedure.
2.20            Entity  Descriptions
Some debugging information entries may describe entities in the program that are
artiocial, or which otherwise have a inamej that is not a valid identioer in the
programming language. This attribute provides a means for the producer to indicate the
purpose or usage of the containing debugging infor
Generally, any debugging information entry that has, or may have, a
DW.AT.name attribute, may also have a DW.AT.description attribute whose
value is a null-terminated string providing a description of the entity.
It is expected that a debugger will display these descriptions as part of displaying other
properties of an entity.
2.21            Byte  and  Bit  Sizes
Many debugging information entries allow either a DW.AT.byte.size attribute
or a DW.AT.bit.size attribute, whose integer constant value (see Section 2.19)
specioes an amount of storage. The value of the DW.AT.byte.size attribute is
interpreted in bytes and the value of the DW.AT.bit.size attribute is interpreted
in bits. The DW.AT.string.length.byte.size and DW.AT.string.length.bit.size
attributes are similar.
In addition, the integer constant value of a DW.AT.byte.stride attribute is
interpreted in bytes and the integer constant value of a DW.AT.bit.stride
attribute is interpreted in bits.
2.22            Linkage  Names
Some language implementations, notably C++ and similar languages, make use of
implementation-deoned names within object oles that are dioeerent from the identioer
names (see Section 2.15 on page 52) of entities as they appear in the source. Such names,
sometimes known as mangled names, are used in various ways, such as: to encode
additional information about an entity, to distinguish multiple entities that have the
same name, and so on. When an entity has an associated distinct linkage name it may
sometimes be useful for a producer to include this name in the DWARF description of the
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 58
                                            Chapter 2.  General Description
program to facilitate consumer access to and use of object ole information about an entity
and/or information that is encoded in the linkage name itself.
A debugging information entry may have a DW.AT.linkage.name attribute
whose value is a null-terminated string containing the object ole linkage name
associated with the corresponding entity.
2.23            Template  Parameters
In C++, a template is a generic deonition of a class, function, member function, or
typedef (alias). A template has formal parameters that can be types or constant values;
the class, function, member function, or typedef is instantiated dioeerently for each
distinct combination of type or value actual parameters. DWARF does not represent the
generic template deonition, but does represent each instantiation.
A debugging information entry that represents a template instantiation will
contain child entries describing the actual template parameters. The containing
entry and each of its child entries reference a template parameter entry in any
circumstance where the template deonition referenced a formal template
parameter.
A template type parameter is represented by a debugging information entry with
the tag DW.TAG.template.type.parameter. A template value parameter is
represented by a debugging information entry with the tag
DW.TAG.template.value.parameter. The actual template parameter entries
appear in the same order as the corresponding template formal parameter
declarations in the source program.
A type or value parameter entry may have a DW.AT.name attribute, whose
value is a null-terminated string containing the name of the corresponding
formal parameter. The entry may also have a DW.AT.default.value attribute,
which is a AEag indicating that the value corresponds to the default argument for
the template parameter.
A template type parameter entry has a DW.AT.type attribute describing the
actual type by which the formal is replaced.
A template value parameter entry has a DW.AT.type attribute describing the
type of the parameterized value. The entry also has an attribute giving the actual
compile-time or run-time constant value of the value parameter for this
instantiation. This can be a DW.AT.const.value attribute,  whose value is the
compile-time constant value as represented on the target architecture, or a
DW.AT.location attribute, whose value is a single location description for the
run-time constant address.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 59
                                            Chapter 2.  General Description
2.24            Alignment
A debugging information entry may have a DW.AT.alignment attribute whose
value of class constant is a positive, non-zero, integer describing the alignment of
the entity.
For example, an alignment attribute whose value is 8 indicates that the entity to which it
applies occurs at an address that is a multiple of eight (not a multiple of 28  or 256).
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 60

Chapter  3
Program  Scope  Entries
This section describes debugging information entries that relate to dioeerent
levels of program scope: compilation, module, subprogram, and so on. Except
for separate type entries (see Section 3.1.4 on page 72), these entries may be
thought of as ranges of text addresses within the program.
3.1          Unit  Entries
A DWARF object ole is an object ole that contains one or more DWARF
compilation units, of which there are these kinds:
     #    A full compilation unit describes a complete compilation, possibly in
          combination with related partial compilation units and/or type units.
     #    A partial compilation unit describes a part of a compilation (generally
          corresponding to an imported module) which is imported into one or more
          related full compilation units.
     #    A type unit is a specialized unit (similar to a compilation unit) that
          represents a type whose description may be usefully shared by multiple
          other units.
These orst three kinds of compilation unit are sometimes called iconventionalj
compilation units~they are kinds of compilation units that were deoned prior to DWARF
Version 5. Conventional compilation units are part of the same object ole as the compiled
code and data (whether relocatable, executable, shared and so on). The word
iconventionalj is usually omitted in these names, unless needed to distinguish them
from the similar split compilation units below.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 61
                                          Chapter 3.  Program Scope Entries
     #    A skeleton compilation unit represents the DWARF debugging information
          for a compilation using a minimal description that identioes a separate split
          compilation unit that provides the remainder (and most) of the description.
A skeleton compilation acts as a minimal conventional full compilation (see above) that
identioes and is paired with a corresponding split full compilation (as described below).
Like the conventional compilation units, a skeleton compilation unit is part of the same
object ole as the compiled code and data.
     #    A split compilation unit describes a complete compilation, possibly in
          combination with related type compilation units. It corresponds to a
          specioc skeleton compilation unit.
     #    A split type unit is a specialized compilation unit that represents a type
          whose description may be usefully shared by multiple other units.
Split compilation units and split type units may be contained in object oles separate from
those containing the program code and data. These object oles are not processed by a
linker; thus, split units do not depend on underlying object ole relocations.
Either a full compilation unit or a partial compilation unit may be logically incorporated
into another compilation unit using an imported unit entry (see Section 3.2.5 on
page 78).
A partial compilation unit is not deoned for use within a split object ole.
In the remainder of this document, the word icompilationj in the phrase icompilation
unitj is generally omitted, unless it is deemed needed for clarity or emphasis.
3.1.1          Full and Partial Compilation Unit Entries
A full compilation unit is represented by a debugging information entry with the
tag DW.TAG.compile.unit. A partial compilation unit is represented by a
debugging information entry with the tag DW.TAG.partial.unit.
In a simple compilation, a single compilation unit with the tag
DW.TAG.compile.unit represents a complete object ole and the tag
DW.TAG.partial.unit (as well as tag DW.TAG.type.unit) is not used. In a
compilation employing the DWARF space compression and duplicate
elimination techniques from Appendix E.1 on page 391, multiple compilation
units using the tags DW.TAG.compile.unit, DW.TAG.partial.unit and/or
DW.TAG.type.unit are used to represent portions of an object ole.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 62
                                          Chapter 3.  Program Scope Entries
A full compilation unit typically represents the text and data contributed to an
executable by a single relocatable object ole. It may be derived from several source oles,
including pre-processed header oles. A partial compilation unit typically represents a
part of the text and data of a relocatable object ole, in a manner that can potentially be
shared with the results of other compilations to save space. It may be derived from an
iinclude ole,j template instantiation, or other implementation-dependent portion of a
compilation. A full compilation unit can also function in a manner similar to a partial
compilation unit in some cases. See Appendix E on page 391 for discussion of related
compression techniques.
A full or partial compilation unit entry owns debugging information entries that
represent all or part of the declarations made in the corresponding compilation.
In the case of a partial compilation unit, the containing scope of its owned
declarations is indicated by imported unit entries in one or more other
compilation unit entries that refer to that partial compilation unit (see Section
3.2.5 on page 78).
A full or partial compilation unit entry may have the following attributes:
1.    Either a DW.AT.low.pc and DW.AT.high.pc pair of attributes or a
      DW.AT.ranges attribute whose values encode the contiguous or
      non-contiguous address ranges, respectively, of the machine instructions
      generated for the compilation unit (see Section 2.17 on page 53).
      A DW.AT.low.pc attribute may also be specioed in combination with
      DW.AT.ranges to specify the default base address for use in location lists
      (see Section 2.6.2 on page 44) and range lists (see Section 2.17.3 on page 54).
2.    A DW.AT.name attribute whose value is a null-terminated string containing
      the full or relative path name (relative to the value of the DW.AT.comp.dir
      attribute, see below) of the primary source ole from which the compilation
      unit was derived.
3.    A DW.AT.language.name attribute whose constant value is an integer code
      indicating the source language of the compilation unit. The set of language
      names and their meanings are given in Table 3.1 on the next page.
      The most recent list of approved language names and applicable versions may be
      found at http://dwarfstd.org/languages-v6.html.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 63
                                          Chapter 3.  Program Scope Entries
                                               Table 3.1: Language names
________________________________________________________________________________________________________________________________________________
  Language name                               ||                Meaning                                      ||Version Scheme
                                              |                                                              | (See Table 3.2)
______________________________________________|______________________________________________________________|__________________________________
  DW.LNAME.Ada                          ||                      ISO Ada                                      ||YYYY
  DW.LNAME.Assembly                ||                           Assembly                                     ||
  DW.LNAME.BLISS                       ||                       BLISS                                        ||
  DW.LNAME.C                               ||                   ISO C                                        ||YYYYMM
  DW.LNAME.C.plus.plus            ||                            ISO C++                                      ||YYYYMM
  DW.LNAME.Cobol                       ||                       ISO COBOL                                    ||YYYY
  DW.LNAME.CPP.for.OpenCL  ||                                   C++ for OpenCL                               ||VVMM
  DW.LNAME.Crystal                     ||                       Crystal                                      ||
  DW.LNAME.C.sharp                   ||                         C#                                           ||
  DW.LNAME.D                               ||                   D                                            ||
  DW.LNAME.Dylan                       ||                       Dylan                                        ||
  DW.LNAME.Fortran                     ||                       ISO Fortran                                  ||YYYY
  DW.LNAME.Go                             ||                    Go                                           ||
  DW.LNAME.GLSL                        ||                       OpenGL Shading                               ||VVMMPP
                                       |                        Language                                     |
                                       |                                                                     |
  DW.LNAME.GLSL.ES                 ||                           OpenGL ES Shading                            ||VVMMPP
                                   |                            Language                                     |
                                   |                                                                         |
  DW.LNAME.Haskell                    ||                        Haskell                                      ||
  DW.LNAME.HIP                           ||                     HIP Language                                 ||
  DW.LNAME.HLSL                        ||                       High-Level Shading                           ||YYYY
                                       |                        Language                                     |
                                       |                                                                     |
  DW.LNAME.Hylo                         ||                      Hylo Language                                ||
  DW.LNAME.Java                          ||                     Java                                         ||
  DW.LNAME.Julia                          ||                    Julia                                        ||
  DW.LNAME.Kotlin                       ||                      Kotlin                                       ||
  DW.LNAME.Modula2                  ||                          ISO Modula-2                                 ||
  DW.LNAME.Modula3                  ||                          Modula-3                                     ||
  DW.LNAME.Mojo                         ||                      Mojo Language                                ||
  DW.LNAME.Move                        ||                       Move Language                                ||YYYYMM
__DW.LNAME.ObjC_________________________||______________________Objective_C__________________________________||YYYYMM___________________________
  Continued on next page
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 64
                                          Chapter 3.  Program Scope Entries
__Language_name_______________________________||________________Meaning______________________________________||Version_Scheme___________________
  DW.LNAME.ObjC.plus.plus      ||                               Objective C++                                ||YYYYMM
  DW.LNAME.OCaml                     ||                         OCaml                                        ||
  DW.LNAME.Odin                         ||                      Odin                                         ||YYYYMM
  DW.LNAME.OpenCL.C1              ||                            OpenCL C                                     ||VVMM
  DW.LNAME.OpenCL.CPP         ||                                OpenCL C++                                   ||VVMM
  DW.LNAME.P4                             ||                    P4                                           ||VVMMPP
  DW.LNAME.Pascal                       ||                      ISO Pascal                                   ||YYYY
  DW.LNAME.PLI                            ||                    ANSI PL/I                                    ||
  DW.LNAME.Python                     ||                        Python                                       ||
  DW.LNAME.RenderScript           ||                            RenderScript Kernel                          ||
                                  |                             Language                                     |
                                  |                                                                          |
  DW.LNAME.Ruby                        ||                       Ruby                                         ||VVMMPP
  DW.LNAME.Rust                          ||                     Rust                                         ||
  DW.LNAME.Swift                         ||                     Swift                                        ||VVMM
  DW.LNAME.SYCL                        ||                       SYCL                                         ||YYYYRR
  DW.LNAME.UPC                          ||                      UPC (Unioed Parallel C)                      ||
__DW.LNAME.Zig____________________________||____________________Zig__________________________________________||_________________________________
4.    A DW.AT.language.version attribute may be specioed whose constant
      value is an integer value that indicates the version of the source language.
      This value is encoded using one of several schemes as shown in Table 3.2 on
      the following page. A value of zero is equivalent to omitting this attribute.
5.    A DW.AT.stmt.list attribute whose value is a section ooeset to the line
      number information for this compilation unit.
      This information is placed in a separate object ole section from the debugging
      information entries themselves. The value of the statement list attribute is the
      ooeset in the .debug_line section of the orst byte of the line number
      information for this compilation unit (see Section 6.2 on page 155).
6.    A DW.AT.macros attribute whose value is a section ooeset to the macro
      information for this compilation unit.
      This information is placed in a separate object ole section from the debugging
      information entries themselves. The value of the macro information attribute
_________________________________________________________
      1This is equivalent to DW.LANG.OpenCL in DWARF Version 5
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 65
                                          Chapter 3.  Program Scope Entries
                                       Table 3.2: Version Encoding Schemes
          ___________________________________________________________________________________________________________________________
          __Scheme_________||_______Encoding_________________________________________________________________________________________
            YYYY            ||      Year in which the language deonition was released.
            YYYYMM #  ||            Year in which the language deonition was released
                      |
                      |             times 100 plus the ordinal number of the month
                      |
                      |             (from 1 to 12).
                      |             For example, 202206 represents June of 2022.
                      |
            YYYYRR      ||          Year in which the language deonition was released
                        |
                        |           times 100 plus the revision number.
                        |
                        |           For example, 202007 represents version 2020 revision 7
                        |           while 202011 represents version 2020 revision 11.
                        |
            VVMM         ||         Major version number times 100 plus the minor
                         |
                         |          version number.
                         |
                         |          For example, 306 represents version 3.6 while 312
                         |          represents version 3.12.
                         |
            VVMMPP    ||            Major version number times 10,000 plus the minor
                      |
                      |             version number times 100 plus the patch version
                      |
                      |             number.
                      |
                      |             For example, 30607 represents version 3.6.7 while 31215
                      |             represents version 3.12.15.
          ____________|______________________________________________________________________________________________________________
          #  For the YYYYMM version scheme, to convert a version number to a specioc
          release, it is good practice to treat the version numbers listed on the
          http://dwarfstd.org/languages-v6.html                            website as the maximum version that
          is interpreted as belonging to a specioc release. This way producers can emit
          version numbers for unreleased upcoming speciocations, by using, e.g., the date the
          compiler was built.
      is the ooeset in the .debug_macro section of the orst byte of the macro
      information for this compilation unit (see Section 6.3 on page 172).
7.    A DW.AT.comp.dir attribute whose value is a null-terminated string
      containing the current working directory of the compilation command that
      produced this compilation unit in whatever form makes sense for the host
      system.
      If a relative path is used in DW.AT.comp.dir, it will be relative to the
      location of the linked image containing the DW.AT.comp.dir entry.
      In some cases a producer may allow the user to specify a relative path for
      DW.AT.comp.dir. There are a few cases in which this is useful, but in general using
      a relative path for DW.AT.comp.dir is discouraged as it will not work well in many
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 66
                                          Chapter 3.  Program Scope Entries
      cases including the following: dioeerent relative paths are used within the same build;
      the build system creates multiple linked images in dioeerent directories; the onal linked
      image is moved before being debugged; .o oles that need to be debugged directly.
8.    A DW.AT.producer attribute whose value is a null-terminated string
      containing information about the compiler that produced the compilation
      unit.
      The actual contents of the string will be specioc to each producer, but should begin
      with the name of the compiler producer or some other identifying character sequence
      that will avoid confusion with other producer values.
9.    A DW.AT.identioer.case attribute whose integer constant value is a code
      describing the treatment of identioers within this compilation unit. The set of
      identioer case codes is given in Table 3.3.
                                             Table 3.3: Identioer case codes
                                               ________________________________________________
                                                 DW.ID.case.sensitive
                                                 DW.ID.up.case
                                                 DW.ID.down.case
                                                 DW.ID.case.insensitive
                                               ________________________________________________
      DW.ID.case.sensitive is the default for all compilation units that do not
      have this attribute. It indicates that names given as the values of
      DW.AT.name attributes in debugging information entries for the
      compilation unit reAEect the names as they appear in the source program.
      A debugger should be sensitive to the case of identioer names when doing identioer
      lookups.
      DW.ID.up.case means that the producer of the debugging information for
      this compilation unit converted all source names to upper case. The values of
      the name attributes may not reAEect the names as they appear in the source
      program.
      A debugger should convert all names to upper case when doing lookups.
      DW.ID.down.case means that the producer of the debugging information
      for this compilation unit converted all source names to lower case. The values
      of the name attributes may not reAEect the names as they appear in the source
      program.
      A debugger should convert all names to lower case when doing lookups.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 67
                                            Chapter 3.  Program Scope Entries
        DW.ID.case.insensitive means that the values of the name attributes reAEect
        the names as they appear in the source program but that case is not
        signiocant.
        A debugger should ignore case when doing lookups.
10.     A DW.AT.base.types attribute whose value is a reference. This attribute
        points to a debugging information entry representing another compilation
        unit. It may be used to specify the compilation unit containing the base type
        entries used by entries in the current compilation unit (see Section 5.1 on
        page 106).
        This attribute provides a consumer a way to ond the deonition of base types for a
        compilation unit that does not itself contain such deonitions. This allows a consumer,
        for example, to interpret a type conversion to a base type correctly.
11.     A DW.AT.use.UTF8 attribute,  which is a AEag whose presence indicates that
        all strings (such as the names of declared entities in the source program, or
        olenames in the line number table) are represented using the UTF-8
        representation.
12.     A DW.AT.main.subprogram attribute, which is a AEag, whose presence
        indicates that the compilation unit contains a subprogram that has been
        identioed as the starting subprogram of the program. If more than one
        compilation unit contains this AEag, any one of them may contain the starting
        function.
        Fortran has a PROGRAM statement which is used to specify and provide a
        user-specioed name for the main subroutine of a program. C uses the name imainj to
        identify the main subprogram of a program. Some other languages provide similar or
        other means to identify the main subprogram of a program. The
        DW.AT.main.subprogram attribute may also be used to identify such subprograms
        (see Section 3.3.1 on page 79).
13.     A DW.AT.entry.pc attribute whose value is the address of the orst
        executable instruction of the unit (see Section 2.18 on page 57).
14.     A DW.AT.str.ooesets attribute, whose value is of class strooesetsptr. This
        attribute points to the header of the compilation unit's contribution to the
        .debug_str_offsets (or .debug_str_offsets.dwo) section. Indirect string
        references (using DW.FORM.strx, DW.FORM.strx1, DW.FORM.strx2,
        DW.FORM.strx3 or DW.FORM.strx4) within the compilation unit are
        interpreted as indices into the array of ooesets following that header.
  November 1, 2024                                  ***WORKING DRAFT***                                                             Page 68
                                            Chapter 3.  Program Scope Entries
15.     A DW.AT.addr.base attribute, whose value is of class addrptr. This
        attribute points to the beginning of the compilation unit's contribution to the
        .debug_addr section. Indirect references (using DW.FORM.addrx,
        DW.FORM.addrx1, DW.FORM.addrx2, DW.FORM.addrx3,
        DW.FORM.addrx4, DW.OP.addrx, DW.OP.constx,
        DW.LLE.base.addressx, DW.LLE.startx.endx, DW.LLE.startx.length,
        DW.RLE.base.addressx, DW.RLE.startx.endx or DW.RLE.startx.length)
        within the compilation unit are interpreted as indices relative to this base.
16.     A DW.AT.rnglists.base attribute, whose value is of class rnglistsptr. This
        attribute points to the beginning of the ooesets table (immediately following
        the header) of the compilation unit's contribution to the .debug_rnglists
        section. References to range lists (using DW.FORM.rnglistx) within the
        compilation unit are interpreted relative to this base.
17.     A DW.AT.loclists.base attribute, whose value is of class loclistsptr. This
        attribute points to the beginning of the ooesets table (immediately following
        the header) of the compilation unit's contribution to the .debug_loclists
        section. References to value lists and location lists (using DW.FORM.loclistx)
        within the compilation unit are interpreted relative to this base.
  The base address of a compilation unit is deoned as the value of the
  DW.AT.low.pc attribute, if present; otherwise, it is undeoned. If the base
  address is undeoned, then any DWARF entry or structure deoned in terms of the
  base address of that compilation unit is not valid.
  3.1.2          Skeleton Compilation Unit Entries
  When generating a split DWARF object ole (see Section 7.3.2 on page 195), the
  compilation unit in the .debug_info section is a "skeleton" compilation unit with
  the tag DW.TAG.skeleton.unit, which contains a DW.AT.dwo.name attribute
  as well as a subset of the attributes of a full or partial compilation unit. In
  general, it contains those attributes that are necessary for the consumer to locate
  the object ole where the split full compilation unit can be found, and for the
  consumer to interpret references to addresses in the program.
  A skeleton compilation unit has no children.
  A skeleton compilation unit has the following attributes:
  1.    A DW.AT.dwo.name attribute whose value is a null-terminated string
        containing the full or relative path name (relative to the value of the
        DW.AT.comp.dir attribute, see below) of the object ole that contains the full
        compilation unit.
  November 1, 2024                                  ***WORKING DRAFT***                                                             Page 69
                                          Chapter 3.  Program Scope Entries
      The value in the dwo_id oeld of the unit header for this unit is the same as the
      value in the dwo_id oeld of the unit header of the corresponding full
      compilation unit (see Section 7.5.1 on page 208).
      The means of determining a compilation unit ID does not need to be similar or related
      to the means of determining a type unit signature. However, it should be suitable for
      detecting ole version skew or other kinds of mismatched oles and for looking up a full
      split unit in a DWARF package ole (see Section 7.3.5 on page 198).
A skeleton compilation unit may have additional attributes, which are the same
as for conventional compilation unit entries except as noted, from among the
following:
2.    Either a DW.AT.low.pc and DW.AT.high.pc pair of attributes or a
      DW.AT.ranges attribute.
3.    A DW.AT.stmt.list attribute.
4.    A DW.AT.comp.dir attribute.
5.    A DW.AT.use.UTF8 attribute.
      This attribute applies to strings referred to by the skeleton compilation unit entry
      itself, and strings in the associated line number information. The representation for
      strings in the object ole referenced by the DW.AT.dwo.name attribute is determined
      by the presence of a DW.AT.use.UTF8 attribute in the full compilation unit (see
      Section 3.1.3 on the following page).
6.    A DW.AT.str.ooesets attribute, for indirect strings references from the
      corresponding split full compilation unit.
7.    A DW.AT.addr.base attribute.
8.    A DW.AT.rnglists.base attribute, for range list entry references from the
      corresponding split full compilation unit.
All other attributes of a compilation unit entry (described in Section 3.1.1 on
page 62) are placed in the split full compilation unit (see 3.1.3 on the following
page). The attributes provided by the skeleton compilation unit entry do not
need to be repeated in the full compilation unit entry.
The DW.AT.addr.base, DW.AT.str.ooesets, and DW.AT.rnglists.base attributes
provide context that may be necessary to interpret the contents of the corresponding split
DWARF object ole.
The DW.AT.base.types attribute is not deoned for a skeleton compilation unit.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 70
                                          Chapter 3.  Program Scope Entries
3.1.3          Split Full Compilation Unit Entries
A split full compilation unit is represented by a debugging information entry
with tag DW.TAG.compile.unit. It is very similar to a conventional full
compilation unit but is logically paired with a specioc skeleton compilation unit
while being physically separate.
A split full compilation unit may have the following attributes, which are the
same as for conventional compilation unit entries except as noted:
1.    A DW.AT.name attribute.
2.    A DW.AT.language.name attribute.
3.    A DW.AT.language.version attribute.
4.    A DW.AT.macros attribute.
5.    A DW.AT.producer attribute.
6.    A DW.AT.identioer.case attribute.
7.    A DW.AT.main.subprogram attribute.
8.    A DW.AT.entry.pc attribute.
9.    A DW.AT.use.UTF8 attribute.
The following attributes are not part of a split full compilation unit entry but instead are
inherited (if present) from the corresponding skeleton compilation unit:
DW.AT.addr.base, DW.AT.comp.dir, DW.AT.high.pc, DW.AT.low.pc,
DW.AT.ranges and DW.AT.stmt.list.
The DW.AT.base.types attribute is not deoned for a split full compilation unit.
Use of DW.FORM.sec.ooeset and other equivalent encodings (for example, the abbrev
ooeset in a compilation unit header) are resolved relative to the beginning of the
contribution of the relevant section within the dwo or dwp ole and cannot be used for
sharing content between multiple compilation units. DW.FORM.sec.ooeset may not be
used when a reference to content in the skeleton unit is required (as the value present in
the dwo ole could not be relocated during linking of the skeleton units), such as for the
addrptr class.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 71
                                          Chapter 3.  Program Scope Entries
3.1.4          Type Unit Entries
An object ole may contain any number of separate type unit entries, each
representing a single complete type deonition. Each type unit must be uniquely
identioed by an 8-byte signature, stored as part of the type unit, which can be
used to reference the type deonition from debugging information entries in other
compilation units and type units.
Conventional and split type units are identical except for the sections in which
they are represented (see Section 7.3.2 on page 195 for details).   Moreover, the
DW.AT.str.ooesets attribute (see below) is not used in a split type unit.
A type unit is represented by a debugging information entry with the tag
DW.TAG.type.unit. A type unit entry owns debugging information entries that
represent the deonition of a single type, plus additional debugging information
entries that may be necessary to include as part of the deonition of the type.
A type unit entry may have the following attributes:
1.    A DW.AT.language.name attribute, whose  constant value is an integer
      code indicating the source language used to deone the type. The set of
      language names and their meanings are given in Table 3.1 on page 64.
2.    A DW.AT.language.version attribute, whose constant value is an integer
      code indicating the source language version as described in Table 3.2 on
      page 66.
3.    A DW.AT.stmt.list attribute whose value of class lineptr points to the line
      number information for this type unit.
      Because type units do not describe any code, they do not actually need a line number
      table, but the line number headers contain a list of directories and ole names that may
      be referenced by the DW.AT.decl.ole attribute of the type or part of its description.
      In an object ole with a conventional compilation unit entry, the type unit entries may
      refer to (share) the line number table used by the compilation unit. In a type unit
      located in a split compilation unit, the DW.AT.stmt.list attribute refers to a
      ispecializedj line number table in the .debug_line.dwo section, which contains
      only the list of directories and ole names.
      All type unit entries in a split DWARF object ole may (but are not required to) refer
      to the same specialized line number table.
4.    A DW.AT.use.UTF8 attribute, which is a AEag whose presence indicates that
      all strings referred to by this type unit entry, its children, and its associated
      specialized line number table, are represented using the UTF-8
      representation.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 72
                                          Chapter 3.  Program Scope Entries
5.    A DW.AT.str.ooesets attribute, whose value is of class strooesetsptr. This
      attribute points to the header of the type unit's contribution to the
      .debug_str_offsets section. Indirect string references (using
      DW.FORM.strx, DW.FORM.strx1, DW.FORM.strx2, DW.FORM.strx3 or
      DW.FORM.strx4) within the type unit are interpreted as indices into the
      array of ooesets following that header.
A type unit entry for a given type T owns a debugging information entry that
represents a deoning declaration of type T. If the type is nested within enclosing
types or namespaces, the debugging information entry for T is nested within
debugging information entries describing its containers; otherwise, T is a direct
child of the type unit entry.
A type unit entry may also own additional debugging information entries that
represent declarations of additional types that are referenced by type T and have
not themselves been placed in separate type units. Like T, if an additional type U
is nested within enclosing types or namespaces, the debugging information entry
for U is nested within entries describing its containers; otherwise, U is a direct
child of the type unit entry.
The containing entries for types T and U are declarations, and the outermost
containing entry for any given type T or U is a direct child of the type unit entry.
The containing entries may be shared among the additional types and between T
and the additional types.
Examples of these kinds of relationships are found in Section E.2.1 on page 403 and
Section E.2.3 on page 413.
Types are not required to be placed in type units. In general, only large types such as
structure, class, enumeration, and union types included from header oles should be
considered for separate type units. Base types and other small types are not usually worth
the overhead of placement in separate type units. Types that are unlikely to be replicated,
such as those deoned in the main source ole, are also better left in the main compilation
unit.
3.2          Module,  Namespace  and  Importing  Entries
Modules and namespaces provide a means to collect related entities into a single entity
and to manage the names of those entities.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 73
                                          Chapter 3.  Program Scope Entries
3.2.1          Module Entries
Several languages have the concept of a imodule.j A Modula-2 deonition module may be
represented by a module entry containing a declaration attribute (DW.AT.declaration).
A Fortran 90 module may also be represented by a module entry (but no declaration
attribute is warranted because Fortran has no concept of a corresponding module body).
A module is represented by a debugging information entry with the tag
DW.TAG.module. Module entries may own other debugging information
entries describing program entities whose declaration scopes end at the end of
the module itself.
If the module has a name, the module entry has a DW.AT.name attribute whose
value is a null-terminated string containing the module name.
The module entry may have either a DW.AT.low.pc and DW.AT.high.pc pair
of attributes or a DW.AT.ranges attribute whose values encode the contiguous
or non-contiguous address ranges, respectively, of the machine instructions
generated for the module initialization code (see Section 2.17 on page 53). It may
also have a DW.AT.entry.pc attribute whose value is the address of the orst
executable instruction of that initialization code (see Section 2.18 on page 57).
If the module has been assigned a priority, it may have a DW.AT.priority
attribute. The value of this attribute is a reference to another debugging
information entry describing a variable with a constant value. The value of this
variable is the actual constant value of the module's priority, represented as it
would be on the target architecture.
3.2.2          Namespace Entries
C++ has the notion of a namespace, which provides a way to implement name hiding, so
that names of unrelated things do not accidentally clash in the global namespace when an
application is linked together.
A namespace is represented by a debugging information entry with the tag
DW.TAG.namespace. A namespace extension is represented by a
DW.TAG.namespace entry with a DW.AT.extension attribute referring to the
previous extension, or if there is no previous extension, to the original
DW.TAG.namespace entry. A namespace extension entry does not need to
duplicate information in a previous extension entry of the namespace nor need it
duplicate information in the original namespace entry. (Thus, for a namespace
with a name, a DW.AT.name attribute need only be attached directly to the
original DW.TAG.namespace entry.)
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 74
                                          Chapter 3.  Program Scope Entries
Namespace and namespace extension entries may own other debugging
information entries describing program entities whose declarations occur in the
namespace.
A namespace may have a DW.AT.export.symbols attribute which is a AEag
which indicates that all member names deoned within the namespace may be
referenced as if they were deoned within the containing namespace.
This may be used to describe an inline namespace in C++.
If a type, variable, or function declared in a namespace is deoned outside of the
body of the namespace declaration, that type, variable, or function deonition
entry has a DW.AT.speciocation attribute whose value is a reference to the
debugging information entry representing the declaration of the type, variable or
function. Type, variable, or function entries with a DW.AT.speciocation
attribute do not need to duplicate information provided by the declaration entry
referenced by the speciocation attribute.
The C++ global namespace (the namespace referred to by ::f, for example) is not
explicitly represented in DWARF with a namespace entry (thus mirroring the situation
in C++ source). Global items may be simply declared with no reference to a namespace.
The C++ compilation unit specioc iunnamed namespacej may  be represented by a
namespace entry with no name attribute in the original namespace declaration entry
(and therefore no name attribute in any namespace extension entry of this namespace).
C++ states that declarations in the unnamed namespace are implicitly available in the
containing scope; a producer should make this eoeect explicit with the
DW.AT.export.symbols attribute, or by using a DW.TAG.imported.module that is a
sibling of the namespace entry and references it.
A compiler emitting namespace information may choose to explicitly represent
namespace extensions, or to represent the onal namespace declaration of a compilation
unit; this is a quality-of-implementation issue and no specioc requirements are given
here. If only the onal namespace is represented, it is impossible for a debugger to interpret
using declaration references in exactly the manner deoned by the C++ language.
For C++ namespace examples, see Appendix D.3 on page 334.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 75
                                          Chapter 3.  Program Scope Entries
3.2.3          Imported (or Renamed) Declaration Entries
Some languages support the concept of importing into or making accessible in a given
unit certain declarations that occur in a dioeerent module or scope. An imported
declaration may sometimes be given another name.
An imported declaration is represented by one or more debugging information
entries with the tag DW.TAG.imported.declaration. When an overloaded entity
is imported, there is one imported declaration entry for each overloading. Each
imported declaration entry has a DW.AT.import attribute, whose value is a
reference to the debugging information entry representing the declaration that is
being imported.
An imported declaration may also have a DW.AT.name attribute whose value is
a null-terminated string containing the name by which the imported entity is to
be known in the context of the imported declaration entry (which may be
dioeerent than the name of the entity being imported). If no name is present, then
the name by which the entity is to be known is the same as the name of the entity
being imported.
An imported declaration entry with a name attribute may be used as a general
means to rename or provide an alias for an entity, regardless of the context in
which the importing declaration or the imported entity occurs.
A C++ namespace alias may be represented by an imported declaration entry with a
name attribute whose value is a null-terminated string containing the alias name and a
DW.AT.import attribute whose value is a reference to the applicable original namespace
or namespace extension entry.
A C++ using declaration may be represented by one or more imported declaration entries.
When the using declaration refers to an overloaded function, there is one imported
declaration entry corresponding to each overloading. Each imported declaration entry
has no name attribute but it does have a DW.AT.import attribute that refers to the entry
for the entity being imported. (C++ provides no means to irenamej an imported entity,
other than a namespace).
A Fortran use statement  with an ionly listj may be represented by a series of imported
declaration entries, one (or more) for each entity that is imported. An entity that is
renamed in the importing context may be represented by an imported declaration entry
with a name attribute that specioes the new local name.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 76
                                          Chapter 3.  Program Scope Entries
3.2.4          Imported Module Entries
Some languages support the concept of importing into or making accessible in a given
unit all of the declarations contained within a separate module or namespace.
An imported module declaration is represented by a debugging information
entry with the tag DW.TAG.imported.module. An imported module entry
contains a DW.AT.import attribute whose value is a reference to the module or
namespace entry containing the deonition and/or declaration entries for the
entities that are to be imported into the context of the imported module entry.
An imported module declaration may own a set of imported declaration entries,
each of which refers to an entry in the module whose corresponding entity is to
be known in the context of the imported module declaration by a name other
than its name in that module. Any entity in the module that is not renamed in
this way is known in the context of the imported module entry by the same name
as it is declared in the module.
A C++ using directive  may be represented by an imported module entry, with a
DW.AT.import attribute referring to the namespace entry of the appropriate extension
of the namespace (which might be the original namespace entry) and no owned entries.
A Fortran use statement with a irename listj may be represented by an imported module
entry with an import attribute referring to the module and owned entries corresponding
to those entities that are renamed as part of being imported.
A Fortran use statement with neither a irename listj nor an ionly listj may be
represented by an imported module entry with an import attribute referring to the
module and no owned child entries.
A use statement with an ionly listj is represented by a series of individual imported
declaration entries as described in Section 3.2.3 on the previous page.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 77
                                           Chapter 3.  Program Scope Entries
 A Fortran use statement for an entity in a module that is itself imported by a use
 statement without an explicit mention may be represented by an imported declaration
 entry that refers to the original debugging information entry. For example, given
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||mA*
 *o d u l e
|||=============================================================================================================================================|||iX*
 *n,tYe,gZe r
|||=============================================================================================================================================|||em*
 *nodd u l e
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||mB*
 *o d u l e
|||=============================================================================================================================================|||uA*
 *s e
|||=============================================================================================================================================|||em*
 *nodd u l e
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||mC*
 *o d u l e
|||=============================================================================================================================================|||uB*
 *s,eoQn=l>yX
|||=============================================================================================================================================|||em*
 *nodd_u|l_e___|
 the imported declaration entry for Q within module C refers directly to the variable
 declaration entry for X in module A because there is no explicit representation for X in
 module B.
 A similar situation arises for a C++ using declaration  that imports an entity in terms of
 a namespace alias. See Appendix D.3 on page 334 for an example.
 3.2.5          Imported Unit Entries
 The place where a normal or partial compilation unit is imported is represented
 by a debugging information entry with the tag DW.TAG.imported.unit. An
 imported unit entry contains a DW.AT.import attribute whose value is a
 reference to the normal or partial compilation unit entry whose declarations
 logically belong at the place of the imported unit entry.
 An imported unit entry does not necessarily correspond to any entity or construct in the
 source program. It is merely igluej used to relate a partial unit, or a compilation unit
 used as a partial unit, to a place in some other compilation unit.
 3.3          Subroutine  and  Entry  Point  Entries
 The following tags exist to describe debugging information entries for
 subroutines and entry points:
   DW.TAG.subprogram                                        A subroutine or function
   DW.TAG.inlined.subroutine                                A  particular  inlined  instance  of  a  subroutine  or
                                                            function
   DW.TAG.entry.point                                       An alternate entry point
 November 1, 2024                                  ***WORKING DRAFT***                                                             Page 78
                                          Chapter 3.  Program Scope Entries
3.3.1          General Subroutine and Entry Point Information
The subroutine or entry point entry has a DW.AT.name attribute whose value is
a null-terminated string containing the subroutine or entry point name. It may
also have a DW.AT.linkage.name attribute as described in Section 2.22 on
page 58.
If the name of the subroutine described by an entry with the tag
DW.TAG.subprogram is visible outside of its containing compilation unit, that
entry has a DW.AT.external attribute, which is a AEag.
Additional attributes for functions that are members of a class or structure are described
in Section 5.7.8 on page 124.
A subroutine entry may contain a DW.AT.main.subprogram attribute which is
a AEag whose presence indicates that the subroutine has been identioed as the
starting function of the program. If more than one subprogram contains this AEag,
any one of them may be the starting subroutine of the program.
See also Section 3.1 on page 61) regarding the related use of this attribute to indicate that
a compilation unit contains the main subroutine of a program.
3.3.1.1        Calling Convention Information
A subroutine entry may contain a DW.AT.calling.convention attribute, whose
value is an integer constant. The set of calling convention codes for subroutines
is given in Table 3.4.
                           Table 3.4: Calling convention codes for subroutines
                                                       __________________________________
                                                        DW.CC.normal
                                                        DW.CC.program
                                                        DW.CC.nocall
                                                       __________________________________
If this attribute is not present, or its value is the constant DW.CC.normal, then
the subroutine may be safely called by obeying the istandardj calling
conventions of the target architecture. If the value of the calling convention
attribute is the constant DW.CC.nocall, the subroutine does not obey standard
calling conventions, and it may not be safe for the debugger to call this
subroutine.
Note that DW.CC.normal is also used as a calling convention code for certain types (see
Table 5.5 on page 120).
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 79
                                          Chapter 3.  Program Scope Entries
If the semantics of the language of the compilation unit containing the
subroutine entry distinguishes between ordinary subroutines and subroutines
that can serve as the imain program,j that is, subroutines that cannot be called
directly according to the ordinary calling conventions, then the debugging
information entry for such a subroutine may have a calling convention attribute
whose value is the constant DW.CC.program.
A common debugger feature is to allow the debugger user to call a subroutine within the
subject program. In certain cases, however, the generated code for a subroutine will not
obey the standard calling conventions for the target architecture and will therefore not be
safe to call from within a debugger.
The DW.CC.program value is intended to support Fortran main programs which in
some implementations may not be callable or which must be invoked in a special way. It
is not intended as a way of onding the entry address for the program.
3.3.1.2        Miscellaneous Subprogram Properties
In C there is a dioeerence between the types of functions declared using function prototype
style declarations and those declared using non-prototype declarations.
A subroutine entry declared with a function prototype style declaration may
have a DW.AT.prototyped attribute, which is a AEag. The attribute indicates
whether a subroutine entry point corresponds to a function declaration that
includes parameter prototype information.
A subprogram entry may have a DW.AT.elemental attribute, which is a AEag.
The attribute indicates whether the subroutine or entry point was declared with
the ielementalj keyword or property.
A subprogram entry may have a DW.AT.pure attribute, which is a AEag. The
attribute indicates whether the subroutine was declared with the ipurej
keyword or property.
A subprogram entry may have a DW.AT.recursive attribute, which is a AEag. The
attribute indicates whether the subroutine or entry point was declared with the
irecursivej keyword or property.
A subprogram entry may have a DW.AT.noreturn attribute, which is a AEag. The
attribute indicates whether the subprogram was declared with the inoreturnj
keyword or property indicating that the subprogram can be called, but will never
return to its caller.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 80
                                          Chapter 3.  Program Scope Entries
The Fortran language allows the keywords elemental, pure and recursive to be
included as part of the declaration of a subroutine; these attributes reAEect that usage.
These attributes are not relevant for languages that do not support similar keywords or
syntax. In particular, the DW.AT.recursive attribute is neither needed nor appropriate
in languages such as C where functions support recursion by default.
3.3.1.3        Call Site-Related Attributes
While subprogram attributes in the previous section provide information about the
subprogram and its entry point(s) as a whole, the following attributes provide summary
information about the calls that occur within a subprogram.
A subroutine entry may have DW.AT.call.all.tail.calls, DW.AT.call.all.calls
and/or DW.AT.call.all.source.calls attributes, each of which is a AEag.   These
AEags indicate the completeness of the call site information provided by call site
entries (see Section 3.4.1 on page 94) within the subprogram.
The DW.AT.call.all.tail.calls attribute indicates that every tail call that occurs
in the code for the subprogram is described by a DW.TAG.call.site entry. (There
may or may not be other non-tail calls to some of the same target subprograms.)
The DW.AT.call.all.calls attribute indicates that every non-inlined call (either a
tail call or a normal call) that occurs in the code for the subprogram is described
by a DW.TAG.call.site entry.
The DW.AT.call.all.source.calls attribute indicates that every call that occurs in
the code for the subprogram, including every call inlined into it, is described by
either a DW.TAG.call.site entry or a DW.TAG.inlined.subroutine entry;
further, any call that is optimized out is nonetheless also described using a
DW.TAG.call.site entry that has neither a DW.AT.call.pc nor
DW.AT.call.return.pc attribute.
The DW.AT.call.all.source.calls attribute is intended for debugging information
format consumers that analyze call graphs.
If the the DW.AT.call.all.source.calls attribute is present then the
DW.AT.call.all.calls and DW.AT.call.all.tail.calls attributes are also
implicitly present. Similarly, if the DW.AT.call.all.calls attribute is present then
the DW.AT.call.all.tail.calls attribute is implicitly present.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 81
                                          Chapter 3.  Program Scope Entries
3.3.2          Subroutine and Entry Point Return Types
If the subroutine or entry point is a function that returns a value, then its
debugging information entry has a DW.AT.type attribute to denote the type
returned by that function.
Debugging information entries for C void functions should not have an attribute for the
return type.
Debugging information entries for declarations of C++ member functions with an auto
return type specioer should use an unspecioed type entry (see Section 5.2 on page 112).
The debugging information entry for the corresponding deonition should provide the
deduced return type. This practice causes the description of the containing class to be
consistent across compilation units, allowing the class declaration to be placed into a
separate type unit if desired.
3.3.3          Subroutine and Entry Point Locations
A subroutine entry may have either a DW.AT.low.pc and DW.AT.high.pc
pair of attributes or a DW.AT.ranges attribute whose values encode the
contiguous or non-contiguous address ranges, respectively, of the machine
instructions generated for the subroutine (see Section 2.17 on page 53).
A subroutine entry may also have a DW.AT.entry.pc attribute whose value is
the address of the orst executable instruction of the subroutine (see Section 2.18
on page 57).
An entry point has a DW.AT.low.pc attribute whose value is the relocated
address of the orst machine instruction generated for the entry point.
Subroutines and entry points may also have a DW.AT.address.class attribute, if
appropriate, to specify the addressing mode to be used in calling that subroutine.
A subroutine entry representing a subroutine declaration that is not also a
deonition does not have code address or range attributes.
3.3.4          Declarations Owned by Subroutines and Entry Points
The declarations enclosed by a subroutine or entry point are represented by
debugging information entries that are owned by the subroutine or entry point
entry. Entries representing the formal parameters of the subroutine or entry point
appear in the same order as the corresponding declarations in the source
program.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 82
                                          Chapter 3.  Program Scope Entries
There is no ordering requirement for entries for declarations other than formal
parameters. The formal parameter entries may be interspersed with other entries used by
formal parameter entries, such as type entries.
The unspecioed (sometimes called ivaryingj) parameters of a subroutine
parameter list are represented by a debugging information entry with the tag
DW.TAG.unspecioed.parameters.
The entry for a subroutine that includes a Fortran common block has a child
entry with the tag DW.TAG.common.inclusion. The common inclusion entry
has a DW.AT.common.reference attribute whose value is a reference to the
debugging information entry for the common block being included (see Section
4.2 on page 104).
3.3.5          Low-Level Information
3.3.5.1        Return Address Location
A subroutine or entry point entry may have a DW.AT.return.addr attribute,
whose value is a location description. The location specioed is the place where
the return address for the subroutine or entry point is stored.
3.3.5.2        Frame Base
A subroutine or entry point entry may also have a DW.AT.frame.base attribute,
whose value is a location description that describes the iframe basej for the
subroutine or entry point. If the location description is a simple register location
description, the given register contains the frame base address. If the location
description is a DWARF expression, the result of evaluating that expression is the
frame base address. Finally, for a location list, this interpretation applies to each
location description contained in the list of location list entries.
The use of one of the DW.OP.reg!n? operations in this context is equivalent to using
DW.OP.breg!n?(0) but more compact. However, these are not equivalent in general.
The frame base for a subprogram is typically an address relative to the orst unit of storage
allocated for the subprogram's stack frame. The DW.AT.frame.base attribute can be
used in several ways:
1.    In subprograms that need location lists to locate local variables, the
      DW.AT.frame.base can hold the needed location list, while all variables' location
      descriptions can be simpler ones involving the frame base.
2.    It can be used in resolving iup-levelj addressing within nested routines. (See also
      DW.AT.static.link, below)
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 83
                                          Chapter 3.  Program Scope Entries
3.3.5.3        Nested subroutines and up-level references
Some languages support nested subroutines. In such languages, it is possible to reference
the local variables of an outer subroutine from within an inner subroutine. The
DW.AT.static.link and DW.AT.frame.base attributes allow debuggers to support this
same kind of referencing.
If a subroutine or entry point is nested, it may have a  DW.AT.static.link
attribute, whose value is a location description that computes the frame base of
the relevant instance of the subroutine that immediately encloses the subroutine
or entry point.
In the context of supporting nested subroutines, the DW.AT.frame.base
attribute value obeys the following constraints:
1.    It computes a value that does not change during the life of the subprogram,
      and
2.    The computed value is unique among instances of the same subroutine.
      For typical DW.AT.frame.base use, this means that a recursive subroutine's stack
      frame must have non-zero size.
If a debugger is attempting to resolve an up-level reference to a variable, it uses the
nesting structure of DWARF to determine which subroutine is the lexical parent and the
DW.AT.static.link value to identify the appropriate active frame of the parent. It can
then attempt to ond the reference within the context of the parent.
3.3.5.4        Lanes in SIMD Vectorization
SIMD instructions process multiple data elements in one instruction. The number of
data elements that is processed with one instruction is typically referred to as the SIMD
width. Each individual data element is typically referred to as SIMD lane.
When generating code for a SIMD architecture, compilers may need to implicitly widen
the source code to match the SIMD width of the instruction set they are using. Source
variables are widened into a vector of variables, with one instance per SIMD lane.
A subroutine that is implicitly vectorized may have a DW.AT.num.lanes
attribute whose value describes the implicit vectorization factor and the
corresponding number of lanes in the generated code. The value of this attribute
is determined as described in Section 2.19 on page 57.
To refer to individual lanes in such vectorized code, for example to describe the
location of widened source variables, producers may use the DW.OP.push.lane
operation (see Section 2.5.1.3 on page 29) to have the consumer supply the
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 84
                                          Chapter 3.  Program Scope Entries
current focus lane for which to evaluate the expression. The pushed lane index
must be an unsigned integer value between zero (inclusive) and the value of
DW.AT.num.lanes (exclusive) at the current location.
If the attribute is omitted, its value is deoned by the ABI.
If the source code had already been vectorized and is not further widened by the compiler,
the value should be one.
This value does not only apply to vector instructions. If a loop or function has been
widened, the entire loop or function body shall be annotated with the vectorization factor.
3.3.6          Types Thrown by Exceptions
In C++ a subroutine may declare a set of types which it may validly throw.
If a subroutine explicitly declares that it may throw an exception of one or more
types, each such type is represented by a debugging information entry with the
tag DW.TAG.thrown.type. Each such entry is a child of the entry representing
the subroutine that may throw this type. Each thrown type entry contains a
DW.AT.type attribute, whose value is a reference to an entry describing the type
of the exception that may be thrown.
3.3.7          Function Template Instantiations
In C++, a function template is a generic deonition of a function that is instantiated
dioeerently for calls with values of dioeerent types. DWARF does not represent the generic
template deonition, but does represent each instantiation.
A function template instantiation is represented by a debugging information
entry with the tag DW.TAG.subprogram. With the following exceptions, such
an entry will contain the same attributes and will have the same types of child
entries as would an entry for a subroutine deoned explicitly using the
instantiation types and values. The exceptions are:
1.    Template parameters are described and referenced as specioed in Section 2.23
      on page 59.
2.    If the compiler has generated a separate compilation unit to hold the template
      instantiation and that compilation unit has a dioeerent name from the
      compilation unit containing the template deonition, the name attribute for
      the debugging information entry representing that compilation unit is empty
      or omitted.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 85
                                          Chapter 3.  Program Scope Entries
3.    If the subprogram entry representing the template instantiation or any of its
      child entries contain declaration coordinate attributes, those attributes refer to
      the source for the template deonition, not to any source generated artiocially
      by the compiler for this instantiation.
3.3.8          Inlinable and Inlined Subroutines
A declaration or a deonition of an inlinable subroutine is represented by a
debugging information entry with the tag DW.TAG.subprogram. The entry for
a subroutine that is explicitly declared to be available for inline expansion or that
was expanded inline implicitly by the compiler has a DW.AT.inline attribute
whose value is an integer constant. The set of values for the DW.AT.inline
attribute is given in Table 3.5.
                                                    Table 3.5: Inline codes
  ___________________________________________________________________________________________________________________________________________
  __Name_______________________________________________||_______Meaning______________________________________________________________________
    DW.INL.not.inlined                   ||                     Not declared inline nor inlined by the
                                         |
                                         |                      compiler        (equivalent to the absence of the
                                         |                      containing DW.AT.inline attribute)
                                         |
    DW.INL.inlined                           ||                 Not declared inline but inlined by the
                                             |                  compiler
                                             |
    DW.INL.declared.not.inlined  ||                             Declared inline but not inlined by the
                                 |                              compiler
                                 |
    DW.INL.declared.inlined          ||                         Declared inline and inlined by the
                                     |                          compiler
  ___________________________________|_______________________________________________________________________________________________________
In C++, a function or a constructor declared with constexpr is implicitly declared
inline. The abstract instance (see Section 3.3.8.1) is represented by a debugging
information entry with the tag DW.TAG.subprogram. Such an entry has a
DW.AT.inline attribute whose value is DW.INL.inlined.
3.3.8.1        Abstract Instances
Any subroutine entry that contains a DW.AT.inline attribute whose value is
other than DW.INL.not.inlined is known as an abstract instance root.  Any
debugging information entry that is owned (either directly or indirectly) by an
abstract instance root is known as an abstract instance entry. Any set of abstract
instance entries that are all children (either directly or indirectly) of some abstract
instance root, together with the root itself, is known as an abstract instance tree.
However, in the case where an abstract instance tree is nested within another
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 86
                                          Chapter 3.  Program Scope Entries
abstract instance tree, the entries in the nested abstract instance tree are not
considered to be entries in the outer abstract instance tree.
Each abstract instance root is either part of a larger tree (which gives a context for
the root) or uses DW.AT.speciocation to refer to the declaration in context.
For example, in C++ the context might be a namespace declaration or a class declaration.
Abstract instance trees are deoned so that no entry is part of more than one abstract
instance tree.
Attributes and children in an abstract instance are shared by all concrete
instances (see Section 3.3.8.2).
A debugging information entry that is a member of an abstract instance tree may
not contain any attributes which describe aspects of the subroutine which vary
between distinct inlined expansions or distinct out-of-line expansions.
For example, the DW.AT.low.pc, DW.AT.high.pc, DW.AT.ranges,
DW.AT.entry.pc, DW.AT.location, DW.AT.return.addr and DW.AT.start.scope
attributes typically should be omitted; however, this list is not exhaustive.
It would not make sense normally to put these attributes into abstract instance entries
since such entries do not represent actual (concrete) instances and thus do not actually
exist at run-time. However, see Appendix D.7.3 on page 354 for a contrary example.
The rules for the relative location of entries belonging to abstract instance trees
are exactly the same as for other similar types of entries that are not abstract.
Speciocally, the rule that requires that an entry representing a declaration be a
direct child of the entry representing the scope of the declaration applies equally
to both abstract and non-abstract entries. Also, the ordering rules for formal
parameter entries, member entries, and so on, all apply regardless of whether or
not a given entry is abstract.
3.3.8.2        Concrete Instances
Each inline expansion of a subroutine is represented by a debugging information
entry with the tag DW.TAG.inlined.subroutine. Each such entry is a direct
child of the entry that represents the scope within which the inlining occurs.
Each inlined subroutine entry may have either a DW.AT.low.pc and
DW.AT.high.pc pair of attributes  or a DW.AT.ranges attribute whose values
encode the contiguous or non-contiguous address ranges, respectively, of the
machine instructions generated for the inlined subroutine (see Section 2.17
following). An inlined subroutine entry may also contain a DW.AT.entry.pc
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 87
                                          Chapter 3.  Program Scope Entries
attribute, representing the orst executable instruction of the inline expansion (see
Section 2.18 on page 57).
An inlined subroutine entry may also have DW.AT.call.ole, DW.AT.call.line
and DW.AT.call.column attributes, each of whose value is an integer constant.
These attributes represent the source ole, source line number, and source column
number, respectively, of the orst character of the statement or expression that
caused the inline expansion. The call ole, call line, and call column attributes are
interpreted in the same way as the declaration ole, declaration line, and
declaration column attributes, respectively (see Section 2.14 on page 51).
The call ole, call line and call column coordinates do not describe the coordinates of the
subroutine declaration that was inlined, rather they describe the coordinates of the call.
An inlined subroutine entry may have a DW.AT.const.expr attribute, which is a
AEag whose presence indicates that the subroutine has been evaluated as a
compile-time constant. Such an entry may also have a DW.AT.const.value
attribute, whose value may be of any form that is appropriate for the
representation of the subroutine's return value. The value of this attribute is the
actual return value of the subroutine, represented as it would be on the target
architecture.
In C++, if a function or a constructor declared with constexpr is called with constant
expressions, then the corresponding concrete inlined instance has a DW.AT.const.expr
attribute, as well as a DW.AT.const.value attribute whose value represents the actual
return value of the concrete inlined instance.
Any debugging information entry that is owned (either directly or indirectly) by
a debugging information entry with the tag DW.TAG.inlined.subroutine is
referred to as a iconcrete inlined instance entry.j Any entry that has the tag
DW.TAG.inlined.subroutine is known as a iconcrete inlined instance root.j
Any set of concrete inlined instance entries that are all children (either directly or
indirectly) of some concrete inlined instance root, together with the root itself, is
known as a iconcrete inlined instance tree.j However, in the case where a
concrete inlined instance tree is nested within another concrete instance tree, the
entries in the nested concrete inline instance tree are not considered to be entries
in the outer concrete instance tree.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 88
                                          Chapter 3.  Program Scope Entries
Concrete inlined instance trees are deoned so that no entry is part of more than one
concrete inlined instance tree. This simplioes later descriptions.
Each concrete inlined instance tree is uniquely associated with one (and only
one) abstract instance tree.
Note, however, that the reverse is not true. Any given abstract instance tree may be
associated with several dioeerent concrete inlined instance trees, or may even be associated
with zero concrete inlined instance trees.
Concrete inlined instance entries may omit attributes that are not specioc to the
concrete instance (but present in the abstract instance) and need include only
attributes that are specioc to the concrete instance (but omitted in the abstract
instance). In place of these omitted attributes, each concrete inlined instance
entry has a DW.AT.abstract.origin attribute that may be used to obtain the
missing information (indirectly) from the associated abstract instance entry. The
value of the abstract origin attribute is a reference to the associated abstract
instance entry.
If an entry within a concrete inlined instance tree contains attributes describing
the declaration coordinates of that entry, then those attributes refer to the ole, line
and column of the original declaration of the subroutine, not to the point at
which it was inlined. As a consequence, they may usually be omitted from any
entry that has an abstract origin attribute.
For each pair of entries that are associated via a DW.AT.abstract.origin
attribute, both members of the pair have the same tag. So, for example, an entry
with the tag DW.TAG.variable can only be associated with another entry that
also has the tag DW.TAG.variable. The only exception to this rule is that the
root of a concrete instance tree (which must always have the tag
DW.TAG.inlined.subroutine) can only be associated with the root of its
associated abstract instance tree (which must have the tag
DW.TAG.subprogram).
In general, the structure and content of any given concrete inlined instance tree
will be closely analogous to the structure and content of its associated abstract
instance tree. There are a few exceptions:
1.    An entry in the concrete instance tree may be omitted if it contains only a
      DW.AT.abstract.origin attribute and either has no children, or its children
      are omitted. Such entries would provide no useful information. In C-like
      languages, such entries frequently include types, including structure, union,
      class, and interface types; and members of types. If any entry within a
      concrete inlined instance tree needs to refer to an entity declared within the
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 89
                                          Chapter 3.  Program Scope Entries
      scope of the relevant inlined subroutine and for which no concrete instance
      entry exists, the reference refers to the abstract instance entry.
2.    Entries in the concrete instance tree which are associated with entries in the
      abstract instance tree such that neither has a DW.AT.name attribute, and
      neither is referenced by any other debugging information entry, may be
      omitted. This may happen for debugging information entries in the abstract
      instance trees that became unnecessary in the concrete instance tree because
      of additional information available there. For example, an anonymous
      variable might have been created and described in the abstract instance tree,
      but because of the actual parameters for a particular inlined expansion, it
      could be described as a constant value without the need for that separate
      debugging information entry.
3.    A concrete instance tree may contain entries which do not correspond to
      entries in the abstract instance tree to describe new entities that are specioc to
      a particular inlined expansion. In that case, they will not have associated
      entries in the abstract instance tree, do not contain DW.AT.abstract.origin
      attributes, and must contain all their own attributes directly. This allows an
      abstract instance tree to omit debugging information entries for anonymous
      entities that are unlikely to be needed in most inlined expansions. In any
      expansion which deviates from that expectation, the entries can be described
      in its concrete inlined instance tree.
3.3.8.3        Out-of-Line Instances of Inlined Subroutines
Under some conditions, compilers may need to generate concrete executable
instances of inlined subroutines other than at points where those subroutines are
actually called. Such concrete instances of inlined subroutines are referred to as
iconcrete out-of-line instances.j
In C++, for example, taking the address of a function declared to be inline can necessitate
the generation of a concrete out-of-line instance of the given function.
The DWARF representation of a concrete out-of-line instance of an inlined
subroutine is essentially the same as for a concrete inlined instance of that
subroutine (as described in the preceding section). The representation of such a
concrete out-of-line instance  makes use of DW.AT.abstract.origin attributes in
exactly the same way as they are used for a concrete inlined instance (that is, as
references to corresponding entries within the associated abstract instance tree).
The dioeerences between the DWARF representation of a concrete out-of-line
instance of a given subroutine and the representation of a concrete inlined
instance of that same subroutine are as follows:
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 90
                                          Chapter 3.  Program Scope Entries
1.    The root entry for a concrete out-of-line instance of a given inlined subroutine
      has the same tag as does its associated (abstract) inlined subroutine entry
      (that is, tag DW.TAG.subprogram rather than
      DW.TAG.inlined.subroutine).
2.    The root entry for a concrete out-of-line instance tree is normally owned by
      the same parent entry that also owns the root entry of the associated abstract
      instance. However, it is not required that the abstract and out-of-line instance
      trees be owned by the same parent entry.
3.3.8.4        Nested Inlined Subroutines
Some languages and compilers may permit the logical nesting of a subroutine
within another subroutine, and may permit either the outer or the nested
subroutine, or both, to be inlined.
For a non-inlined subroutine nested within an inlined subroutine, the nested
subroutine is described normally in both the abstract and concrete inlined
instance trees for the outer subroutine. All rules pertaining to the abstract and
concrete instance trees for the outer subroutine apply also to the abstract and
concrete instance entries for the nested subroutine.
For an inlined subroutine nested within another inlined subroutine, the
following rules apply to their abstract and  concrete instance trees:
1.    The abstract instance tree for the nested subroutine is described within the
      abstract instance tree for the outer subroutine according to the rules in
      Section 3.3.8.1 on page 86, and without regard to the fact that it is within an
      outer abstract instance tree.
2.    Any abstract instance tree for a nested subroutine is always omitted within
      the concrete instance tree for an outer subroutine.
3.    A concrete instance tree for a nested subroutine is always omitted within the
      abstract instance tree for an outer subroutine.
4.    The concrete instance tree for any inlined or out-of-line expansion of the
      nested subroutine is described within a concrete instance tree for the outer
      subroutine according to the rules in Sections 3.3.8.2 on page 87 or 3.3.8.3
      following , respectively, and without regard to the fact that it is within an
      outer concrete instance tree.
See Appendix D.7 on page 350 for discussion and examples.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 91
                                          Chapter 3.  Program Scope Entries
3.3.9          Trampolines
A trampoline is a compiler-generated subroutine that serves as an intermediary in
making a call to another subroutine. It may adjust parameters and/or the result (if any)
as appropriate to the combined calling and called execution contexts.
A trampoline is represented by a debugging information entry with the tag
DW.TAG.subprogram or DW.TAG.inlined.subroutine that has a
DW.AT.trampoline attribute. The value of that attribute indicates the target
subroutine of the trampoline, that is, the subroutine to which the trampoline
passes control. (A trampoline entry may but need not also have a
DW.AT.artiocial attribute.)
The value of the trampoline attribute may be represented using any of the
following forms:
     #    If the value is of class reference, then the value specioes the debugging
          information entry of the target subprogram.
     #    If the value is of class address, then the value is the relocated address of the
          target subprogram.
     #    If the value is of class string, then the value is the (possibly mangled) name
          of the target subprogram.
     #    If the value is of class AEag, then the value true indicates that the containing
          subroutine is a trampoline but that the target subroutine is not known.
The target subprogram may itself be a trampoline. (A sequence of trampolines
necessarily ends with a non-trampoline subprogram.)
In C++, trampolines may be used to implement derived virtual member functions; such
trampolines typically adjust the implicit this parameter in the course of passing control.
Other languages and environments may use trampolines in a manner sometimes known
as transfer functions or transfer vectors.
Trampolines may sometimes pass control to the target subprogram using a branch or
jump instruction instead of a call instruction, thereby leaving no trace of their existence
in the subsequent execution context.
This attribute helps make it feasible for a debugger to arrange that stepping into a
trampoline or setting a breakpoint in a trampoline will result in stepping into or setting
the breakpoint in the target subroutine instead. This helps to hide the compiler generated
subprogram from the user.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 92
                                          Chapter 3.  Program Scope Entries
3.4          Call  Site  Entries  and  Parameters
 A call site entry describes a call from one subprogram to another in the source program.
It provides information about the actual parameters of the call so that they may be more
easily accessed by a debugger. When used together with call frame information (see
Section 6.4 on page 179), call site entries can be useful for computing the value of an
actual parameter passed by a caller, even when the location description for the callee's
corresponding formal parameter does not provide a current location for the formal
parameter.
The DWARF expression for computing the value of an actual parameter at a call site may
refer to registers or memory locations. The expression assumes these contain the values
they would have at the point where the call is executed. After the called subprogram has
been entered, these registers and memory locations might have been modioed. In order to
recover the values that existed at the point of the call (to allow evaluation of the DWARF
expression for the actual parameter), a debugger may virtually unwind the subprogram
activation (see Section 6.4 on page 179). Any register or memory location that cannot be
recovered is referred to as "clobbered by the call."
A source call can be compiled into dioeerent types of machine code:
     #    A normal call uses a call-like instruction which transfers control to the start
          of some subprogram and preserves the call site location for use by the
          callee.
     #    A tail call uses a jump-like instruction which transfers control to the start of
          some subprogram, but there is no call site location address to preserve (and
          thus none is available using the virtual unwind information).
     #    A tail recursion call is a call to the current subroutine which is compiled as a
          jump to the current subroutine.
     #    An inline (or inlined) call is a call to an inlined subprogram, where at least
          one instruction has the location of the inlined subprogram or any of its
          blocks or inlined subprograms.
There are also dioeerent types of ioptimized outj calls:
     #    An optimized out (normal) call is a call that is in unreachable code that has
          not been emitted (such as, for example, the call to foo in if  (0)  foo();).
     #    An optimized out inline call is a call to an inlined subprogram which either
          did not expand to any instructions or only parts of instructions belong to it
          and for debug information purposes those instructions are given a location
          in the caller.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 93
                                          Chapter 3.  Program Scope Entries
DW.TAG.call.site entries describe normal and tail calls but not tail recursion
calls, while DW.TAG.inlined.subroutine entries describe inlined calls (see
Section 3.3.8 on page 86). Call site entries cannot fully describe tail recursion or
optimized out calls.
For optimized out calls there is no code address to use for DW.AT.call.return.pc or
DW.AT.call.pc attributes; however, the fact that the souce code makes a call to a certain
function at a specioc source code location and whether some of the arguments have
constant values can be useful for certain consumers.
3.4.1          Call Site Entries
A call site is represented by a debugging information entry with the tag
DW.TAG.call.site. The entry for a call site is owned by the innermost
debugging information entry representing the scope within which the call is
present in the source program.
A scope entry (for example, a lexical block) that would not otherwise be present in the
debugging information of a subroutine need not be introduced solely to represent the
immediately containing scope of a call.
The call site entry may have a DW.AT.call.return.pc attribute which is the
return address after the call. The value of this attribute corresponds to the return
address computed by call frame information in the called subprogram (see
Section 7.24 on page 251).
On many architectures the return address is the address immediately following the call
instruction, but on architectures with delay slots it might be an address after the delay
slot of the call.
The call site entry may have a DW.AT.call.pc attribute which is the address of
the call-like instruction for a normal call or the jump-like instruction for a tail call.
If the call site entry corresponds to a tail call, it has the DW.AT.call.tail.call
attribute, which is a AEag.
The call site entry may have a DW.AT.call.origin attribute which is a reference.
For direct calls or jumps where the called subprogram is known it is a reference
to the called subprogram's debugging information entry. For indirect calls it may
be a reference to a DW.TAG.variable, DW.TAG.formal.parameter or
DW.TAG.member entry representing the subroutine pointer that is called.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 94
                                          Chapter 3.  Program Scope Entries
The call site may have a DW.AT.call.target attribute which is a DWARF
expression. For indirect calls or jumps where it is unknown at compile time
which subprogram will be called the expression computes the address of the
subprogram that will be called.
The DWARF expression should not use register or memory locations that might be
clobbered by the call.
The call site entry may have a DW.AT.call.target.clobbered attribute which is a
DWARF expression. For indirect calls or jumps where the address is not
computable without use of registers or memory locations that might be
clobbered by the call the DW.AT.call.target.clobbered attribute is used instead
of the DW.AT.call.target attribute.
The expression of a call target clobbered attribute may only be valid at the time the call or
call-like transfer of control is executed.
The call site entry may have a DW.AT.type attribute referencing a debugging
information entry for the type of the called function.
When DW.AT.call.origin is present, DW.AT.type is usually omitted.
The call site entry may have DW.AT.call.ole, DW.AT.call.line and
DW.AT.call.column attributes,  each of whose value is an integer constant.
These attributes represent the source ole, source line number, and source column
number, respectively, of the orst character of the call statement or expression.
The call ole, call line, and call column attributes are interpreted in the same way
as the declaration ole, declaration line, and declaration column attributes,
respectively (see Section 2.14 on page 51).
The call ole, call line and call column coordinates do not describe the coordinates of the
subroutine declaration that was called, rather they describe the coordinates of the call.
3.4.2          Call Site Parameters
The call site entry may own DW.TAG.call.site.parameter debugging
information entries representing the parameters passed to the call. Call site
parameter entries occur in the same order as the corresponding parameters in the
source. Each such entry has a DW.AT.location attribute which is a location
description. This location description describes where the parameter is passed
(usually either some register, or a memory location expressible as the contents of
the stack register plus some ooeset).
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 95
                                          Chapter 3.  Program Scope Entries
Each DW.TAG.call.site.parameter entry may have a DW.AT.call.value
attribute which is a DWARF expression which when evaluated yields the value
of the parameter at the time of the call.
If it is not possible to avoid registers or memory locations that might be clobbered by the
call in the expression, then the DW.AT.call.value attribute should not be provided. The
reason for the restriction is that the value of the parameter may be needed in the midst of
the callee, where the call clobbered registers or memory might be already clobbered, and if
the consumer is not assured by the producer it can safely use those values, the consumer
can not safely use the values at all.
For parameters passed by reference, where the code passes a pointer to a location
which contains the parameter, or for reference type parameters, the
DW.TAG.call.site.parameter entry may also have a DW.AT.call.data.location
attribute whose value is a location description and a DW.AT.call.data.value
attribute whose value is a DWARF expression. The DW.AT.call.data.location
attribute describes where the referenced value lives during the call. If it is just
DW.OP.push.object.address, it may be left out. The DW.AT.call.data.value
attribute describes the value in that location. The expression should not use
registers or memory locations that might be clobbered by the call, as it might be
evaluated after virtually unwinding from the called function back to the caller.
Each call site parameter entry may also have a DW.AT.call.parameter attribute
which contains a reference to a DW.TAG.formal.parameter entry, DW.AT.type
attribute referencing the type of the parameter or DW.AT.name attribute
describing the parameter 's name.
Examples using call site entries and related attributes are found in Appendix D.15 on
page 374.
3.5          Lexical  Block  Entries
A lexical block is a bracketed sequence of source statements that may contain any number
of declarations. In some languages (including C and C++), blocks can be nested within
other blocks to any depth.
A lexical block is represented by a debugging information entry with the tag
DW.TAG.lexical.block.
The lexical block entry may have either a DW.AT.low.pc and DW.AT.high.pc
pair of attributes or a DW.AT.ranges attribute whose values encode the
contiguous or non-contiguous address ranges, respectively, of the machine
instructions generated for the lexical block (see Section 2.17 on page 53).
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 96
                                          Chapter 3.  Program Scope Entries
A lexical block entry may also have a DW.AT.entry.pc attribute whose value is
the address of the orst executable instruction of the lexical block (see Section 2.18
on page 57).
If a name has been given to the lexical block in the source program, then the
corresponding lexical block entry has a DW.AT.name attribute whose value is a
null-terminated string containing the name of the lexical block.
This is not the same as a C or C++ label (see Section 3.6).
The lexical block entry owns debugging information entries that describe the
declarations within that lexical block. There is one such debugging information
entry for each local declaration of an identioer or inner lexical block.
3.6          Label  Entries
A label is a way of identifying a source location. A labeled statement is usually the target
of one or more igo toj statements.
A label is represented by a debugging information entry with the tag
DW.TAG.label. The entry for a label is owned by the debugging information
entry representing the scope within which the name of the label could be legally
referenced within the source program.
The label entry has a DW.AT.low.pc attribute whose value is the address of the
orst executable instruction for the location identioed by the label in the source
program. The label entry also has a DW.AT.name attribute whose value is a
null-terminated string containing the name of the label.
3.7          With  Statement  Entries
Both Pascal and Modula-2 support the concept of a iwithj statement. The with
statement specioes a sequence of executable statements within which the oelds of a record
variable may be referenced, unqualioed by the name of the record variable.
A with statement is represented by a debugging information entry with the tag
DW.TAG.with.stmt.
A with statement entry may have either a DW.AT.low.pc and DW.AT.high.pc
pair of attributes  or a DW.AT.ranges attribute whose values encode the
contiguous or non-contiguous address ranges, respectively, of the machine
instructions generated for the with statement (see Section 2.17 on page 53).
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 97
                                          Chapter 3.  Program Scope Entries
A with statement entry may also have a DW.AT.entry.pc attribute whose value
is the address of the orst executable instruction of the with statement (see Section
2.18 on page 57).
The with statement entry has a DW.AT.type attribute, denoting the type of
record whose oelds may be referenced without full qualiocation within the body
of the statement. It also has a DW.AT.location attribute, describing how to ond
the base address of the record object referenced within the body of the with
statement.
3.8          Try  and  Catch  Block  Entries
In C++, a lexical block may be designated as a icatch block.j A catch block is an
exception handler that handles exceptions thrown by an immediately preceding itry
block.j A catch block designates the type of the exception that it can handle.
A try block is represented by a debugging information entry with the tag
DW.TAG.try.block. A catch block is represented by a debugging information
entry with the tag DW.TAG.catch.block.
Both try and catch block entries may have either a DW.AT.low.pc and
DW.AT.high.pc pair of attributes  or a DW.AT.ranges attribute whose values
encode the contiguous or non-contiguous address ranges, respectively, of the
machine instructions generated for the block (see Section 2.17 on page 53).
A try or catch block entry may also have a  DW.AT.entry.pc attribute whose
value is the address of the orst executable instruction of the try or catch block
(see Section 2.18 on page 57).
Catch block entries have at least one child entry, an entry representing the type of
exception accepted by that catch block. This child entry has one of the tags
DW.TAG.formal.parameter or DW.TAG.unspecioed.parameters, and will
have the same form as other parameter entries.
The siblings immediately following a try block entry are its corresponding catch
block entries.
November 1, 2024                                  ***WORKING DRAFT***                                                             Page 98
                                           Chapter 3.  Program Scope Entries
 3.9          Declarations  with  Reduced  Scope
 Any debugging information entry for a declaration (including objects,
 subprograms, types and modules) whose scope has an address range that is a
 subset of the address range for the lexical scope most closely enclosing the
 declared entity may have a DW.AT.start.scope attribute to specify that reduced
 range of addresses.
 There are two cases:
 1.    If the address range for the scope of the entry includes all of addresses for the
       containing scope except for a contiguous sequence of bytes at the beginning
       of the address range for the containing scope, then the address is specioed
       using a value of class constant.
       a)     If the address range of the containing scope is contiguous, the value of
              this attribute is the ooeset in bytes of the beginning of the address range
              for the scope of the object from the low PC value of the debugging
              information entry that deones that containing scope.
       b)     If the address range of the containing scope is non-contiguous (see 2.17.3
              on page 54) the value of this attribute is the ooeset in bytes of the
              beginning of the address range for the scope of the entity from the
              beginning of the orst range list entry for the containing scope that is not a
              base address entry or an end-of-list entry.
 2.    Otherwise, the set of addresses for the scope of the entity is specioed using a
       value of class rnglistsptr. This value indicates the beginning of a range list
       (see Section 2.17.3 on page 54).
 For example, the scope of a variable may begin somewhere in the midst of a lexical block
 in a language that allows executable code in a block before a variable declaration, or where
 one declaration containing initialization code may change the scope of a subsequent
 declaration.
 Consider the following example C code:
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||fx*
 *l=o9a9t. 9 9 ;
|||=============================================================================================================================================|||im*
 *nytf(u)n c
|||=============================================================================================================================================|||{
|||=============================================================================================================================================|||ff*
 *l=oxa;t
|||=============================================================================================================================================|||fx*
 *l=o8a8t. 9 9 ;
|||=============================================================================================================================================|||r0*
 *e;t u r n
|||=============================================================================================================================================|||}_*
 *|_____|
 November 1, 2024                                  ***WORKING DRAFT***                                                             Page 99
                                          Chapter 3.  Program Scope Entries
C scoping rules require that the value of the variable x assigned to the variable f in the
initialization sequence is the value of the global variable x, rather than the local x,
because the scope of the local variable x only starts after the full declarator for the local x.
Due to optimization, the scope of an object may be non-contiguous and require use of a
range list even when the containing scope is contiguous. Conversely, the scope of an
object may not require its own range list even when the containing scope is
non-contiguous.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 100

Chapter  4
Data  Object  and  Object  List  Entries
This section presents the debugging information entries that describe individual
data objects: variables, parameters and constants, and lists of those objects that
may be grouped in a single declaration, such as a common block.
4.1          Data  Object  Entries
Program variables, formal parameters and constants are represented by
debugging information entries with the tags DW.TAG.variable,
DW.TAG.formal.parameter and DW.TAG.constant, respectively.
The tag DW.TAG.constant is used for languages that have true named constants.
The debugging information entry for a program variable, formal parameter or
constant may have the following attributes:
1.    A DW.AT.name attribute, whose value is a null-terminated string
      containing the data object name.
      If a variable entry describes an anonymous object (for example an anonymous
      union), the name attribute is omitted or its value consists of a single zero byte.
2.    A DW.AT.external attribute, which is a AEag, if the name of a variable is
      visible outside of its enclosing compilation unit.
      The deonitions of C++ static data members of structures or classes are represented by
      variable entries AEagged as external. Both ole static and local variables in C and C++
      are represented by non-external variable entries.
3.    A DW.AT.declaration attribute, which is a AEag that indicates whether this
      entry represents a non-deoning declaration of an object.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 101
                                      Chapter 4.  Data Object and Object List
4.    A DW.AT.location attribute, whose value describes the location of a variable
      or parameter at run-time.
      If no location attribute is present in a variable entry representing the
      deonition of a variable (that is, with no DW.AT.declaration attribute), or if
      the location attribute is present but has an empty location description (as
      described in Section 2.6 on page 39), the variable is assumed to exist in the
      source code but not in the executable program (but see number 10, below).
      In a variable entry representing a non-deoning declaration of a variable, the
      location specioed supersedes the location specioed by the deoning
      declaration but only within the scope of the variable entry; if no location is
      specioed, then the location specioed in the deoning declaration applies.
      This can occur, for example, for a C or C++ external variable (one that is deoned and
      allocated in another compilation unit) and whose location varies in the current unit
      due to optimization.
5.    A DW.AT.type attribute describing the type of the variable, constant or
      formal parameter.
6.    If the variable entry represents the deoning declaration for a C++ static data
      member of a structure, class or union, the entry has a DW.AT.speciocation
      attribute, whose value is a reference to the debugging information entry
      representing the declaration of this data member. The referenced entry also
      has the tag DW.TAG.variable and will be a child of some class, structure or
      union type entry.
      If the variable entry represents a non-deoning declaration,
      DW.AT.speciocation may be used to reference the deoning declaration of
      the variable. If no DW.AT.speciocation attribute is present, the deoning
      declaration may be found as a global deonition either in the current
      compilation unit or in another compilation unit with the DW.AT.external
      attribute.
      Variable entries containing the DW.AT.speciocation attribute do not need to
      duplicate information provided by the declaration entry referenced by the
      speciocation attribute. In particular, such variable entries do not need to
      contain attributes for the name or type of the data member whose deonition
      they represent.
7.    A DW.AT.variable.parameter attribute, which is a AEag, if a formal
      parameter entry represents a parameter whose value in the calling function
      may be modioed by the callee. The absence of this attribute implies that the
      parameter 's value in the calling function cannot be modioed by the callee.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 102
                                        Chapter 4.  Data Object and Object List
  8.    A DW.AT.is.optional attribute, which is a AEag, if a parameter entry
        represents an optional parameter.
  9.    A DW.AT.default.value attribute for a formal parameter entry. The value of
        this attribute may be a constant, a reference to the debugging information
        entry for a variable, a reference to a debugging information entry for a
        DWARF procedure, or a string containing a source language fragment.
            #    If the attribute form is of class constant, that constant is interpreted as a
                 value whose type is the same as the type of the formal parameter.
                 For a constant form there is no way to express the absence of a default value.
            #    If the attribute form is of class reference, and the referenced entry is for a
                 variable, the default value of the parameter is the value of the referenced
                 variable. If the reference value is 0, no default value has been specioed.
            #    If the attribute form is of class string, that string is interpreted as an
                 expression in the source language, as deoned by the compilation unit's
                 DW.AT.language.name and DW.AT.language.version attributes, that
                 is to be evaluated according to the rules deoned by that source language.
                 The source language fragment may be dioeerent from the actual source text if the
                 latter contains macros which have been expanded.
10.     A DW.AT.const.value attribute for an entry describing a variable or formal
        parameter whose value is constant and not represented by an object in the
        address space of the program, or an entry describing a named constant. (Note
        that such an entry does not have a location attribute.) The value of this
        attribute may be a string or any of the constant data or data block forms, as
        appropriate for the representation of the variable's value. The value is the
        actual constant value of the variable, represented as it would be on the target
        architecture.
        One way in which a formal parameter with a constant value and no location can arise
        is for a formal parameter of an inlined subprogram that corresponds to a constant
        actual parameter of a call that is inlined.
  November 1, 2024                                  ***WORKING DRAFT***                                                           Page 103
                                        Chapter 4.  Data Object and Object List
11.     A DW.AT.endianity attribute, whose value is a constant that specioes the
        endianity of the object. The value of this attribute specioes an ABI-deoned
        byte ordering for the value of the object. If omitted, the default endianity of
        data for the given type is assumed.
        The set of values and their meaning for this attribute is given in Table 4.1.
        These represent the default encoding formats as deoned by the target
        architecture's ABI or processor deonition. The exact deonition of these
        formats may dioeer in subtle ways for dioeerent architectures.
                                          Table 4.1: Endianity attribute values
           ______________________________________________________________________________________________________________________________
           __Name________________________||_______Meaning________________________________________________________________________________
             DW.END.default  ||                   Default endian encoding (equivalent to the
                             |                    absence       of a DW.AT.endianity attribute)
                             |
             DW.END.big         ||                Big-endian encoding
           __DW.END.little_______||_______________Little-endian_encoding_________________________________________________________________
12.     A DW.AT.const.expr attribute, constant expression attribute which is a AEag,
        if a variable entry represents a C++ object declared with the constexpr
        specioer. This attribute indicates that the variable can be evaluated as a
        compile-time constant.
        In C++, a variable declared with constexpr is implicitly const. Such a variable has
        a DW.AT.type attribute whose value is a reference to a debugging information entry
        describing a const qualioed type.
13.     A DW.AT.linkage.name attribute for a variable or constant entry as
        described in Section 2.22 on page 58.
  4.2          Common  Block  Entries
  A Fortran common block may be described by a debugging information entry
  with the tag DW.TAG.common.block.
  The common block entry has a DW.AT.name attribute whose value is a
  null-terminated string containing the common block name. It may also have a
  DW.AT.linkage.name attribute as described in Section 2.22 on page 58.
  A common block entry also has a DW.AT.location attribute whose value
  describes the location of the beginning of the common block.
  The common block entry owns debugging information entries describing the
  variables contained within the common block.
  November 1, 2024                                  ***WORKING DRAFT***                                                           Page 104
                                      Chapter 4.  Data Object and Object List
Fortran allows each declarer of a common block to independently deone its contents;
thus, common blocks are not types.
4.3          Namelist  Entries
At least one language, Fortran 90, has the concept of a namelist. A namelist is an ordered
list of the names of some set of declared objects. The namelist object itself may be used as
a replacement for the list of names in various contexts.
A namelist is represented by a debugging information entry with the tag
DW.TAG.namelist. If the namelist itself has a name, the namelist entry has a
DW.AT.name attribute, whose value is a null-terminated string containing the
namelist's name.
Each name that is part of the namelist is represented by a debugging information
entry with the tag DW.TAG.namelist.item. Each such entry is a child of the
namelist entry, and all of the namelist item entries for a given namelist are
ordered as were the list of names they correspond to in the source program.
Each namelist item entry contains a DW.AT.namelist.item attribute whose
value is a reference to the debugging information entry representing the
declaration of the item whose name appears in the namelist.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 105

Chapter  5
Type  Entries
This section presents the debugging information entries that describe program
types: base types, modioed types and user-deoned types.
5.1          Base  Type  Entries
A base type is a data type that is not deoned in terms of other data types. Each
programming language has a set of base types that are considered to be built into that
language.
A base type is represented by a debugging information entry with the tag
DW.TAG.base.type.
A base type entry may have a DW.AT.name attribute whose value is a
null-terminated string containing the name of the base type as recognized by the
programming language of the compilation unit containing the base type entry.
A base type entry has a DW.AT.encoding attribute describing how the base type
is encoded and is to be interpreted. The DW.AT.encoding attribute is described
in Section 5.1.1 following.
A base type entry may have a DW.AT.endianity attribute as described in
Section 4.1 on page 101. If omitted, the encoding assumes the representation that
is the default for the target architecture.
A base type entry has a DW.AT.byte.size attribute or a
DW.AT.bit.size attribute whose integer constant value (see Section 2.21 on
page 58) is the amount of storage needed to hold a value of the type.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 106
                                                   Chapter 5.  Type Entries
For example, the C type int on a machine that uses 32-bit integers is represented by a
base type entry with a name attribute whose value is iintj, an encoding attribute whose
value is DW.ATE.signed and a byte size attribute whose value is 4.
If the value of an object of the given type does not fully occupy the storage
described by a byte size attribute, the base type entry may also have a
DW.AT.bit.size and a DW.AT.data.bit.ooeset attribute,  both of whose values
are integer constant values (see Section 2.19 on page 57). The bit size attribute
describes the actual size in bits used to represent values of the given type. The
data bit ooeset attribute is the ooeset in bits from the beginning of the containing
storage to the beginning of the value. Bits that are part of the ooeset are padding.
If this attribute is omitted a default data bit ooeset of zero is assumed.
A DW.TAG.base.type entry may have additional attributes that augment
certain of the base type encodings; these are described in the following section.
5.1.1          Base Type Encodings
A base type entry has a DW.AT.encoding attribute describing how the base type
is encoded and is to be interpreted. The value of this attribute is an integer of
class constant. The set of values and their meanings for the DW.AT.encoding
attribute is given in Table 5.1 on the next page.
In Table 5.1, encodings are shown in groups that have similar characteristics purely for
presentation purposes. These groups are not part of this DWARF speciocation.
5.1.1.1        Simple Encodings
Types with simple encodings are widely supported in many programming
languages and are not discussed further.
For a type with simple encodings, the type entry may have a DW.AT.bias
attribute whose value is an integer constant which is added to the encoded value
to determine the value of an object of the type in the source program. If the
DW.AT.bias is encoded using DW.FORM.data!n?, then the bias value is
treated as an unsigned integer.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 107
                                                   Chapter 5.  Type Entries
                                        Table 5.1: Encoding attribute values
________________________________________________________________________________________________________________________________________________
__Name_______________________________________________||______Meaning____________________________________________________________________________
                     Simple encodings
  DW.ATE.boolean                         ||                  true or false
  DW.ATE.address                         ||                  machine address
  DW.ATE.signed                           ||                 signed binary integer
  DW.ATE.signed.char                 ||                      signed character
  DW.ATE.unsigned                      ||                    unsigned binary integer
  DW.ATE.unsigned.char             ||                        unsigned character
                     Character encodings
  DW.ATE.ASCII                            ||                 ISO/IEC 646:1991 character
  DW.ATE.UCS                               ||                ISO/IEC 10646-1:1993 character (UCS-4)
  DW.ATE.UTF                               ||                ISO/IEC 10646-1:1993 character
                     Bit-precise integer types
  DW.ATE.signed.bitint                ||                     bit-precise signed integer
  DW.ATE.unsigned.bitint           ||                        bit-precise unsigned integer
                     Scaled encodings
  DW.ATE.signed.oxed                ||                       signed oxed-point scaled integer
  DW.ATE.unsigned.oxed            ||                         unsigned oxed-point scaled integer
                     Floating-point encodings
  DW.ATE.AEoat                               ||              binary AEoating-point number
  DW.ATE.complex.AEoat              ||                       complex binary AEoating-point number
  DW.ATE.imaginary.AEoat           ||                        imaginary binary AEoating-point number
  DW.ATE.decimal.AEoat               ||                      IEEE 754R decimal AEoating-point number
                     Decimal string encodings
  DW.ATE.packed.decimal          ||                          packed decimal number
  DW.ATE.numeric.string            ||                        numeric string
  DW.ATE.edited                            ||                edited string
                     Complex integral encodings
  DW.ATE.complex.signed          ||                          complex (signed) binary integral number
  DW.ATE.imaginary.signed       ||                           imaginary (signed) binary integral number
  DW.ATE.complex.unsigned     ||                             complex unsigned binary integral number
__DW.ATE.imaginary.unsigned__||______________________________imaginary_unsigned_binary_integral_number__________________________________________
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 108
                                                   Chapter 5.  Type Entries
5.1.1.2        Character Encodings
DW.ATE.UTF specioes the Unicode string encoding (see the Universal
Character Set standard, ISO/IEC 10646-1:1993).
For example, the C++ type char16.t is represented by a base type entry with a name
attribute whose value is ichar16.tj, an encoding attribute whose value is
DW.ATE.UTF and a byte size attribute whose value is 2.
DW.ATE.ASCII and DW.ATE.UCS specify encodings for the Fortran 2003
string kinds ASCII (ISO/IEC 646:1991) and ISO  10646 (UCS-4 in ISO/IEC
10646:2000).
5.1.2          Bit-precise integer types
Bit-precise integer types DW.ATE.signed.bitint and DW.ATE.unsigned.bitint
are supported in C231 , where they are known as _BitInt(N) and
unsigned  _BitInt(N)                   , respectively.
5.1.2.1        Scaled Encodings
The DW.ATE.signed.oxed and DW.ATE.unsigned.oxed entries describe
signed and unsigned oxed-point binary data types, respectively.
The oxed binary type encodings have a DW.AT.digit.count attribute with the
same interpretation as described for the DW.ATE.packed.decimal and
DW.ATE.numeric.string base type encodings (see Section 5.1.2.3 on the
following page).
For a data type with a decimal scale factor, the oxed binary type entry has a
DW.AT.decimal.scale attribute with the same interpretation as described for
the DW.ATE.packed.decimal and DW.ATE.numeric.string base types (see
Section 5.1.2.3 on the next page).
For a data type with a binary scale factor, the oxed binary type entry has a
DW.AT.binary.scale attribute. The DW.AT.binary.scale attribute is an integer
constant value that represents the exponent of the base two scale factor to be
applied to an instance of the type. Zero scale puts the binary point immediately
to the right of the least signiocant bit. Positive scale moves the binary point to the
right and implies that additional zero bits on the right are not stored in an
instance of the type. Negative scale moves the binary point to the left; if the
absolute value of the scale is larger than the number of bits, this implies
additional zero bits on the left are not stored in an instance of the type.
_________________________________________________________
      1C23 is an informal name for what will likely become ISO/IEC 9899:2024.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 109
                                                   Chapter 5.  Type Entries
For a data type with a rational scale factor, one or both of the following attributes
may be used:
     #    DW.AT.scale.multiplier. This attribute is an integer constant value that
          represents a multiplicative scale factor to be applied to an instance of the
          type.
     #    DW.AT.scale.divisor. This attribute is an integer constant value that
          represents the reciprocal of a multiplicative scale factor to be applied to an
          instance of the type.
If both attributes are present, both are applied, with the result being equivalent to
a rational scale factor x/y, where x is the value of DW.AT.scale.multiplier and y
is the value of DW.AT.scale.divisor.
For a data type with a non-rational scale factor, the oxed binary type entry has a
DW.AT.small attribute which references a DW.TAG.constant entry. The scale
factor value is interpreted in accordance with the value deoned by the
DW.TAG.constant entry. The value represented is the product of the integer
value in memory and the associated constant entry for the type.
The DW.AT.small attribute is deoned with the Ada small attribute in mind.
If a type entry has attributes that describe more than one kind of scale factor, the
resulting scale factor for the type is the product of the individual scale factors.
5.1.2.2        Floating-Point Encodings
Types with binary AEoating-point encodings (DW.ATE.AEoat,
DW.ATE.complex.AEoat and DW.ATE.imaginary.AEoat) are supported in many
programming languages and are not discussed further.
DW.ATE.decimal.AEoat specioes AEoating-point representations that have a
power-of-ten exponent, such as specioed in IEEE 754R.
5.1.2.3        Decimal String Encodings
The DW.ATE.packed.decimal and DW.ATE.numeric.string base type
encodings represent packed and unpacked decimal string numeric data types,
respectively, either of which may be either signed or unsigned. These base types
are used in combination with DW.AT.decimal.sign, DW.AT.digit.count and
DW.AT.decimal.scale attributes.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 110
                                                   Chapter 5.  Type Entries
A DW.AT.decimal.sign attribute is an integer constant that conveys the
representation of the sign of the decimal type (see Table 5.2). Its integer constant
value is interpreted to mean that the type has a leading overpunch, trailing
overpunch, leading separate or trailing separate sign representation or,
alternatively, no sign at all.
                                     Table 5.2: Decimal sign attribute values
________________________________________________________________________________________________________________________________________________
__Name__________________________________________||_______Meaning________________________________________________________________________________
  DW.DS.unsigned                    ||                   Unsigned
  DW.DS.leading.overpunch  ||                            Sign is encoded in the most signiocant digit in a
                           |                             target-dependent manner
                           |
  DW.DS.trailing.overpunch   ||                          Sign is encoded in the least signiocant digit in a
                             |                           target-dependent manner
                             |
  DW.DS.leading.separate       ||                        Decimal type: Sign is a i+j or i-j character to
                               |                         the left of the most signiocant digit.
                               |
  DW.DS.trailing.separate       ||                       Decimal type: Sign is a i+j or i-j character to
                                |                        the right of the least signiocant digit.
                                |
                                                       |
                                                       | Packed decimal type: Least signiocant nibble
                                                       |
                                                       | contains a target-dependent value indicating
                                                       | positive or negative.
_______________________________________________________|________________________________________________________________________________________
The DW.AT.decimal.scale attribute is an integer constant value that represents
the exponent of the base ten scale factor to be applied to an instance of the type.
A scale of zero puts the decimal point immediately to the right of the least
signiocant digit. Positive scale moves the decimal point to the right and implies
that additional zero digits on the right are not stored in an instance of the type.
Negative scale moves the decimal point to the left; if the absolute value of the
scale is larger than the digit count, this implies additional zero digits on the left
are not stored in an instance of the type.
The DW.AT.digit.count attribute is an integer constant value that represents the
number of digits in an instance of the type.
The DW.ATE.edited base type is used to represent an edited numeric or
alphanumeric data type. It is used in combination with a DW.AT.picture.string
attribute whose value is a null-terminated string containing the target-dependent
picture string associated with the type.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 111
                                                   Chapter 5.  Type Entries
If the edited base type entry describes an edited numeric data type, the edited
type entry has a DW.AT.digit.count and a DW.AT.decimal.scale attribute.
These attributes have the same interpretation as described for the
DW.ATE.packed.decimal and DW.ATE.numeric.string base types. If the
edited type entry describes an edited alphanumeric data type, the edited type
entry does not have these attributes.
The presence or absence of the DW.AT.digit.count and DW.AT.decimal.scale
attributes allows a debugger to easily distinguish edited numeric from edited
alphanumeric, although in principle the digit count and scale are derivable by
interpreting the picture string.
5.1.2.4        Complex Integral Encodings
Complex types with binary integral encodings (DW.ATE.complex.signed,
DW.ATE.imaginary.signed, DW.ATE.complex.unsigned and
DW.ATE.imaginary.unsigned) are supported in some programming languages
(for example, GNU C and Rust) and are not discussed further."
5.2          Unspecioed  Type  Entries
Some languages have constructs in which a type may be left unspecioed or the
absence of a type may be explicitly indicated.
An unspecioed (implicit, unknown, ambiguous or nonexistent) type is
represented by a debugging information entry with the tag
DW.TAG.unspecioed.type. If a name has been given to the type, then the
corresponding unspecioed type entry has a DW.AT.name attribute whose value
is a null-terminated string containing the name.
The interpretation of this debugging information entry is intentionally left AEexible to
allow it to be interpreted appropriately in dioeerent languages. For example, in C and
C++ the language implementation can provide an unspecioed type entry with the name
ivoidj which can be referenced by the type attribute of pointer types and typedef
declarations for 'void' (see Sections 5.3 on the next page and 5.4 on page 115,
respectively). As another example, in Ada such an unspecioed type entry can be referred
to by the type attribute of an access type where the denoted type is incomplete (the name
is declared as a type but the deonition is deferred to a separate compilation unit).
C++ permits using the auto return type specioer for the return type of a member
function declaration. The actual return type is deduced based on the deonition of the
function, so it may not be known when the function is declared. The language
implementation can provide an unspecioed type entry with the name auto which can be
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 112
                                                   Chapter 5.  Type Entries
referenced by the return type attribute of a function declaration entry. When the function
is later deoned, the DW.TAG.subprogram entry for the deonition includes a reference to
the actual return type.
5.3          Type  Modioer  Entries
A base or user-deoned type may be modioed in dioeerent ways in dioeerent
languages. A type modioer is represented in DWARF by a debugging
information entry with one of the tags given in Table 5.3.
                                              Table 5.3: Type modioer tags
_____________________________________________________________________________________________________________________________________________________*
 *___
__Name__________________________________________________||_______Meaning_____________________________________________________________________________*
 *___
  DW.TAG.atomic.type                    ||                       atomic qualioed type (for example, in C)
  DW.TAG.const.type                      ||                      const qualioed type (for example in C, C++)
  DW.TAG.immutable.type            ||                            immutable type (for example, in D)
  DW.TAG.packed.type                   ||                        packed type (for example in Ada, Pascal)
  DW.TAG.pointer.type                   ||                       pointer to an object of the type being modioed
  DW.TAG.reference.type               ||                         reference to (lvalue of) an object of the type
                                      |                          being     modioed
                                      |
  DW.TAG.restrict.type                   ||                      restrict qualioed type
  DW.TAG.rvalue.reference.type  ||                               rvalue reference to an object of the type being
                                |                                modioed (for example, in C++)
                                |
  DW.TAG.shared.type                    ||                       shared qualioed type (for example, in UPC)
__DW.TAG.volatile.type__________________||_______________________volatile_qualioed_type_(for_example,_in_C,_C++)_____________________________________*
 *___
If a name has been given to the modioed type in the source program, then the
corresponding modioed type entry has a DW.AT.name attribute whose value is
a null-terminated string containing the name of the modioed type.
Each of the type modioer entries has a DW.AT.type attribute, whose value is a
reference to a debugging information entry describing a base type, a user-deoned
type or another type modioer.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 113
                                                    Chapter 5.  Type Entries
 As examples of how type modioers are ordered, consider the following C declarations:
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||cu*
 *onnssitgcnheadr*vpo;l_a|t_i_l_e|
 This_represents_a_volatile_pointer_to_a_constant_character._It_is_encoded_in_DWARF_as_____________________________________________________________
 |                                                                                                                                                  |
 |              DW_TAG_variable(p)  -->                                                                                                             |
 ||                    DW_TAG_volatile_type  -->                                                                                                    ||
 |                            DW_TAG_pointer_type  -->                                                                                              |
 ||                                  DW_TAG_const_type  -->                                                                                         ||
 ||_________________________________________DW_TAG_base_type(unsigned__char)_______________________________________________________________________ ||
 On the other hand
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||vu*
 *onlsaitginleedc*hcaornrsetspt;r_i|c_t___|
 represents__a__restricted__constant__pointer__to__a__volatile__character._____This__is__encoded__as_______________________________________________||
 ||             DW_TAG_variable(p)  -->                                                                                                             ||
 |                     DW_TAG_restrict_type  -->                                                                                                    |
 ||                           DW_TAG_const_type  -->                                                                                                ||
 |                                   DW_TAG_pointer_type  -->                                                                                       |
 ||                                         DW_TAG_volatile_type  -->                                                                               ||
 ||________________________________________________DW_TAG_base_type(unsigned__char)________________________________________________________________ ||
                                         Figure 5.1: Type modioer examples
 A modioed type entry describing a pointer or reference type (using
 DW.TAG.pointer.type, DW.TAG.reference.type or
 DW.TAG.rvalue.reference.type) may have a DW.AT.address.class attribute to
 describe how objects having the given pointer or reference type are dereferenced.
 A modioed type entry describing a UPC shared qualioed type (using
 DW.TAG.shared.type) may have a DW.AT.count attribute whose value is a
 constant expressing the (explicit or implied) blocksize specioed for the type in the
 source. If no count attribute is present, then the iinonitej blocksize is assumed.
 When multiple type modioers are chained together to modify a base or
 user-deoned type, the tree ordering reAEects the semantics of the applicable
 language rather than the textual order in the source presentation.
 Examples of modioed types are shown in Figure 5.1.
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 114
                                                   Chapter 5.  Type Entries
5.4          Typedef  Entries
A named type that is deoned in terms of another type deonition is represented
by a debugging information entry with the tag DW.TAG.typedef. The typedef
entry has a DW.AT.name attribute whose value is a null-terminated string
containing the name of the typedef.
The typedef entry may also contain a DW.AT.type attribute whose value is a
reference to the type named by the typedef. If the debugging information entry
for a typedef represents a declaration of the type that is not also a deonition, it
does not contain a type attribute.
Depending on the language, a named type that is deoned in terms of another type may be
called a type alias, a subtype, a constrained type and other terms. A type name declared
with no deoning details may be termed an incomplete, forward or hidden type. While the
DWARF DW.TAG.typedef entry was originally inspired by the like named construct in
C and C++, it is broadly suitable for similar constructs (by whatever source syntax) in
other languages.
5.5          Array  Type  Entries
Many languages share the concept of an iarray,j which is a table of components of
identical type. Furthermore, many architectures contain vector types which mirror the
language concept of a short single dimension array but have dioeerent encoding, a
dioeerent calling convention and dioeerent arithmetic and logical operational semantics
than the source language arrays. Likewise, a few architectures are starting to add matrix
register types with similar variations in encoding and semantics from normal source
language array types.
An array type is represented by a debugging information entry with the tag
DW.TAG.array.type. If a name has been given to the array type in the source
program, then the corresponding array type entry has a DW.AT.name attribute
whose value is a null-terminated string containing the array type name.
The array type may have a DW.AT.tensor attribute, which is a AEag. If present,
this attribute indicates that the entry describes a vector or matrix type. The array
dimensions (see below) describe the vector width, and when applicable the
number of rows.
The array type entry describing a multidimensional array may have a
DW.AT.ordering attribute whose integer constant value is interpreted to mean
either row-major or column-major ordering of array elements. The set of values
and their meanings for the ordering attribute are listed in Table 5.4 following. If
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 115
                                                   Chapter 5.  Type Entries
no ordering attribute is present, the default ordering for the source language
(which is indicated by the DW.AT.language.name attribute of the enclosing
compilation unit entry) is assumed.
                                                 Table 5.4: Array ordering
                                                  ____________________________________________
                                                   DW.ORD.col.major
                                                   DW.ORD.row.major
                                                  ____________________________________________
An array type entry has a DW.AT.type attribute describing the type of each
element of the array. If DW.AT.tensor is present, the element type must be a
base type (see Section 5.1 on page 106).
If the amount of storage allocated to hold each element of an object of the given
array type is dioeerent from the amount of storage that is normally allocated to
hold an individual object of the indicated element type, then the array type entry
has either a DW.AT.byte.stride or a DW.AT.bit.stride attribute, whose value
(see Section 2.19 on page 57) is the size of each element of the array.
The array type entry may have either a DW.AT.byte.size or a DW.AT.bit.size
attribute (see Section 2.21 on page 58), whose value is the amount of storage
needed to hold an instance of the array type.
If the size of the array can be determined statically at compile time, this value can usually
be computed by multiplying the number of array elements by the size of each element.
Each array dimension is described by a debugging information entry with either
the tag DW.TAG.subrange.type or the tag DW.TAG.enumeration.type. These
entries are children of the array type entry and are ordered to reAEect the
appearance of the dimensions in the source program (that is, leftmost dimension
orst, next to leftmost second, and so on).
In languages that have no concept of a imultidimensional arrayj (for example, C), an
array of arrays may be represented by a debugging information entry for a
multidimensional array.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 116
                                                   Chapter 5.  Type Entries
Alternatively, for an array with dynamic rank the array dimensions are described
by a debugging information entry with the tag DW.TAG.generic.subrange.
This entry has the same attributes as a DW.TAG.subrange.type entry; however,
there is just one DW.TAG.generic.subrange entry and it describes all of the
dimensions of the array. If DW.TAG.generic.subrange is used, the number of
dimensions must be specioed using a DW.AT.rank attribute. See also Section
5.18.3 on page 139.
Other attributes especially applicable to arrays are DW.AT.allocated,
DW.AT.associated and DW.AT.data.location, which are described in Section
5.18 on page 137. For relevant examples, see also Appendix D.2.1 on page 307.
5.6          Coarray  Type  Entries
In Fortran, a icoarrayj is an array whose elements are located in dioeerent processes
rather than in the memory of one process. The individual elements of a coarray can be
scalars or arrays. Similar to arrays, coarrays have icodimensionsj that are indexed using
a icoindexj or multiple icoindicesj.
A coarray type is represented by a debugging information entry with the tag
DW.TAG.coarray.type. If a name has been given to the coarray type in the
source, then the corresponding coarray type entry has a DW.AT.name attribute
whose value is a null-terminated string containing the array type name.
A coarray entry has one or more DW.TAG.subrange.type child entries, one for
each codimension. It also has a DW.AT.type attribute describing the type of
each element of the coarray.
In a coarray application, the run-time number of processes in the application is part of the
coindex calculation. It is represented in the Fortran source by a coindex which is declared
with a i*j as the upper bound. To express this concept in DWARF, the
DW.TAG.subrange.type child entry for that index has only a lower bound and no
upper bound.
How coarray elements are located and how coindices are converted to process
speciocations is implementation-deoned.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 117
                                                   Chapter 5.  Type Entries
5.7          Structure,  Union,  Class  and  Interface  Type
             Entries
The languages C, C++, and Pascal, among others, allow the programmer to deone types
that are collections of related components. In C and C++, these collections are called
istructures.j In Pascal, they are called irecords.j The components may be of dioeerent
types. The components are called imembersj in C and C++, and ioeldsj in Pascal.
The components of these collections each exist in their own space in computer memory.
The components of a C or C++ iunionj all coexist in the same memory.
Pascal and other languages have a idiscriminated union,j also called a ivariant record.j
Here, selection of a number of alternative substructures (ivariantsj) is based on the
value of a component that is not part of any of those substructures (the idiscriminantj).
C++ and Java have the notion of iclass,j which is in some ways similar to a structure. A
class may have imember functionsj which are subroutines that are within the scope of a
class or structure.
The C++ notion of structure is more general than in C, being equivalent to a class with
minor dioeerences. Accordingly, in the following discussion, statements about C++
classes may be understood to apply to C++ structures as well.
5.7.1          Structure, Union and Class Type Entries
Structure, union, and class types are represented by debugging information
entries with the tags DW.TAG.structure.type, DW.TAG.union.type, and
DW.TAG.class.type, respectively. If a name has been given to the structure,
union, or class in the source program, then the corresponding structure type,
union type, or class type entry has a DW.AT.name attribute whose value is a
null-terminated string containing the type name.
The members of a structure, union, or class are represented by debugging
information entries that are owned by the corresponding structure type, union
type, or class type entry and appear in the same order as the corresponding
declarations in the source program.
A structure, union, or class type may have a DW.AT.export.symbols attribute
which indicates that all member names deoned within the structure, union, or
class may be referenced as if they were deoned within the containing structure,
union, or class.
This may be used to describe anonymous structures, unions and classes in C or C++.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 118
                                                   Chapter 5.  Type Entries
A structure type, union type or class type entry may have either a
DW.AT.byte.size or a DW.AT.bit.size attribute (see Section 2.21 on page 58),
whose value is the amount of storage needed to hold an instance of the structure,
union or class type, including any padding.
An incomplete structure, union or class type  is represented by a structure, union
or class entry that does not have a byte size attribute and that has a
DW.AT.declaration attribute.
If the complete declaration of a type has been placed in a separate type unit (see
Section 3.1.4 on page 72), an incomplete declaration of that type in the
compilation unit may provide the unique 8-byte signature of the type using a
DW.AT.signature attribute.
If a structure, union or class entry represents the deonition of a structure, union
or class member corresponding to a prior incomplete structure, union or class,
the entry may have a DW.AT.speciocation attribute whose value is a reference
to the debugging information entry representing that incomplete declaration.
Structure, union and class entries containing the DW.AT.speciocation attribute
do not need to duplicate information provided by the declaration entry
referenced by the speciocation attribute. In particular, such entries do not need to
contain an attribute for the name of the structure, union or class they represent if
such information is already provided in the declaration.
For C and C++, data member declarations occurring within the declaration of a
structure, union or class type are considered to be ideonitionsj of those members, with
the exception of istaticj data members, whose deonitions appear outside of the
declaration of the enclosing structure, union or class type. Function member declarations
appearing within a structure, union or class type declaration are deonitions only if the
body of the function also appears within the type declaration.
If the deonition for a given member of the structure, union or class does not
appear within the body of the declaration, that member also has a debugging
information entry describing its deonition. That latter entry has a
DW.AT.speciocation attribute referencing the debugging information entry
owned by the body of the structure, union or class entry and representing a
non-deoning declaration of the data, function or type member. The referenced
entry will not have information about the location of that member (low and high
PC attributes for function members, location descriptions for data members) and
will have a DW.AT.declaration attribute.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 119
                                                    Chapter 5.  Type Entries
 Consider a nested class whose deonition occurs outside of the containing class deonition,
 as in:
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||sA*
 *t{r u c t
|||=============================================================================================================================================|||sB*
 *t;r u c t
|||=============================================================================================================================================|||};
|||=============================================================================================================================================|||sA*
 *t:r:uBc{t.}.;._|_____|
 The two dioeerent structs can be described in dioeerent compilation units to facilitate
 DWARF space compression (see Appendix E.1 on page 391).
 A structure type, union type or class type entry may have a
 DW.AT.calling.convention attribute, whose value indicates whether a value of
 the type is passed by reference or passed by value. The set of calling convention
 codes for use with types is given in Table 5.5 following.
                                 Table 5.5: Calling convention codes for types
                                              _____________________________________________________
                                                DW.CC.normal
                                                DW.CC.pass.by.value
                                                DW.CC.pass.by.reference
                                              _____________________________________________________
 If this attribute is not present, or its value is DW.CC.normal, the convention to
 be used for an object of the given type is assumed to be unspecioed.
 Note that DW.CC.normal is also used as a calling convention code for certain
 subprograms (see Table 3.4 on page 79).
 If unspecioed, a consumer may be able to deduce the calling convention based on
 knowledge of the type and the ABI.
 5.7.2          Interface Type Entries
 The Java language deones iinterfacej types. An interface in Java is similar to a C++ or
 Java class with only abstract methods and constant data members.
 Interface types are represented by debugging information entries with the tag
 DW.TAG.interface.type.
 An interface type entry has a DW.AT.name attribute, whose value is a
 null-terminated string containing the type name.
 The members of an interface are represented by debugging information entries
 that are owned by the interface type entry and that appear in the same order as
 the corresponding declarations in the source program.
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 120
                                                   Chapter 5.  Type Entries
5.7.3          Derived or Extended Structures, Classes and Interfaces
In C++, a class (or struct) may be iderived fromj or be a isubclass ofj another class. In
Java, an interface may iextendj one or more other interfaces, and a class may iextendj
another class and/or iimplementj one or more interfaces. All of these relationships may
be described using the following. Note that in Java, the distinction between extends and
implements is implied by the entities at the two ends of the relationship.
A class type or interface type entry that describes a derived, extended or
implementing class or interface owns debugging information entries describing
each of the classes or interfaces it is derived from, extending or implementing,
respectively, ordered as they were in the source program. Each such entry has the
tag DW.TAG.inheritance.
An inheritance entry has a DW.AT.type attribute whose value is a reference to
the debugging information entry describing the class or interface from which the
parent class or structure of the inheritance entry is derived, extended or
implementing.
An inheritance entry for a class that derives from or extends another class or
struct also has a DW.AT.data.member.location attribute, whose value describes
the location of the beginning of the inherited type relative to the beginning
address of the instance of the derived class. If that value is a constant, it is the
ooeset in bytes from the beginning of the class to the beginning of the instance of
the inherited type. Otherwise, the value must be a location description. In this
latter case, the beginning address of the instance of the derived class is pushed
on the expression stack before the location description is evaluated and the result
of the evaluation is the location of the instance of the inherited type.
The interpretation of the value of this attribute for inherited types is the same as the
interpretation for data members (see Section 5.7.6 following).
An inheritance entry may have a DW.AT.accessibility attribute. If no
accessibility attribute is present, private access is assumed for an entry of a class
and public access is assumed for an entry of a struct, union or interface.
If the class referenced by the inheritance entry serves as a C++ virtual base class,
the inheritance entry has a DW.AT.virtuality attribute.
For a C++ virtual base, the data member location attribute will usually consist of a
non-trivial location description.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 121
                                                   Chapter 5.  Type Entries
5.7.4          Access Declarations
In C++, a derived class may contain access declarations that change the accessibility of
individual class members from the overall accessibility specioed by the inheritance
declaration. A single access declaration may refer to a set of overloaded names.
If a derived class or structure contains access declarations, each such declaration
may be represented by a debugging information entry with the tag
DW.TAG.access.declaration. Each such entry is a child of the class or structure
type entry.
An access declaration entry has a DW.AT.name attribute, whose value is a
null-terminated string representing the name used in the declaration, including
any class or structure qualioers.
An access declaration entry also has a DW.AT.accessibility attribute describing
the declared accessibility of the named entities.
5.7.5          Friends
Each friend declared by a structure, union or class type may be represented by a
debugging information entry that is a child of the structure, union or class type
entry; the friend entry has the tag DW.TAG.friend.
A friend entry has a DW.AT.friend attribute, whose value is a reference to the
debugging information entry describing the declaration of the friend.
5.7.6          Data Member Entries
A data member (as opposed to a member function) is represented by a
debugging information entry with the tag DW.TAG.member. The member
entry for a named member has a DW.AT.name attribute whose value is a
null-terminated string containing the member name. If the member entry
describes an anonymous union, the name attribute is omitted or the value of the
attribute consists of a single zero byte.
The data member entry has a DW.AT.type attribute to denote the type of that
member.
A data member entry may have a DW.AT.accessibility attribute. If no
accessibility attribute is present, private access is assumed for an member of a
class and public access is assumed for an member of a structure, union, or
interface.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 122
                                                   Chapter 5.  Type Entries
A data member entry may have a DW.AT.mutable attribute, which is a AEag.
This attribute indicates whether the data member was declared with the mutable
storage class specioer.
The beginning of a data member is described relative to the beginning of the
object in which it is immediately contained. In general, the beginning is
characterized by both an address and a bit ooeset within the byte at that address.
When the storage for an entity includes all of the bits in the beginning byte, the
beginning bit ooeset is deoned to be zero.
The member entry corresponding to a data member that is deoned in a structure,
union or class may have either a DW.AT.data.member.location attribute or a
DW.AT.data.bit.ooeset attribute. If the beginning of the data member is the
same as the beginning of the containing entity then neither attribute is required.
For a DW.AT.data.member.location attribute there are two cases:
1.    If the value is an integer constant, it is the ooeset in bytes from the beginning
      of the containing entity. If the beginning of the containing entity has a
      non-zero bit ooeset then the beginning of the member entry has that same bit
      ooeset as well.
2.    Otherwise, the value must be a location description. In this case, the
      beginning of the containing entity must be byte aligned. The beginning
      address is pushed on the DWARF stack before the location description is
      evaluated; the result of the evaluation is the base address of the member
      entry.
      The push on the DWARF expression stack of the base address of the containing
      construct is equivalent to execution of the DW.OP.push.object.address operation
      (see Section 2.5.1.3 on page 29); DW.OP.push.object.address therefore is not
      needed at the beginning of a location description for a data member. The result of the
      evaluation is a location~either an address or the name of a register, not an ooeset to
      the member.
      A DW.AT.data.member.location attribute that has the form of a location
      description is not valid for a data member contained in an entity that is not byte
      aligned because DWARF operations do not allow for manipulating or computing bit
      ooesets.
For a DW.AT.data.bit.ooeset attribute, the value is an integer constant (see
Section 2.19 on page 57) that specioes the number of bits from the beginning of
the containing entity to the beginning of the data member. This value must be
greater than or equal to zero, but is not limited to less than the number of bits per
byte.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 123
                                                   Chapter 5.  Type Entries
If the size of a data member is not the same as the size of the type given for the
data member, the data member has either a DW.AT.byte.size or a
DW.AT.bit.size attribute whose integer constant value (see Section 2.19 on
page 57) is the amount of storage needed to hold the value of the data member.
For showing nested and packed records and arrays, see Appendix D.2.7 on page 324 and
D.2.8 on page 326.
5.7.7          Class Variable Entries
A class variable (istatic data memberj in C++) is a variable shared by all
instances of a class. It is represented by a debugging information entry with the
tag DW.TAG.variable.
The class variable entry may contain the same attributes and follows the same
rules as non-member global variable entries (see Section 4.1 on page 101).
A class variable entry may have a DW.AT.accessibility attribute. If no
accessibility attribute is present, private access is assumed for an entry of a class
and public access is assumed for an entry of a structure, union or interface.
5.7.8          Member Function Entries
A member function is represented by a debugging information entry with the tag
DW.TAG.subprogram. The member function entry may contain the same
attributes and follows the same rules as non-member global subroutine entries
(see Section 3.3 on page 78).
In particular, if the member function entry is an instantiation of a member function
template, it follows the same rules as function template instantiations (see Section 3.3.7
on page 85).
A member function entry may have a DW.AT.accessibility attribute. If no
accessibility attribute is present, private access is assumed for an entry of a class
and public access is assumed for an entry of a structure, union or interface.
If the member function entry describes a virtual function, then that entry has a
DW.AT.virtuality attribute.
If the member function entry describes an explicit member function, then that
entry has a DW.AT.explicit attribute.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 124
                                                   Chapter 5.  Type Entries
An entry for a virtual function also has a DW.AT.vtable.elem.location attribute
whose value contains a location description yielding the address of the slot for
the function within the virtual function table for the enclosing class. The address
of an object of the enclosing type is pushed onto the expression stack before the
location description is evaluated.
If the member function entry describes a non-static member function, then that
entry has a DW.AT.object.pointer attribute whose value is a reference to the
formal parameter entry that corresponds to the object for which the function is
called. The name attribute of that formal parameter is deoned by the current
language (for example, this for C++ or self for Objective C and some other
languages). That parameter also has a DW.AT.artiocial attribute whose value is
true.
Conversely, if the member function entry describes a static member function, the
entry does not have a DW.AT.object.pointer attribute.
In C++, non-static member functions can have const-volatile qualioers, which aoeect the
type of the orst formal parameter (the ithisj-pointer).
If the member function entry describes a non-static member function that has a
const-volatile qualiocation, then the entry describes a non-static member
function whose object formal parameter has a type that has an equivalent
const-volatile qualiocation.
Beginning in C++11, non-static member functions can also have one of the ref-qualioers,
& and &&. These do not change the type of the ithisj-pointer, but they do aoeect the
types of object values on which the function can be invoked.
The member function entry may have an DW.AT.reference attribute to indicate
a non-static member function that can only be called on lvalue objects, or the
DW.AT.rvalue.reference attribute to indicate that it can only be called on
prvalues and xvalues.
The lvalue, prvalue and xvalue concepts are deoned in the C++11 and later standards.
If a subroutine entry represents the deoning declaration of a member function
and that deonition appears outside of the body of the enclosing class declaration,
the subroutine entry has a DW.AT.speciocation attribute, whose value is a
reference to the debugging information entry representing the declaration of this
function member. The referenced entry will be a child of some class (or structure)
type entry.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 125
                                                   Chapter 5.  Type Entries
Subroutine entries containing the DW.AT.speciocation attribute do not need to
duplicate information provided by the declaration entry referenced by the
speciocation attribute. In particular, such entries do not need to contain a name
attribute giving the name of the function member whose deonition they
represent. Similarly, such entries do not need to contain a return type attribute,
unless the return type on the declaration was unspecioed (for example, the
declaration used the C++ auto return type specioer).
In C++, a member function may be declared as deleted. This prevents the compiler from
generating a default implementation of a special member function such as a constructor
or destructor, and can aoeect overload resolution when used on other member functions.
If the member function entry has been declared as deleted, then that entry has a
DW.AT.deleted attribute.
In C++, a special member function may be declared as defaulted, which explicitly declares
a default compiler-generated implementation of the function. The declaration may have
dioeerent eoeects on the calling convention used for objects of its class, depending on
whether the default declaration is made inside or outside the class.
If the member function has been declared as defaulted, then the entry has a
DW.AT.defaulted attribute whose integer constant value indicates whether, and
if so, how, that member is defaulted. The possible values and their meanings are
shown in Table 5.6 following.
                                       Table 5.6: Defaulted attribute names
             ______________________________________________________________________________________________________________________
             __Defaulted_attribute_name_____________||______________________Meaning________________________________________________
               DW.DEFAULTED.no                   ||                         Not declared default
               DW.DEFAULTED.in.class          ||                            Defaulted within the class
             __DW.DEFAULTED.out.of.class__||________________________________Defaulted_outside_of_the_class_________________________
An artiocial member function (that is, a compiler-generated copy that does not appear in
the source) does not have a DW.AT.defaulted attribute.
5.7.9          Class Template Instantiations
In C++ a class template is a generic deonition of a class type that may be instantiated
when an instance of the class is declared or deoned. The generic description of the class
may include parameterized types, parameterized compile-time constant values, and/or
parameterized run-time constant addresses. DWARF does not represent the generic
template deonition, but does represent each instantiation.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 126
                                                   Chapter 5.  Type Entries
A class template instantiation is represented by a debugging information entry
with the tag DW.TAG.class.type, DW.TAG.structure.type or
DW.TAG.union.type. With the following exceptions, such an entry will contain
the same attributes and have the same types of child entries as would an entry
for a class type deoned explicitly using the instantiation types and values. The
exceptions are:
1.    Template parameters are described and referenced as specioed in Section 2.23
      on page 59.
2.    If the compiler has generated a special compilation unit to hold the template
      instantiation and that special compilation unit has a dioeerent name from the
      compilation unit containing the template deonition, the name attribute for
      the debugging information entry representing the special compilation unit is
      empty or omitted.
3.    If the class type entry representing the template instantiation or any of its
      child entries contains declaration coordinate attributes, those attributes refer
      to the source for the template deonition, not to any source generated
      artiocially by the compiler.
5.7.10           Variant Entries
A variant part of a structure is represented by a debugging information entry
with the tag DW.TAG.variant.part and is owned by the corresponding
structure type entry.
If the variant part has a discriminant, the discriminant is represented by a
separate debugging information entry. This entry has the form of a structure data
member entry. The variant part entry will have a DW.AT.discr attribute whose
value is a reference to the member entry for the discriminant.
If the variant part does not have a discriminant (tag oeld), the variant part entry
may have  a DW.AT.type attribute to represent the tag type.
A reference to a type supports the Pascal notion of a tagless variant part where the
omitted tag nonetheless is given a type whose values are used in later parts of the variant
syntax.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 127
                                                   Chapter 5.  Type Entries
Each variant of a particular variant part is represented by a debugging
information entry with the tag DW.TAG.variant and is a child of the variant
part entry. The value that selects a given variant may be represented in one of
three ways. The variant entry may have a DW.AT.discr.value attribute whose
value represents the discriminant value selecting this variant. The value of this
attribute is encoded as an LEB128 number. The number is signed if the tag type
for the variant part containing this variant is a signed type. The number is
unsigned if the tag type is an unsigned type.
Alternatively, the variant entry may contain a DW.AT.discr.list attribute, whose
value represents a list of discriminant values. This list is represented by any of
the block forms and may contain a mixture of discriminant values and
discriminant ranges. Each item on the list is preoxed with a discriminant value
descriptor that determines whether the list item represents a single label or a
label range. A single case label is represented as an LEB128 number as deoned
above for the DW.AT.discr.value attribute. A label range is represented by two
LEB128 numbers, the low value of the range followed by the high value. Both
values follow the rules for signedness just described. The discriminant value
descriptor is an integer constant that may have one of the values given in Table
5.7.
                                    Table 5.7: Discriminant descriptor values
                                                       __________________________________
                                                        DW.DSC.label
                                                        DW.DSC.range
                                                       __________________________________
If a variant entry has neither a DW.AT.discr.value attribute nor a
DW.AT.discr.list attribute, or if it has a DW.AT.discr.list attribute with 0 size,
the variant is a default variant.
The components selected by a particular variant are represented by debugging
information entries owned by the corresponding variant entry and appear in the
same order as the corresponding declarations in the source program.
For examples using variant entries in several languages, see Section D.2.10 on page 329.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 128
                                                   Chapter 5.  Type Entries
5.8          Condition  Entries
COBOL has the notion of a ilevel-88 conditionj that associates a data item, called the
conditional variable, with a set of one or more constant values and/or value ranges.
Semantically, the condition is `true' if the conditional variable's value matches any of the
described constants, and the condition is `false' otherwise.
The DW.TAG.condition debugging information entry describes a logical
condition that tests whether a given data item's value matches one of a set of
constant values. If a name has been given to the condition, the condition entry
has a DW.AT.name attribute whose value is a null-terminated string giving the
condition name.
The condition entry's parent entry describes the conditional variable; normally
this will be a DW.TAG.variable, DW.TAG.member or
DW.TAG.formal.parameter entry. If the parent entry has an array type, the
condition can test any individual element, but not the array as a whole. The
condition entry implicitly specioes a icomparison typej that is the type of an
array element if the parent has an array type; otherwise it is the type of the
parent entry.
The condition entry owns DW.TAG.constant and/or DW.TAG.subrange.type
entries that describe the constant values associated with the condition. If any
child entry has a DW.AT.type attribute, that attribute describes a type
compatible with the comparison type (according to the source language);
otherwise the child's type is the same as the comparison type.
For conditional variables with alphanumeric types, COBOL permits a source program to
provide ranges of alphanumeric constants in the condition. Normally a subrange type
entry does not describe ranges of strings; however, this can be represented using bounds
attributes that are references to constant entries describing strings. A subrange type
entry may refer to constant entries that are siblings of the subrange type entry.
5.9          Enumeration  Type  Entries
An ienumeration typej is a scalar that can assume one of a oxed number of symbolic
values.
An enumeration type is represented by a debugging information entry with the
tag DW.TAG.enumeration.type.
If a name has been given to the enumeration type in the source program, then the
corresponding enumeration type entry has a DW.AT.name attribute whose
value is a null-terminated string containing the enumeration type name.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 129
                                                   Chapter 5.  Type Entries
The enumeration type entry may have a DW.AT.type attribute which refers to
the underlying data type used to implement the enumeration. The entry also
may have a DW.AT.byte.size attribute or DW.AT.bit.size attribute, whose
value (see Section 2.21 on page 58) is the amount of storage required to hold an
instance of the enumeration. If no DW.AT.byte.size or DW.AT.bit.size
attribute is present, the size for holding an instance of the enumeration is given
by the size of the underlying data type.
If an enumeration type has type safe semantics such that
1.    Enumerators are contained in the scope of the enumeration type, and/or
2.    Enumerators are not implicitly converted to another type
then the enumeration type entry may have a DW.AT.enum.class attribute,
which is a AEag. In a language that ooeers only one kind of enumeration
declaration, this attribute is not required.
In C or C++, the underlying type will be the appropriate integral type determined by the
compiler from the properties of the enumeration literal values. A C++ type declaration
written using enum class declares a strongly typed enumeration and is represented using
DW.TAG.enumeration.type in combination with DW.AT.enum.class.
Each enumeration literal is represented by a debugging information entry with
the tag DW.TAG.enumerator. Each such entry is a child of the enumeration
type entry, and the enumerator entries appear in the same order as the
declarations of the enumeration literals in the source program.
Each enumerator entry has a DW.AT.name attribute, whose value is a
null-terminated string containing the name of the enumeration literal. Each
enumerator entry also has a DW.AT.const.value attribute, whose value is the
actual numeric value of the enumerator as represented on the target system.
If the enumeration type occurs as the description of a dimension of an array type,
and the stride for that dimension is dioeerent than what would otherwise be
determined, then the enumeration type entry has either a DW.AT.byte.stride or
DW.AT.bit.stride attribute which specioes the separation between successive
elements along the dimension as described in Section 2.19 on page 57. The value
of the DW.AT.bit.stride attribute is interpreted as bits and the value of the
DW.AT.byte.stride attribute is interpreted as bytes.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 130
                                                   Chapter 5.  Type Entries
5.10            Subroutine  Type  Entries
It is possible in C to declare pointers to subroutines that return a value of a specioc type.
In both C and C++, it is possible to declare pointers to subroutines that not only return a
value of a specioc type, but accept only arguments of specioc types. The type of such
pointers would be described with a ipointer toj modioer applied to a user-deoned type.
A subroutine type is represented by a debugging information entry with the tag
DW.TAG.subroutine.type. If a name has been given to the subroutine type in
the source program, then the corresponding subroutine type entry has a
DW.AT.name attribute whose value is a null-terminated string containing the
subroutine type name.
If the subroutine type describes a function that returns a value, then the
subroutine type entry has a DW.AT.type attribute to denote the type returned
by the subroutine. If the types of the arguments are necessary to describe the
subroutine type, then the corresponding subroutine type entry owns debugging
information entries that describe the arguments. These debugging information
entries appear in the order that the corresponding argument types appear in the
source program.
In C there is a dioeerence between the types of functions declared using function prototype
style declarations and those declared using non-prototype declarations.
A  subroutine entry declared with a function prototype style declaration may
have a DW.AT.prototyped attribute, which is a AEag.
Each debugging information entry owned by a subroutine type entry
corresponds to either a formal parameter or the sequence of unspecioed
parameters of the subprogram type:
1.    A formal parameter of a parameter list (that has a specioc type) is represented
      by a debugging information entry with the tag DW.TAG.formal.parameter.
      Each formal parameter entry has a DW.AT.type attribute that refers to the
      type of the formal parameter.
2.    The unspecioed parameters of a variable parameter list are represented by a
      debugging information entry with the tag DW.TAG.unspecioed.parameters.
C++ const-volatile qualioers are encoded as part of the type of the ithisj-pointer.
C++11 reference and rvalue-reference qualioers are encoded using the DW.AT.reference
and DW.AT.rvalue.reference attributes, respectively. See also Section 5.7.8 on
page 124.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 131
                                                   Chapter 5.  Type Entries
A subroutine type entry may have the DW.AT.reference or
DW.AT.rvalue.reference attribute to indicate that it describes the type of a
member function with reference or rvalue-reference semantics, respectively.
5.11            String  Type  Entries
A istringj is a sequence of characters that have specioc semantics and operations that
distinguish them from arrays of characters. Fortran is one of the languages that has a
string type. Note that istringj in this context refers to a target machine concept, not the
class string as used in this document (except for the name attribute).
A string type is represented by a debugging information entry with the tag
DW.TAG.string.type. If a name has been given to the string type in the source
program, then the corresponding string type entry has a DW.AT.name attribute
whose value is a null-terminated string containing the string type name.
A string type entry may have a DW.AT.type attribute describing how each
character is encoded and is to be interpreted. The value of this attribute is a
reference to a DW.TAG.base.type base type entry. If the attribute is absent, then
the character is encoded using the system default.
The Fortran 2003 language standard allows string types that are composed of dioeerent
types of (same sized) characters. While there is no standard list of character kinds, the
kinds ASCII (see DW.ATE.ASCII), ISO_10646 (see DW.ATE.UCS) and DEFAULT are
deoned.
The string type entry may have a DW.AT.byte.size attribute or
DW.AT.bit.size attribute, whose value (see Section 2.21 on page 58) is the
amount of storage needed to hold a value of the string type.
The string type entry may also have a DW.AT.string.length attribute whose
value is either (a) a reference (see Section 2.19) to another debugging information
entry that provides the value of the length of the string, or (b) a location
description yielding the location where the length of the string is stored in the
program. If the DW.AT.string.length attribute is not present, the size of the
string is assumed to be the amount of storage that is allocated for the string (as
specioed by the DW.AT.byte.size or DW.AT.bit.size attribute).
The string type entry may also have a DW.AT.string.length.byte.size or
DW.AT.string.length.bit.size attribute,  whose value (see Section 2.21 on
page 58) is the size of the data to be retrieved from the location referenced by the
DW.AT.string.length attribute. If no byte or bit size attribute is present, the size
of the data to be retrieved is the same as the size of an address on the target
machine.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 132
                                                   Chapter 5.  Type Entries
Prior to DWARF Version 5, the meaning of a DW.AT.byte.size attribute depended on
the presence of the DW.AT.string.length attribute:
      #   If DW.AT.string.length was present, DW.AT.byte.size specioed the size of the
          length data to be retrieved from the location specioed by the
          DW.AT.string.length attribute.
      #   If DW.AT.string.length was not present, DW.AT.byte.size specioed the
          amount of storage allocated for objects of the string type.
In DWARF Version 5, DW.AT.byte.size always specioes the amount of storage
allocated for objects of the string type.
5.12            Set  Type  Entries
Pascal provides the concept of a iset,j which represents a group of values of ordinal type.
A set is represented by a debugging information entry with the tag
DW.TAG.set.type. If a name has been given to the set type, then the set type
entry has a DW.AT.name attribute whose value is a null-terminated string
containing the set type name.
The set type entry has a DW.AT.type attribute to denote the type of an element
of the set.
If the amount of storage allocated to hold each element of an object of the given
set type is dioeerent from the amount of storage that is normally allocated to hold
an individual object of the indicated element type, then the set type entry has
either a DW.AT.byte.size attribute, or DW.AT.bit.size attribute whose value
(see Section 2.21 on page 58) is the amount of storage needed to hold a value of
the set type.
5.13            Subrange  Type  Entries
Several languages support the concept of a isubrangej type. Objects of the subrange type
can represent only a contiguous subset (range) of values from the type on which the
subrange is deoned. Subrange types may also be used to represent the bounds of array
dimensions.
A subrange type is represented by a debugging information entry with the tag
DW.TAG.subrange.type. If a name has been given to the subrange type, then
the subrange type entry has a DW.AT.name attribute whose value is a
null-terminated string containing the subrange type name.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 133
                                                    Chapter 5.  Type Entries
 The tag DW.TAG.generic.subrange is used to describe arrays with a dynamic
 rank. See Section 5.5 on page 115.
 The subrange entry may have a DW.AT.type attribute to describe the type of
 object, called the basis type, of whose values this subrange is a subset.
 If the amount of storage allocated to hold each element of an object of the given
 subrange type is dioeerent from the amount of storage that is normally allocated
 to hold an individual object of the indicated element type, then the subrange
 type entry has a DW.AT.byte.size attribute or DW.AT.bit.size attribute, whose
 value (see Section 2.19 on page 57) is the amount of storage needed to hold a
 value of the subrange type.
 The subrange entry may have a DW.AT.threads.scaled attribute, which is a
 AEag. If present, this attribute indicates whether this subrange represents a UPC
 array bound which is scaled by the runtime THREADS value (the number of UPC
 threads in this execution of the program).
 This allows the representation of a UPC shared array such as
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||is*
 *nhtafroeod[T3H4R*E]A[D1S0_]|[_2_0_]|;
 The subrange entry may have the attributes DW.AT.lower.bound and
 DW.AT.upper.bound to specify, respectively, the lower and upper bound
 values of the subrange. The DW.AT.upper.bound attribute may be replaced by
 a  DW.AT.count attribute, whose value describes the number of elements in the
 subrange rather than the value of the last element. The value of each of these
 attributes is determined as described in Section 2.19 on page 57.
 If the lower bound value is missing, the value is assumed to be a
 language-dependent default constant as deoned in Table 7.17 on page 241.
 If the upper bound and count are missing, then the upper bound value is
 unknown.
 If the subrange entry has no type attribute describing the basis type, the basis
 type is determined as follows:
 1.    If there is a lower bound attribute that references an object, the basis type is
       assumed to be the same as the type of that object.
 2.    Otherwise, if there is an upper bound or count attribute that references an
       object, the basis type is assumed to be the same as the type of that object.
 3.    Otherwise, the type is assumed to be the same type, in the source language of
       the compilation unit containing the subrange entry, as a signed integer with
       the same size as an address on the target machine.
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 134
                                                   Chapter 5.  Type Entries
If the subrange type occurs as the description of a dimension of an array type,
and the stride for that dimension is dioeerent than what would otherwise be
determined, then the subrange type entry has either a DW.AT.byte.stride or
DW.AT.bit.stride attribute which specioes the separation between successive
elements along the dimension as described in Section 2.21 on page 58.
Note that the stride can be negative.
5.14            Pointer  to  Member  Type  Entries
In C++, a pointer to a data or function member of a class or structure is a unique type.
A debugging information entry representing the type of an object that is a pointer
to a structure or class member has the tag DW.TAG.ptr.to.member.type.
If the pointer to member type has a name, the pointer to member entry has a
DW.AT.name attribute, whose value is a null-terminated string containing the
type name.
The pointer to member entry has a DW.AT.type attribute to describe the type of
the class or structure member to which objects of this type may point.
The entry also has a DW.AT.containing.type attribute, whose value is a
reference to a debugging information entry for the class or structure to whose
members objects of this type may point.
The pointer to member entry has a DW.AT.use.location attribute whose value
is a location description that computes the address of the member of the class to
which the pointer to member entry points.
The method used to ond the address of a given member of a class or structure is common
to any instance of that class or structure and to any instance of the pointer or member
type. The method is thus associated with the type entry, rather than with each instance of
the type.
The DW.AT.use.location description is used in conjunction with the location
descriptions for a particular object of the given pointer to member type and for a
particular structure or class instance. The DW.AT.use.location attribute expects
two values to be pushed onto the DWARF expression stack before the
DW.AT.use.location description is evaluated. The orst value pushed is the
value of the pointer to member object itself. The second value pushed is the base
address of the entire structure or union instance containing the member whose
address is being calculated.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 135
                                                    Chapter 5.  Type Entries
 For an expression such as
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||o.*
 *b*jmebcrt__p|t_r___|
 where mbr_ptr has some pointer to member type, a debugger should:
 1.    Push the value of mbr_ptr onto the DWARF expression stack.
 2.    Push the base address of object onto the DWARF expression stack.
 3.    Evaluate the DW.AT.use.location description given in the type of mbr_ptr.
 5.15            File  Type  Entries
 Some languages, such as Pascal, provide a data type to represent oles.
 A ole type is represented by a debugging information entry with the tag
 DW.TAG.ole.type. If the ole type has a name, the ole type entry has a
 DW.AT.name attribute, whose value is a null-terminated string containing the
 type name.
 The ole type entry has a DW.AT.type attribute describing the type of the objects
 contained in the ole.
 The ole type entry also has a DW.AT.byte.size or DW.AT.bit.size attribute,
 whose value (see Section 2.19 on page 57) is the amount of storage need to hold a
 value of the ole type.
 5.16            Dynamic  Type  Entries
 Some languages such as Fortran 90, provide types whose values may be dynamically
 allocated or associated with a variable under explicit program control. However, unlike
 the pointer type in C or C++, the indirection involved in accessing the value of the
 variable is generally implicit, that is, not indicated as part of the program source.
 A dynamic type entry is used to declare a dynamic type that is ijust likej another
 non-dynamic type without needing to replicate the full description of that other
 type.
 A dynamic type is represented by a debugging information entry with the tag
 DW.TAG.dynamic.type. If a name has been given to the dynamic type, then the
 dynamic type has a DW.AT.name attribute whose value is a null-terminated
 string containing the dynamic type name.
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 136
                                                   Chapter 5.  Type Entries
A dynamic type entry has a DW.AT.type attribute whose value is a reference to
the type of the entities that are dynamically allocated.
A dynamic type entry also has a DW.AT.data.location, and may also have
DW.AT.allocated and/or DW.AT.associated attributes as described in Section
5.18. A DW.AT.data.location, DW.AT.allocated or DW.AT.associated
attribute may not occur on a dynamic type entry if the same kind of attribute
already occurs on the type referenced by the DW.AT.type attribute.
5.17            Template  Alias  Entries
In C++, a template alias is a form of typedef that has template parameters. DWARF does
not represent the template alias deonition but does represent instantiations of the alias.
A type named using a template alias is represented by a debugging information
entry with the tag DW.TAG.template.alias. The template alias entry has a
DW.AT.name attribute whose value is a null-terminated string containing the
name of the template alias. The template alias entry has child entries describing
the template actual parameters (see Section 2.23 on page 59).
5.18            Dynamic  Properties  of  Types
The DW.AT.data.location, DW.AT.allocated and DW.AT.associated attributes
described in this section are motivated for use with DW.TAG.dynamic.type entries but
can be used for any other type as well.
5.18.1           Data Location
Some languages may represent objects using descriptors to hold information, including a
location and/or run-time parameters, about the data that represents the value for that
object.
The DW.AT.data.location attribute may be used with any type that provides
one or more levels of hidden indirection and/or run-time parameters in its
representation. Its value is a location description. The result of evaluating this
description yields the location of the data for an object. When this attribute is
omitted, the address of the data is the same as the address of the object.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 137
                                                   Chapter 5.  Type Entries
This location description will typically begin with DW.OP.push.object.address which
loads the address of the object which can then serve as a descriptor in subsequent
calculation. For an example using DW.AT.data.location for a Fortran 90 array, see
Appendix D.2.1 on page 307.
5.18.2           Allocation and Association Status
Some languages, such as Fortran 90, provide types whose values may be dynamically
allocated or associated with a variable under explicit program control.
The DW.AT.allocated attribute may be used with any type for which objects of
the type can be explicitly allocated and deallocated. The presence of the attribute
indicates that objects of the type are allocatable and deallocatable. The integer
value of the attribute (see below) specioes whether an object of the type is
currently allocated or not.
The DW.AT.associated attribute may optionally be used with any type for
which objects of the type can be dynamically associated with other objects. The
presence of the attribute indicates that objects of the type can be associated. The
integer value of the attribute (see below) indicates whether an object of the type
is currently associated or not.
The value of these attributes is determined as described in Section 2.19 on
page 57. A non-zero value is interpreted as allocated or associated, and zero is
interpreted as not allocated or not associated.
For Fortran 90, if the DW.AT.associated attribute is present, the type has the
POINTER property where either the parent variable is never associated with a dynamic
object or the implementation does not track whether the associated object is static or
dynamic. If the DW.AT.allocated attribute is present and the DW.AT.associated
attribute is not, the type has the ALLOCATABLE property. If both attributes are present,
then the type should be assumed to have the POINTER property (and not
ALLOCATABLE); the DW.AT.allocated attribute may then be used to indicate that the
association status of the object resulted from execution of an ALLOCATE statement
rather than pointer assignment.
For examples using DW.AT.allocated for Ada and Fortran 90 arrays, see Appendix D.2
on page 307.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 138
                                                   Chapter 5.  Type Entries
5.18.3           Array Rank
The Fortran language supports iassumed-rank arraysj. The rank (the number of
dimensions) of an assumed-rank array is unknown at compile time. The Fortran runtime
stores the rank in an array descriptor.
The presence of the attribute indicates that an array's rank (number of
dimensions) is dynamic, and therefore unknown at compile time. The value of
the DW.AT.rank attribute is either an integer constant or a DWARF expression
whose evaluation yields the dynamic rank.
The bounds of an array with dynamic rank are described using a
DW.TAG.generic.subrange entry, which is the dynamic rank array equivalent
of DW.TAG.subrange.type. The dioeerence is that a
DW.TAG.generic.subrange entry contains generic lower/upper bound and
stride expressions that need to be evaluated for each dimension. Before any
expression contained in a DW.TAG.generic.subrange can be evaluated, the
dimension for which the expression is to be evaluated needs to be pushed onto
the stack. The expression will use it to ond the ooeset of the respective oeld in the
array descriptor metadata.
A producer is free to choose any layout for the array descriptor. In particular, the upper
and lower bounds and stride values do not need to be bundled into a structure or record,
but could be laid end to end in the containing descriptor, pointed to by the descriptor, or
even allocated independently of the descriptor.
Dimensions are enumerated 0 to rank     - 1 in source program order.
For an example in Fortran 2008, see Section D.2.3 on page 316.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 139

Chapter  6
Other  Debugging  Information
This section describes debugging information that is not represented in the form
of debugging information entries and is not contained within a .debug_info
section.
In the descriptions that follow, these terms are used to specify the representation
of DWARF sections:
     #    initial length, section ooeset and section length, which are deoned in
          Sections 7.2.2 on page 192 and 7.4 on page 204.
     #    sbyte, ubyte, uhalf and uword, which are deoned in Section 7.31 on
          page 258.
     #    MBZ, which indicates that a value or the contents of a oeld must be zero.
6.1          Accelerated  Access
A debugger frequently needs to ond the debugging information for a program entity
deoned outside of the compilation unit where the debugged program is currently stopped.
Sometimes the debugger will know only the name of the entity; sometimes only the
address. To ond the debugging information associated with a global entity by name,
using the DWARF debugging information entries alone, a debugger would need to run
through all entries at the highest scope within each compilation unit.
Similarly, in languages in which the name of a type is required to always refer to the same
concrete type (such as C++), a compiler may choose to elide type deonitions in all
compilation units except one. In this case a debugger needs a rapid way of locating the
concrete type deonition by name. As with the deonition of global data objects, this would
require a search of all the top level type deonitions of all compilation units in a program.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 140
                                   Chapter 6.  Other Debugging Information
To ond the debugging information associated with a subroutine, given an address, a
debugger can use the low and high PC attributes of the compilation unit entries to
quickly narrow down the search, but these attributes only cover the range of addresses for
the text associated with a compilation unit entry. To ond the debugging information
associated with a data object, given an address, an exhaustive search would be needed.
Furthermore, any search through debugging information entries for dioeerent compilation
units within a large program would potentially require the access of many memory pages,
probably hurting debugger performance.
To make lookups of program entities (including data objects, functions and
types) by name or by address faster, a producer of DWARF information may
provide two dioeerent types of tables containing information about the
debugging information entries owned by a particular compilation unit entry in a
more condensed format.
6.1.1          Lookup by Name
For lookup by name, a name index is maintained in a separate object ole section
named .debug_names.
The .debug_names section is new in DWARF Version 5, and supersedes the
.debug_pubnames and .debug_pubtypes sections of earlier DWARF versions. While
.debug_names and either .debug_pubnames and/or .debug_pubtypes sections cannot
both occur in the same compilation unit, both may be found in the set of units that make
up an executable or shared object.
The index consists primarily of two parts: a list of names, and a list of index
entries. A name, such as a subprogram name, type name, or variable name, may
have several deoning declarations in the debugging information. In this case, the
entry for that name in the list of names will refer to a sequence of index entries in
the second part of the table, each corresponding to one deoning declaration in
the .debug_info section.
The name index may also contain an optional hash table for faster lookup.
A relocatable object ole may contain a "per-CU" index, which provides an index
to the names deoned in that compilation unit.
An executable or shareable object ole may contain either a collection of "per-CU"
indexes, simply copied from each relocatable object ole, or the linker may
produce a "per-module" index by combining the per-CU indexes into a single
index that covers the entire module.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 141
                                   Chapter 6.  Other Debugging Information
6.1.1.1        Contents of the Name Index
The name index must contain an entry for each debugging information entry that
deones a named subprogram, label, variable, type, or namespace, subject to the
following rules:
     #    All non-deoning declarations (that is, debugging information entries with a
          DW.AT.declaration attribute) are excluded.
     #    DW.TAG.namespace debugging information entries without a
          DW.AT.name attribute are included with the name i(anonymous
          namespace)j.
     #    All other debugging information entries without a DW.AT.name attribute
          are excluded.
     #    DW.TAG.subprogram, DW.TAG.inlined.subroutine, and
          DW.TAG.label debugging information entries without an address
          attribute (DW.AT.low.pc, DW.AT.high.pc, DW.AT.ranges, or
          DW.AT.entry.pc) are excluded.
     #    DW.TAG.variable debugging information entries with a DW.AT.location
          attribute that includes a DW.OP.addr or DW.OP.form.tls.address
          operator are included; otherwise, they are excluded.
     #    If a subprogram or inlined subroutine is included, and has a
          DW.AT.linkage.name attribute, there will be an additional index entry for
          the linkage name.
For the purposes of determining whether a debugging information entry has a
particular attribute (such as DW.AT.name), if debugging information entry A
has a DW.AT.speciocation or DW.AT.abstract.origin attribute pointing to
another debugging information entry B, any attributes of B are considered to be
part of A.
The intent of the above rules is to provide the consumer with some assurance that looking
up an unqualioed name in the index will yield all relevant debugging information entries
that provide a deoning declaration at global scope for that name.
A producer may choose to implement additional rules for what names are placed in the
index, and may communicate those rules to a cooperating consumer via augmentation
sequence as described below.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 142
                                   Chapter 6.  Other Debugging Information
6.1.1.2        Structure of the Name Index
Logically, the name index can be viewed as a list of names, with a list of index
entries for each name. Each index entry corresponds to a debugging information
entry that matches the criteria given in the previous section. For example, if one
compilation unit has a function named fred and another has a struct named
fred, a lookup for ifredj will ond the list containing those two index entries.
The index section contains nine individual parts, as illustrated in Figure 6.1
following.
     1.   A header, describing the layout of the section.
     2.   A list of compile units (CUs) referenced by this index.
     3.   A list of local type units (TUs) referenced by this index that are present in
          this object ole.
     4.   A list of foreign type units (TUs) referenced by this index that are not
          present in this object ole (that is, that have been placed in a split DWARF
          object ole as described in 7.3.2 on page 195).
     5.   An optional hash lookup table.
     6.   The name table.
     7.   An optional local string pool.
     8.   An abbreviations table, similar to the one used by the .debug_info section.
     9.   The entry pool, containing a list of index entries for each name in the name
          list.
The formats of the header and the hash lookup table are described in Section
6.1.1.4 on page 148.
The list of CUs and the list of local TUs are each an array of ooesets, each of which
is the ooeset of a compile unit or a type unit in the .debug_info section. For a
per-CU index, there is a single CU entry, and there may be a TU entry for each
type unit generated in the same translation unit as the single CU. For a
per-module index, there will be one CU entry for each compile unit in the
module, and one TU entry for each unique type unit in the module. Each list is
indexed starting at 0.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 143
                                   Chapter 6.  Other Debugging Information
NameHIndexeaderCULListocalFTUoListreignHTUaListshNTableameLTableocalAStringbPoolbrevITablendexoPooloesetotooCUe0set.to.CU.1ooesetctopartC1Uofk3-o1mp_*
 *unit_counto(=ok)esetotooTUe0set.to.TU.1ooesetltooTUcta-l1_type_unit_counts(=it)gnaturesofiTUgtnature.of.TU.ts+i1gnaturefofoTUrt+fe-1ign_type_unit_c*
 *ountB(=ufc)ketsHashesStringEPointersntryLOoesetso@
  or Indexes
                                            Figure 6.1: Name Index Layout
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 144
                                   Chapter 6.  Other Debugging Information
                                                                                                                                    part 2 of 3
            bucketb0ucket.1.b.ucketbbu-c1ket_counth(=ab)shhvaluea1shhvaluea2shhvaluea3shhvaluea4sh.value.5.hashSvaluetnringEntryname_count.debug.istr*
 *ndexaentriesbbrevtcodeamgi(DW.TAG)dx.attrib.name.(DW.IDX),iformdx0attrib,name0(DW.IDX),(formend.of.abbrev.code0m)(endpofaabbreviations)ddingabbrev_*
 *table_size
            BucketsHashesOoesetsOoesets(=An)bbreviations(DW.FORM)(DW.FORM)(= s)
                                  Figure 6.1: Name Index Layout (continued)
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 145
                                   Chapter 6.  Other Debugging Information
                                                                                                                                    part 3 of 3
                                          IndexiEntriesndexientryn#1dforeiajx.entry.#2.for0iaj(endiofnentriesdforeiaj)xientryn#1dforeibjx.entry.#2.fo*
 *r0ibj(endiofnentriesdforeibj)x.entry.#1.foraicjbbrevicodedmxiattribdvaluex.attrib.value.idxfattribrvalueomfentryrooesetsomfentryrooesetsom entry oo*
 *esets
                                               ofonameftablenameotablef name table
                                  Figure 6.1: Name Index Layout (concluded)
The list of foreign TUs is an array of 64-bit (DW.FORM.ref.sig8) type
signatures, representing types referenced by the index whose deonitions have
been placed in a dioeerent object ole (that is, a split DWARF object). This list may
be empty. The foreign TU list immediately follows the local TU list and they both
use the same index, so that if there are N  local TU entries, the index for the orst
foreign TU is N .
The name table is logically a table with a row for each unique name in the index,
and two columns. The orst column contains a reference to the name, as a string.
The second column contains the ooeset within the entry pool of the list of index
entries for the name.
The abbreviations table describes the formats of the entries in the entry pool.
Like the DWARF abbreviations table in the .debug_abbrev section, it deones one
or more abbreviation codes. Each abbreviation code provides a DWARF tag
value followed by a list of pairs that deones an attribute and form code used by
entries with that abbreviation code.
The entry pool contains all the index entries, grouped by name. The second
column of the name list points to the orst index entry for the name, and all the
index entries for that name are placed one after the other.
Each index entry begins with an unsigned LEB128 abbreviation code. The
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 146
                                   Chapter 6.  Other Debugging Information
abbreviation list for that code provides the DWARF tag value for the entry as
well as the set of attributes provided by the entry and their forms.
The standard index attributes (see Table 6.1 on page 153) are:
     #    Compilation Unit (CU), a reference to an entry in the list of CUs. In a
          per-CU index, index entries without this index attribute implicitly refer to
          the single CU.
     #    Type Unit (TU), a reference to an entry in the list of local or foreign TUs.
     #    Debugging information entry ooeset within the CU or TU.
     #    Parent debugging information entry, a reference to the index entry for the
          parent. This is represented as the ooeset of the entry relative to the start of
          the entry pool.
     #    Type hash, an 8-byte hash of the type declaration.
It is possible that an indexed debugging information entry has a parent that is
not indexed (for example, if its parent does not have a name attribute). In such a
case, a parent index attribute may point to a nameless index entry (that is, one
that cannot be reached from any entry in the name table), or it may point to the
nearest ancestor that does have an index entry.
A producer may deone additional producer-specioc index attributes, and a
consumer will be able to ignore and skip over any index attributes it is not
prepared to handle.
When an index entry refers to a foreign type unit, it may have index attributes
for both CU and (foreign) TU. For such entries, the CU index attribute gives the
consumer a reference to the CU that may be used to locate a split DWARF object
ole that contains the type unit.
The type hash index attribute, not to be confused with the type signature for a TU, may
be provided for type entries whose declarations are not in a type unit, for the convenience
of link-time or post-link utilities that wish to de-duplicate type declarations across
compilation units. The type hash, however, is computed by the same method as specioed
for type signatures.
The last entry for each name is followed by a zero byte that terminates the list.
There may be gaps between the lists.
6.1.1.3        Per-CU versus Per-Module Indexes
In a per-CU index, the CU list may have only a single entry, and index entries may omit
the CU attribute. (Cross-module or link-time optimization, however, may produce an
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 147
                                   Chapter 6.  Other Debugging Information
object ole with several compile units in one object. A compiler in this case may produce a
separate index for each CU, or a combined index for all CUs. In the latter case, index
entries will require the CU attribute.) Most name table entries may have only a single
index entry for each, but sometimes a name may be used in more than one context and
will require multiple index entries, each pointing to a dioeerent debugging information
entry.
When linking object oles containing per-CU indexes, the linker may choose to
concatenate the indexes as ordinary sections, or it may choose to combine the input
indexes into a single per-module index.
A per-module index will contain a number of CUs, and each index entry contains a CU
attribute or a TU attribute to identify which CU or TU contains the debugging
information entry being indexed. When a given name is used in multiple CUs or TUs, it
will typically have a series of index entries pointing to each CU or TU where it is
declared. For example, an index entry for a C++ namespace needs to list each occurrence,
since each CU may contribute additional names to the namespace, and the consumer
needs to ond them all. On the other hand, some index entries do not need to list more
than one deonition; for example, with the one-deonition rule in C++, duplicate entries for
a function may be omitted, since the consumer only needs to ond one declaration.
Likewise, a per-module index needs to list only a single copy of a type declaration
contained in a type unit.
For the beneot of link-time or post-link utilities that consume per-CU indexes and
produce a per-module index, the per-CU index entries provide the tag encoding for the
original debugging information entry, and may provide a type hash for certain types that
may beneot from de-duplication. For example, the standard declaration of the typedef
uint32_t is likely to occur in many CUs, but a combined per-module index needs to
retain only one; a user declaration of a typedef mytype may refer to a dioeerent type at
each occurrence, and a combined per-module index retains each unique declaration of that
type.
6.1.1.4        Data Representation of the Name Index
The name index is placed in a section named .debug_names, and consists of the
eight parts described in the following sections.
6.1.1.4.1    Section Header
The section header contains the following oelds:
1.    unit_length (initial length)
      The length of this contribution to the name index section, not including the
      length oeld itself (see Section 7.2.2 on page 192).
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 148
                                     Chapter 6.  Other Debugging Information
  2.    version (uhalf)
        A version number (see Section 7.19 on page 245). This number is specioc to
        the name index table and is independent of the DWARF version number.
  3.    str_format (ubyte)
        An enumerated constant that specioes the representation of string references
        in the name index. The possible values are: DW.FORM.strp,
        DW.FORM.strp8, and DW.FORM.strx4 (see Section 7.5.5 on page 222).
  4.    padding (ubyte)
        Reserved to DWARF (must be zero).
  5.    comp_unit_count (uword)
        The number of CUs in the CU list.
  6.    local_type_unit_count (uword)
        The number of TUs in the local TU list.
  7.    foreign_type_unit_count (uword)
        The number of TUs in the foreign TU list.
  8.    bucket_count (uword)
        The number of hash buckets in the hash lookup table. If there is no hash
        lookup table, this oeld contains 0.
  9.    name_count (uword)
        The number of unique names in the index.
10.     local_str_pool_size (section length)
        Size of the local string pool. If this value is non-zero, string ooesets (when
        str_format is DW.FORM.strp or DW.FORM.strp8) reference the local
        string pool. If this value is 0, string ooesets reference the .debug_str section. If
        str_format is DW.FORM.strx4, this oeld should be 0.
11.     str_offsets (section_offset)
        A 4-byte or 8-byte unsigned ooeset that points to the header of the compilation
        unit's contribution to the .debug_str_offsets section. Indirect string
        references (when str_format is DW.FORM.strx4) are interpreted as
        zero-based indexes into the array of ooesets following the header. If
        str_format is DW.FORM.strp or DW.FORM.strp8, this oeld should be 0.
12.     abbrev_table_size (uword)
        The size in bytes of the abbreviations table.
  November 1, 2024                                  ***WORKING DRAFT***                                                           Page 149
                                     Chapter 6.  Other Debugging Information
13.     augmentation_size (uword)
        The size in bytes of the augmentation sequence. This value must be a
        multiple of four.
14.     augmentation (sequence of ubyte)
        A producer-specioc sequence of bytes, which provides additional
        information about the contents of this index. If provided, the sequence begins
        with four bytes which serve as a producer ID. The remainder of the sequence
        is meant to be read by a cooperating consumer, and its contents and
        interpretation are not specioed here. The block is padded with zero bytes to a
        multiple of four bytes in length.
        The presence of an unrecognized augmentation producer ID does not make it
        impossible for a consumer to process data in the .debug_names section. The
        augmentation sequence only provides hints to the consumer regarding the
        completeness of the set of names in the index.
  6.1.1.4.2    List of CUs
  The list of CUs immediately follows the header. Each entry in the list is an ooeset
  of the corresponding compilation unit in the .debug_info section. In the
  DWARF-32 format, a section ooeset is 4 bytes, while in the DWARF-64 format, a
  section ooeset is 8 bytes.
  The total number of entries in the list is given by comp_unit_count. There must
  be at least one CU.
  6.1.1.4.3    List of Local TUs
  The list of local TUs immediately follows the list of CUs. Each entry in the list is
  an ooeset of the corresponding type unit in the .debug_info section. In the
  DWARF-32 format, a section ooeset is 4 bytes, while in the DWARF-64 format, a
  section ooeset is 8 bytes.
  Any local TU entry with a maximum representable value is considered not
  present. Any index entry referencing such a local TU entry should be ignored.
  The total number of entries in the list is given by local_type_unit_count. This
  list may be empty.
  6.1.1.4.4    List of Foreign TUs
  The list of foreign TUs immediately follows the list of local TUs. Each entry in
  the list is a 8-byte type signature (as described by DW.FORM.ref.sig8).
  The number of entries in the list is given by foreign_type_unit_count. This list
  may be empty.
  November 1, 2024                                  ***WORKING DRAFT***                                                           Page 150
                                   Chapter 6.  Other Debugging Information
6.1.1.4.5    Hash Lookup Table
The optional hash lookup table immediately follows the list of type signatures.
The hash lookup table is actually two separate arrays: an array of buckets,
followed immediately by an array of hashes. The number of entries in the
buckets array is given by bucket_count, and the number of entries in the hashes
array is given by name_count. Each array contains 4-byte unsigned integers.
Symbols are entered into the hash table by orst computing a hash value from the
symbol name. The hash is computed using the "DJB" hash function described in
Section 7.33 on page 262. Given a hash value for the symbol, the symbol is
entered into a bucket whose index is the hash value modulo bucket_count. The
buckets array is indexed starting at 0.
For the purposes of the hash computation, each symbol name should be folded
according to the simple case folding algorithm deoned in the "Caseless
Matching" subsection of Section 5.18 ("Case Mappings") of the Unicode Standard,
Version 9.0.0. The original symbol name, as it appears in the source code, should
be stored in the name table.
Thus, two symbols that dioeer only by case will hash to the same slot, but the consumer
will be able to distinguish the names when appropriate.
The simple case folding algorithm is further described in the CaseFolding.txt ole
distributed with the Unicode Character Database. That ole deones four classes of
mappings: Common (C), Simple (S), Full (F), and Turkish (T). The hash
computation specioed here uses the C + S mappings only, which do not aoeect the
total length of the string, with the addition that Turkish upper case dotted '#' and
lower case dotless 'ss' are folded to the Latin lower case 'i'.
Each bucket contains the index of an entry in the hashes array. The hashes array
is indexed starting at 1, and an empty bucket is represented by the value 0.
The hashes array contains a sequence of the full hash values for each symbol. All
symbols that have the same index into the bucket list follow one another in the
hashes array, and the indexed entry in the bucket list refers to the orst symbol.
When searching for a symbol, the search starts at the index given by the bucket,
and continues either until a matching symbol is found or until a hash value from
a dioeerent bucket is found. If two dioeerent symbol names produce the same hash
value, that hash value will occur twice in the hashes array. Thus, if a matching
hash value is found, but the name does not match, the search continues visiting
subsequent entries in the hashes table.
When a matching hash value is found in the hashes array, the index of that entry
in the hashes array is used to ond the corresponding entry in the name table.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 151
                                   Chapter 6.  Other Debugging Information
6.1.1.4.6    Name Table
The name table immediately follows the hash lookup table. It consists of two
arrays: an array of string pointers or indexes, followed immediately by an array
of entry ooesets. The items in the orst array are determined by the str_format
oeld in the section header, and may be 4-byte or 8-byte ooesets into either the
.debug_str section or the local string pool, or 4-byte indexes into the array of
ooesets in the .debug_str_offsets section. The items in the second array are
section ooesets: 4-byte unsigned integers for the DWARF-32 format or 8-byte
unsigned integers for the DWARF-64 format. The entry ooesets in the second
array refer to index entries, and are relative to the start of the entry pool area.
These two arrays are indexed starting at 1, and correspond one-to-one with each
other. The length of each array is given by name_count.
If there is a hash lookup table, the hashes array corresponds on a one-to-one
basis with the string ooesets array and with the entry ooesets array.
If there is no hash lookup table, there is no ordering requirement for the name table.
6.1.1.4.7    Local String Pool
The local string pool, if present, immediately follows the name table. It consists
of a series of null-terminated strings. Its size is given by local_str_pool_size.
For non-split DWARF compilation units, strings used by the name table will have
signiocant overlap with strings used by the .debug_info section, and a local string pool
is not advisable. Relocations for the string references may be minimized by using the
indirect string forms in both .debug_info and .debug_names. For split DWARF
compilation units with a linker that is aware of and can combine .debug_names sections
into a single per-module index, there is likely little overlap, and relocations for string
references in the name table can be minimized by using the local string pool. If the linker
simply concatenates the per-CU indexes, however, it remains beneocial to use indirect
string forms and a separate string table.
6.1.1.4.8    Abbreviations Table
The abbreviations table immediately follows the local string pool or, if the local
string pool is absent, the name table. This table consists of a series of
abbreviation declarations. Its size is given by abbrev_table_size.
Each abbreviation declaration deones the tag and other attributes for a particular
form of index entry. Each declaration starts with an unsigned LEB128 number
representing the abbreviation code itself. It is this code that appears at the
beginning of an index entry. The abbreviation code must not be 0.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 152
                                   Chapter 6.  Other Debugging Information
The abbreviation code is followed by another unsigned LEB128 number that
encodes the tag of the debugging information entry corresponding to the index
entry.
Following the tag encoding is a series of attribute speciocations. Each index
attribute consists of two parts: an unsigned LEB128 number that represents the
index attribute, and another unsigned LEB128 number that represents the index
attribute's form (as described in Section 7.5.4 on page 217). The series of attribute
speciocations ends with an entry containing 0 for the attribute and 0 for the form.
The index attributes and their meanings are listed in Table 6.1.
                                        Table 6.1: Index attribute encodings
              _____________________________________________________________________________________________________________________
              __Index_attribute_name______||_________________Meaning_______________________________________________________________
                DW.IDX.compile.unit  ||                      Index of CU
                DW.IDX.type.unit        ||                   Index of TU (local    or foreign)
                DW.IDX.die.ooeset        ||                  Ooeset of DIE within CU or TU
                DW.IDX.parent              ||                Index of name table     entry for parent
                DW.IDX.type.hash       ||                    Hash of type declaration
                DW.IDX.external           ||                 Whether DW.AT.external is present
                                          |                  on the declaration (AEag)
              ____________________________|________________________________________________________________________________________
The abbreviations table ends with an entry consisting of a single 0 byte for the
abbreviation code. The size of the table given by abbrev_table_size may
include optional padding following the terminating 0 byte.
6.1.1.4.9    Entry Pool
The entry pool immediately follows the abbreviations table. Each entry in the
entry ooesets array in the name table (see Section 6.1.1.4.6) points to an ooeset in
the entry pool, where a series of index entries for that name is located.
Each index entry in the series begins with an abbreviation code, and is followed
by the index attribute values described by the abbreviation declaration for that
code. The last index entry in the series is followed by a terminating entry whose
abbreviation code is 0.
Each index entry has a AEag indicating whether the corresponding DIE has the
DW.AT.external attribute with a true value. If the DW.IDX.external attribute is
missing from an entry, it means that DW.AT.external is false for that DIE.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 153
                                   Chapter 6.  Other Debugging Information
Gaps are not allowed between entries in a series (that is, the entries for a single
name must all be contiguous), but there may be gaps between series.
For example, a producer/consumer combination may ond it useful to maintain alignment.
The size of the entry pool is the remaining size of the contribution to the index
section, as deoned by the unit_length header oeld.
6.1.2          Lookup by Address
For lookup by address, a table is maintained in a separate object ole section
called .debug_aranges. The table consists of sets of variable length entries, each
set describing the portion of the program's address space that is covered by a
single compilation unit.
Each set begins with a header containing ove values:
1.    unit_length (initial length)
      The length of this contribution to the address lookup section, not including
      the length oeld itself (see Section 7.2.2 on page 192).
2.    version (uhalf)
      A version number (see Section 7.21 on page 246). This number is specioc to
      the address lookup table and is independent of the DWARF version number.
3.    debug_info_offset (section ooeset)
      The ooeset from the beginning of the .debug_info section of the compilation
      unit header referenced by the set.
4.    address_size (ubyte)
      The size of an address in bytes on the target architecture.
5.    reserved 1  (ubyte, MBZ)
_________________________________________________________
      1This allows backward compatible support of the deprecated segment_selector_size oeld
which was deoned in DWARF Version 5 and earlier.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 154
                                   Chapter 6.  Other Debugging Information
This header is followed by a variable number of address range descriptors. Each
descriptor is a pair consisting of the beginning address of a range of text or data
covered by some entry owned by the corresponding compilation unit, followed
by the length of that range. A particular set is terminated by an entry consisting
of two zeroes. By scanning the table, a debugger can quickly decide which
compilation unit to look in to ond the debugging information for an object that
has a given address.
A range description entry whose address is the reserved address (see Section
2.4.1 on page 26), indicates a non-existent range, which is equivalent to omitting
the range description.
If the range of addresses covered by the text and/or data of a compilation unit is not
contiguous, then there may be multiple address range descriptors for that compilation
unit.
6.2          Line  Number  Information
A source-level debugger needs to know how to associate locations in the source oles with
the corresponding machine instruction addresses in the executable or the shared object
oles used by that executable object ole. Such an association makes it possible for the
debugger user to specify machine instruction addresses in terms of source locations. This
is done by specifying the line number and the source ole containing the statement. The
debugger can also use this information to display locations in terms of the source oles and
to single step from line to line, or statement to statement.
Line number information generated for a compilation unit is represented in the
.debug_line section of an object ole, and optionally also in the .debug_line_str
section, and is referenced by a corresponding compilation unit debugging
information entry (see Section 3.1.1 on page 62) in the .debug_info section.
Some computer architectures employ more than one instruction set (for example, the
ARM and MIPS architectures support a 32-bit as well as a 16-bit instruction set).
Because the instruction set is a function of the program counter, it is convenient to
encode the applicable instruction set in the .debug_line section as well.
If space were not a consideration, the information provided in the .debug_line section
could be represented as a large matrix, with one row for each instruction in the emitted
object code. The matrix would have columns for:
     #    the source ole name
     #    the source line number
     #    the source column number
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 155
                                   Chapter 6.  Other Debugging Information
     #    whether this instruction is the beginning of a source statement
     #    whether this instruction is the beginning of a basic block
     #    and so on
Such a matrix, however, would be impractically large. We shrink it with two techniques.
First, we delete from the matrix each row whose ole, line, source column and
discriminator is identical with that of its predecessors, except where the instruction is
marked as a suggested breakpoint location, the end of a prologue region, or the beginning
of an epilogue region. Second, we design a byte-coded language for a state machine and
store a stream of bytes in the object ole instead of the matrix. This language can be much
more compact than the matrix. To the line number information a consumer must irunj
the state machine to generate the matrix for each compilation unit of interest. The concept
of an encoded matrix also leaves room for expansion. In the future, columns can be added
to the matrix to encode other things that are related to individual instruction addresses.
6.2.1          Deonitions
The following terms are used in the description of the line number information
format:
        state machine                             The hypothetical machine used by a consumer
                                                  of the line number information to expand the
                                                  byte-coded instruction stream into a matrix of
                                                  line number information.
        line number program                       A series of byte-coded line number information
                                                  instructions representing one compilation unit.
        basic block                               A sequence of instructions where only the orst
                                                  instruction may be a branch target and only the
                                                  last instruction may transfer control. A
                                                  subprogram invocation is deoned to be an exit
                                                  from a basic block.
                                                  A basic block does not necessarily correspond to a
                                                  specioc source code construct.
        sequence                                  A series of contiguous target machine
                                                  instructions. One compilation unit may emit
                                                  multiple sequences (that is, not all instructions
                                                  within a compilation unit are assumed to be
                                                  contiguous).
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 156
                                   Chapter 6.  Other Debugging Information
6.2.2          State Machine Registers
The line number information state machine has a number of registers as shown
in Table 6.3 following.
                                          Table 6.3: State machine registers
   __________________________________________________________________________________________________________________________________________
   __Register_name___________||_____________Meaning__________________________________________________________________________________________
     address                       ||       The program-counter value corresponding to a
                                   |        machine instruction generated by the compiler.
                                   |
     op_index                     ||        An unsigned integer representing the index of an
                                  |
                                  |         operation within a VLIW instruction. The index of
                                  |
                                  |         the orst operation is 0. For non-VLIW architectures,
                                  |         this register will always be 0.
                                  |
     file                             ||    An unsigned integer indicating the identity of the
                                      |
                                      |     source ole corresponding to a machine instruction.
                                      |     Files are numbered beginning at 0.
                                      |
     line                             ||    An unsigned integer indicating a source line number.
                                      |
                                      |     Lines are numbered beginning at 1. The compiler
                                      |
                                      |     may emit the value 0 in cases where an instruction
                                      |     cannot be attributed to any source line.
                                      |
     column                         ||      An unsigned integer indicating a column number
                                    |
                                    |       within a source line. Columns are numbered
                                    |
                                    |       beginning at 1. The value 0 is reserved to indicate
                                    |       that a statement begins at the ileft edgej of the line.
                                    |
     is_stmt                       ||       A boolean indicating that the current instruction is a
                                   |
                                   |        recommended breakpoint location. A recommended
                                   |
                                   |        breakpoint location is intended to irepresentj a line,
                                   |
                                   |        a statement and/or a semantically distinct subpart of
                                   |        a statement.
                                   |
     basic_block              ||            A boolean indicating that the current instruction is
                              |             the beginning of a basic block.
                              |
     end_sequence            ||             A boolean indicating that the current address is that
                             |
                             |              of the orst byte after the end of a sequence of target
                             |
                             |              machine instructions. end_sequence terminates a
                             |
                             |              sequence of lines; therefore other information in the
                             |              same row is not meaningful.
   __________________________|_______________________________________________________________________________________________________________
     Continued on next page
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 157
                                   Chapter 6.  Other Debugging Information
  __Register_name___________||_____________Meaning__________________________________________________________________________________________
    prologue_end            ||             A boolean indicating that the current address is one
                            |
                            |              (of possibly many) where execution should be
                            |              suspended for a breakpoint at the entry of a function.
                            |
    epilogue_begin        ||               A boolean indicating that the current address is one
                          |
                          |                (of possibly many) where execution should be
                          |
                          |                suspended for a breakpoint just prior to the exit of a
                          |                function.
                          |
    prologue_epilogue  ||                  A boolean indicating that the current row describes
                       |                   instructions within a prologue or epilogue range.
                       |              ||
    isa                               |    An unsigned integer whose value encodes the
                                      |
                                      |    applicable instruction set architecture for the current
                                      |
                                      |    instruction.
                                      |
                                      |    The encoding of instruction sets should be shared by all
                                      |
                                      |    users of a given architecture. It is recommended that this
                                      |
                                      |    encoding be deoned by the ABI authoring committee for
                                      |    each architecture.
                           ||         |
    discriminator          |               An unsigned integer identifying the block to which
                           |
                           |               the current instruction belongs. Discriminator values
                           |
                           |               are assigned arbitrarily by the DWARF producer and
                           |
                           |               serve to distinguish among multiple blocks that may
                           |
                           |               all be associated with the same source ole, line, and
                           |
                           |               column. Where only one block exists for a given
                           |               source position, the discriminator value is zero.
  _________________________|________________________________________________________________________________________________________________
The address and op_index registers, taken together, form an operation pointer
that can reference any individual operation within the instruction stream.
At the beginning of each sequence within a line number program, the state of the
registers is as show in Table 6.4 on the following page.
The isa value 0 specioes that the instruction set is the architecturally determined default
instruction set. This may be oxed by the ABI, or it may be specioed by other means, for
example, by the object ole description.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 158
                                   Chapter 6.  Other Debugging Information
                                 Table 6.4: Line number program initial state
     _____________________________________________________________________________________________________________________________________
       address                       ||       0
       op_index                     ||        0
       file                             ||    0
       line                             ||    1
       column                         ||      0
       is_stmt                       ||       determined by default_is_stmt in the line number
                                     |        program header
                                     |
       basic_block              ||            ifalsej
       end_sequence            ||             ifalsej
       prologue_end            ||             ifalsej
       epilogue_begin        ||               ifalsej
       prologue_epilogue  ||                  ifalsej
       isa                               ||   0
     __discriminator__________||______________0___________________________________________________________________________________________
6.2.3          Line Number Program Instructions
The state machine instructions in a line number program belong to one of three
categories:
1.    special opcodes
      These have a ubyte opcode oeld and no operands.
      Most of the instructions in a line number program are special opcodes.
2.    standard opcodes
      These have a ubyte opcode oeld which may be followed by zero or more
      LEB128 operands (except for DW.LNS.oxed.advance.pc,                              see Section 6.2.5.2
      on page 169). The opcode implies the number of operands and their
      meanings, but the line number program header also specioes the number of
      operands for each standard opcode.
      One standard opcode (DW.LNS.extended.op) serves as an escape that
      allows additional opcodes without reducing the number of special opcodes.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 159
                                   Chapter 6.  Other Debugging Information
3.    extended opcodes
      These have a multiple byte format. The orst byte is DW.LNS.extended.op.
      The next bytes are an unsigned LEB128 integer giving the number of bytes in
      the instruction itself (this does not include the orst DW.LNS.extended.op
      byte or the size). The remaining bytes are the instruction itself (which begins
      with a ubyte extended opcode).
6.2.4          The Line Number Program Header
The optimal encoding of line number information depends to a certain degree
upon the architecture of the target machine. The line number program header
provides information used by consumers in decoding the line number program
instructions for a particular compilation unit and also provides information used
throughout the rest of the line number program.
The line number program for each compilation unit begins with a header
containing the following oelds in order:
1.    unit_length (initial length)
      The size in bytes of the line number information for this compilation unit, not
      including the length oeld itself (see Section 7.2.2 on page 192).
2.    version (uhalf)
      A version number (see Section 7.22 on page 247). This number is specioc to
      the line number information and is independent of the DWARF version
      number.
3.    address_size (ubyte)
      The size of an address in bytes on the target architecture.
      The address_size oeld supports the common practice of stripping all but the line
      number sections (.debug_line and .debug_line_str) from an executable.
4.    reserved 2  (ubyte, MBZ)
5.    header_length
      The number of bytes following the header_length oeld to the beginning of
      the orst byte of the line number program itself. In the 32-bit DWARF format,
      this is a 4-byte unsigned length; in the 64-bit DWARF format, this oeld is an
      8-byte unsigned length (see Section 7.4 on page 204).
_________________________________________________________
      2This allows backward compatible support of the deprecated segment_selector_size oeld
which was deoned in DWARF Version 5 and earlier.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 160
                                     Chapter 6.  Other Debugging Information
  6.    minimum_instruction_length (ubyte)
        The size in bytes of the smallest target machine instruction. Line number
        program opcodes that alter the address and op_index registers use this and
        maximum_operations_per_instruction in their calculations.
  7.    maximum_operations_per_instruction (ubyte)
        The maximum number of individual operations that may be encoded in an
        instruction. Line number program opcodes that alter the address and
        op_index registers use this and minimum_instruction_length in their
        calculations.
        For non-VLIW architectures, this oeld is 1, the op_index register is always 0,
        and the operation pointer is simply the address register.
  8.    default_is_stmt (ubyte)
        The initial value of the is_stmt register.
        A simple approach to building line number information when machine instructions
        are emitted in an order corresponding to the source program is to set
        default_is_stmt to itruej and to not change the value of the is_stmt register
        within the line number program. One matrix entry is produced for each line that has
        code generated for it. The eoeect is that every entry in the matrix recommends the
        beginning of each represented line as a breakpoint location. This is the traditional
        practice for unoptimized code.
        A more sophisticated approach might involve multiple entries in the matrix for a line
        number; in this case, at least one entry (often but not necessarily only one) specioes a
        recommended breakpoint location for the line number. DW.LNS.negate.stmt
        opcodes in the line number program control which matrix entries constitute such a
        recommendation and default_is_stmt might be either itruej or ifalse.j This
        approach might be used as part of support for debugging optimized code.
  9.    line_base (sbyte)
        This parameter aoeects the meaning of the special opcodes. See below.
10.     line_range (ubyte)
        This parameter aoeects the meaning of the special opcodes. See below.
11.     opcode_base (ubyte)
        The number assigned to the orst special opcode.
        Opcode base is typically one greater than the highest-numbered standard opcode
        deoned for the specioed version of the line number information (12 in DWARF
        Versions 3 through 6,   and 9 in Version 2). If opcode_base is less than the typical
        value, then standard opcode numbers greater than or equal to the opcode base are not
        used in the line number table of this unit (and the codes are treated as special
  November 1, 2024                                  ***WORKING DRAFT***                                                           Page 161
                                     Chapter 6.  Other Debugging Information
        opcodes). If opcode_base is greater than the typical value, then the numbers
        between that of the highest standard opcode and the orst special opcode (not
        inclusive) are used for producer-specioc extensions.
12.     standard_opcode_lengths (array of ubyte)
        This array specioes the number of LEB128 operands for each of the standard
        opcodes. The orst element of the array corresponds to the opcode whose
        value is 1, and the last element corresponds to the opcode whose value is
        opcode_base - 1             .
        By increasing opcode_base, and adding elements to this array, new standard
        opcodes can be added, while allowing consumers who do not know about these new
        opcodes to be able to skip them.
        Codes for producer-specioc extensions, if any, are described just like standard opcodes.
13.     directory_format_count (ULEB128)
        A count of the number of entries in the following directory_format_table
        oeld.
14.     directory_format_table (sequence of record format descriptors)
        A sequence of record format descriptors. Each descriptor consists the
        following:
            #    A sequence of oeld descriptors. Each oeld descriptor consists of a pair of
                 unsigned LEB128 values: (a) a content type code (see Sections 6.2.4.1 on
                 page 164 and 6.2.4.2 on page 166), and (b) a form code (using the
                 attribute form codes).
            #    A pair of zero bytes to terminate the descriptor.
        The line number program numbers the record format descriptors
        sequentially, beginning with 0.
        The format declarations describe the layout of the entries in the directories
        oeld, below.
15.     directories_count (ULEB128)
        A count of the number of entries in the following directories oeld.
  November 1, 2024                                  ***WORKING DRAFT***                                                           Page 162
                                     Chapter 6.  Other Debugging Information
16.     directories (sequence of directory entries)
        A sequence of directory entries. Each entry consists of:
            #    A format code (ULEB128), which selects a record format descriptor from
                 the directory_format_table oeld, above, by its index.
            #    A sequence of oelds as described by the selected record format
                 descriptor.
        Each directory entry describes a path that was searched for included source
        oles in this compilation, including the compilation directory of the
        compilation. (The paths include those directories specioed by the user for the
        compiler to search and those the compiler searches without explicit direction.)
        The orst path entry is the current directory of the compilation; if that entry is
        specioed using a relative path, it is relative to the location of the linked image
        containing the line table entries (assuming the image has not been moved).
        Each additional path entry is either a full path name or is relative to the
        current directory of the compilation.
        The line number program assigns a number (index) to each of the directory
        entries in order, beginning with 0.
        Prior to DWARF Version 5, the current compilation ole did not have a specioc entry
        in the file_names oeld. Starting in DWARF Version 5, the current ole name has
        index 0.
        Note that if a .debug_line_str section is present, both the compilation unit
        debugging information entry and the line number header can share a single copy of
        the current directory name string.
17.     file_name_format_count (ULEB128)
        A count of the number of format descriptors in the following
        file_name_format_table oeld.
18.     file_name_format_table (sequence of record format descriptors)
        A sequence of record format descriptors. Each descriptor consists of:
            #    A sequence of oeld descriptors. Each oeld descriptor consists of a pair of
                 unsigned LEB128 values: (a) a content type code (see Sections 6.2.4.1 on
                 the next page and 6.2.4.2 on page 166), and (b) a form code (using the
                 attribute form codes).
            #    A pair of zero bytes to terminate the descriptor.
        The line number program numbers the record format descriptors
        sequentially, beginning with 0.
  November 1, 2024                                  ***WORKING DRAFT***                                                           Page 163
                                     Chapter 6.  Other Debugging Information
        The format declarations describe the layout of the entries in the file_names
        oeld, below.
19.     file_names_count (ULEB128)
        A count of the number of ole name entries in the following file_names oeld.
20.     file_names (sequence of ole name entries)
        A sequence of ole name entries. Each entry consists of:
            #    A format code (ULEB128), which selects a record format descriptor from
                 the file_name_format_table, by its index.
            #    A sequence of oelds as described by the selected record format
                 descriptor.
        Each ole name entry describes a source ole that contributes to the line
        number information for this compilation or is used in other contexts, such as
        in a declaration coordinate or a macro ole inclusion.
        The orst ole name entry is the primary source ole, whose ole name exactly
        matches that given in the DW.AT.name attribute in the compilation unit
        debugging information entry.
        The line number program references ole names in this sequence beginning
        with 0, and uses those numbers instead of ole names in the line number
        program that follows.
        Prior to DWARF Version 5, the current compilation ole name was not represented in
        the file_names oeld. In DWARF Version 5and after, the current compilation ole
        name is explicitly present and has index 0. This is needed to support the common
        practice of stripping all but the line number sections fnad and .debug_line_str)
        from an executable.
        Note that if a .debug_line_str section is present, both the compilation unit
        debugging information entry and the line number header can share a single copy of
        the current ole name string.
  6.2.4.1        Standard Content Descriptions
  DWARF-deoned content type codes are used to indicate the type of information
  that is represented in one component of an include directory or ole name
  description. The following type codes are deoned.
  1.    DW.LNCT.path
        The component is a null-terminated path name string. If the associated form
        code is DW.FORM.string, then the string occurs immediately in the
  November 1, 2024                                  ***WORKING DRAFT***                                                           Page 164
                                   Chapter 6.  Other Debugging Information
      containing directories or file_names oeld. If the form code is
      DW.FORM.line.strp, then the string is included in the .debug_line_str
      section; if the form code is DW.FORM.strp or DW.FORM.strp8, then the
      string is included in the .debug_str section; if the form code is
      DW.FORM.strp.sup or DW.FORM.strp.sup8, then the string is included in
      the supplementary string section. In all cases other than DW.FORM.string,
      the string's ooeset occurs immediately in the containing directories or
      file_names oeld.
      In the 32-bit DWARF format, the representation of a DW.FORM.line.strp
      value is a 4-byte unsigned ooeset; in the 64-bit DWARF format, it is an 8-byte
      unsigned ooeset (see Section 7.4 on page 204).
      Note that this use of DW.FORM.line.strp is similar to DW.FORM.strp but refers
      to the .debug_line_str section, not .debug_str. It is needed to support the
      common practice of stripping all but the line number sections (.debug_line and
      .debug_line_str) from an executable.
      In a .debug_line.dwo section, the forms DW.FORM.strx, DW.FORM.strx1,
      DW.FORM.strx2, DW.FORM.strx3 and DW.FORM.strx4 may also be
      used. These refer into the .debug_str_offsets.dwo section (and indirectly
      also the .debug_str.dwo section) because no i.debug.line.str.ooesets.dwoj
      or i.debug.line.str.dwoj sections exist or are deoned for use in split objects.
      (The form DW.FORM.string may also be used, but this precludes the
      beneots of string sharing.)
2.    DW.LNCT.directory.index
      The unsigned directory index represents an entry in the directories oeld of
      the header. The index is 0 if the ole was found in the current directory of the
      compilation (hence, the orst directory in the directories oeld), 1 if it was
      found in the second directory in the directories oeld, and so on.
      This content code is always paired with one of the forms DW.FORM.data1,
      DW.FORM.data2 or DW.FORM.udata.
      The optimal form for a producer to use (which results in the minimum size for the set
      of include_index oelds) depends not only on the number of directories in the
      directories oeld, but potentially on the order in which those directories are listed and
      the number of times each is used in the file_names oeld.
3.    DW.LNCT.timestamp
      DW.LNCT.timestamp indicates that the value is the
      implementation-deoned time of last modiocation of the ole, or 0 if not
      available. It is always paired with one of the forms DW.FORM.udata,
      DW.FORM.data4, DW.FORM.data8 or DW.FORM.block.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 165
                                   Chapter 6.  Other Debugging Information
4.    DW.LNCT.size
      DW.LNCT.size indicates that the value is the unsigned size of the ole in
      bytes, or 0 if not available. It is paired with one of the forms
      DW.FORM.udata, DW.FORM.data1, DW.FORM.data2, DW.FORM.data4
      or DW.FORM.data8.
5.    DW.LNCT.MD5
      DW.LNCT.MD5 indicates that the value is a 16-byte MD5 digest of the ole
      contents. It is paired with form DW.FORM.data16.
6.    DW.LNCT.source
      DW.LNCT.source specioes a null-terminated UTF-8 string that constitutes
      the source text for the program. It is paired with the same forms as
      DW.LNCT.path.
      When the source oeld is present, consumers use the embedded source instead of
      accessing the source using the ole path provided by the DW.LNCT.path oeld.
      This is useful for programming languages that support runtime compilation and
      runtime generation of source text. In these cases, the source text does not reside in
      any permanent ole. For example, the OpenCL C language supports runtime
      compilation.
7.    DW.LNCT.URL
      DW.LNCT.URL specioes a null-terminated UTF-8 string that identioes
      where the source text for the program is found on the Internet. It is paired
      with the same forms as DW.LNCT.path.
An example that uses this line number header format is found in Appendix D.5.1 on
page 342.
6.2.4.2        Producer-deoned Content Descriptions
Producer-deoned content descriptions may be deoned using content type codes
in the range DW.LNCT.lo.user to DW.LNCT.hi.user. Each such code may be
combined with one or more forms from the set: DW.FORM.block,
DW.FORM.block1, DW.FORM.block2, DW.FORM.block4, DW.FORM.data1,
DW.FORM.data2, DW.FORM.data4, DW.FORM.data8, DW.FORM.data16,
DW.FORM.AEag, DW.FORM.line.strp, DW.FORM.sdata,
DW.FORM.sec.ooeset, DW.FORM.string, DW.FORM.strp, DW.FORM.strp8,
DW.FORM.strp.sup, DW.FORM.strp.sup8, DW.FORM.strx,
DW.FORM.strx1, DW.FORM.strx2, DW.FORM.strx3, DW.FORM.strx4 and
DW.FORM.udata.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 166
                                   Chapter 6.  Other Debugging Information
If a consumer encounters a producer-deoned content type that it does not understand, it
should skip the content data as though it were not present.
6.2.5          The Line Number Program
As stated before, the goal of a line number program is to build a matrix
representing one compilation unit, which may have produced multiple
sequences of target machine instructions. Within a sequence, addresses and
operation pointers may only increase. (Line numbers may decrease in cases of
pipeline scheduling or other optimization.)
6.2.5.1        Special Opcodes
Each ubyte special opcode has the following eoeect on the state machine:
1.    Add a signed integer to the line register.
2.    Modify the operation pointer by incrementing the address and op_index
      registers as described below.
3.    Append a row to the matrix using the current values of the state machine
      registers.
4.    Set the basic_block register to ifalse.j
5.    Set the prologue_end register to ifalse.j
6.    Set the epilogue_begin register to ifalse.j
7.    Set the epilogue_epilogue register to ifalse.j
8.    Set the discriminator register to 0.
All of the special opcodes do those same things; they dioeer from one another
only in what values they add to the line, address and op_index registers.
Instead of assigning a oxed meaning to each special opcode, the line number program
uses several parameters in the header to conogure the instruction set. There are two
reasons for this. First, although the opcode space available for special opcodes ranges from
13 through 255, the lower bound may increase if one adds new standard opcodes. Thus,
the opcode_base oeld of the line number program header gives the value of the orst
special opcode. Second, the best choice of special-opcode meanings depends on the target
architecture. For example, for a RISC machine where the compiler-generated code
interleaves instructions from dioeerent lines to schedule the pipeline, it is important to be
able to add a negative value to the line register to express the fact that a later instruction
may have been emitted for an earlier source line. For a machine where pipeline scheduling
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 167
                                   Chapter 6.  Other Debugging Information
never occurs, it is advantageous to trade away the ability to decrease the line register (a
standard opcode provides an alternate way to decrease the line number) in return for the
ability to add larger positive values to the address register. To permit this variety of
strategies, the line number program header deones a line_base oeld that specioes the
minimum value which a special opcode can add to the line register and a line_range
oeld that deones the range of values it can add to the line register.
A special opcode value is chosen based on the amount that needs to be added to
the line, address and op_index registers. The maximum line increment for a
special opcode is the value of the line_base oeld in the header, plus the value of
the line_range oeld, minus 1 (line base + line range - 1). If the desired line
increment is greater than the maximum line increment, a standard opcode must
be used instead of a special opcode. The operation advance represents the
number of operations to skip when advancing the operation pointer.
The special opcode is then calculated using the following formula:
    opcode  =
        (desired  line  increment   -  line_base)  +
            (line_range  *  operation  advance )  +  opcode_base
If the resulting opcode is greater than 255, a standard opcode must be used
instead.
When maximum_operations_per_instruction is 1, the operation advance is simply
the address increment divided by the minimum_instruction_length.
To decode a special opcode, subtract the opcode_base from the opcode itself to
give the adjusted opcode. The operation advance is the result of the adjusted opcode
divided by the line_range. The new address and op_index values are given by
    adjusted  opcode   =  opcode  -  opcode_base
    operation  advance   =  adjusted  opcode   /  line_range
    new  address  =  address  +
        minimum_instruction_length  *
            ((op_index  +  operation  advance)  /  maximum_operations_per_instruction)
    new  op_index  =
        (op_index  +  operation  advance)  %  maximum_operations_per_instruction
When the maximum_operations_per_instruction oeld is 1, op_index is always 0
and these calculations simplify to those given for addresses in DWARF Version 3 and
earlier.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 168
                                   Chapter 6.  Other Debugging Information
The amount to increment the line register is the line_base plus the result of the
adjusted opcode modulo the line_range. That is,
    line  increment  =  line_base  +  (adjusted  opcode   %  line_range)
See Appendix D.5.2 on page 343 for an example.
6.2.5.2        Standard Opcodes
The standard opcodes, their applicable operands and the actions performed by
these opcodes are as follows:
1.    DW.LNS.copy
      The DW.LNS.copy opcode takes no operands. It appends a row to the
      matrix using the current values of the state machine registers. Then it sets the
      discriminator register to 0, and sets the basic_block, prologue_end,
      epilogue_begin and prologue_epilogue registers to ifalse.j
2.    DW.LNS.advance.pc
      The DW.LNS.advance.pc opcode takes a single unsigned LEB128 operand
      as the operation advance and modioes the address and op_index registers as
      specioed in Section 6.2.5.1 on page 167.
3.    DW.LNS.advance.line
      The DW.LNS.advance.line opcode takes a single signed LEB128 operand
      and adds that value to the line register of the state machine.
4.    DW.LNS.set.ole
      The DW.LNS.set.ole opcode takes a single unsigned LEB128 operand and
      stores it in the file register of the state machine.
5.    DW.LNS.set.column
      The DW.LNS.set.column opcode takes a single unsigned LEB128 operand
      and stores it in the column register of the state machine.
6.    DW.LNS.negate.stmt
      The DW.LNS.negate.stmt opcode takes no operands. It sets the is_stmt
      register of the state machine to the logical negation of its current value.
7.    DW.LNS.set.basic.block
      The DW.LNS.set.basic.block opcode takes no operands. It sets the
      basic_block register of the state machine to itrue.j
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 169
                                     Chapter 6.  Other Debugging Information
  8.    DW.LNS.const.add.pc
        The DW.LNS.const.add.pc opcode takes no operands. It advances the
        address and op_index registers by the increments corresponding to special
        opcode 255.
        When the line number program needs to advance the address by a small amount, it
        can use a single special opcode, which occupies a single byte. When it needs to
        advance the address by up to twice the range of the last special opcode, it can use
        DW.LNS.const.add.pc followed by a special opcode, for a total of two bytes. Only if
        it needs to advance the address by more than twice that range will it need to use both
        DW.LNS.advance.pc and a special opcode, requiring three or more bytes.
  9.    DW.LNS.oxed.advance.pc
        The DW.LNS.oxed.advance.pc opcode takes a single uhalf (unencoded)
        operand and adds it to the address register of the state machine and sets the
        op_index register to 0. This is the only standard opcode whose operand is not
        a variable length number. It also does not multiply the operand by the
        minimum_instruction_length oeld of the header.
        Some assemblers may not be able emit DW.LNS.advance.pc or special opcodes
        because they cannot encode LEB128 numbers or judge when the computation of a
        special opcode overAEows and requires the use of DW.LNS.advance.pc. Such
        assemblers, however, can use DW.LNS.oxed.advance.pc instead, sacriocing
        compression.
10.     DW.LNS.set.prologue.end
        The DW.LNS.set.prologue.end opcode takes no operands. It sets the
        prologue_end register to itrue.j
        When a breakpoint is set on entry to a function, it is generally desirable for execution
        to be suspended, not on the very orst instruction of the function, but rather at a point
        after the function's frame has been set up, after any language deoned local declaration
        processing has been completed, and before execution of the orst statement of the
        function begins. Debuggers generally cannot properly determine where this point is.
        This command allows a compiler to communicate the location(s) to use.
        In the case of optimized code, there may be more than one such location; for example,
        the code might test for a special case and make a fast exit prior to setting up the frame.
        Note that the function to which the prologue  end applies cannot be directly
        determined from the line number information alone; the function must be determined
        in combination with the subroutine information entries of the compilation (including
        inlined subroutines).
  November 1, 2024                                  ***WORKING DRAFT***                                                           Page 170
                                     Chapter 6.  Other Debugging Information
11.     DW.LNS.set.epilogue.begin
        The DW.LNS.set.epilogue.begin opcode takes no operands. It sets the
        epilogue_begin and prologue_epilogue registers to itrue.j
        When a breakpoint is set on the exit of a function or execution steps over the last
        executable statement of a function, it is generally desirable to suspend execution after
        completion of the last statement but prior to tearing down the frame (so that local
        variables can still be examined). Debuggers generally cannot properly determine
        where this point is. This command allows a compiler to communicate the location(s)
        to use.
        Note that the function to which the epilogue end applies cannot be directly
        determined from the line number information alone; the function must be determined
        in combination with the subroutine information entries of the compilation (including
        inlined subroutines).
        In the case of a trivial function, both prologue  end and epilogue  begin may
        occur at the same address.
12.     DW.LNS.set.isa
        The DW.LNS.set.isa opcode takes a single unsigned LEB128 operand and
        stores that value in the isa register of the state machine.
13.     DW.LNS.extended.op
        The DW.LNS.extended.op opcode takes two operands. The orst is an
        unsigned LEB128 value that gives the size of the operand that follows. The
        second begins with an extended opcode which is followed by operands
        appropriate to that opcode.
  6.2.5.3        Extended Opcodes
  Extended opcodes are used as part of a DW.LNS.extended.op operation (see
  Section 6.2.3 on page 159).
  The extended opcodes are as follows:
  1.    DW.LNE.end.sequence
        The DW.LNE.end.sequence opcode takes no operands. It sets the
        end_sequence register of the state machine to itruej and appends a row to
        the matrix using the current values of the state-machine registers. Then it
        resets the registers to the initial values specioed above (see Section 6.2.2 on
        page 157). Every line number program sequence must end with a
        DW.LNE.end.sequence instruction which creates a row whose address is
        that of the byte after the last target machine instruction of the sequence.
  November 1, 2024                                  ***WORKING DRAFT***                                                           Page 171
                                   Chapter 6.  Other Debugging Information
2.    DW.LNE.set.address
      The DW.LNE.set.address opcode takes a single relocatable address as an
      operand. The size of the operand is the size of an address on the target
      machine. It sets the address register to the value given by the relocatable
      address and sets the op_index register to 0.
      If the address value is the reserved target address (see Section 2.4.1 on
      page 26), no instructions are associated with subsequent rows up to but not
      including the subsequent DW.LNE.set.address or DW.LNE.end.sequence
      opcode, which is equivalent to omitting that sequence of opcodes.
      All of the other line number program opcodes that aoeect the address register add a
      delta to it. This instruction stores a relocatable value into the address register instead.
3.    DW.LNE.set.discriminator
      The DW.LNE.set.discriminator opcode takes a single parameter, an
      unsigned LEB128 integer. It sets the discriminator register to the new value.
4.    DW.LNE.padding
      The DW.LNE.padding opcode is followed by a single operand which
      consists of a sequence of zero or more arbitrary bytes up to the length
      specioed by the unsigned LEB128 integer that precedes all extended opcodes.
      The opcode and operand have no eoeect on the line number program.
      This permits a producer to pad or overwrite arbitrary parts of a line number program,
      with a minimum of the three bytes needed to encode any extended opcode.
5.    DW.LNE.set.prologue.epilogue
      The DW.LNE.set.prologue.epilogue opcode takes no operands. It sets the
      prologue_epilogue register to "true."
Appendix D.5.3 on page 344 gives some sample line number programs.
6.3          Macro  Information
Some languages, such as C and C++, provide a way to replace text in the source program
with macros deoned either in the source ole itself, or in another ole included by the source
ole. Because these macros are not themselves deoned in the target language, it is diOEcult
to represent their deonitions using the standard language constructs of DWARF. The
debugging information therefore reAEects the state of the source after the macro deonition
has been expanded, rather than as the programmer wrote it. The macro information table
provides a way of preserving the original source in the debugging information.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 172
                                   Chapter 6.  Other Debugging Information
As described in Section 3.1.1 on page 62, the macro information for a given
compilation unit is represented in the .debug_macro section of an object ole.
The macro information for each compilation unit consists of one or more macro
units. Each macro unit starts with a header and is followed by a series of macro
information entries or ole inclusion entries. Each entry consists of an opcode
followed by zero or more operands. Each macro unit ends with an entry
containing an opcode of 0.
In all macro information entries, the line number of the entry is encoded as an
unsigned LEB128 integer.
6.3.1          Macro Information Header
The macro information header contains the following oelds:
1.    version (uhalf)
      A version number (see Section 7.23 on page 249). This number is specioc to
      the macro information and is independent of the DWARF version number.
2.    flags (ubyte)
      The bits of the flags oeld are interpreted as a set of AEags, some of which may
      indicate that additional oelds follow.
      The following AEags, beginning with the least signiocant bit, are deoned:
          #    offset_size_flag
               If the offset_size_flag is zero, the header is for a 32-bit DWARF format
               macro section and all ooesets are 4 bytes long; if it is one, the header is for
               a 64-bit DWARF format macro section and all ooesets are 8 bytes long.
               This AEag does not apply to the the following entries:
               DW.MACRO.deone.sup4, DW.MACRO.deone.sup8,
               DW.MACRO.undef.sup4, DW.MACRO.undef.sup8,
               DW.MACRO.import.sup4 and DW.MACRO.import.sup8.
          #    debug_line_offset_flag
               If the debug_line_offset_flag is one, the debug_line_offset oeld (see
               below) is present. If zero, that oeld is omitted.
          #    opcode_operands_table_flag
               If the opcode_operands_table_flag is one, the opcode_operands_table
               oeld (see below) is present. If zero, that oeld is omitted.
      All other AEags are reserved by DWARF.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 173
                                   Chapter 6.  Other Debugging Information
3.    debug_line_offset
      An ooeset in the .debug_line section (if this header is in a .debug_macro
      section) or .debug_line.dwo section (if this header is in a .debug_macro.dwo
      section) of the beginning of the line number information in the containing
      compilation, encoded as a 4-byte ooeset for a 32-bit DWARF format macro
      section and an 8-byte ooeset for a 64-bit DWARF format macro section.
4.    opcode_operands_table
      An opcode_operands_table describing the operands of the macro
      information entry opcodes.
      The macro information entries deoned in this standard may, but need not, be
      described in the table, while other producer-deoned entry opcodes used in
      the section are described there. Producer extension entry opcodes are
      allocated in the range from DW.MACRO.lo.user to DW.MACRO.hi.user.
      Other unassigned codes are reserved for future DWARF standards.
      The table starts with a 1-byte count of the deoned opcodes, followed by an
      entry for each of those opcodes. Each entry starts with a 1-byte unsigned
      opcode number, followed by unsigned LEB128 encoded number of operands
      and for each operand there is a single unsigned byte describing the form in
      which the operand is encoded. The allowed forms are: DW.FORM.block,
      DW.FORM.block1, DW.FORM.block2, DW.FORM.block4,
      DW.FORM.data1, DW.FORM.data2, DW.FORM.data4,
      DW.FORM.data8, DW.FORM.data16, DW.FORM.AEag,
      DW.FORM.line.strp, DW.FORM.sdata, DW.FORM.sec.ooeset,
      DW.FORM.string, DW.FORM.strp, DW.FORM.strp8,
      DW.FORM.strp.sup, DW.FORM.strp.sup8, DW.FORM.strx,
      DW.FORM.strx1, DW.FORM.strx2, DW.FORM.strx3, DW.FORM.strx4
      and DW.FORM.udata.
6.3.2          Macro Information Entries
All macro information entries within a .debug_macro section for a given
compilation unit appear in the same order in which the directives were
processed by the compiler (after taking into account the eoeect of the macro
import directives).
The source ole in which a macro information entry occurs can be derived by interpreting
the sequence of entries from the beginning of the .debug_macro section.
DW.MACRO.start.ole and DW.MACRO.end.ole indicate changes in the containing
ole.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 174
                                   Chapter 6.  Other Debugging Information
6.3.2.1        Deone and Undeone Entries
The deone and undeone macro entries have multiple forms that use dioeerent
representations of their two operands.
While described in pairs below, the forms of deone and undeone entries may be
freely intermixed.
1.    DW.MACRO.deone, DW.MACRO.undef
      A DW.MACRO.deone or DW.MACRO.undef entry has two operands. The
      orst operand encodes the source line number of the #define or #undef macro
      directive. The second operand is a null-terminated character string for the
      macro being deoned or undeoned.
      The contents of the operands are described below (see Sections 6.3.2.2 and
      6.3.2.3 following).
2.    DW.MACRO.deone.strp, DW.MACRO.undef.strp
      A DW.MACRO.deone.strp or DW.MACRO.undef.strp entry has two
      operands. The orst operand encodes the source line number of the #define or
      #undef macro directive. The second operand consists of an ooeset into a string
      table contained in the .debug_str section of the object ole. The size of the
      operand is given in the header offset_size_flag oeld.
      The contents of the operands are described below (see Sections 6.3.2.2 and
      6.3.2.3 following).
3.    DW.MACRO.deone.strx, DW.MACRO.undef.strx
      A DW.MACRO.deone.strx or DW.MACRO.undef.strx entry has two
      operands. The orst operand encodes the line number of the #define or
      #undef macro directive. The second operand identioes a string; it is
      represented using an unsigned LEB128 encoded value, which is interpreted as
      a zero-based index into an array of ooesets in the .debug_str_offsets section.
      The contents of the operands are described below (see Sections 6.3.2.2 and
      6.3.2.3 following).
4.    DW.MACRO.deone.sup4, DW.MACRO.deone.sup8,
      DW.MACRO.undef.sup4, DW.MACRO.undef.sup8
      A DW.MACRO.deone.sup4, DW.MACRO.deone.sup8,
      DW.MACRO.undef.sup4 or DW.MACRO.undef.sup8 entry has two
      operands. The orst operand encodes the line number of the #define or
      #undef macro directive. The second operand identioes a string; it is
      represented as an ooeset into a string table contained in the .debug_str
      section of the supplementary object ole. The size of the operand is 4-bytes for
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 175
                                   Chapter 6.  Other Debugging Information
      DW.MACRO.deone.sup4 and DW.MACRO.undef.sup4, and 8-bytes for
      DW.MACRO.deone.sup8 and DW.MACRO.undef.sup8.
      The contents of the operands are described below (see Sections 6.3.2.2 and
      6.3.2.3 following).
6.3.2.2        Macro Deone String
In the case of a DW.MACRO.deone, DW.MACRO.deone.strp,
DW.MACRO.deone.strx, DW.MACRO.deone.sup4 or
DW.MACRO.deone.sup8 entry, the value of the second operand is the name of
the macro symbol that is deoned at the indicated source line, followed
immediately by the macro formal parameter list including the surrounding
parentheses (in the case of a function-like macro) followed by the deonition
string for the macro. If there is no formal parameter list, then the name of the
deoned macro is followed immediately by its deonition string.
In the case of a function-like macro deonition, no whitespace characters appear
between the name of the deoned macro and the following left parenthesis.
Formal parameters are separated by a comma without any whitespace. Exactly
one space character separates the right parenthesis that terminates the formal
parameter list and the following deonition string.
In the case of a inormalj (that is, non-function-like) macro deonition, exactly one
space character separates the name of the deoned macro from the following
deonition text.
6.3.2.3        Macro Undeone String
In the case of a DW.MACRO.undef, DW.MACRO.undef.strp,
DW.MACRO.undef.strx, DW.MACRO.undef.sup4 or
DW.MACRO.undef.sup8 entry, the value of the second string is the name of the
pre-processor symbol that is undeoned at the indicated source line.
6.3.2.4        Entries for Command Line Options
A DWARF producer generates a deone or undeone entry for each pre-processor
symbol which is deoned or undeoned by some means other than such a directive
within the compiled source text. In particular, pre-processor symbol deonitions
and undeonitions which occur as a result of command line options (when
invoking the compiler) are represented by their own deone and undeone entries.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 176
                                   Chapter 6.  Other Debugging Information
All such deone and undeone entries representing compilation options appear
before the orst DW.MACRO.start.ole entry for that compilation unit (see
Section 6.3.3 following) and encode the value 0 in their line number operands.
6.3.3          File Inclusion Entries
6.3.3.1        Source Include Directives
The following directives describe a source ole inclusion directive (#include in
C/C++) and the ending of an included ole.
1.    DW.MACRO.start.ole
      A DW.MACRO.start.ole entry has two operands. The orst operand encodes
      the line number of the source line on which the #include macro directive
      occurs. The second operand encodes a source ole name index.
      The source ole name index is the ole number in the line number information
      table for the compilation unit.
      If a DW.MACRO.start.ole entry is present, the header contains a reference
      to the .debug_line section or .debug_line.dwo section of the compilation, as
      appropriate.
2.    DW.MACRO.end.ole
      A DW.MACRO.end.ole entry has no operands. The presence of the entry
      marks the end of the current source ole inclusion.
When providing macro information in an object ole, a producer generates
DW.MACRO.start.ole and DW.MACRO.end.ole entries for the source ole
submitted to the compiler for compilation. This DW.MACRO.start.ole entry
has the value 0 in its line number operand and references the ole entry in the line
number information table for the primary source ole.
6.3.3.2        Importation of Macro Units
The import entries make it possible to replicate macro units. The orst form
supports replication within the current compilation and the second form
supports replication across separate executable or shared object oles.
Import entries do not reAEect the source program and, in fact, are not necessary at all.
However, they do provide a mechanism that can be used to reduce redundancy in the
macro information and thereby to save space.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 177
                                   Chapter 6.  Other Debugging Information
1.    DW.MACRO.import
      A DW.MACRO.import entry has one operand, an ooeset into another part of
      the .debug_macro section that is the beginning of a target macro unit. The size
      of the operand depends on the header offset_size_flag oeld. The
      DW.MACRO.import entry instructs the consumer to replicate the sequence
      of entries following the target macro header which begins at the given
      .debug_macro ooeset, up to, but excluding, the terminating entry with opcode
      0, as though the sequence of entries occurs in place of the import operation.
2.    DW.MACRO.import.sup4, DW.MACRO.import.sup8
      A DW.MACRO.import.sup4 or DW.MACRO.import.sup8 entry has one
      operand, an ooeset from the start of the .debug_macro section in the
      supplementary object ole. The size of the operand is 4 bytes for
      DW.MACRO.import.sup4 and 8 bytes for DW.MACRO.import.sup8.
      Apart from the dioeerent location in which to ond the macro unit, this entry
      type is equivalent to DW.MACRO.import.
       These entry types are aimed at sharing duplicate macro units between
      .debug_macro sections from dioeerent executable or shared object oles.
      From within the .debug_macro section of the supplementary object ole,
      DW.MACRO.deone.strp and DW.MACRO.undef.strp entries refer to the
      .debug_str section of that same supplementary ole; similarly,
      DW.MACRO.import entries refer to the .debug_macro section of that same
      supplementary ole.
6.3.4          Other Entries
1.    DW.MACRO.padding
      The DW.MACRO.padding opcode takes two operands, a byte count and a
      sequence of arbitrary bytes. The byte count is an unsigned unsigned LEB128
      encoded number and does not include the size of the opcode or the byte count
      operand. The opcode and operands have no eoeect on the macro information.
      This permits a producer to pad the macro information with a minimum of two bytes.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 178
                                   Chapter 6.  Other Debugging Information
6.4          Call  Frame  Information
Debuggers often need to be able to view and modify the state of any subroutine activation
that is on the call stack. An activation consists of:
     #    A code location that is within the subroutine. This location is either the place where
          the program stopped when the debugger got control (for example, a breakpoint), or
          is a place where a subroutine made a call or was interrupted by an asynchronous
          event (for example, a signal).
     #    An area of memory that is allocated on a stack called a icall frame.j The call frame
          is identioed by an address on the stack. We refer to this address as the Canonical
          Frame Address or CFA. Typically, the CFA is deoned to be the value of the stack
          pointer at the call site in the previous frame (which may be dioeerent from its value
          on entry to the current frame).
     #    A set of registers that are in use by the subroutine at the code location.
Typically, a set of registers are designated to be preserved across a call. If a callee wishes
to use such a register, it saves the value that the register had at entry time in its call frame
and restores it on exit. The code that allocates space on the call frame stack and performs
the save operation is called the subroutine's prologue, and the code that performs the
restore operation and deallocates the frame is called its epilogue. Typically, the prologue
code is physically at the beginning of a subroutine and the epilogue code is at the end.
To be able to view or modify an activation that is not on the top of the call frame stack, the
debugger must virtually unwind the stack of activations until it onds the activation of
interest. A debugger virtually unwinds a stack in steps. Starting with the current
activation it virtually restores any registers that were preserved by the current activation
and computes the predecessor's CFA and code location. This has the logical eoeect of
returning from the current subroutine to its predecessor. We say that the debugger
virtually unwinds the stack because the actual state of the target process is unchanged.
The virtual unwind operation needs to know where registers are saved and how to
compute the predecessor's CFA and code location. When considering an
architecture-independent way of encoding this information one has to consider a number
of special things:
     #    Prologue and epilogue code is not always in distinct blocks at the beginning and
          end of a subroutine. It is common to duplicate the epilogue code at the site of each
          return from the code. Sometimes a compiler breaks up the register save/unsave
          operations and moves them into the body of the subroutine to just where they are
          needed.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 179
                                   Chapter 6.  Other Debugging Information
     #    Compilers use dioeerent ways to manage the call frame. Sometimes they use a frame
          pointer register, sometimes not.
     #    The algorithm to compute CFA changes as you progress through the prologue and
          epilogue code. (By deonition, the CFA value does not change.)
     #    Some subroutines have no call frame.
     #    Sometimes a register is saved in another register that by convention does not need
          to be saved.
     #    Some architectures have special instructions that perform some or all of the register
          management in one instruction, leaving special information on the stack that
          indicates how registers are saved.
     #    Some architectures treat return address values specially. For example, in one
          architecture, the call instruction guarantees that the low order two bits will be zero
          and the return instruction ignores those bits. This leaves two bits of storage that
          are available to other uses that must be treated specially.
6.4.1          Structure of Call Frame Information
DWARF supports virtual unwinding by deoning an architecture independent
basis for recording how subprograms save and restore registers during their
lifetimes. This basis must be augmented on some machines with specioc
information that is deoned by an architecture specioc ABI authoring committee,
a hardware vendor, or a compiler producer. The body deoning a specioc
augmentation is referred to below as the iaugmenter.j
Abstractly, this mechanism describes a very large table that has the following
structure:
                 LOC  CFA  R0  R1  ...  RN
                 L0
                 L1
                 ...
                 LN
The orst column indicates an address for every location that contains code in a
program. (In shared object oles, this is an object-relative ooeset.) The remaining
columns contain virtual unwinding rules that are associated with the indicated
location.
The CFA column deones the rule which computes the Canonical Frame Address
value; the rule may indicate either a register and a signed ooeset that are added
together, or a DWARF expression that is evaluated.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 180
                                   Chapter 6.  Other Debugging Information
The remaining columns are labelled by register number. This includes some
registers that have special designation on some architectures such as the PC and
the stack pointer register. (The actual mapping of registers for a particular
architecture is deoned by the augmenter.) The register columns contain rules that
describe whether a given register has been saved and the rule to ond the value
for the register in the previous frame.
The register rules are:
           undeoned                            A register that has this rule has no recoverable
                                               value in the previous frame. (By convention, it
                                               is not preserved by a callee.)
           same value                          This register has not been modioed from the
                                               previous frame. (By convention, it is preserved
                                               by the callee, but the callee has not modioed it.)
           ooeset(N)                           The previous value of this register is saved at
                                               the address CFA+N where CFA is the current
                                               CFA value and N is a signed ooeset.
           val.ooeset(N)                       The previous value of this register is the value
                                               CFA+N where CFA is the current CFA value
                                               and N is a signed ooeset.
           register(R)                         The previous value of this register is stored in
                                               another register numbered R.
           expression(E)                       The previous value of this register is located at
                                               the address produced by executing the DWARF
                                               expression E (see Section 2.5 on page 26).
           val.expression(E)                   The previous value of this register is the value
                                               produced by executing the DWARF expression
                                               E (see Section 2.5 on page 26).
           architectural                       The rule is deoned externally to this
                                               speciocation by the augmenter.
This table would be extremely large if actually constructed as described. Most of the
entries at any point in the table are identical to the ones above them. The whole table can
be represented quite compactly by recording just the dioeerences starting at the beginning
address of each subroutine in the program.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 181
                                   Chapter 6.  Other Debugging Information
The virtual unwind information is encoded in a self-contained section called
.debug_frame. Entries in a .debug_frame section are aligned on a multiple of the
address size relative to the start of the section and come in two forms: a Common
Information Entry (CIE) and a Frame Description Entry (FDE).
If the range of code addresses for a function is not contiguous, there may be multiple CIEs
and FDEs corresponding to the parts of that function.
A Common Information Entry holds information that is shared among many
Frame Description Entries. There is at least one CIE in every non-empty
.debug_frame section. A CIE contains the following oelds, in order:
1.    length (initial length)
      A constant that gives the number of bytes of the CIE structure, not including
      the length oeld itself (see Section 7.2.2 on page 192). The size of the length
      oeld plus the value of length must be an integral multiple of the address size.
2.    CIE_id (4 or 8 bytes, see Section 7.4 on page 204)
      A constant that is used to distinguish CIEs from FDEs.
3.    version (ubyte)
      A version number (see Section 7.24 on page 251). This number is specioc to
      the call frame information and is independent of the DWARF version number.
4.    augmentation (sequence of UTF-8 characters)
      A null-terminated UTF-8 string that identioes the augmentation to this CIE or
      to the FDEs that use it. If a reader encounters an augmentation string that is
      unexpected, then only the following oelds can be read:
          #    CIE: length, CIE_id, version, augmentation
          #    FDE: length, CIE_pointer, initial_location, address_range
      If there is no augmentation, this value is a zero byte.
      The augmentation string allows users to indicate that there is additional
      target-specioc information in the CIE or FDE which is needed to virtually unwind a
      stack frame. For example, this might be information about dynamically allocated data
      which needs to be freed on exit from the routine.
      Because the .debug_frame section is useful independently of any .debug_info
      section, the augmentation string always uses UTF-8 encoding.
5.    address_size (ubyte)
      The size of a target address in bytes in this CIE and any FDEs that use it. If a
      compilation unit exists for this frame, its address size must match the address
      size here.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 182
                                     Chapter 6.  Other Debugging Information
  6.    reserved 3  (ubyte, MBZ)
  7.    code_alignment_factor (unsigned LEB128)
        A constant that is factored out of all advance location instructions (see Section
        6.4.2.1 on the following page). The resulting value is
        operand * code_alignment_factor                             .
  8.    data_alignment_factor (signed LEB128)
        A constant that is factored out of certain ooeset instructions (see Sections
        6.4.2.2 on page 185 and 6.4.2.3 on page 186). The resulting value is
        operand * data_alignment_factor                             .
  9.    return_address_register (unsigned LEB128)
        An unsigned LEB128 constant that indicates which column in the rule table
        represents the return address of the function. Note that this column might not
        correspond to an actual machine register.
10.     initial_instructions (array of ubyte)
        A sequence of rules that are interpreted to create the initial setting of each
        column in the table.
        The default rule for all columns before interpretation of the initial instructions
        is the undeoned rule. However, an ABI authoring body or a compilation
        system authoring body may specify an alternate default value for any or all
        columns.
11.     padding (array of ubyte)
        Enough DW.CFA.nop instructions to make the size of this entry match the
        length value above.
  An FDE contains the following oelds, in order:
  1.    length (initial length)
        A constant that gives the number of bytes of the header and instruction
        stream for this function, not including the length oeld itself (see Section 7.2.2
        on page 192). The size of the length oeld plus the value of length must be an
        integral multiple of the address size.
  2.    CIE_pointer (4 or 8 bytes, see Section 7.4 on page 204)
        A constant ooeset into the .debug_frame section that denotes the CIE that is
        associated with this FDE.
  _________________________________________________________
        3This allows backward compatible support of the deprecated segment_selector_size oeld
  which was deoned in DWARF Version 5 and earlier.
  November 1, 2024                                  ***WORKING DRAFT***                                                           Page 183
                                   Chapter 6.  Other Debugging Information
3.    initial_location (target address)
      The address of the orst location associated with this table entry.
4.    address_range (target address)
      The number of bytes of program instructions described by this entry.
5.    instructions (array of ubyte)
      A sequence of table deoning instructions that are described in Section 6.4.2.
6.    padding (array of ubyte)
      Enough DW.CFA.nop instructions to make the size of this entry match the
      length value above.
6.4.2          Call Frame Instructions
Each call frame instruction is deoned to take 0 or more operands. Some of the
operands may be encoded as part of the opcode (see Section 7.24 on page 251).
The instructions are deoned in the following sections.
Some call frame instructions have operands that are encoded as DWARF
expressions (see Section 2.5.1 on page 27). The following DWARF operators
cannot be used in such operands:
     #    DW.OP.addrx, DW.OP.call2, DW.OP.call4, DW.OP.call.ref,
          DW.OP.const.type, DW.OP.constx, DW.OP.convert,
          DW.OP.deref.type, DW.OP.regval.type and DW.OP.reinterpret
          operators are not allowed in an operand of these instructions because the
          call frame information must not depend on other debug sections.
     #    DW.OP.push.object.address is not meaningful in an operand of these
          instructions because there is no object context to provide a value to push.
     #    DW.OP.call.frame.cfa is not meaningful in an operand of these
          instructions because its use would be circular.
Call frame instructions to which these restrictions apply include
DW.CFA.def.cfa.expression, DW.CFA.expression and DW.CFA.val.expression.
6.4.2.1        Row Creation Instructions
1.    DW.CFA.set.loc
      The DW.CFA.set.loc instruction takes a single operand that represents a
      target address. The required action is to create a new table row using the
      specioed address as the location. All other values in the new row are initially
      identical to the current row. The new location value is always greater than the
      current one.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 184
                                   Chapter 6.  Other Debugging Information
2.    DW.CFA.advance.loc
      The DW.CFA.advance.loc instruction takes a single operand (encoded with
      the opcode) that represents a constant delta. The required action is to create a
      new table row with a location value that is computed by taking the current
      entry's location value and adding the value of delta * code_alignment_factor                         .
      All other values in the new row are initially identical to the current row
3.    DW.CFA.advance.loc1
      The DW.CFA.advance.loc1 instruction takes a single ubyte operand that
      represents a constant delta. This instruction is identical to
      DW.CFA.advance.loc except for the encoding and size of the delta operand.
4.    DW.CFA.advance.loc2
      The DW.CFA.advance.loc2 instruction takes a single uhalf operand that
      represents a constant delta. This instruction is identical to
      DW.CFA.advance.loc except for the encoding and size of the delta operand.
5.    DW.CFA.advance.loc4
      The DW.CFA.advance.loc4 instruction takes a single uword operand that
      represents a constant delta. This instruction is identical to
      DW.CFA.advance.loc except for the encoding and size of the delta operand.
6.4.2.2        CFA Deonition Instructions
1.    DW.CFA.def.cfa
      The DW.CFA.def.cfa instruction takes two unsigned LEB128 operands
      representing a register number and a (non-factored) ooeset. The required
      action is to deone the current CFA rule to use the provided register and ooeset.
2.    DW.CFA.def.cfa.sf
      The DW.CFA.def.cfa.sf instruction takes two operands: an unsigned
      LEB128 value representing a register number and a signed LEB128 factored
      ooeset. This instruction is identical to DW.CFA.def.cfa except that the second
      operand is signed and factored. The resulting ooeset is
      factored.ooeset * data_alignment_factor                               .
3.    DW.CFA.def.cfa.register
      The DW.CFA.def.cfa.register instruction takes a single unsigned LEB128
      operand representing a register number. The required action is to deone the
      current CFA rule to use the provided register (but to keep the old ooeset). This
      operation is valid only if the current CFA rule is deoned to use a register and
      ooeset.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 185
                                   Chapter 6.  Other Debugging Information
4.    DW.CFA.def.cfa.ooeset
      The DW.CFA.def.cfa.ooeset instruction takes a single unsigned LEB128
      operand representing a (non-factored) ooeset. The required action is to deone
      the current CFA rule to use the provided ooeset (but to keep the old register).
      This operation is valid only if the current CFA rule is deoned to use a register
      and ooeset.
5.    DW.CFA.def.cfa.ooeset.sf
      The DW.CFA.def.cfa.ooeset.sf instruction takes a signed LEB128 operand
      representing a factored ooeset. This instruction is identical to
      DW.CFA.def.cfa.ooeset except that the operand is signed and factored. The
      resulting ooeset is factored.ooeset * data_alignment_factor                               . This operation is
      valid only if the current CFA rule is deoned to use a register and ooeset.
6.    DW.CFA.def.cfa.expression
      The DW.CFA.def.cfa.expression instruction takes a single operand encoded
      as an exprval value representing a DWARF expression. The required action is
      to establish that expression as the means by which the current CFA is
      computed.
      See Section 6.4.2 on page 184 regarding restrictions on the DWARF expression
      operators that can be used.
6.4.2.3        Register Rule Instructions
1.    DW.CFA.undeoned
      The DW.CFA.undeoned instruction takes a single unsigned LEB128 operand
      that represents a register number. The required action is to set the rule for the
      specioed register to iundeoned.j
2.    DW.CFA.same.value
      The DW.CFA.same.value instruction takes a single unsigned LEB128
      operand that represents a register number. The required action is to set the
      rule for the specioed register to isame value.j
3.    DW.CFA.ooeset
      The DW.CFA.ooeset instruction takes two operands: a register number
      (encoded with the opcode) and an unsigned LEB128 constant representing a
      factored ooeset. The required action is to change the rule for the register
      indicated by the register number to be an ooeset(N) rule where the value of N
      is factored.ooeset * data_alignment_factor                               .
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 186
                                   Chapter 6.  Other Debugging Information
4.    DW.CFA.ooeset.extended
      The DW.CFA.ooeset.extended instruction takes two unsigned LEB128
      operands representing a register number and a factored ooeset. This
      instruction is identical to DW.CFA.ooeset except for the encoding and size of
      the register operand.
5.    DW.CFA.ooeset.extended.sf
      The DW.CFA.ooeset.extended.sf instruction takes two operands: an
      unsigned LEB128 value representing a register number and a signed LEB128
      factored ooeset. This instruction is identical to DW.CFA.ooeset.extended
      except that the second operand is signed and factored. The resulting ooeset is
      factored.ooeset * data_alignment_factor                               .
6.    DW.CFA.val.ooeset
      The DW.CFA.val.ooeset instruction takes two unsigned LEB128 operands
      representing a register number and a factored ooeset. The required action is to
      change the rule for the register indicated by the register number to be a
      val.ooeset(N) rule where the value of N is
      factored.ooeset * data_alignment_factor                               .
7.    DW.CFA.val.ooeset.sf
      The DW.CFA.val.ooeset.sf instruction takes two operands: an unsigned
      LEB128 value representing a register number and a signed LEB128 factored
      ooeset. This instruction is identical to DW.CFA.val.ooeset except that the
      second operand is signed and factored. The resulting ooeset is
      factored.ooeset * data_alignment_factor                               .
8.    DW.CFA.register
      The DW.CFA.register instruction takes two unsigned LEB128 operands
      representing register numbers. The required action is to set the rule for the
      orst register to be register(R) where R is the second register.
9.    DW.CFA.expression
      The DW.CFA.expression instruction takes two operands: an unsigned
      LEB128 value representing a register number, and an exprval value
      representing a DWARF expression. The required action is to change the rule
      for the register indicated by the register number to be an expression(E) rule
      where E is the DWARF expression. That is, the DWARF expression computes
      the address. The value of the CFA is pushed on the DWARF evaluation stack
      prior to execution of the DWARF expression.
      See Section 6.4.2 on page 184 regarding restrictions on the DWARF expression
      operators that can be used.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 187
                                     Chapter 6.  Other Debugging Information
10.     DW.CFA.val.expression
        The DW.CFA.val.expression instruction takes two operands: an unsigned
        LEB128 value representing a register number, and an exprval value
        representing a DWARF expression. The required action is to change the rule
        for the register indicated by the register number to be a val.expression(E)
        rule where E is the DWARF expression. That is, the DWARF expression
        computes the value of the given register. The value of the CFA is pushed on
        the DWARF evaluation stack prior to execution of the DWARF expression.
        See Section 6.4.2 on page 184 regarding restrictions on the DWARF expression
        operators that can be used.
11.     DW.CFA.restore
        The DW.CFA.restore instruction takes a single operand (encoded with the
        opcode) that represents a register number. The required action is to change
        the rule for the indicated register to the rule assigned it by the
        initial_instructions in the CIE.
12.     DW.CFA.restore.extended
        The DW.CFA.restore.extended instruction takes a single unsigned LEB128
        operand that represents a register number. This instruction is identical to
        DW.CFA.restore except for the encoding and size of the register operand.
  6.4.2.4        Row State Instructions
  The next two instructions provide the ability to stack and retrieve complete register
  states. They may be useful, for example, for a compiler that moves epilogue code into the
  body of a function.
  1.    DW.CFA.remember.state
        The DW.CFA.remember.state instruction takes no operands. The required
        action is to push the set of rules for the current CFA and every register onto
        an implicit stack.
  2.    DW.CFA.restore.state
        The DW.CFA.restore.state instruction takes no operands. The required
        action is to pop the set of rules ooe the implicit stack and place them in the
        current row.
  6.4.2.5        Padding Instruction
  1.    DW.CFA.nop
        The DW.CFA.nop instruction has no operands and no required actions. It is
        used as padding to make a CIE or FDE an appropriate size.
  November 1, 2024                                  ***WORKING DRAFT***                                                           Page 188
                                   Chapter 6.  Other Debugging Information
6.4.3          Call Frame Instruction Usage
To determine the virtual unwind rule set for a given location (L1), search through the
FDE headers looking at the initial_location and address_range values to see if L1
is contained in the FDE. If so, then:
1.    Initialize a register set by reading the initial_instructions oeld of the associated
      CIE. Set L2 to the value of the initial_location oeld from the FDE header.
2.    Read and process the FDE's instruction sequence until a DW.CFA.advance.loc,
      DW.CFA.set.loc, or the end of the instruction stream is encountered.
3.     If a DW.CFA.advance.loc or DW.CFA.set.loc instruction is encountered, then
      compute a new location value (L2). If L1 # L2 then process the instruction and go
      back to step 2.
4.     The end of the instruction stream can be thought of as a DW.CFA.set.loc
      (initial_location + address_range) instruction. Note that the FDE is
      ill-formed if L2 is less than L1.
The rules in the register set now apply to location L1.
For an example, see Appendix D.6 on page 346.
6.4.4          Call Frame Calling Address
When virtually unwinding frames, consumers frequently wish to obtain the address of
the instruction which called a subroutine. This information is not always provided.
Typically, however, one of the registers in the virtual unwind table is the Return Address.
If a Return Address register is deoned in the virtual unwind table, and its rule is
undeoned (for example, by DW.CFA.undeoned), then there is no return address
and no call address, and the virtual unwind of stack activations is complete.
In most cases the return address is in the same context as the calling address, but that
need not be the case, especially if the producer knows in some way the call never will
return. The context of the 'return address' might be on a dioeerent line, in a dioeerent
lexical block, or past the end of the calling subroutine. If a consumer were to assume that
it was in the same context as the calling address, the virtual unwind might fail.
For architectures with constant-length instructions where the return address
immediately follows the call instruction, a simple solution is to subtract the length of an
instruction from the return address to obtain the calling instruction. For architectures
with variable-length instructions (for example, x86), this is not possible. However,
subtracting 1 from the return address, although not guaranteed to provide the exact
calling address, generally will produce an address within the same context as the calling
address, and that usually is suOEcient.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 189
                                   Chapter 6.  Other Debugging Information
                                                             (empty page)
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 190

Chapter  7
Data  Representation
This section describes the binary representation of the debugging information
entry itself, of the attribute types and of other fundamental elements described
above.
7.1          Extensibility
To reserve a portion of the DWARF name space and ranges of enumeration
values for use for producer-specioc extensions, special labels are reserved for tag
names, attribute names, base type encodings, location operations, language
names, calling conventions and call frame instructions.
The labels denoting the beginning and end of the reserved value range for
producer-specioc extensions consist of the appropriate preox (DW.AT,
DW.ATE, DW.CC, DW.CFA, DW.END, DW.IDX, DW.LLE, DW.LNAME,
DW.LNCT, DW.LNE, DW.MACRO, DW.OP, DW.RLE, DW.TAG, DW.UT)
followed by .lo.user or .hi.user. Values in the range between preox.lo.user and
preox.hi.user inclusive, are reserved for producer-specioc extensions. Producers
may use values in this range without conAEicting with current or future
system-deoned values. All other values are reserved for use by the system.
For example, for debugging information entry tags, the special labels are
DW.TAG.lo.user and DW.TAG.hi.user.
There may also be codes for producer-specioc extensions between the number of standard
line number opcodes and the orst special line number opcode. However, since the number
of standard opcodes varies with the DWARF version, the range for extensions is also
version dependent. Thus, DW.LNS.lo.user and DW.LNS.hi.user symbols are not
deoned.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 191
                                            Chapter 7.  Data Representation
Producer-deoned tags, attributes, base type encodings, location atoms, language
names, line number actions, calling conventions and call frame instructions, use
the form preox.producer.id.name                         by historical convention, where producer.id is
some identifying character sequence chosen so as to avoid conAEicts with other
producers. While this convention is not strictly necessary, it is still
recommended.
To ensure that extensions added by one producer may be safely ignored by
consumers that do not understand those extensions, the following rules must be
followed:
1.    New attributes are added in such a way that a debugger may recognize the
      format of a new attribute value without knowing the content of that attribute
      value.
2.    The semantics of any new attributes do not alter the semantics of previously
      existing attributes.
3.    The semantics of any new tags do not conAEict with the semantics of
      previously existing tags.
4.    New forms of attribute value are not added.
7.2          Reserved  Values
7.2.1          Error Values
As a convenience for consumers of DWARF information, the value 0 is reserved
in the encodings for attribute names, attribute forms, base type encodings,
location operations, languages, line number program opcodes, macro
information entries and tag names to represent an error condition or unknown
value. DWARF does not specify names for these reserved values, because they
do not represent valid encodings for the given type and do not appear in
DWARF debugging information.
7.2.2          Initial Length Values
An initial length oeld is one of the oelds that occur at the beginning of those
DWARF sections that have a header (.debug_aranges, .debug_info,
.debug_line, .debug_loclists, .debug_names and .debug_rnglists) or the
length oeld that occurs at the beginning of the CIE and FDE structures in the
.debug_frame section.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 192
                                            Chapter 7.  Data Representation
In an initial length oeld, the values 0xfffffff0 through 0xffffffff are reserved
by DWARF to indicate some form of extension relative to DWARF Version 2;
such values must not be interpreted as a length oeld. The use of one such value,
0xffffffff, is deoned in Section 7.4 on page 204; the use of the other values is
reserved for possible future extensions.
7.3          Relocatable,  Split,  Executable,  Shared,  Package
             and  Supplementary  Object  Files
7.3.1          Relocatable Object Files
A DWARF producer (for example, a compiler) typically generates its debugging
information as part of a relocatable object ole. Relocatable object oles are then
combined by a linker to form an executable ole. During the linking process, the
linker resolves (binds) symbolic references between the various object oles, and
relocates the contents of each object ole into a combined virtual address space.
The DWARF debugging information is placed in several sections (see Appendix
B on page 287), and requires an object ole format capable of representing these
separate sections. There are symbolic references between these sections, and also
between the debugging information sections and the other sections that contain
the text and data of the program itself. Many of these references require
relocation, and the producer must emit the relocation information appropriate to
the object ole format and the target processor architecture. These references
include the following:
     #    The compilation unit header (see Section 7.5.1 on page 208) in the
          .debug_info section contains a reference to the .debug_abbrev table. This
          reference requires a relocation so that after linking, it refers to that
          contribution to the combined .debug_abbrev section in the executable ole.
     #    Debugging information entries may have attributes with the form
          DW.FORM.addr (see Section 7.5.4 on page 217). These attributes represent
          locations within the virtual address space of the program, and require
          relocation.
     #    A DWARF expression may contain a DW.OP.addr (see Section 2.5.1.1 on
          page 27) which contains a location within the virtual address space of the
          program, and require relocation.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 193
                                            Chapter 7.  Data Representation
     #    Debugging information entries may have attributes with the form
          DW.FORM.sec.ooeset (see Section 7.5.4 on page 217). These attributes refer
          to debugging information in other debugging information sections within
          the object ole, and must be relocated during the linking process.
     #    Debugging information entries may have attributes with the form
          DW.FORM.ref.addr (see Section 7.5.4 on page 217). These attributes refer
          to debugging information entries that may be outside the current
          compilation unit. These values require both symbolic binding and
          relocation.
     #    Debugging information entries may have attributes with the form
          DW.FORM.strp or DW.FORM.strp8 (see Section 7.5.4 on page 217).
          These attributes refer to strings in the .debug_str section. These values
          require relocation.
     #    The .debug_macro section may have DW.MACRO.deone.strp and
          DW.MACRO.undef.strp entries (see Section 6.3.2.1 on page 175). These
          entries refer to strings in the .debug_str section. These values require
          relocation.
     #    Entries in the .debug_addr and .debug_aranges sections may contain
          references to locations within the virtual address space of the program, and
          thus require relocation.
     #    Entries in the .debug_loclists and .debug_rnglists sections may contain
          references to locations within the virtual address space of the program
          depending on whether certain kinds of location or range list entries are
          used, and thus require relocation.
     #    In the .debug_line section, the operand of the DW.LNE.set.address
          opcode is a reference to a location within the virtual address space of the
          program, and requires relocation.
     #    The .debug_str_offsets section contains a list of string ooesets, each of
          which is an ooeset of a string in the .debug_str section. Each of these ooesets
          requires relocation. Depending on the implementation, these relocations
          may be implicit (that is, the producer may not need to emit any explicit
          relocation information for these ooesets).
     #    The debug_info_offset oeld in the .debug_aranges header and the list of
          compilation units following the .debug_names header contain references to
          the .debug_info section. These references require relocation so that after
          linking they refer to the correct contribution in the combined .debug_info
          section in the executable ole.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 194
                                            Chapter 7.  Data Representation
     #    Frame descriptor entries in the .debug_frame section (see Section 6.4.1 on
          page 180) contain an initial_location oeld value within the virtual
          address space of the program and require relocation.
Note that operands of classes constant and AEag do not require relocation. Attribute
operands that use forms DW.FORM.string, DW.FORM.ref1, DW.FORM.ref2,
DW.FORM.ref4, DW.FORM.ref8, or DW.FORM.ref.udata also do not need
relocation.
7.3.2          Split DWARF Object Files
A DWARF producer may partition the debugging information such that the
majority of the debugging information can remain in individual object oles
without being processed by the linker.
This reduces link time by reducing the amount of information the linker must process.
7.3.2.1        First Partition (with Skeleton Unit)
The orst partition contains debugging information that must still be processed by
the linker, and includes the following:
     #    The line number tables, frame tables, and accelerated access tables, in the
          usual sections: .debug_line, .debug_line_str, .debug_frame,
          .debug_names and .debug_aranges, respectively.
     #    An address table, in the .debug_addr section. This table contains all
          addresses and constants that require link-time relocation, and items in the
          table can be referenced indirectly from the debugging information via the
          DW.FORM.addrx, DW.FORM.addrx1, DW.FORM.addrx2,
          DW.FORM.addrx3 and DW.FORM.addrx4 forms, by the DW.OP.addrx
          and DW.OP.constx operators, and by certain of the DW_LLE_* location list
          and DW_RLE_* range list entries.
     #    A skeleton compilation unit, as described in Section 3.1.2 on page 69, in the
          .debug_info section.
     #    An abbreviations table for the skeleton compilation unit, in the
          .debug_abbrev section used by the .debug_info section.
     #    A string table, in the .debug_str section. The string table is necessary only
          if the skeleton compilation unit uses one of the indirect string forms
          (DW.FORM.strp, DW.FORM.strp8, DW.FORM.strx, DW.FORM.strx1,
          DW.FORM.strx2, DW.FORM.strx3 or DW.FORM.strx4).
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 195
                                            Chapter 7.  Data Representation
     #    A string ooesets table, in the .debug_str_offsets section for strings in the
          .debug_str section. The string ooesets table is necessary only if the skeleton
          compilation unit uses one of the indexed string forms (DW.FORM.strx,
          DW.FORM.strx1, DW.FORM.strx2, DW.FORM.strx3,
          DW.FORM.strx4).
The attributes contained in the skeleton compilation unit can be used by a
DWARF consumer to ond the DWARF object ole that contains the second
partition.
7.3.2.2        Second Partition (Unlinked or in a .dwo File)
The second partition contains the debugging information that does not need to
be processed by the linker. These sections may be left in the object oles and
ignored by the linker (that is, not combined and copied to the executable object
ole), or they may be placed by the producer in a separate DWARF object ole. This
partition includes the following:
     #    The full compilation unit, in the .debug_info.dwo section.
          Attributes contained in the full compilation unit may refer to machine
          addresses indirectly using one of the DW.FORM.addrx,
          DW.FORM.addrx1, DW.FORM.addrx2, DW.FORM.addrx3 or
          DW.FORM.addrx4 forms, which access the table of addresses specioed by
          the DW.AT.addr.base attribute in the associated skeleton unit. Location
          descriptions may similarly do so using the DW.OP.addrx and
          DW.OP.constx operations.
     #    Separate type units, in the .debug_info.dwo section.
     #    Abbreviations table(s) for the compilation unit and type units, in the
          .debug_abbrev.dwo section used by the .debug_info.dwo section.
     #    Value lists and location lists, in the .debug_loclists.dwo section.
     #    Range lists, in the .debug_rnglists.dwo section.
     #    A specialized line number table (for the type units, and macro information),
          in the .debug_line.dwo section.
          This table contains only the directory and olename lists needed to interpret
          DW.AT.decl.ole attributes in the debugging information entries and
          DW.MACRO.start.ole entries in the macro information.
     #    Macro information, in the .debug_macro.dwo section.
     #    A string table, in the .debug_str.dwo section.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 196
                                            Chapter 7.  Data Representation
     #    A string ooesets table, in the .debug_str_offsets.dwo section for the strings
          in the .debug_str.dwo section.
          Attributes that refer to the .debug_str.dwo string table do so only
          indirectly through the .debug_str_offsets.dwo section using the forms
          DW.FORM.strx, DW.FORM.strx1, DW.FORM.strx2, DW.FORM.strx3
          or DW.FORM.strx4, or the macro entries DW.MACRO.deone.strx or
          DW.MACRO.undef.strx. Direct reference (for example, using forms
          DW.FORM.strp or DW.FORM.strp8, or the macro entries
          DW.MACRO.deone.strp or DW.MACRO.undef.strp) is not allowed.
Except where noted otherwise, all references in this document to a debugging
information section (for example, .debug_info), apply also to the corresponding
split DWARF section (for example, .debug_info.dwo).
Split DWARF object oles do not get linked with any other oles, therefore
references between sections must not make use of normal object ole relocation
information. As a result, symbolic references within or between sections (such as
from using DW.FORM.ref.addr and DW.OP.call.ref) are not possible. Split
DWARF object oles contain at most one compilation unit.
7.3.3          Executable Objects and .dwo Files
The relocated addresses in the debugging information for an executable object
are virtual addresses.
The sections containing the debugging information are typically not loaded as
part of the memory image of the program (in ELF terminology, the sections are
not "allocatable" and are not part of a loadable segment). Therefore, the
debugging information sections described in this document are typically linked
as if they were each to be loaded at virtual address 0. Similarly, debugging
information in a .dwo ole is not loaded in the memory image. The absence (or
non-use) of relocation information in a .dwo ole means that sections described in
this document are eoeectively linked as if they were each to be loaded at virtual
address 0. In both cases, references within the debugging information always
implicitly indicate which section a particular ooeset refers to. (For example, a
reference of form DW.FORM.sec.ooeset may refer to one of several sections,
depending on the class allowed by a particular attribute of a debugging
information entry, as shown in Table 7.5 on page 217.)
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 197
                                            Chapter 7.  Data Representation
7.3.4          Shared Object Files
The relocated addresses in the debugging information for a shared object ole are
ooesets relative to the start of the lowest region of memory loaded from that
shared object ole.
This requirement makes the debugging information for shared object oles position
independent. Virtual addresses in a shared object ole may be calculated by adding the
ooeset to the base address at which the object ole was attached. This ooeset is available in
the run-time linker's data structures.
As with executable objects, the sections containing debugging information are
typically not loaded as part of the memory image of the shared object, and are
typically linked as if they were each to be loaded at virtual address 0.
7.3.5          DWARF Package Files
Using split DWARF object oles allows the developer to compile, link, and debug an
application quickly with less link-time overhead, but a more convenient format is needed
for saving the debug information for later debugging of a deployed application. A
DWARF package ole can be used to collect the debugging information from the object (or
separate DWARF object) oles produced during the compilation of an application.
The package ole is typically placed in the same directory as the application, and is given
the same name with a i.dwpj extension.
A DWARF package ole is itself an object ole, using the  same object ole format
(including byte order) as the corresponding application binary. It contains a ole
header, a section table, a number of DWARF debug information sections, and
two index sections.
Each DWARF package ole contains no more than one of each of the following
sections, copied from a set of object or DWARF object oles, and combined,
section by section:
        .debug_info.dwo
        .debug_abbrev.dwo
        .debug_line.dwo
        .debug_loclists.dwo
        .debug_rnglists.dwo
        .debug_str_offsets.dwo
        .debug_str.dwo
        .debug_macro.dwo
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 198
                                            Chapter 7.  Data Representation
The string table section in .debug_str.dwo contains all the strings referenced
from DWARF attributes using any of the forms DW.FORM.strx,
DW.FORM.strx1, DW.FORM.strx2, DW.FORM.strx3 or DW.FORM.strx4.
Any attribute in a compilation unit or a type unit using this form refers to an
entry in that unit's contribution to the .debug_str_offsets.dwo section, which
in turn provides the ooeset of a string in the .debug_str.dwo section.
The DWARF package ole also contains two index sections that provide a fast way
to locate debug information by compilation unit ID for compilation units, or by
type signature for type units:
        .debug_cu_index
        .debug_tu_index
7.3.5.1        The Compilation Unit (CU) Index Section
The .debug_cu_index section is a hashed lookup table that maps a compilation
unit ID to a set of contributions in the various debug information sections. Each
contribution is stored as an ooeset within its corresponding section and a size.
Each compilation unit set may contain contributions from the following sections:
        .debug_info.dwo  (required)
        .debug_abbrev.dwo  (required)
        .debug_line.dwo
        .debug_loclists.dwo
        .debug_rnglists.dwo
        .debug_str_offsets.dwo
        .debug_macro.dwo
Note that a compilation unit set is not able to represent .debug_macinfo information
from DWARF Version 4 or earlier formats.
7.3.5.2        The Type Unit (TU) Index Section
The .debug_tu_index section is a hashed lookup table that maps a type signature
to a set of ooesets in the various debug information sections. Each contribution is
stored as an ooeset within its corresponding section and a size.
Each type unit set may contain contributions from the following sections:
        .debug_info.dwo  (required)
        .debug_abbrev.dwo  (required)
        .debug_line.dwo
        .debug_str_offsets.dwo
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 199
                                            Chapter 7.  Data Representation
7.3.5.3        Format of the CU and TU Index Sections
Both .debug_cu_index and .debug_tu_index index sections have the same
format, and serve to map an 8-byte signature to a set of contributions to the
debug sections. Each index section begins with a header, followed by a hash table
of signatures, a parallel table of indexes, a table of ooesets, and a table of sizes.
The index sections are aligned at 8-byte boundaries in the DWARF package ole.
The index section header contains the following oelds:
1.    version (uhalf)
      A version number.   This number is specioc to the CU and TU index
      information and is independent of the DWARF version number.
      The version number is 6.
2.    offset_size_flag (uhalf)
      If the offset_size_flag is zero, the header is for a 32-bit DWARF format unit
      index section and all ooesets and lengths are 4 bytes long; if it is one, the
      header is for a 64-bit DWARF format unit index section and all ooesets and
      lengths are 8 bytes long.
3.    padding (uhalf)
      Reserved to DWARF (must be zero).
4.    section_count (uword)
      The number of entries in the table of section counts that follows. For brevity,
      the contents of this oeld is referred to as N  below.
5.    unit_count (uword)
      The number of compilation units or type units in the index. For brevity, the
      contents of this oeld is referred to as U  below.
6.    slot_count (uword)
      The number of slots in the hash table. For brevity, the contents of this oeld is
      referred to as S below.
We assume that U  and S do not exceed 232 .
The size of the hash table, S, must be 2k  such that:    2k    >   3 * U/2
The hash table begins at ooeset 16 in the section, and consists of an array of S
8-byte slots. Each slot contains a 64-bit signature.
The parallel table of indices begins immediately after the hash table (at ooeset
16 + 8 * S        from the beginning of the section), and consists of an array of S 4-byte
slots, corresponding 1-1 with slots in the hash table. Each entry in the parallel
table contains a row index into the tables of ooesets and sizes.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 200
                                            Chapter 7.  Data Representation
Unused slots in the hash table have 0 in both the hash table entry and the parallel
table entry. While 0 is a valid hash value, the row index in a used slot will always
be non-zero.
Given an 8-byte compilation unit ID or type signature X , an entry in the hash
table is located as follows:
1.    Deone REP (X ) to be the value of X  interpreted as an unsigned 64-bit integer
      in the target byte order.
2.    Calculate a primary hash H  = REP (X ) & M ASK (k), where M ASK (k) is a
      mask with the low-order k bits all set to 1.
3.    Calculate a secondary hash H # = (((REP (X ) >> 32) & M ASK (k)) | 1).
4.    If the hash table entry at index H  matches the signature, use that entry. If the
      hash table entry at index H  is unused (all zeroes), terminate the search: the
      signature is not present in the table.
5.    Let H  = (H + H #) modulo S. Repeat at Step 4.
Because S  > U , and H #and S are relatively prime, the search is guaranteed to
stop at an unused slot or ond the match.
The table of ooesets begins immediately following the parallel table (at ooeset
16 + 12 * S         from the beginning of the section). This table consists of a single
header row containing N  oelds, each a 4-byte unsigned integer, followed by U
data rows, each containing N  unsigned integer oelds of size specioed by the
index header offset_size_flag oeld. The oelds in the header row provide a
section identioer referring to a debug section; the available section identioers are
shown in Table 7.1 following. Each data row corresponds to a specioc CU or TU
in the package ole. In the data rows, each oeld provides an ooeset to the debug
section whose identioer appears in the corresponding oeld of the header row.
The data rows are indexed starting at 1.
Not all sections listed in the table need be included.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 201
                                            Chapter 7.  Data Representation
                       Table   7.1:     DWARF   package   ole   section   identioer
                       encodings
              ___________________________________________________________________________________________________________________
              __Section_identioer__________________||______________Value__||_____Section_________________________________________
                DW.SECT.INFO                  ||                       1      || .debug_info.dwo
                Reserved                                  ||           2      ||
                DW.SECT.ABBREV            ||                           3      || .debug_abbrev.dwo
                DW.SECT.LINE                  ||                       4      || .debug_line.dwo
                DW.SECT.LOCLISTS         ||                            5      || .debug_loclists.dwo
                DW.SECT.STR.OFFSETS  ||                                6      || .debug_str_offsets.dwo
                DW.SECT.MACRO             ||                           7      || .debug_macro.dwo
              __DW.SECT.RNGLISTS_________||____________________________8______||_.debug_rnglists.dwo_____________________________
The ooesets provided by the CU and TU index sections are the base ooesets for the
contributions made by each CU or TU to the corresponding section in the
package ole. Each CU and TU header contains a debug_abbrev_offset oeld,
used to ond the abbreviations table for that CU or TU within the contribution to
the .debug_abbrev.dwo section for that CU or TU, and are interpreted as relative
to the base ooeset given in the index section. Likewise, ooesets into
.debug_line.dwo from DW.AT.stmt.list attributes are interpreted as relative to
the base ooeset for .debug_line.dwo, and ooesets into other debug sections
obtained from DWARF attributes are also interpreted as relative to the
corresponding base ooeset.
The table of sizes begins immediately following the table of ooesets, and provides
the sizes of the contributions made by each CU or TU to the corresponding
section in the package ole. This table consists of U data rows, each with N
unsigned integer oelds of size specioed by the index header offset_size_flag
oeld. Each data row corresponds to the same CU or TU as the corresponding
data row in the table of ooesets described above. Within each data row, the N
oelds also correspond one-to-one with the oelds in the corresponding data row
of the table of ooesets. Each oeld provides the size of the contribution made by a
CU or TU to the corresponding section in the package ole.
For an example, see Figure F.10 on page 438.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 202
                                            Chapter 7.  Data Representation
7.3.6          DWARF Supplementary Object Files
A supplementary object ole permits a post-link utility to analyze executable and shared
object oles and collect duplicate debugging information into a single ole that can be
referenced by each of the original oles. This is in contrast to split DWARF object oles,
which allow the compiler to split the debugging information between multiple oles in
order to reduce link time and executable size.
A DWARF supplementary object ole is itself an object ole, using the same object
ole format, byte order, and size as the corresponding application executables or
shared libraries. It contains a ole header, section table, and a number of DWARF
debug information sections. Both the supplementary object ole and all the
executable or shared object oles that reference entries or strings in that ole must
contain a .debug_sup section that establishes the relationship.
The .debug_sup section contains:
1.    version (uhalf)
      A 2-byte unsigned integer representing the version of the DWARF
      information for the compilation unit.
      The value in this oeld is 5.
2.    is_supplementary (ubyte)
      A 1-byte unsigned integer, which contains the value 1 if it is in the
      supplementary object ole that other executable or shared object oles refer to,
      or 0 if it is an executable or shared object referring to a supplementary object
      ole.
3.    sup.olename (null terminated olename string)
      If is_supplementary is 0, this contains either an absolute olename for the
      supplementary object ole, or a olename relative to the object ole containing
      the .debug_sup section. If is_supplementary is 1, then sup.olename is not
      needed and must be an empty string (a single null byte).
4.    sup_checksum_len (unsigned LEB128)
      Length of the following sup_checksum oeld; this value can be 0 if no
      checksum is provided.
5.    sup_checksum (array of ubyte)
      An implementation-deoned integer constant value that provides unique
      identiocation of the supplementary ole.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 203
                                            Chapter 7.  Data Representation
Debug information entries that refer to an executable's or shared object's
addresses must not be moved to supplementary oles (the addresses will likely
not be the same). Similarly, entries referenced from within location descriptions
or using loclistsptr form attributes must not be moved to a supplementary object
ole.
Executable or shared object ole compilation units can use
DW.TAG.imported.unit with an DW.AT.import attribute that uses form
DW.FORM.ref.sup4 or DW.FORM.ref.sup8 to import entries from the
supplementary object ole, form DW.FORM.ref.sup4 or DW.FORM.ref.sup8 to
refer directly to individual entries in the supplementary ole, or form
DW.FORM.strp.sup or DW.FORM.strp.sup8 to refer to strings that are used
by debug information of multiple executables or shared object oles. Within the
supplementary object ole's debugging sections, forms DW.FORM.ref.sup4,
DW.FORM.ref.sup8, DW.FORM.strp.sup and DW.FORM.strp.sup8 are not
used, and all reference forms referring to other sections refer to the local sections
in the supplementary object ole.
In macro information, DW.MACRO.deone.sup4, DW.MACRO.deone.sup8,
DW.MACRO.undef.sup4 and DW.MACRO.undef.sup8 opcodes can refer to
strings in the .debug_str section of the supplementary object ole, while
DW.MACRO.import.sup4 and DW.MACRO.import.sup8 can refer to
.debug_macro section entries. Within the .debug_macro section of a
supplementary object ole, DW.MACRO.deone.strp and
DW.MACRO.undef.strp opcodes refer to the local .debug_str section in that
supplementary ole, not the one in the executable or shared object ole.
Forms for both 4- and 8-byte references are provided so that references may use the
appropriate ooeset size for the content of the supplementary object ole, which might not
use the same 32-bit or 64-bit DWARF format as a referencing object ole.
7.4          32-Bit  and  64-Bit  DWARF  Formats
There are two closely-related DWARF formats. In the 32-bit DWARF format, all
values that represent lengths of DWARF sections and ooesets relative to the
beginning of DWARF sections are represented using four bytes. In the 64-bit
DWARF format, all values that represent lengths of DWARF sections and ooesets
relative to the beginning of DWARF sections are represented using eight bytes. A
special convention applies to the initial length oeld of certain DWARF sections,
as well as the CIE and FDE structures, so that the 32-bit and 64-bit DWARF
formats can coexist and be distinguished within a single linked object.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 204
                                            Chapter 7.  Data Representation
The 32-bit and 64-bit DWARF format conventions must not be intermixed within
a single compilation unit, except for contributions to the .debug_str_offsets,
.debug_str_offsets.dwo, or .debug_names sections.
The exception for the .debug_str_offsets section enables an executable program with
a mixture of 32-bit and 64-bit DWARF compilation units to refer to any string in the
merged .debug_str section, even if that section exceeds 4GB in size.
Except where noted otherwise, all references in this document to a debugging
information section (for example, .debug_info), apply also to the corresponding
split DWARF section (for example, .debug_info.dwo).
Attribute values and section header oelds that represent addresses in the target program
are not aoeected by the rules that follow.
The dioeerences between the 32- and 64-bit DWARF formats are detailed in the
following:
1.    In the 32-bit DWARF format, an initial length oeld (see Section 7.2.2 on
      page 192). is an unsigned 4-byte integer (which must be less than
      0xfffffff0); in the 64-bit DWARF format, an initial length oeld is 12 bytes in
      size, and has two parts:
          #    The orst four bytes have the value 0xffffffff.
          #    The following eight bytes contain the actual length represented as an
               unsigned 8-byte integer.
      This representation allows a DWARF consumer to dynamically detect that a
      DWARF section contribution is using the 64-bit format and to adapt its processing
      accordingly.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 205
                                            Chapter 7.  Data Representation
2.    Section ooeset and section length oelds that occur in the headers of DWARF
      sections (other than initial length oelds) depend on the choice of DWARF
      format as follows: for the 32-bit DWARF format these are 4-byte unsigned
      integer values; for the 64-bit DWARF format, they are 8-byte unsigned integer
      values.
           __Section_______________________________Name_______________________________________Role_________________________________________
             .debug_aranges                         debug_info_offset                          ooeset in .debug_info
             .debug_frame/CIE                       CIE_id                                     CIE distinguished value
             .debug_frame/FDE                       CIE_pointer                                ooeset in .debug_frame
             .debug_info                            debug_abbrev_offset                        ooeset in .debug_abbrev
             .debug_line                            header_length                              length of header itself
             .debug_names                           entry in array of CUs                      ooeset in .debug_info
           _________________________________________or_local_TUs___________________________________________________________________________
      The CIE_id oeld in a CIE structure must be 64 bits because it overlays the
      CIE_pointer in a FDE structure; this implicit union must be accessed to
      distinguish whether a CIE or FDE is present, consequently, these two oelds
      must exactly overlay each other (both ooeset and size).
3.    Within the body of the .debug_info section, certain forms of attribute value
      depend on the choice of DWARF format as follows: for the 32-bit DWARF
      format, the value is a 4-byte unsigned integer; for the 64-bit DWARF format,
      the value is an 8-byte unsigned integer.
                      __Form________________________________________Role_______________________________________________________
                        DW.FORM.line.strp                           ooeset in .debug_line_str
                        DW.FORM.ref.addr                            ooeset in .debug_info
                        DW.FORM.sec.ooeset                          ooeset in a section other than
                                                                    .debug_info or .debug_str
                        DW.FORM.strp                                ooeset in .debug_str
                        DW.FORM.strp.sup                            ooeset in .debug_str section of a
                                                                    supplementary               object ole
                      __DW.OP.call.ref______________________________ooeset_in_.debug_info______________________________________
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 206
                                            Chapter 7.  Data Representation
4.    Within the body of the .debug_line section, certain forms of content
      description depend on the choice of DWARF format as follows: for the 32-bit
      DWARF format, the value is a 4-byte unsigned integer; for the 64-bit DWARF
      format, the value is a 8-byte unsigned integer.
                       __Form______________________________________Role_______________________________________________________
                       __DW.FORM.line.strp_________________________ooeset_in_.debug_line_str__________________________________
5.    Within the body of the .debug_names sections, the representation of each
      entry in the array of compilation units (CUs) and the array of local type units
      (TUs), which represents an ooeset in the .debug_info section, depends on the
      DWARF format as follows: for the 32-bit DWARF format, each entry is a
      4-byte unsigned integer; for the 64-bit DWARF format, it is a 8-byte unsigned
      integer.
6.    In the body of the .debug_str_offsets sections, the size of entries in the
      body depend on the DWARF format as follows: for the 32-bit DWARF format,
      entries are 4-byte unsigned integer values; for the 64-bit DWARF format, they
      are 8-byte unsigned integers.
7.    Within the body of the .debug_loclists and .debug_rnglists sections, the
      ooesets that follow the header depend on the DWARF format as follows: for
      the 32-bit DWARF format, ooesets are 4-byte unsigned integer values; for the
      64-bit DWARF format, they are 8-byte unsigned integers.
A DWARF consumer that supports the 64-bit DWARF format must support
executables in which some compilation units use the 32-bit format and others use
the 64-bit format provided that the combination links correctly (that is, provided
that there are no link-time errors due to truncation or overAEow). (An
implementation is not required to guarantee detection and reporting of all such
errors.)
It is expected that DWARF producing compilers will not use the 64-bit format by
default. In most cases, the division of even very large applications into a number of
executable and shared object oles will suOEce to assure that the DWARF sections within
each individual linked object are less than 4 GBytes in size. However, for those cases
where needed, the 64-bit format allows the unusual case to be handled as well. Even in
this case, it is expected that only application supplied objects will need to be compiled
using the 64-bit format; separate 32-bit format versions of system supplied shared
executable libraries can still be used.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 207
                                            Chapter 7.  Data Representation
7.5          Format  of  Debugging  Information
For each compilation unit compiled with a DWARF producer, a contribution is
made to the .debug_info section of the object ole. Each such contribution
consists of a compilation unit header (see Section 7.5.1.1 on the following page)
followed by a single DW.TAG.compile.unit or DW.TAG.partial.unit
debugging information entry, together with its children.
For each type deoned in a compilation unit, a separate contribution may also be
made to the .debug_info section of the object ole. Each such contribution
consists of a type unit header (see Section 7.5.1.3 on page 211) followed by a
DW.TAG.type.unit entry, together with its children.
Each debugging information entry begins with a code that represents an entry in
a separate abbreviations table. This code is followed directly by a series of
attribute values.
The appropriate entry in the abbreviations table guides the interpretation of the
information contained directly in the .debug_info section.
Multiple debugging information entries may share the same abbreviation table
entry. Each compilation unit is associated with a particular abbreviation table,
but multiple compilation units may share the same table.
7.5.1          Unit Headers
Unit headers contain a oeld, unit_type, whose value indicates the kind of
compilation unit (see Section 3.1 on page 61). The encodings for the unit type
enumeration are shown in Table 7.2.
                                 Table 7.2: Unit header unit type encodings
                                 ______________________________________________________________________________
                                 __Unit_header_unit_type_encodings__||___________________________Value_________
                                   DW.UT.compile                              ||                   0x01
                                   DW.UT.type                                    ||                0x02
                                   DW.UT.partial                                 ||                0x03
                                   DW.UT.skeleton                              ||                  0x04
                                   DW.UT.split.compile                    ||                       0x05
                                   DW.UT.split.type                           ||                   0x06
                                   DW.UT.lo.user                               ||                  0x80
                                 __DW.UT.hi.user_______________________________||__________________0xff_______
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 208
                                            Chapter 7.  Data Representation
                                 _______________________________________________________________________________
All unit headers have the same initial three oelds: initial_length, version and
unit_type.
7.5.1.1        Full and Partial Compilation Unit Headers
1.    unit_length (initial length)
      A 4-byte or 12-byte unsigned integer representing the length of the
      .debug_info contribution for that compilation unit, not including the length
      oeld itself (see Section 7.4 on page 204).
2.    version (uhalf)
      A 2-byte unsigned integer representing the version of the DWARF
      information for the compilation unit.
      The value in this oeld is 5.
      See also Appendix G on page 441 for a summary of all version numbers that apply to
      DWARF sections.
3.    unit_type (ubyte)
      A 1-byte unsigned integer identifying this unit as a compilation unit. The
      value of this oeld is DW.UT.compile for a (non-split) full compilation unit or
      DW.UT.partial for a (non-split) partial compilation unit (see Section 3.1.1 on
      page 62).
      See Section 7.5.1.2 regarding a split full compilation unit.
4.    address_size (ubyte)
      A 1-byte unsigned integer representing the size in bytes of an address on the
      target architecture.
5.    debug_abbrev_offset (section ooeset)
      A 4-byte or 8-byte unsigned ooeset into the .debug_abbrev section. This ooeset
      associates the compilation unit with a particular set of debugging
      information entry abbreviations. In the 32-bit DWARF format, this is a 4-byte
      unsigned length; in the 64-bit DWARF format, this is an 8-byte unsigned
      length (see Section 7.4 on page 204).
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 209
                                            Chapter 7.  Data Representation
7.5.1.2        Skeleton and Split Compilation Unit Headers
1.    unit_length (initial length)
      A 4-byte or 12-byte unsigned integer representing the length of the
      .debug_info contribution for that compilation unit, not including the length
      oeld itself (see Section 7.4 on page 204).
2.    version (uhalf)
      A 2-byte unsigned integer representing the version of the DWARF
      information for the compilation unit.
      The value in this oeld is 5.
      See also Appendix G on page 441 for a summary of all version numbers that apply to
      DWARF sections.
3.    unit_type (ubyte)
      A 1-byte unsigned integer identifying this unit as a compilation unit. The
      value of this oeld is DW.UT.skeleton for a skeleton compilation unit or
      DW.UT.split.compile for a split (full) compilation unit (see Section 3.1.2 on
      page 69).
      There is no split analog to the partial compilation unit.
4.    address_size (ubyte)
      A 1-byte unsigned integer representing the size in bytes of an address on the
      target architecture.
5.    debug_abbrev_offset (section ooeset)
      A 4-byte or 8-byte unsigned ooeset into the .debug_abbrev section. This ooeset
      associates the compilation unit with a particular set of debugging
      information entry abbreviations. In the 32-bit DWARF format, this is a 4-byte
      unsigned length; in the 64-bit DWARF format, this is an 8-byte unsigned
      length (see Section 7.4 on page 204).
6.    dwo_id (unit ID)
      An 8-byte implementation-deoned integer constant value, known as the
      compilation unit ID, that provides unique identiocation of a skeleton
      compilation unit and its associated split compilation unit in the object ole
      named in the DW.AT.dwo.name attribute of the skeleton compilation.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 210
                                            Chapter 7.  Data Representation
7.5.1.3        Type Unit Headers
The header for the series of debugging information entries contributing to the
description of a type that has been placed in its own type unit, within the
.debug_info section, consists of the following information:
1.    unit_length (initial length)
      A 4-byte or 12-byte unsigned integer representing the length of the
      .debug_info contribution for that type unit, not including the length oeld
      itself (see Section 7.4 on page 204).
2.    version (uhalf)
      A 2-byte unsigned integer representing the version of the DWARF
      information for the type unit.
      The value in this oeld is 5.
3.    unit_type (ubyte)
      A 1-byte unsigned integer identifying this unit as a type unit. The value of
      this oeld is DW.UT.type for a non-split type unit (see Section 3.1.4 on
      page 72) or DW.UT.split.type for a split type unit.
4.    address_size (ubyte)
      A 1-byte unsigned integer representing the size in bytes of an address on the
      target architecture.
5.    debug_abbrev_offset (section ooeset)
      A 4-byte or 8-byte unsigned ooeset into the .debug_abbrev section. This ooeset
      associates the type unit with a particular set of debugging information entry
      abbreviations. In the 32-bit DWARF format, this is a 4-byte unsigned length;
      in the 64-bit DWARF format, this is an 8-byte unsigned length (see Section 7.4
      on page 204).
6.    type_signature (8-byte unsigned integer)
      A unique 8-byte signature (see Section 7.32 on page 258) of the type described
      in this type unit.
      An attribute that refers (using DW.FORM.ref.sig8) to the primary type contained
      in this type unit uses this value.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 211
                                            Chapter 7.  Data Representation
7.    type_offset (section ooeset)
      A 4-byte or 8-byte unsigned ooeset relative to the beginning of the type unit
      header. This ooeset refers to the debugging information entry that describes
      the type. Because the type may be nested inside a namespace or other
      structures, and may contain references to other types that have not been
      placed in separate type units, it is not necessarily either the orst or the only
      entry in the type unit. In the 32-bit DWARF format, this is a 4-byte unsigned
      length; in the 64-bit DWARF format, this is an 8-byte unsigned length (see
      Section 7.4 on page 204).
7.5.2          Debugging Information Entry
Each debugging information entry begins with an unsigned LEB128 number
containing the abbreviation code for the entry. This code represents an entry
within the abbreviations table associated with the compilation unit containing
this entry. The abbreviation code is followed by a series of attribute values.
On some architectures, there are alignment constraints on section boundaries. To
make it easier to pad debugging information sections to satisfy such constraints,
the abbreviation code 0 is reserved. Debugging information entries consisting of
only the abbreviation code 0 are considered null entries.
7.5.3          Abbreviations Tables
The abbreviations tables for all compilation units are contained in a separate
object ole section called .debug_abbrev. As mentioned before, multiple
compilation units may share the same abbreviations table.
The abbreviations table for a single compilation unit consists of a series of
abbreviation declarations. Each declaration specioes the tag and attributes for a
particular form of debugging information entry. Each declaration begins with an
unsigned LEB128 number representing the abbreviation code itself. It is this code
that appears at the beginning of a debugging information entry in the
.debug_info section. As described above, the abbreviation code 0 is reserved for
null debugging information entries. The abbreviation code is followed by
another unsigned LEB128 number that encodes the entry's tag. The encodings
for the tag names are given in Table 7.3 on the next page.
An abbreviations table may be padded at the end with null bytes.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 212
                                            Chapter 7.  Data Representation
                                                  Table 7.3: Tag encodings
                            ________________________________________________________________________________________
                            __Tag_name___________________________________________________||__________Value__________
                              DW.TAG.array.type                              ||                        0x01
                              DW.TAG.class.type                               ||                       0x02
                              DW.TAG.entry.point                             ||                        0x03
                              DW.TAG.enumeration.type                 ||                               0x04
                              DW.TAG.formal.parameter                  ||                              0x05
                              Reserved                                                      ||         0x06
                              Reserved                                                      ||         0x07
                              DW.TAG.imported.declaration           ||                                 0x08
                              Reserved                                                      ||         0x09
                              DW.TAG.label                                         ||                  0x0a
                              DW.TAG.lexical.block                           ||                        0x0b
                              Reserved                                                      ||         0x0c
                              DW.TAG.member                                   ||                      0x0d
                              Reserved                                                      ||         0x0e
                              DW.TAG.pointer.type                           ||                         0x0f
                              DW.TAG.reference.type                        ||                          0x10
                              DW.TAG.compile.unit                          ||                          0x11
                              DW.TAG.string.type                             ||                        0x12
                              DW.TAG.structure.type                        ||                          0x13
                              Reserved                                                      ||         0x14
                              DW.TAG.subroutine.type                     ||                            0x15
                              DW.TAG.typedef                                    ||                     0x16
                              DW.TAG.union.type                             ||                         0x17
                              DW.TAG.unspecioed.parameters       ||                                    0x18
                              DW.TAG.variant                                     ||                    0x19
                              DW.TAG.common.block                       ||                             0x1a
                              DW.TAG.common.inclusion                ||                                0x1b
                              DW.TAG.inheritance                              ||                       0x1c
                              DW.TAG.inlined.subroutine                ||                             0x1d
                            __DW.TAG.module____________________________________||______________________0x1e_________
                              Continued on next page
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 213
                                            Chapter 7.  Data Representation
                            __Tag_name___________________________________________________||__________Value__________
                              DW.TAG.ptr.to.member.type            ||                                  0x1f
                              DW.TAG.set.type                                   ||                    0x20
                              DW.TAG.subrange.type                       ||                           0x21
                              DW.TAG.with.stmt                                ||                      0x22
                              DW.TAG.access.declaration                 ||                            0x23
                              DW.TAG.base.type                                ||                      0x24
                              DW.TAG.catch.block                             ||                       0x25
                              DW.TAG.const.type                              ||                       0x26
                              DW.TAG.constant                                   ||                    0x27
                              DW.TAG.enumerator                             ||                        0x28
                              DW.TAG.ole.type                                  ||                     0x29
                              DW.TAG.friend                                       ||                  0x2a
                              DW.TAG.namelist                                  ||                     0x2b
                              DW.TAG.namelist.item                         ||                         0x2c
                              DW.TAG.packed.type                           ||                         0x2d
                              DW.TAG.subprogram                            ||                         0x2e
                              DW.TAG.template.type.parameter    ||                                     0x2f
                              DW.TAG.template.value.parameter  ||                                     0x30
                              DW.TAG.thrown.type                           ||                         0x31
                              DW.TAG.try.block                                 ||                     0x32
                              DW.TAG.variant.part                            ||                       0x33
                              DW.TAG.variable                                   ||                    0x34
                              DW.TAG.volatile.type                           ||                       0x35
                              DW.TAG.dwarf.procedure                   ||                             0x36
                              DW.TAG.restrict.type                           ||                       0x37
                              DW.TAG.interface.type                        ||                         0x38
                              DW.TAG.namespace                              ||                        0x39
                              DW.TAG.imported.module                 ||                               0x3a
                              DW.TAG.unspecioed.type                   ||                             0x3b
                              DW.TAG.partial.unit                             ||                      0x3c
                            __DW.TAG.imported.unit________________________||__________________________0x3d__________
                              Continued on next page
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 214
                                            Chapter 7.  Data Representation
                            __Tag_name___________________________________________________||__________Value__________
                              Reserved                                                      ||       0x3e1
                              DW.TAG.condition                                 ||                     0x3f
                              DW.TAG.shared.type                            ||                        0x40
                              DW.TAG.type.unit                                ||                      0x41
                              DW.TAG.rvalue.reference.type          ||                                0x42
                              DW.TAG.template.alias                        ||                         0x43
                              DW.TAG.coarray.type                          ||                         0x44
                              DW.TAG.generic.subrange                  ||                             0x45
                              DW.TAG.dynamic.type                        ||                           0x46
                              DW.TAG.atomic.type                            ||                        0x47
                              DW.TAG.call.site                                   ||                   0x48
                              DW.TAG.call.site.parameter               ||                             0x49
                              DW.TAG.skeleton.unit                          ||                        0x4a
                              DW.TAG.immutable.type                     ||                            0x4b
                              DW.TAG.lo.user                                     ||                 0x4080
                            __DW.TAG.hi.user____________________________________||__________________0xffff__________
Following the tag encoding is a 1-byte value that determines whether a
debugging information entry using this abbreviation has child entries or not. If
the value is DW.CHILDREN.yes, the next physically succeeding entry of any
debugging information entry using this abbreviation is the orst child of that
entry. If the 1-byte value following the abbreviation's tag encoding is
DW.CHILDREN.no, the next physically succeeding entry of any debugging
information entry using this abbreviation is a sibling of that entry. (Either the
orst child or sibling entries may be null entries). The encodings for the child
determination byte are given in Table 7.4 on the following page (As mentioned in
Section 2.3 on page 25, each chain of sibling entries is terminated by a null entry.)
_________________________________________________________
      1Code 0x3e is reserved to allow backward compatible support of the DW.TAG.mutable.type
DIE that was deoned (only) in DWARF Version 3.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 215
                                            Chapter 7.  Data Representation
                                  Table 7.4: Child determination encodings
                                   __________________________________________________________________________
                                   __Children_determination_name__||___________________________Value_________
                                     DW.CHILDREN.no                   ||                        0x00
                                   __DW.CHILDREN.yes__________________||________________________0x01___________
Finally, the child encoding is followed by a series of attribute speciocations. Each
attribute speciocation consists of two parts (except for
DW.FORM.implicit.const, DW.FORM.addrx.ooeset and DW.FORM.indirect,
see below). The orst part is an unsigned LEB128 number representing the
attribute's name. The second part is an unsigned LEB128 number representing
the attribute's form. The series of attribute speciocations ends with an entry
containing 0 for the name and 0 for the form.
For attributes with the form DW.FORM.implicit.const, in addition to the
attribute name and form values, the attribute speciocation contains a third part,
which is a signed LEB128 number. The value of this number is used as the value
of the attribute.
For attributes with the form DW.FORM.addrx.ooeset, following the attribute
name, the attribute speciocation contains two unsigned LEB128 numbers, each
representing a form. The orst form must be of class address and the second of
class constant. Values using this form in the .debug_info section contain a value
for the orst form followed by a value for the second form. The total value of the
DW.FORM.addrx.ooeset is then computed by adding those two values together
(if the orst value is an indirect address, that is resolved orst before adding it to
the second value).
For attributes with the form DW.FORM.indirect, the actual attribute form value
itself is in the .debug_info section which begins with an unsigned LEB128
number that specioes the actual form, followed by the value according to that
form. This allows producers to choose forms for particular attributes
dynamically, without having to add a new entry to the abbreviations table.
If the actual attribute form is DW.FORM.implicit.const, the form is (still)
followed by a signed LEB128 number.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 216
                                            Chapter 7.  Data Representation
If the actual attribute form is itself DW.FORM.indirect, the indirection repeats.
There may be one or more occurrences of DW.FORM.indirect in sequence until
a non-DW.FORM.indirect form is reached. The sequence of
DW.FORM.indirect forms does not have any eoeect other than to use up space.
The abbreviations for a given compilation unit end with an entry consisting of a
0 byte for the abbreviation code.
See Appendix D.1.1 on page 301 for a depiction of the organization of the debugging
information.
7.5.4          Attribute Encodings
The encodings for the attribute names are given in Table 7.5 following.
                                            Table 7.5: Attribute encodings
   _________________________________________________________________________________________________________________________________________
   __Attribute_name________________________________||_______________Value___||______Classes_________________________________________________
     DW.AT.sibling                                ||                  0x01    ||    reference
     DW.AT.location                              ||                   0x02    ||    locdesc, loclist
     DW.AT.name                                  ||                   0x03    ||    string
     Reserved                                              ||         0x04    ||    not applicable
     Reserved                                              ||         0x05    ||    not applicable
     Reserved                                              ||         0x06    ||    not applicable
     Reserved                                              ||         0x07    ||    not applicable
     Reserved                                              ||         0x08    ||    not applicable
     DW.AT.ordering                             ||                    0x09    ||    constant
     Reserved                                              ||         0x0a    ||    not applicable
     DW.AT.byte.size                            ||                   0x0b    ||     constant, exprval, reference
     Reserved                                              ||        0x0c2     ||   not applicable
     DW.AT.bit.size                               ||                 0x0d    ||     constant, exprval, reference
     Reserved                                              ||         0x0e    ||    not applicable
     Reserved                                              ||         0x0f     ||   not applicable
     DW.AT.stmt.list                             ||                   0x10    ||    lineptr
   __DW.AT.low.pc_______________________________||____________________0x11____||____address_________________________________________________
     Continued on next page
_________________________________________________________
      2Code  0x0c  is  reserved  to  allow  backward  compatible  support  of  the  DW.AT.bit.ooeset
attribute     which was deoned in DWARF Version 3 and earlier.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 217
                                            Chapter 7.  Data Representation
   __Attribute_name________________________________||_______________Value___||_____Classes__________________________________________________
     DW.AT.high.pc                              ||                   0x12    ||    address, constant
     Reserved                                              ||       0x133     ||   not applicable
     Reserved                                              ||         0x14    ||    not applicable
     DW.AT.discr                                   ||                 0x15    ||    reference
     DW.AT.discr.value                        ||                      0x16    ||    constant
     DW.AT.visibility                             ||                  0x17    ||    constant
     DW.AT.import                                ||                   0x18    ||    reference
     DW.AT.string.length                     ||                       0x19    ||    locdesc, loclist, reference
     DW.AT.common.reference           ||                              0x1a    ||    reference
     DW.AT.comp.dir                           ||                     0x1b    ||     string
     DW.AT.const.value                       ||                       0x1c    ||    block, constant, string
     DW.AT.containing.type               ||                          0x1d    ||     reference
     DW.AT.default.value                    ||                        0x1e    ||    constant, reference, AEag, string
     Reserved                                              ||         0x1f     ||   not applicable
     DW.AT.inline                                  ||                 0x20    ||    constant
     DW.AT.is.optional                        ||                      0x21    ||    AEag
     DW.AT.lower.bound                    ||                          0x22    ||    constant, exprval, reference
     Reserved                                              ||         0x23    ||    not applicable
     Reserved                                              ||         0x24    ||    not applicable
     DW.AT.producer                            ||                     0x25    ||    string
     Reserved                                              ||         0x26    ||    not applicable
     DW.AT.prototyped                        ||                       0x27    ||    AEag
     Reserved                                              ||         0x28    ||    not applicable
     Reserved                                              ||         0x29    ||    not applicable
     DW.AT.return.addr                       ||                       0x2a    ||    locdesc, loclist
     Reserved                                              ||        0x2b    ||     not applicable
     DW.AT.start.scope                        ||                      0x2c    ||    constant, rnglist
     Reserved                                              ||        0x2d    ||     not applicable
     DW.AT.bit.stride                           ||                    0x2e    ||    constant, exprval, reference
   __DW.AT.upper.bound____________________||__________________________0x2f_____||___constant,_exprval,_reference____________________________
     Continued on next page
_________________________________________________________
      3Code  0x13  is  reserved  to  allow  backward  compatible  support  of  the  DW.AT.language
attribute     which was deoned in DWARF Version 5 and earlier.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 218
                                            Chapter 7.  Data Representation
   __Attribute_name________________________________||_______________Value___||_____Classes__________________________________________________
     Reserved                                              ||        0x30    ||    not applicable
     DW.AT.abstract.origin                  ||                       0x31    ||    reference
     DW.AT.accessibility                       ||                    0x32    ||    constant
     DW.AT.address.class                    ||                       0x33    ||    constant
     DW.AT.artiocial                             ||                  0x34    ||    AEag
     DW.AT.base.types                         ||                     0x35    ||    reference
     DW.AT.calling.convention           ||                           0x36    ||    constant
     DW.AT.count                                  ||                 0x37    ||    constant, exprval, reference
     DW.AT.data.member.location    ||                                 0x38    ||    constant, locdesc, loclist
     DW.AT.decl.column                     ||                         0x39    ||    constant
     DW.AT.decl.ole                             ||                    0x3a    ||    constant
     DW.AT.decl.line                            ||                   0x3b    ||     constant
     DW.AT.declaration                        ||                      0x3c    ||    AEag
     DW.AT.discr.list                            ||                  0x3d    ||     block
     DW.AT.encoding                            ||                     0x3e    ||    constant
     DW.AT.external                              ||                   0x3f    ||    AEag
     DW.AT.frame.base                        ||                       0x40    ||    locdesc, loclist
     DW.AT.friend                                 ||                  0x41    ||    reference
     DW.AT.identioer.case                  ||                         0x42    ||    constant
     Reserved                                              ||        0x434     ||   not applicable
     DW.AT.namelist.item                   ||                         0x44    ||    reference
     DW.AT.priority                              ||                   0x45    ||    reference
     Reserved                                              ||        0x465     ||   not applicable
     DW.AT.speciocation                      ||                       0x47    ||    reference
     DW.AT.static.link                          ||                    0x48    ||    locdesc, loclist
     DW.AT.type                                    ||                 0x49    ||    reference
     DW.AT.use.location                      ||                       0x4a    ||    locdesc, loclist
     DW.AT.variable.parameter          ||                            0x4b    ||     AEag
   __DW.AT.virtuality___________________________||____________________0x4c____||____constant________________________________________________
     Continued on next page
_________________________________________________________
      4Code  0x43  is  reserved  to  allow  backward  compatible  support  of  the  DW.AT.macro.info
attribute     which was deoned in DWARF Version 4 and earlier.
      5Code  0x46  is  reserved  to  allow  backward  compatible  support  of  the  DW.AT.segment
attribute     which was deoned in DWARF Version 5 and earlier.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 219
                                            Chapter 7.  Data Representation
   __Attribute_name________________________________||_______________Value___||_____Classes__________________________________________________
     DW.AT.vtable.elem.location       ||                             0x4d    ||    locdesc, loclist
     DW.AT.allocated                            ||                    0x4e    ||    constant, exprval, reference
     DW.AT.associated                          ||                     0x4f     ||   constant, exprval, reference
     DW.AT.data.location                    ||                        0x50    ||    locdesc
     DW.AT.byte.stride                        ||                      0x51    ||    constant, exprval, reference
     DW.AT.entry.pc                            ||                     0x52    ||    address, constant
     DW.AT.use.UTF8                          ||                       0x53    ||    AEag
     DW.AT.extension                           ||                     0x54    ||    reference
     DW.AT.ranges                                ||                   0x55    ||    rnglist
     DW.AT.trampoline                        ||                       0x56    ||    address, AEag, reference, string
     DW.AT.call.column                       ||                       0x57    ||    constant
     DW.AT.call.ole                              ||                   0x58    ||    constant
     DW.AT.call.line                             ||                   0x59    ||    constant
     DW.AT.description                        ||                      0x5a    ||    string
     DW.AT.binary.scale                      ||                      0x5b    ||     constant
     DW.AT.decimal.scale                    ||                        0x5c    ||    constant
     DW.AT.small                                  ||                 0x5d    ||     reference
     DW.AT.decimal.sign                     ||                        0x5e    ||    constant
     DW.AT.digit.count                        ||                      0x5f     ||   constant
     DW.AT.picture.string                   ||                        0x60    ||    string
     DW.AT.mutable                             ||                     0x61    ||    AEag
     DW.AT.threads.scaled                  ||                         0x62    ||    AEag
     DW.AT.explicit                               ||                  0x63    ||    AEag
     DW.AT.object.pointer                   ||                        0x64    ||    reference
     DW.AT.endianity                           ||                     0x65    ||    constant
     DW.AT.elemental                           ||                     0x66    ||    AEag
     DW.AT.pure                                    ||                 0x67    ||    AEag
     DW.AT.recursive                            ||                    0x68    ||    AEag
     DW.AT.signature                           ||                     0x69    ||    reference
     DW.AT.main.subprogram           ||                               0x6a    ||    AEag
     DW.AT.data.bit.ooeset                  ||                       0x6b    ||     constant
   __DW.AT.const.expr_________________________||______________________0x6c____||____AEag____________________________________________________
     Continued on next page
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 220
                                            Chapter 7.  Data Representation
   __Attribute_name________________________________||_______________Value___||_____Classes__________________________________________________
     DW.AT.enum.class                        ||                      0x6d    ||    AEag
     DW.AT.linkage.name                   ||                         0x6e    ||    string
     DW.AT.string.length.bit.size     ||                             0x6f     ||   constant
     DW.AT.string.length.byte.size  ||                               0x70    ||    constant
     DW.AT.rank                                    ||                0x71    ||    constant, exprval
     Reserved                                              ||        0x726     ||   not applicable
     DW.AT.addr.base                          ||                      0x73    ||    addrptr
     DW.AT.rnglists.base                     ||                       0x74    ||    rnglistsptr
     Reserved                                              ||         0x75    ||    not applicable
     DW.AT.dwo.name                        ||                         0x76    ||    string
     DW.AT.reference                            ||                    0x77    ||    AEag
     DW.AT.rvalue.reference               ||                          0x78    ||    AEag
     DW.AT.macros                               ||                    0x79    ||    macptr
     DW.AT.call.all.calls                      ||                     0x7a    ||    AEag
     DW.AT.call.all.source.calls        ||                           0x7b    ||     AEag
     DW.AT.call.all.tail.calls              ||                        0x7c    ||    AEag
     DW.AT.call.return.pc                   ||                       0x7d    ||     address
     DW.AT.call.value                          ||                     0x7e    ||    exprval
     DW.AT.call.origin                         ||                     0x7f     ||   reference
     DW.AT.call.parameter                  ||                         0x80    ||    reference
     DW.AT.call.pc                                ||                  0x81    ||    address
     DW.AT.call.tail.call                      ||                     0x82    ||    AEag
     DW.AT.call.target                          ||                    0x83    ||    locdesc
     DW.AT.call.target.clobbered       ||                             0x84    ||    locdesc
     DW.AT.call.data.location            ||                           0x85    ||    locdesc
     DW.AT.call.data.value                 ||                         0x86    ||    exprval
     DW.AT.noreturn                            ||                     0x87    ||    AEag
     DW.AT.alignment                          ||                      0x88    ||    constant
     DW.AT.export.symbols                ||                           0x89    ||    AEag
   __DW.AT.deleted_______________________________||___________________0x8a____||____AEag____________________________________________________
     Continued on next page
_________________________________________________________
      6Code 0x72 is reserved to allow backward compatible support of the DW.AT.str.ooesets.base
attribute     which was deoned in DWARF Version 5 and earlier.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 221
                                            Chapter 7.  Data Representation
   __Attribute_name________________________________||_______________Value___||_____Classes__________________________________________________
     DW.AT.defaulted                           ||                    0x8b    ||    constant
     DW.AT.loclists.base                      ||                     0x8c    ||    loclistsptr
     DW.AT.scale.multiplier #             ||                         0x8d    ||    constant
     DW.AT.scale.divisor #                  ||                        0x8e    ||    constant
     DW.AT.str.ooesets #                       ||                     0x8f     ||   strooesetsptr
     DW.AT.language.name #             ||                             0x90    ||    constant
     DW.AT.language.version #          ||                             0x91    ||    constant
     DW.AT.bias #                                  ||                 0x92    ||    constant
     DW.AT.tensor #                              ||                   0x93    ||    AEag
     DW.AT.num.lanes #                      ||                        0x94    ||    constant, exprval, vallist
     DW.AT.lo.user                               ||                 0x2000  ||      ~
   __DW.AT.hi.user_______________________________||________________0x3fff__||_______~_______________________________________________________
     # New in DWARF Version 6
7.5.5          Classes and Forms
Each class is a set of forms which have related representations and which are
given a common interpretation according to the attribute in which the form is
used. The attribute form governs how the value of an attribute is encoded. The
classes and the forms they include are listed below.
Form DW.FORM.sec.ooeset is a member of more than one class, namely
addrptr, lineptr, loclist, loclistsptr, macptr, rnglist, rnglistsptr, and strooesetsptr;
as a result, it is not possible for an attribute to allow more than one of these
classes. The list of classes allowed by the applicable attribute in Table 7.5 on
page 217 determines the class of the form.
In the form descriptions that follow, some forms are said to depend in part on the
value of an attribute of the associated compilation unit:
     #    In the case of a split DWARF object ole, the associated compilation unit is
          the skeleton compilation unit corresponding to the containing unit.
     #    Otherwise, the associated compilation unit is the containing unit.
Each possible form belongs to one or more of the following classes (see Table 2.3
on page 23 for a summary of the purpose and general usage of each class):
     #    address
          Represented as either:
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 222
                                            Chapter 7.  Data Representation
               ~  An object of appropriate size to hold an address on the target machine
                  (DW.FORM.addr). The size is encoded in the compilation unit header
                  (see Section 7.5.1.1 on page 209). This address is relocatable in a
                  relocatable object ole and is relocated in an executable ole or shared
                  object ole.
               ~  An indirect index into a table of addresses (as described in the
                  previous bullet) in the .debug_addr section (DW.FORM.addrx,
                  DW.FORM.addrx1, DW.FORM.addrx2, DW.FORM.addrx3 and
                  DW.FORM.addrx4). The representation of a DW.FORM.addrx value
                  is an unsigned LEB128 value, which is interpreted as a zero-based
                  index into an array of addresses in the .debug_addr section. The
                  representation of a DW.FORM.addrx1, DW.FORM.addrx2,
                  DW.FORM.addrx3 or DW.FORM.addrx4 value is a 1-, 2-, 3- or
                  4-byte unsigned integer value, respectively, which is similarly
                  interpreted. The index is relative to the value of the
                  DW.AT.addr.base attribute of the associated compilation unit.
     #    addrptr
          This is an ooeset into the .debug_addr section (DW.FORM.sec.ooeset). It
          consists of an ooeset from the beginning of the .debug_addr section to the
          beginning of the list of machine addresses information for the referencing
          entity. It is relocatable in a relocatable object ole, and relocated in an
          executable or shared object ole. In the 32-bit DWARF format, this ooeset is a
          4-byte unsigned value; in the 64-bit DWARF format, it is an 8-byte
          unsigned value (see Section 7.4 on page 204).
     #    block
          Blocks come in four forms:
               ~   A 1-byte length followed by 0 to 255 contiguous information bytes
                   (DW.FORM.block1).
               ~   A 2-byte length followed by 0 to 65,535 contiguous information bytes
                   (DW.FORM.block2).
               ~   A 4-byte length followed by 0 to 4,294,967,295 contiguous information
                   bytes (DW.FORM.block4).
               ~   An unsigned LEB128 length followed by the number of bytes specioed
                   by the length (DW.FORM.block).
          In all forms, the length is the number of information bytes that follow. The
          information bytes may contain any mixture of relocated (or relocatable)
          addresses, references to other debugging information entries or data bytes.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 223
                                            Chapter 7.  Data Representation
     #    constant
          There are eight forms of constants. There are oxed length constant data
          forms for one-, two-, four-, eight- and sixteen-byte values (respectively,
          DW.FORM.data1, DW.FORM.data2, DW.FORM.data4,
          DW.FORM.data8 and DW.FORM.data16). There are variable length
          constant data forms encoded using signed LEB128 numbers
          (DW.FORM.sdata) and unsigned LEB128 numbers (DW.FORM.udata).
          There is also an implicit constant (DW.FORM.implicit.const, see Section
          7.5.3 on page 216), whose value is provided as part of an abbreviation
          speciocation.
          The data in DW.FORM.data1, DW.FORM.data2, DW.FORM.data4,
          DW.FORM.data8 and DW.FORM.data16 can be anything. Depending on
          context, it may be a signed integer, an unsigned integer, a AEoating-point
          constant, or anything else. A consumer must use context to know how to
          interpret the bits, which if they are target machine data (such as an integer
          or AEoating-point constant) will be in target machine byte order.
          If one of the DW.FORM.data!n?forms is used to represent a signed or unsigned
          integer, it can be hard for a consumer to discover the context necessary to
          determine which interpretation is intended. Producers are therefore strongly
          encouraged to use DW.FORM.sdata or DW.FORM.udata for signed and
          unsigned integers respectively, rather than DW.FORM.data!n?.
     #    exprval
          A DWARF expression that evaluates to a value (see Section 2.5 on page 26).
          This is represented as an unsigned LEB128 length, followed by a byte
          sequence of the specioed length (DW.FORM.exprval) containing the
          expression.
     #    AEag
          A AEag is represented explicitly as a single byte of data (DW.FORM.AEag) or
          implicitly (DW.FORM.AEag.present). In the orst case, if the AEag has value
          zero, it indicates the absence of the attribute; if the AEag has a non-zero
          value, it indicates the presence of the attribute. In the second case, the
          attribute is implicitly indicated as present, and no value is encoded in the
          debugging information entry itself.
     #    lineptr
          This is an ooeset into the .debug_line or .debug_line.dwo section
          (DW.FORM.sec.ooeset). It consists of an ooeset from the beginning of the
          .debug_line section to the orst byte of the data making up the line number
          list for the compilation unit. It is relocatable in a relocatable object ole, and
          relocated in an executable or shared object ole. In the 32-bit DWARF
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 224
                                            Chapter 7.  Data Representation
          format, this ooeset is a 4-byte unsigned value; in the 64-bit DWARF format,
          it is an 8-byte unsigned value (see Section 7.4 on page 204).
     #    locdesc
          A DWARF location description (see Section 2.6 on page 39). This is
          represented as an unsigned LEB128 length, followed by a byte sequence of
          the specioed length (DW.FORM.locdesc) containing the location
          description.
     #    loclist
          A location list (see Section 2.6.2 on page 44). This is represented as either:
               ~   An index into the .debug_loclists section (DW.FORM.loclistx). The
                   unsigned ULEB operand identioes an ooeset location relative to the
                   base of that section (the location of the orst ooeset in the section, not the
                   orst byte of the section). The contents of that location is then added to
                   the base to determine the location of the target list of entries.
               ~   An ooeset into the .debug_loclists section (DW.FORM.sec.ooeset).
                   The operand consists of a byte ooeset from the beginning of the
                   .debug_loclists section. It is relocatable in a relocatable object ole,
                   and relocated in an executable or shared object ole. In the 32-bit
                   DWARF format, this ooeset is a 4-byte unsigned value; in the 64-bit
                   DWARF format, it is an 8-byte unsigned value (see Section 7.4 on
                   page 204).
     #    loclistsptr
          This is an ooeset into the .debug_loclists section (DW.FORM.sec.ooeset).
          The operand consists of a byte ooeset from the beginning of the
          .debug_loclists section. It is relocatable in a relocatable object ole, and
          relocated in an executable or shared object ole. In the 32-bit DWARF
          format, this ooeset is a 4-byte unsigned value; in the 64-bit DWARF format,
          it is an 8-byte unsigned value (see Section 7.4 on page 204).
     #    macptr
          This is an ooeset into the .debug_macro or .debug_macro.dwo section
          (DW.FORM.sec.ooeset). It consists of an ooeset from the beginning of the
          .debug_macro or .debug_macro.dwo section to the the header making up
          the macro information list for the compilation unit. It is relocatable in a
          relocatable object ole, and relocated in an executable or shared object ole. In
          the 32-bit DWARF format, this ooeset is a 4-byte unsigned value; in the 64-bit
          DWARF format, it is an 8-byte unsigned value (see Section 7.4 on page 204).
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 225
                                            Chapter 7.  Data Representation
     #    rnglist
          This is represented as either:
               ~   An index into the .debug_rnglists section (DW.FORM.rnglistx). The
                   unsigned ULEB operand identioes an ooeset location relative to the
                   base of that section (the location of the orst ooeset in the section, not the
                   orst byte of the section). The contents of that location is then added to
                   the base to determine the location of the target range list of entries.
               ~   An ooeset into the .debug_rnglists section (DW.FORM.sec.ooeset).
                   The operand consists of a byte ooeset from the beginning of the
                   .debug_rnglists section. It is relocatable in a relocatable object ole,
                   and relocated in an executable or shared object ole. In the 32-bit
                   DWARF format, this ooeset is a 4-byte unsigned value; in the 64-bit
                   DWARF format, it is an 8-byte unsigned value (see Section 7.4 on
                   page 204).
     #    rnglistsptr
          This is an ooeset into the .debug_rnglists section (DW.FORM.sec.ooeset).
          It consists of a byte ooeset from the beginning of the .debug_rnglists
          section. It is relocatable in a relocatable object ole, and relocated in an
          executable or shared object ole. In the 32-bit DWARF format, this ooeset is a
          4-byte unsigned value; in the 64-bit DWARF format, it is an 8-byte
          unsigned value (see Section 7.4 on page 204).
     #    reference
          There are four types of reference.
               ~   The orst type of reference can identify any debugging information
                   entry within the containing unit. This type of reference is an ooeset
                   from the orst byte of the compilation header for the compilation unit
                   containing the reference. There are ove forms for this type of reference.
                   There are oxed length forms for one, two, four and eight byte ooesets
                   (respectively, DW.FORM.ref1, DW.FORM.ref2, DW.FORM.ref4,
                   and DW.FORM.ref8). There is also an unsigned variable length ooeset
                   encoded form that uses unsigned LEB128 numbers
                   (DW.FORM.ref.udata). Because this type of reference is within the
                   containing compilation unit, no relocation of the value is required.
               ~   The second type of reference can identify any debugging information
                   entry within a .debug_info section; in particular, it may refer to an
                   entry in a dioeerent compilation unit from the unit containing the
                   reference, and may refer to an entry in a dioeerent shared object ole.
                   This type of reference (DW.FORM.ref.addr) is an ooeset from the
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 226
                                            Chapter 7.  Data Representation
                  beginning of the .debug_info section of the target executable or
                  shared object ole, or, for references within a supplementary object ole,
                  an ooeset from the beginning of the local .debug_info section; it is
                  relocatable in a relocatable object ole and frequently relocated in an
                  executable or shared object ole. In the 32-bit DWARF format, this
                  ooeset is a 4-byte unsigned value; in the 64-bit DWARF format, it is an
                  8-byte unsigned value (see Section 7.4 on page 204).
                  A debugging information entry that may be referenced by another compilation
                  unit using DW.FORM.ref.addr must have a global symbolic name.
                  For a reference from one executable or shared object ole to another, the
                  reference is resolved by the debugger to identify the executable or shared object
                  ole and the ooeset into that ole's .debug_info section in the same fashion as
                  the run time loader, either when the debug information is orst read, or when
                  the reference is used.
               ~  The third type of reference can identify any debugging information
                  type entry that has been placed in its own type unit. This type of
                  reference (DW.FORM.ref.sig8) is the 8-byte type signature (see
                  Section 7.32 on page 258) that was computed for the type.
               ~  The fourth type of reference is a reference from within the .debug_info
                  section of the executable or shared object ole to a debugging
                  information entry in the .debug_info section of a supplementary
                  object ole. This type of reference (DW.FORM.ref.sup4 or
                  DW.FORM.ref.sup8) is a 4- or 8-byte ooeset (respectively) from the
                  beginning of the .debug_info section in the supplementary object ole.
                  The use of compilation unit relative references will reduce the number of
                  link-time relocations and so speed up linking. The use of the second, third and
                  fourth type of reference allows for the sharing of information, such as types,
                  across compilation units, while the fourth type further allows for sharing of
                  information across compilation units from dioeerent executables or shared
                  object oles.
                  A reference to any kind of compilation unit identioes the debugging
                  information entry for that unit, not the preceding header.
     #    string
          A string is a sequence of contiguous non-null bytes followed by one null
          byte. A string may be represented:
               ~   Immediately in the debugging information entry itself
                   (DW.FORM.string),
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 227
                                            Chapter 7.  Data Representation
               ~  As an ooeset into a string table contained in the .debug_str section of
                  the object ole (DW.FORM.strp or DW.FORM.strp8), the
                   .debug_line_str section of the object ole (DW.FORM.line.strp), or
                   as an ooeset into a string table contained in the .debug_str section of a
                   supplementary object ole (DW.FORM.strp.sup or
                   DW.FORM.strp.sup8), DW.FORM.strp.sup ooesets from the
                   .debug_info section of a supplementary object ole refer to the local
                   .debug_str section of that same ole.
                   In the 32-bit DWARF format, the representation of a DW.FORM.strp,
                   DW.FORM.line.strp or DW.FORM.strp.sup value is a 4-byte
                   unsigned ooeset; in the 64-bit DWARF format, it is an 8-byte unsigned
                   ooeset (see Section 7.4 on page 204). In both 32-bit and 64-bit formats,
                   the representation of a DW.FORM.strp8 or DW.FORM.strp.sup8
                   value is an 8-byte unsigned ooeset.
               ~   As an indirect ooeset into the string table using an index into a table of
                   ooesets contained in the .debug_str_offsets section of the object ole
                   (DW.FORM.strx, DW.FORM.strx1, DW.FORM.strx2,
                   DW.FORM.strx3 and DW.FORM.strx4). The representation of a
                   DW.FORM.strx value is an unsigned LEB128 value, which is
                   interpreted as a zero-based index into an array of ooesets in the
                   .debug_str_offsets section. The representation of a
                   DW.FORM.strx1, DW.FORM.strx2, DW.FORM.strx3 or
                   DW.FORM.strx4 value is a 1-, 2-, 3- or 4-byte unsigned integer value,
                   respectively, which is similarly interpreted. The ooeset entries in the
                   .debug_str_offsets section are described in Section 7.26 on page 253.
          Any combination of these three forms may be used within a single
          compilation.
          If the DW.AT.use.UTF8  attribute is specioed for the compilation, partial,
          skeleton or type unit entry, string values are encoded using the UTF-8
          (Unicode Transformation Format-8) from the Universal Character Set
          standard (ISO/IEC 10646-1:1993). Otherwise, the string representation is
          unspecioed.
          The Unicode Standard Version 3 is fully compatible with ISO/IEC 10646-1:1993.
          It contains all the same characters and encoding points as ISO/IEC 10646, as well
          as additional information about the characters and their use.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 228
                                            Chapter 7.  Data Representation
          Earlier versions of DWARF did not specify the representation of strings; for
          compatibility, this version also does not. However, the UTF-8 representation is
          strongly recommended.
     #    strooesetsptr
          This is an ooeset into the .debug_str_offsets section
          (DW.FORM.sec.ooeset). It consists of an ooeset from the beginning of the
          .debug_str_offsets section to the header of the string ooesets information
          for the referencing entity. It is relocatable in a relocatable object ole, and
          relocated in an executable or shared object ole. In the 32-bit DWARF
          format, this ooeset is a 4-byte unsigned value; in the 64-bit DWARF format,
          it is an 8-byte unsigned value (see Section 7.4 on page 204).
     #    vallist
          A value list (see Section 2.5.2 on page 38). This class has the same
          representation as class loclist.
          This class is new in DWARF Version 6.
In no case does an attribute use one of the classes addrptr, lineptr, loclistsptr,
macptr, rnglistsptr or strooesetsptr to point into either the .debug_info or
.debug_str section.
7.5.6          Form Encodings
The form encodings are listed in Table 7.6 following.
                                        Table 7.6: Attribute form encodings
  _____________________________________________________________________________________________________________________________________________
  __Form_name_____________________________||___________Value__||______Classes__________________________________________________________________
    DW.FORM.addr                   ||                    0x01   ||    address
    Reserved                                   ||        0x02   ||
    DW.FORM.block2                ||                     0x03   ||    block
    DW.FORM.block4                ||                     0x04   ||    block
    DW.FORM.data2                 ||                     0x05   ||    constant
    DW.FORM.data4                 ||                     0x06   ||    constant
    DW.FORM.data8                 ||                     0x07   ||    constant
    DW.FORM.string                 ||                    0x08   ||    string
    DW.FORM.block                  ||                    0x09   ||    block
  __DW.FORM.block1________________||_____________________0x0a___||____block____________________________________________________________________
    Continued on next page
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 229
                                            Chapter 7.  Data Representation
 __Form_name_____________________________||____________Value__||_____Classes__________________________________________________________________
   DW.FORM.data1                 ||                     0x0b   ||    constant
   DW.FORM.AEag                    ||                   0x0c    ||   AEag
   DW.FORM.sdata                  ||                    0x0d   ||    constant
   DW.FORM.strp                    ||                   0x0e   ||    string
   DW.FORM.udata                 ||                     0x0f    ||   constant
   DW.FORM.ref.addr            ||                       0x10   ||    reference
   DW.FORM.ref1                    ||                   0x11   ||    reference
   DW.FORM.ref2                    ||                   0x12   ||    reference
   DW.FORM.ref4                    ||                   0x13   ||    reference
   DW.FORM.ref8                    ||                   0x14   ||    reference
   DW.FORM.ref.udata          ||                        0x15   ||    reference
   DW.FORM.indirect              ||                     0x16   ||    (see Section 7.5.3 on page 212)
   DW.FORM.sec.ooeset          ||                       0x17   ||    addrptr, lineptr, loclist, loclistsptr,
                                                     |             | macptr, rnglist, rnglistsptr, strooesetsptr
                                                     |             |
   DW.FORM.exprloc              ||                      0x18   ||    exprval, locdesc
    DW.FORM.AEag.present     ||                          0x19   ||    AEag
    DW.FORM.strx                    ||                   0x1a   ||    string
    DW.FORM.addrx                 ||                    0x1b   ||     address
    DW.FORM.ref.sup4            ||                       0x1c    ||   reference
    DW.FORM.strp.sup            ||                      0x1d   ||     string
    DW.FORM.data16               ||                      0x1e   ||    constant
    DW.FORM.line.strp            ||                      0x1f    ||   string
    DW.FORM.ref.sig8             ||                      0x20   ||    reference
    DW.FORM.implicit.const  ||                           0x21   ||    constant
    DW.FORM.loclistx               ||                    0x22   ||    loclist, vallist
    DW.FORM.rnglistx              ||                     0x23   ||    rnglist
    DW.FORM.ref.sup8            ||                       0x24   ||    reference
    DW.FORM.strx1                  ||                    0x25   ||    string
    DW.FORM.strx2                  ||                    0x26   ||    string
    DW.FORM.strx3                  ||                    0x27   ||    string
    DW.FORM.strx4                  ||                    0x28   ||    string
  __DW.FORM.addrx1_______________||______________________0x29___||____address__________________________________________________________________
    Continued on next page
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 230
                                            Chapter 7.  Data Representation
 __Form_name_____________________________||____________Value__||_____Classes__________________________________________________________________
   DW.FORM.addrx2               ||                      0x2a   ||    address
   DW.FORM.addrx3               ||                      0x2b   ||    address
   DW.FORM.addrx4               ||                      0x2c    ||   address
   DW.FORM.strp8 #               ||                     0x2d   ||    string
  __DW.FORM.strp.sup8_#_______||_________________________0x2e___||____string___________________________________________________________________
    # New in DWARF Version 6
7.6          Variable  Length  Data
Integers may be encoded using iLittle-Endian Base 128j (LEB128) numbers.
LEB128 is a scheme for encoding integers densely that exploits the assumption
that most integers are small in magnitude.
This encoding is equally suitable whether the target machine architecture represents data
in big-endian or little-endian byte order. It is ilittle-endianj only in the sense that it
avoids using space to represent the ibigj end of an unsigned integer, when the big end is
all zeroes or sign extension bits.
Unsigned LEB128 (ULEB128) numbers are encoded as follows: start at the low
order end of an unsigned integer and chop it into 7-bit chunks. Place each chunk
into the low order 7 bits of a byte. Typically, several of the high order bytes will
be zero, which may be discarded. Emit the remaining bytes in a stream, starting
with the low order byte; set the high order bit on each byte except the last
emitted byte. The high bit of zero on the last byte indicates to the decoder that it
has encountered the last byte.
The integer zero is a special case, consisting of a single zero byte.
Table 7.7 on the following page gives some examples of unsigned LEB128
numbers. The 0x80 in each case is the high order bit of the byte, indicating that
an additional byte follows.
The encoding for signed, two's complement LEB128 (SLEB128) numbers is
similar, except that the criterion for discarding high order bytes is not whether
they are zero, but whether they consist entirely of sign extension bits. Consider
the 4-byte integer -2. The three high level bytes of the number are sign extension,
thus LEB128 would represent it as a single byte containing the low order 7 bits,
with the high order bit cleared to indicate the end of the byte stream. Note that
there is nothing within the LEB128 representation that indicates whether an
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 231
                                            Chapter 7.  Data Representation
encoded number is signed or unsigned. The decoder must know what type of
number to expect. Table 7.7 gives some examples of unsigned LEB128 numbers
and Table 7.8 gives some examples of signed LEB128 numbers.
Some producers may choose to insert padding or alignment bytes by retaining (not
discarding) one or more high-order bytes that would not aoeect the decoded value.
Appendix C on page 297 gives algorithms for encoding and decoding these forms.
                          Table 7.7: Examples of unsigned LEB128 encodings
                          ___________________________________________________________________________________________
                          ______________Number______________||_________First_byte__||_______Second_byte______________
                                               2                    ||        2          ||          ~
                                             127                  ||        127        ||            ~
                                             128                  ||    0 + 0x80    ||                1
                                             129                  ||    1 + 0x80    ||                1
                          _________________12857________________||_____57_+_0x80___||_______________100______________
                            Table 7.8: Examples of signed LEB128 encodings
                         ______________________________________________________________________________________________
                         ______________Number______________||__________First_byte____||______Second_byte_______________
                                             2                    ||          2           ||          ~
                                             -2                    ||      0x7e        ||             ~
                                           127                  ||    127 + 0x80   ||                  0
                                           -127                  ||     1 + 0x80     ||              0x7f
                                           128                  ||      0 + 0x80     ||                1
                                           -128                  ||     0 + 0x80     ||              0x7f
                                           129                  ||      1 + 0x80     ||                1
                         __________________-129__________________||___0x7f_+_0x80__||________________0x7e______________
7.7          DWARF  Expressions  and  Location  Descriptions
7.7.1          DWARF Expressions
A DWARF expression is stored in a block of contiguous bytes. The bytes form a
sequence of operations. Each operation is a 1-byte code that identioes that
operation, followed by zero or more bytes of additional data. The encodings for
the operations are described in Table 7.9 on the following page.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 232
                                            Chapter 7.  Data Representation
                                       Table 7.9: DWARF operation encodings
_____________________________________________________________________________________________________________________________________________________
                                                         |             |    No. of     |
                                                         |             |               |
__Operation_____________________________________||_________Code__||______Operands__||__________Notes_________________________________________________
  Reserved                                         ||       0x01   ||            -           ||
  Reserved                                         ||       0x02   ||            -           ||
  DW.OP.addr                              ||                0x03   ||            1          || constant address
                                                         |             |                     | (size is target specioc)
                                                         |             |                     |
  Reserved                                         ||       0x04   ||            -           ||
  Reserved                                         ||       0x05   ||            -           ||
  DW.OP.deref                              ||               0x06   ||            0          ||
  Reserved                                         ||       0x07   ||            -           ||
  DW.OP.const1u                         ||                  0x08   ||            1          || 1-byte constant
  DW.OP.const1s                          ||                 0x09   ||            1          || 1-byte constant
  DW.OP.const2u                         ||                  0x0a   ||            1          || 2-byte constant
  DW.OP.const2s                          ||                 0x0b   ||            1          || 2-byte constant
  DW.OP.const4u                         ||                  0x0c   ||            1          || 4-byte constant
  DW.OP.const4s                          ||                 0x0d   ||            1          || 4-byte constant
  DW.OP.const8u                         ||                  0x0e   ||            1          || 8-byte constant
  DW.OP.const8s                          ||                  0x0f   ||           1          || 8-byte constant
  DW.OP.constu                           ||                 0x10   ||            1          || ULEB128 constant
  DW.OP.consts                            ||                0x11   ||            1          || SLEB128 constant
  DW.OP.dup                                ||               0x12   ||            0          ||
  DW.OP.drop                              ||                0x13   ||            0          ||
  DW.OP.over                               ||               0x14   ||            0          ||
  DW.OP.pick                               ||               0x15   ||            1          || 1-byte stack index
  DW.OP.swap                             ||                 0x16   ||            0          ||
  DW.OP.rot                                  ||             0x17   ||            0          ||
  DW.OP.xderef                            ||                0x18   ||            0          ||
  DW.OP.abs                                 ||              0x19   ||            0          ||
  DW.OP.and                                ||               0x1a   ||            0          ||
  DW.OP.div                                 ||              0x1b   ||            0          ||
__DW.OP.minus____________________________||_________________0x1c___||____________0__________||_______________________________________________________
  Continued on next page
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 233
                                            Chapter 7.  Data Representation
                                                         |            |     No. of     |
                                                         |            |                |
__Operation_____________________________________||_________Code__||______Operands__||__________Notes_________________________________________________
  DW.OP.mod                               ||                0x1d   ||            0          ||
  DW.OP.mul                                ||               0x1e   ||            0          ||
  DW.OP.neg                                ||               0x1f   ||            0          ||
  DW.OP.not                                 ||              0x20   ||            0          ||
  DW.OP.or                                   ||             0x21   ||            0          ||
  DW.OP.plus                               ||               0x22   ||            0          ||
  DW.OP.plus.uconst                  ||                     0x23   ||            1          || ULEB128 addend
  DW.OP.shl                                  ||             0x24   ||            0          ||
  DW.OP.shr                                 ||              0x25   ||            0          ||
  DW.OP.shra                               ||               0x26   ||            0          ||
  DW.OP.xor                                 ||              0x27   ||            0          ||
  DW.OP.bra                                 ||              0x28   ||            1          || signed 2-byte constant
  DW.OP.eq                                   ||             0x29   ||            0          ||
  DW.OP.ge                                   ||             0x2a   ||            0          ||
  DW.OP.gt                                   ||             0x2b   ||            0          ||
  DW.OP.le                                    ||            0x2c   ||            0          ||
  DW.OP.lt                                    ||            0x2d   ||            0          ||
  DW.OP.ne                                   ||             0x2e   ||            0          ||
__DW.OP.skip_______________________________||_______________0x2f___||____________1__________||_signed_2-byte_constant________________________________
  DW.OP.lit0                                 ||             0x30   ||            0          ||
  DW.OP.lit1                                 ||             0x31   ||            0          || literals 0 .. 31 =
  . . .                                                   ||          ||                    ||   (DW.OP.lit0 + literal)
__DW.OP.lit31_______________________________||______________0x4f___||____________0__________||_______________________________________________________
  DW.OP.reg0                               ||               0x50   ||            0          ||
  DW.OP.reg1                               ||               0x51   ||            0          || reg 0 .. 31 =
  . . .                                                   ||          ||                    ||   (DW.OP.reg0 + regnum)
__DW.OP.reg31_____________________________||________________0x6f___||____________0__________||_______________________________________________________
  DW.OP.breg0                             ||                0x70   ||            1          || SLEB128 ooeset
  DW.OP.breg1                             ||                0x71   ||            1          || base register 0 .. 31 =
  ...                                                    ||           ||                    ||   (DW.OP.breg0 + regnum)
__DW.OP.breg31___________________________||_________________0x8f___||____________1__________||________________________________________________________
  Continued on next page
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 234
                                            Chapter 7.  Data Representation
                                                         |            |     No. of     |
                                                         |            |                |
__Operation_____________________________________||_________Code__||______Operands__||__________Notes__________________________________________________
  DW.OP.regx                               ||               0x90   ||            1          || ULEB128 register
  DW.OP.fbreg                              ||               0x91   ||            1          || SLEB128 ooeset
  DW.OP.bregx                             ||                0x92   ||            2          || ULEB128 register,
                                                         |            |                     |  SLEB128 ooeset
                                                         |            |                     |
  DW.OP.piece                              ||               0x93   ||            1          || ULEB128 size of piece
  DW.OP.deref.size                     ||                   0x94   ||            1          || 1-byte size of data retrieved
  DW.OP.xderef.size                   ||                    0x95   ||            1          || 1-byte size of data retrieved
  DW.OP.nop                                ||               0x96   ||            0          ||
  DW.OP.push.object.address  ||                             0x97   ||            0          ||
  DW.OP.call2                               ||              0x98   ||            1          || 2-byte ooeset of DIE
  DW.OP.call4                               ||              0x99   ||            1          || 4-byte ooeset of DIE
  DW.OP.call.ref                          ||                0x9a   ||            1          || 4- or 8-byte ooeset of DIE
  DW.OP.form.tls.address         ||                         0x9b   ||            0          ||
  DW.OP.call.frame.cfa             ||                       0x9c   ||            0          ||
  DW.OP.bit.piece                       ||                  0x9d   ||            2          || ULEB128 size,
                                                         |            |                     |  ULEB128 ooeset
                                                         |            |                     |
  DW.OP.implicit.value              ||                      0x9e   ||            2          || ULEB128 size,
                                                         |            |                     |  block of that size
                                                         |            |                     |
  DW.OP.stack.value                  ||                     0x9f   ||            0          ||
  DW.OP.implicit.pointer          ||                        0xa0   ||                       || 4- or 8-byte ooeset of DIE,
                                                         |            |                     |  SLEB128 constant ooeset
                                                         |            |                     |
  DW.OP.addrx                            ||                 0xa1   ||            1          || ULEB128 indirect address
  DW.OP.constx                            ||                0xa2   ||            1          || ULEB128 indirect constant
  DW.OP.entry.value                  ||                     0xa3   ||            2          || ULEB128 size,
                                                         |            |                     |  block of that size
                                                         |            |                     |
  DW.OP.const.type                    ||                    0xa4   ||            3          || ULEB128 type entry ooeset,
                                                         |            |                     |  1-byte size,
                                                         |            |                     |
                                                         |            |                     |  constant value
                                                         |            |                     |
  DW.OP.regval.type                  ||                     0xa5   ||            2          || ULEB128 register number,
                                                         |            |                     |  ULEB128 constant ooeset
_________________________________________________________|____________|_____________________|________________________________________________________
  Continued on next page
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 235
                                            Chapter 7.  Data Representation
                                                         |            |     No. of     |
                                                         |            |                |
__Operation_____________________________________||_________Code__||______Operands__||__________Notes_________________________________________________
  DW.OP.deref.type                    ||                    0xa6   ||            2          || 1-byte size,
                                                         |            |                     |  ULEB128 type entry ooeset
                                                         |            |                     |
  DW.OP.xderef.type                  ||                     0xa7   ||            2          || 1-byte size,
                                                         |            |                     |  ULEB128 type entry ooeset
                                                         |            |                     |
  DW.OP.convert                          ||                 0xa8   ||            1          || ULEB128 type entry ooeset
  DW.OP.reinterpret                    ||                   0xa9   ||            1          || ULEB128 type entry ooeset
  DW.OP.regval.bits #                 ||                    0xaa   ||            1          || ULEB128 oeld size,
                                                         |            |     TOS #      |       integer bit ooeset,
                                                         |            |                |
                                                         |            |    TOS - 1     |       integer register number
                                                         |            |                |
  DW.OP.push.lane #                  ||                     0xab   ||            0          ||
  DW.OP.extended #                    ||                    0xde   ||          1 +        ||
  DW.OP.user.extended #          ||                         0xdf   ||          1 +        ||
  DW.OP.lo.user                          ||                 0xe0   ||                        ||
__DW.OP.hi.user__________________________||_________________0xff___||________________________||______________________________________________________
  # New in DWARF Version 6                                               # TOS indicates parameter on top of stack
7.7.2          Location Descriptions
A location description is used to compute the location of a variable or other
entity.
7.7.3          Location Lists
Each entry in a location list is either a location list entry, a base address entry, a
default location entry or an end-of-list entry.
Each entry begins with an unsigned 1-byte code that indicates the kind of entry
that follows. The encodings for these constants are given in Table 7.10 on the next
page.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 236
                                            Chapter 7.  Data Representation
                              Table 7.10: Location list entry encoding values
                               _________________________________________________________________________________
                               __Location_list_entry_encoding_name__||_____________________________Value________
                                 DW.LLE.end.of.list                          ||                     0x00
                                 DW.LLE.base.addressx                    ||                         0x01
                                 DW.LLE.startx.endx                         ||                      0x02
                                 DW.LLE.startx.length                      ||                       0x03
                                 DW.LLE.ooeset.pair                           ||                    0x04
                                 DW.LLE.default.location                 ||                         0x05
                                 DW.LLE.base.address                      ||                        0x06
                                 DW.LLE.start.end                             ||                    0x07
                                 DW.LLE.start.length                        ||                      0x08
                                 DW.LLE.include.loclist #                 ||                        0x09
                                 DW.LLE.include.loclistx #               ||                         0x0a
                                 DW.LLE.lo.user #                              ||                   0xc0
                               __DW.LLE.hi.user_#_____________________________||____________________0xff________
                                 # New in DWARF Version 6
If a producer deones a producer-specioc kind of location list entry, the kind code
must be immediately followed by an unsigned LEB128 value that specioes the
length of all remaining bytes (not including either the kind or the length itself)
for that entry.
7.8          Base  Type  Attribute  Encodings
The encodings of the constants used in the DW.AT.encoding attribute are given
in Table 7.11.
                                      Table 7.11: Base type encoding values
                                 ______________________________________________________________________________
                                 __Base_type_encoding_name______________||_______________________Value_________
                                   DW.ATE.address                            ||                   0x01
                                   DW.ATE.boolean                            ||                   0x02
                                   DW.ATE.complex.AEoat                 ||                        0x03
                                 __DW.ATE.AEoat__________________________________||_______________0x04_________
                                   Continued on next page                      ||
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 237
                                            Chapter 7.  Data Representation
                                 __Base_type_encoding_name______________||_______________________Value_________
                                   DW.ATE.signed                              ||                  0x05
                                   DW.ATE.signed.char                    ||                       0x06
                                   DW.ATE.unsigned                         ||                     0x07
                                   DW.ATE.unsigned.char                ||                         0x08
                                   DW.ATE.imaginary.AEoat              ||                         0x09
                                   DW.ATE.packed.decimal             ||                           0x0a
                                   DW.ATE.numeric.string               ||                         0x0b
                                   DW.ATE.edited                               ||                 0x0c
                                   DW.ATE.signed.oxed                   ||                        0x0d
                                   DW.ATE.unsigned.oxed               ||                          0x0e
                                   DW.ATE.decimal.AEoat                  ||                       0x0f
                                   DW.ATE.UTF                                  ||                 0x10
                                   DW.ATE.UCS                                  ||                 0x11
                                   DW.ATE.ASCII                               ||                  0x12
                                   DW.ATE.complex.signed #          ||                            0x13
                                   DW.ATE.imaginary.signed #       ||                             0x14
                                   DW.ATE.complex.unsigned #     ||                               0x15
                                   DW.ATE.imaginary.unsigned #  ||                                0x16
                                   DW.ATE.signed.bitint #                ||                       0x17
                                   DW.ATE.unsigned.bitint #           ||                          0x18
                                   DW.ATE.lo.user                             ||                  0x80
                                 __DW.ATE.hi.user_____________________________||__________________0xff_________
                                   # New in DWARF Version 6
The encodings of the constants used in the DW.AT.decimal.sign attribute are
given in Table 7.12 on the next page.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 238
                                            Chapter 7.  Data Representation
                                        Table 7.12: Decimal sign encodings
                                     ______________________________________________________________________
                                     __Decimal_sign_code_name________||______________________Value_________
                                       DW.DS.unsigned                    ||                    0x01
                                       DW.DS.leading.overpunch  ||                             0x02
                                       DW.DS.trailing.overpunch   ||                           0x03
                                       DW.DS.leading.separate       ||                         0x04
                                     __DW.DS.trailing.separate_______||________________________0x05________
The encodings of the constants used in the DW.AT.endianity attribute are given
in Table 7.13.
                                           Table 7.13: Endianity encodings
                                           __________________________________________________________
                                           __Endian_code_name_______||_________________Value_________
                                             DW.END.default        ||                    0x00
                                             DW.END.big               ||                 0x01
                                             DW.END.little             ||                0x02
                                             DW.END.lo.user        ||                    0x40
                                           __DW.END.hi.user________||___________________0xff_________
7.9          Accessibility  Codes
The encodings of the constants used in the DW.AT.accessibility attribute are
given in Table 7.14.
                                         Table 7.14: Accessibility encodings
                                        ________________________________________________________________
                                        __Accessibility_code_name__||_____________________Value_________
                                          DW.ACCESS.public         ||                      0x01
                                          DW.ACCESS.protected   ||                         0x02
                                        __DW.ACCESS.private_______||_______________________0x03_________
7.10            Visibility  Codes
The encodings of the constants used in the DW.AT.visibility attribute are given
in Table 7.15 on the following page.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 239
                                            Chapter 7.  Data Representation
                                            Table 7.15: Visibility encodings
                                           __________________________________________________________
                                           __Visibility_code_name___||_________________Value_________
                                             DW.VIS.local               ||               0x01
                                             DW.VIS.exported        ||                   0x02
                                           __DW.VIS.qualioed________||___________________0x03________
7.11            Virtuality  Codes
The encodings of the constants used in the DW.AT.virtuality attribute are given
in Table 7.16.
                                           Table 7.16: Virtuality encodings
                                  _____________________________________________________________________________
                                  __Virtuality_code_name_____________________||__________________Value_________
                                    DW.VIRTUALITY.none               ||                           0x00
                                    DW.VIRTUALITY.virtual            ||                           0x01
                                  __DW.VIRTUALITY.pure.virtual__||________________________________0x02_________
The value DW.VIRTUALITY.none is equivalent to the absence of the
DW.AT.virtuality attribute.
7.12            Source  Languages
The encodings of the constants used in the DW.AT.language.name attribute are
given in Table 7.17 on the following page. Table 7.17 on the next page also shows
the default lower bound, if any, assumed for an omitted DW.AT.lower.bound
attribute in the context of a DW.TAG.subrange.type debugging information
entry for_each_deoned_language.________________________________________________________________________________________________________
           Continued on next page
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 240
                                            Chapter 7.  Data Representation
         __Language_name__________________________________||________________Value___||______Default_Lower_Bound________________________
                                           Table 7.17: Language encodings
         ______________________________________________________________________________________________________________________________
         __Language_name__________________________________||_________________Value___||_____Default_Lower_Bound________________________
           DW.LNAME.Ada                             ||                      0x0001  ||                         1
           DW.LNAME.BLISS                          ||                       0x0002  ||                         0
           DW.LNAME.C                                  ||                   0x0003  ||                         0
           DW.LNAME.C.plus.plus               ||                            0x0004  ||                         0
           DW.LNAME.Cobol                          ||                       0x0005  ||                         1
           DW.LNAME.Crystal #                     ||                        0x0006  ||                         0
           DW.LNAME.D                                  ||                   0x0007  ||                         0
           DW.LNAME.Dylan                          ||                       0x0008  ||                         0
           DW.LNAME.Fortran                        ||                       0x0009  ||                         1
           DW.LNAME.Go                                ||                    0x000a  ||                         0
           DW.LNAME.Haskell                       ||                        0x000b  ||                         0
           DW.LNAME.Java                             ||                     0x000c   ||                        0
           DW.LNAME.Julia                             ||                    0x000d  ||                         1
           DW.LNAME.Kotlin #                       ||                       0x000e  ||                         0
           DW.LNAME.Modula2                     ||                          0x000f   ||                        1
           DW.LNAME.Modula3                     ||                          0x0010  ||                         1
           DW.LNAME.ObjC                            ||                      0x0011  ||                         0
           DW.LNAME.ObjC.plus.plus         ||                               0x0012  ||                         0
           DW.LNAME.OCaml                        ||                         0x0013  ||                         0
           DW.LNAME.OpenCL.C7                 ||                            0x0014  ||                         0
           DW.LNAME.Pascal                          ||                      0x0015  ||                         1
           DW.LNAME.PLI                               ||                    0x0016  ||                         1
           DW.LNAME.Python                        ||                        0x0017  ||                         0
           DW.LNAME.RenderScript              ||                            0x0018  ||                         0
           DW.LNAME.Rust                             ||                     0x0019  ||                         0
           DW.LNAME.Swift                            ||                     0x001a  ||                         0
           DW.LNAME.UPC                             ||                      0x001b  ||                         0
         __DW.LNAME.Zig_#____________________________||_____________________0x001c___||________________________0_______________________
           Continued on next page
_________________________________________________________
      7Formerly DW.LANG.OpenCL in DWARF Version 5.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 241
                                            Chapter 7.  Data Representation
         __Language_name__________________________________||________________Value___||______Default_Lower_Bound________________________
           DW.LNAME.Assembly #                ||                           0x001d  ||                          0
           DW.LNAME.C.sharp #                   ||                          0x001e  ||                         0
           DW.LNAME.Mojo #                         ||                       0x001f   ||                        0
           DW.LNAME.GLSL #                        ||                        0x0020  ||                         0
           DW.LNAME.GLSL.ES #                 ||                            0x0021  ||                         0
           DW.LNAME.HLSL #                        ||                        0x0022  ||                         0
           DW.LNAME.OpenCL.CPP #         ||                                 0x0023  ||                         0
           DW.LNAME.CPP.for.OpenCL #  ||                                    0x0024  ||                         0
           DW.LNAME.SYCL #                        ||                        0x0025  ||                         0
           DW.LNAME.Ruby #                        ||                        0x0026  ||                         0
           DW.LNAME.Move #                        ||                        0x0027  ||                         0
           DW.LNAME.Hylo #                         ||                       0x0028  ||                         0
           DW.LNAME.HIP #                           ||                      0x0029  ||                         0
           DW.LNAME.Odin #                         ||                       0x002a  ||                         0
           DW.LNAME.P4 #                             ||                    0x002b  ||                         0
           DW.LNAME.lo.user                        ||                       0x8000  ||
         __DW.LNAME.hi.user________________________||_______________________0xffff__||_________________________________________________
           # Base language is new in DWARF Version 6
7.13            Address  Class  Encodings
The value of the common address class encoding DW.ADDR.none is 0.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 242
                                            Chapter 7.  Data Representation
7.14            Identioer  Case
The encodings of the constants used in the DW.AT.identioer.case attribute are
given in Table 7.18.
                                       Table 7.18: Identioer case encodings
                                        _______________________________________________________________
                                        __Identioer_case_name_________||__________________Value________
                                          DW.ID.case.sensitive      ||                     0x00
                                          DW.ID.up.case                ||                  0x01
                                          DW.ID.down.case           ||                     0x02
                                        __DW.ID.case.insensitive__||_______________________0x03________
7.15            Calling  Convention  Encodings
The encodings of the constants used in the DW.AT.calling.convention attribute
are given in Table 7.19.
                                   Table 7.19: Calling convention encodings
                                      _____________________________________________________________________
                                      __Calling_convention_name_____||_______________________Value_________
                                        DW.CC.normal                      ||                  0x01
                                        DW.CC.program                   ||                    0x02
                                        DW.CC.nocall                        ||                0x03
                                        DW.CC.pass.by.reference  ||                           0x04
                                        DW.CC.pass.by.value         ||                        0x05
                                        DW.CC.lo.user                     ||                  0x40
                                      __DW.CC.hi.user_____________________||__________________0xff_________
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 243
                                            Chapter 7.  Data Representation
7.16            Inline  Codes
The encodings of the constants used in the DW.AT.inline attribute are given in
Table 7.20.
                                               Table 7.20: Inline encodings
                                   ___________________________________________________________________________
                                   _Inline_code_name__________________________||________________Value_________
                                    DW.INL.not.inlined                   ||                      0x00
                                    DW.INL.inlined                           ||                  0x01
                                    DW.INL.declared.not.inlined  ||                              0x02
                                   _DW.INL.declared.inlined__________||__________________________0x03_________
7.17            Array  Ordering
The encodings of the constants used in the DW.AT.ordering attribute are given
in Table 7.21.
                                            Table 7.21: Ordering encodings
                                           ___________________________________________________________
                                           __Ordering_name______________||______________Value_________
                                             DW.ORD.row.major  ||                        0x00
                                           __DW.ORD.col.major____||______________________0x01_________
7.18            Discriminant  Lists
The descriptors used in the DW.AT.discr.list attribute are encoded as 1-byte
constants. The deoned values are given in Table 7.22.
                               Table 7.22: Discriminant descriptor encodings
                                           __________________________________________________________
                                           __Descriptor_name__________||_______________Value_________
                                             DW.DSC.label             ||                 0x00
                                           __DW.DSC.range____________||__________________0x01________
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 244
                                            Chapter 7.  Data Representation
7.19            Name  Index  Table
The version number in the name index table header is 6.
The name index attributes and their encodings are listed in Table 7.23.
                                 Table 7.23: Name index attribute encodings
                      ___________________________________________________________________________________________________
                      __Attribute_name________________||_______________Value___||_____Form/Class_________________________
                        DW.IDX.compile.unit  ||                            1       || constant
                        DW.IDX.type.unit        ||                         2       || constant
                        DW.IDX.die.ooeset        ||                        3       || reference
                        DW.IDX.parent              ||                      4       || constant
                        DW.IDX.type.hash       ||                          5       || DW.FORM.data8
                        DW.IDX.external #        ||                        6       || AEag
                        DW.IDX.lo.user             ||                 0x2000  ||
                      __DW.IDX.hi.user____________||__________________0x3fff__||_________________________________________
                        # New in DWARF Version 6
It is suggested that producers should use the form code DW.FORM.AEag.present for the
DW.IDX.external attribute for abbreviation codes that represent external names.
The abbreviations table ends with an entry consisting of a single 0 byte for the
abbreviation code. The size of the table given by abbrev_table_size may
include optional padding following the terminating 0 byte.
7.20            Defaulted  Member  Encodings
The encodings of the constants used in the DW.AT.defaulted attribute are given
in Table 7.24 following.
                                   Table 7.24: Defaulted attribute encodings
                                  ____________________________________________________________________________
                                  __Defaulted_name_____________________________||_______________Value_________
                                    DW.DEFAULTED.no                   ||                          0x00
                                    DW.DEFAULTED.in.class          ||                             0x01
                                  __DW.DEFAULTED.out.of.class__||_________________________________0x02________
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 245
                                            Chapter 7.  Data Representation
7.21            Address  Range  Table
Each .debug_aranges section contribution begins with a header containing:
1.    unit_length (initial length)
      A 4-byte or 12-byte length containing the length of the set of entries for this
      compilation unit, not including the length oeld itself (see Section 7.4 on
      page 204).
2.    version (uhalf)
      A 2-byte version identioer representing the version of the DWARF
      information for the address range table.
      This value in this oeld is 2.
3.    debug_info_offset (section ooeset)
      A 4-byte or 8-byte ooeset into the .debug_info section of the compilation unit
      header. In the 32-bit DWARF format, this is a 4-byte unsigned ooeset; in the
      64-bit DWARF format, this is an 8-byte unsigned ooeset (see Section 7.4 on
      page 204).
4.    address_size (ubyte)
      A 1-byte unsigned integer containing the size in bytes of an address.
5.    reserved 8  (ubyte, MBZ)
This header is followed by a series of tuples. Each tuple consists of an address
and a length. The address and length size are each given by the address_size
oeld of the header. The orst tuple following the header in each set begins at an
ooeset that is a multiple of the size of a single tuple (that is, twice the size of an
address). The header is padded, if necessary, to that boundary. Each set of tuples
is terminated by a 0 for the address and a 0 for the length.
_________________________________________________________
      8This allows backward compatible support of the deprecated segment_selector_size oeld
which was deoned in DWARF Version 5 and earlier.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 246
                                            Chapter 7.  Data Representation
7.22            Line  Number  Information
The version number in the line number program header is 6.
The boolean values itruej and ifalsej used by the line number information
program are encoded as a single byte containing the value 0 for ifalse,j and a
non-zero value for itrue.j
The encodings for the standard opcodes are given in Table 7.25.
                         Table 7.25: Line number standard opcode encodings
                                    _________________________________________________________________________
                                    __Opcode_name______________________________||______________Value_________
                                      DW.LNS.extended.op #          ||                          0x00
                                      DW.LNS.copy                            ||                 0x01
                                      DW.LNS.advance.pc               ||                        0x02
                                      DW.LNS.advance.line             ||                        0x03
                                      DW.LNS.set.ole                        ||                  0x04
                                      DW.LNS.set.column                ||                       0x05
                                      DW.LNS.negate.stmt               ||                       0x06
                                      DW.LNS.set.basic.block         ||                         0x07
                                      DW.LNS.const.add.pc            ||                         0x08
                                      DW.LNS.oxed.advance.pc     ||                             0x09
                                      DW.LNS.set.prologue.end     ||                            0x0a
                                      DW.LNS.set.epilogue.begin  ||                             0x0b
                                    __DW.LNS.set.isa________________________||__________________0x0c_________
                                      # New in DWARF Version 6
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 247
                                            Chapter 7.  Data Representation
The encodings for the extended opcodes are given in Table 7.26.
                         Table 7.26: Line number extended opcode encodings
                               __________________________________________________________________________________
                               __Opcode_name_______________________________________||______________Value_________
                                 DW.LNE.end.sequence                     ||                         0x01
                                 DW.LNE.set.address                         ||                      0x02
                                 Reserved                                                  ||       0x039
                                 DW.LNE.set.discriminator               ||                          0x04
                                 DW.LNE.padding #                           ||                      0x05
                                 DW.LNE.set.prologue.epilogue #  ||                                 0x06
                                 DW.LNE.lo.user                                ||                   0x80
                               __DW.LNE.hi.user________________________________||___________________0xff_________
                                 # New in DWARF Version 6
The encodings for the line number header entry formats are given in Table 7.27.
                       Table    7.27:      Line    number    header    entry    format
                       encodings
                          _____________________________________________________________________________________________
                          __Line_number_header_entry_format_name__||____________________________________Value__________
                            DW.LNCT.path                                            ||                    0x1
                            DW.LNCT.directory.index                        ||                             0x2
                            DW.LNCT.timestamp                                 ||                          0x3
                            DW.LNCT.size                                             ||                   0x4
                            DW.LNCT.MD5                                           ||                      0x5
                            DW.LNCT.source #                                     ||                       0x6
                            DW.LNCT.URL #                                        ||                       0x7
                            DW.LNCT.lo.user                                       ||                   0x2000
                          __DW.LNCT.hi.user_______________________________________||___________________0x3fff__________
                            # New in DWARF Version 6
_________________________________________________________
      9Code  0x03  is  reserved  to  allow  backward  compatible  support  of  the  DW.LNE.deone.ole
operation which was deoned in DWARF Version 4 and earlier.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 248
                                            Chapter 7.  Data Representation
7.23            Macro  Information
The version number in the macro information header is 5.
The source line numbers and source ole indices encoded in the macro
information section are represented as unsigned LEB128 numbers.
The macro information entry type is encoded as a single unsigned byte. The
encodings are given in Table 7.28 on the next page.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 249
                                            Chapter 7.  Data Representation
                          Table 7.28: Macro information entry type encodings
                              _____________________________________________________________________________________
                              __Macro_information_entry_type_name__||________________________________Value_________
                                DW.MACRO.padding #                       ||                           0x00
                                DW.MACRO.deone                             ||                         0x01
                                DW.MACRO.undef                              ||                        0x02
                                DW.MACRO.start.ole                         ||                         0x03
                                DW.MACRO.end.ole                          ||                          0x04
                                DW.MACRO.deone.strp                     ||                            0x05
                                DW.MACRO.undef.strp                     ||                            0x06
                                DW.MACRO.import                            ||                         0x07
                                Reserved                                                     ||     0x0810
                                Reserved                                                     ||     0x0911
                                Reserved                                                     ||     0x0a12
                                DW.MACRO.deone.strx                     ||                            0x0b
                                DW.MACRO.undef.strx                     ||                            0x0c
                                DW.MACRO.deone.sup4 #                ||                              0x0d
                                DW.MACRO.deone.sup8 #                ||                               0x0e
                                DW.MACRO.undef.sup4 #                 ||                              0x0f
                                DW.MACRO.undef.sup8 #                 ||                              0x10
                                DW.MACRO.import.sup4 #               ||                               0x11
                                DW.MACRO.import.sup8 #               ||                               0x12
                                DW.MACRO.lo.user                            ||                        0xe0
                              __DW.MACRO.hi.user___________________________||_________________________0xff_________
                                # New in DWARF Version 6
_________________________________________________________
     10Code     0x08     is     reserved     to     allow     backward     compatible     support     of     the
DW.MACRO.deone.sup entry type that was deoned (only) in DWARF Version 5.
     11Code 0x09 is reserved to allow backward compatible support of the DW.MACRO.undef.sup
entry type that was deoned (only) in DWARF Version 5.
     12Code     0x0a     is     reserved     to     allow     backward     compatible     support     of     the
DW.MACRO.import.sup entry type that was deoned (only) in DWARF Version 5.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 250
                                            Chapter 7.  Data Representation
7.24            Call  Frame  Information
In the 32-bit DWARF format, the value of the CIE id in the CIE header is
0xffffffff; in the 64-bit DWARF format, the value is 0xffffffffffffffff.
The value of the CIE version number is 4.
Call frame instructions are encoded in one or more bytes. The primary opcode is
encoded in the high order two bits of the orst byte (that is, opcode = byte >> 6).
An operand or extended opcode may be encoded in the low order 6 bits.
Additional operands are encoded in subsequent bytes. The instructions and their
encodings are presented in Table 7.29.
                                Table 7.29: Call frame instruction encodings
        ________________________________________________________________________________________________________________________________
                                                                | High 2  |         Low 6   |       Operand 1,
                                                                |         |                 |
        __Instruction__________________________________||____________Bits_____||______Bits_____||___Operand_2___________________________
          DW.CFA.advance.loc              ||                         0x1     ||      delta    ||
          DW.CFA.ooeset                          ||                  0x2     ||    register  ||     ULEB128 ooeset
          DW.CFA.restore                        ||                   0x3     ||    register  ||
          DW.CFA.nop                             ||                    0       ||       0        ||
          DW.CFA.set.loc                        ||                     0       ||    0x01     ||    address
          DW.CFA.advance.loc1            ||                            0       ||    0x02     ||    1-byte delta
          DW.CFA.advance.loc2            ||                            0       ||    0x03     ||    2-byte delta
          DW.CFA.advance.loc4            ||                            0       ||    0x04     ||    4-byte delta
          DW.CFA.ooeset.extended        ||                             0       ||    0x05     ||    ULEB128 register,
                                        |                                      |              |     ULEB128 ooeset
                                        |                                      |              |
          DW.CFA.restore.extended      ||                              0       ||    0x06     ||    ULEB128 register
          DW.CFA.undeoned                  ||                          0       ||    0x07     ||    ULEB128 register
          DW.CFA.same.value               ||                           0       ||    0x08     ||    ULEB128 register
          DW.CFA.register                      ||                      0       ||    0x09     ||    ULEB128 register,
                                               |                               |              |     ULEB128 ooeset
                                               |                               |              |
          DW.CFA.remember.state        ||                              0       ||    0x0a     ||
          DW.CFA.restore.state              ||                         0       ||    0x0b     ||
          DW.CFA.def.cfa                       ||                      0       ||    0x0c     ||    ULEB128 register,
                                               |                               |              |     ULEB128 ooeset
        _______________________________________|_______________________________|______________|_________________________________________
          Continued on next page
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 251
                                            Chapter 7.  Data Representation
       ________________________________________________________________________________________________________________________________
                                                                | High 2  |        Low 6   |       Operand 1,
                                                                |         |                |
       __Instruction__________________________________||____________Bits_____||______Bits_____||___Operand_2___________________________
         DW.CFA.def.cfa.register        ||                             0       ||    0x0d     ||   ULEB128 register
         DW.CFA.def.cfa.ooeset           ||                            0       ||    0x0e     ||   ULEB128 ooeset
         DW.CFA.def.cfa.expression  ||                                 0       ||    0x0f     ||   exprloc
          DW.CFA.expression                 ||                         0       ||    0x10     ||    ULEB128 register,
                                            |                                  |              |     exprloc
                                            |                                  |              |
          DW.CFA.ooeset.extended.sf   ||                               0       ||    0x11     ||    ULEB128 register,
                                      |                                        |              |     SLEB128 ooeset
                                      |                                        |              |
          DW.CFA.def.cfa.sf                  ||                        0       ||    0x12     ||    ULEB128 register,
                                             |                                 |              |     SLEB128 ooeset
                                             |                                 |              |
          DW.CFA.def.cfa.ooeset.sf      ||                             0       ||    0x13     ||    SLEB128 ooeset
          DW.CFA.val.ooeset                   ||                       0       ||    0x14     ||    ULEB128 register,
                                              |                                |              |     ULEB128 ooeset
                                              |                                |              |
          DW.CFA.val.ooeset.sf              ||                         0       ||    0x15     ||    ULEB128 register,
                                            |                                  |              |     SLEB128 ooeset
                                            |                                  |              |
          DW.CFA.val.expression          ||                            0       ||    0x16     ||    ULEB128 register,
                                         |                                     |              |     exprloc
                                         |                                     |              |
          DW.CFA.lo.user                       ||                      0       ||    0x1c     ||
        __DW.CFA.hi.user_______________________||______________________0_______||____0x3f_____||________________________________________
7.25            Range  List  Entries  for  Non-contiguous  Address
                Ranges
Each entry in a range list (see Section 2.17.3 on page 54) is either a range list
entry, a base address selection entry, or an end-of-list entry.
Each entry begins with an unsigned 1-byte code that indicates the kind of entry
that follows. The encodings for these constants are given in Table 7.30 on the
following page.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 252
                                            Chapter 7.  Data Representation
                                 Table 7.30: Range list entry encoding values
                                 _____________________________________________________________________________
                                 __Range_list_entry_encoding_name__||____________________________Value________
                                   DW.RLE.end.of.list                      ||                     0x00
                                   DW.RLE.base.addressx                ||                         0x01
                                   DW.RLE.startx.endx                     ||                      0x02
                                   DW.RLE.startx.length                  ||                       0x03
                                   DW.RLE.ooeset.pair                      ||                     0x04
                                   DW.RLE.base.address                  ||                        0x05
                                   DW.RLE.start.end                         ||                    0x06
                                   DW.RLE.start.length                    ||                      0x07
                                   DW.RLE.include.rnglist #            ||                         0x08
                                   DW.RLE.include.rnglistx #          ||                          0x09
                                   DW.RLE.lo.user #                         ||                    0xc0
                                 __DW.RLE.hi.user_#_________________________||____________________0xff________
                                   # New in DWARF Version 6
If a producer deones a producer-specioc kind of range list entry, the kind code
must be immediately followed by an unsigned LEB128 value that specioes the
length of all remaining bytes (not including either the kind or the length itself)
for that entry.
For a range list to be specioed, the base address of the corresponding compilation
unit must be deoned (see Section 3.1.1 on page 62).
7.26            String  Ooesets  Table
Each .debug_str_offsets or .debug_str_offsets.dwo section contribution
begins with a header containing:
1.    unit_length (initial length)
      A 4-byte or 12-byte length containing the length of the set of entries for this
      compilation unit, not including the length oeld itself (see Section 7.4 on
      page 204).
      The DWARF format used for the string ooesets table is not required to match
      the format used by other sections describing the same compilation unit.
2.    version (uhalf)
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 253
                                            Chapter 7.  Data Representation
      A 2-byte version identioer containing the value 5.
3.    padding (uhalf)
      Reserved to DWARF (must be zero).
This header is followed by a series of string table ooeset entries that have the same
representation as DW.FORM.strp. For the 32-bit DWARF format, each ooeset is 4
bytes long; for the 64-bit DWARF format, each ooeset is 8 bytes long.
The DW.AT.str.ooesets attribute points to the header. The entries following the
header are indexed sequentially, starting from 0.
This table may be padded with unused entries. These entries should have all 1 bits as a
hint that the entries are unused.
7.27            Address  Table
Each .debug_addr section contribution begins with a header containing:
1.    unit_length (initial length)
      A 4-byte or 12-byte length containing the length of the set of entries for this
      compilation unit, not including the length oeld itself (see Section 7.4 on
      page 204).
2.    version (uhalf)
      A 2-byte version identioer containing the value 5.
3.    address_size (ubyte)
      A 1-byte unsigned integer containing the size in bytes of an address on the
      target system.
4.    reserved 13  (ubyte, MBZ)
This header is followed by a series of addresses where the address size is given
by the address_size oeld of the header.
The DW.AT.addr.base attribute points to the orst entry following the header.
The entries are indexed sequentially from this base entry, starting from 0.
This table may be padded with unused entries. These entries should have all 1 bits as a
hint that the entries are unused.
_________________________________________________________
     13This allows backward compatible support of the deprecated segment_selector_size oeld
which was deoned in DWARF Version 5 and earlier.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 254
                                            Chapter 7.  Data Representation
7.28            Range  List  Table
Each .debug_rnglists and .debug_rnglists.dwo section contribution begins
with a header containing:
1.    unit_length (initial length)
      A 4-byte or 12-byte length containing the length of the set of entries for this
      compilation unit, not including the length oeld itself (see Section 7.4 on
      page 204).
2.    version (uhalf)
      A 2-byte version identioer containing the value 5.
3.    address_size (ubyte)
      A 1-byte unsigned integer containing the size in bytes of an address on the
      target system.
4.    reserved 14  (ubyte, MBZ)
5.    offset_entry_count (uword)
      A 4-byte count of the number of ooesets that follow the header. This count
      may be zero.
Immediately following the header is an array of ooesets. This array is followed by
a series of range lists.
If the offset_entry_count is non-zero, there is one ooeset for each range list. The
contents of the ith  ooeset is the ooeset (an unsigned integer) from the beginning of
the ooeset array to the location of the ith  range list. In the 32-bit DWARF format,
each ooeset is 4-bytes in size; in the 64-bit DWARF format, each ooeset is 8-bytes in
size (see Section 7.4 on page 204).
If the offset_entry_count is zero, then DW.FORM.rnglistx cannot be used to access
a range list; DW.FORM.sec.ooeset must be used instead. If the offset_entry_count
is non-zero, then DW.FORM.rnglistx may be used to access a range list.
Range lists are described in Section 2.17.3 on page 54.
The DW.AT.rnglists.base attribute points to the orst ooeset following the header.
The range lists are referenced by the index of the position of their corresponding
ooeset in the array of ooesets, which indirectly specioes the ooeset to the target list.
This table may be padded with unused entries. These entries should have all 1 bits as a
hint that the entries are unused.
_________________________________________________________
     14This allows backward compatible support of the deprecated segment_selector_size oeld
which was deoned in DWARF Version 5 and earlier.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 255
                                            Chapter 7.  Data Representation
7.29            Value  List  and  Location  List  Table
Each .debug_loclists or .debug_loclists.dwo section contribution begins with
a header containing:
1.    unit_length (initial length)
      A 4-byte or 12-byte length containing the length of the set of entries for this
      compilation unit, not including the length oeld itself (see Section 7.4 on
      page 204).
2.    version (uhalf)
      A 2-byte version identioer containing the value 5.
3.    address_size (ubyte)
      A 1-byte unsigned integer containing the size in bytes of an address on the
      target system.
4.    reserved 15  (ubyte, MBZ)
5.    offset_entry_count (uword)
      A 4-byte count of the number of ooesets that follow the header. This count
      may be zero.
Immediately following the header is an array of ooesets. This array is followed by
a series of value lists and location lists.
If the offset_entry_count is non-zero, there is one ooeset for each value list and
location list. The contents of the ith  ooeset is the ooeset (an unsigned integer) from
the beginning of the ooeset array to the location of the ith  value list or location list.
In the 32-bit DWARF format, each ooeset is 4-bytes in size; in the 64-bit DWARF
format, each ooeset is 8-bytes in size (see Section 7.4 on page 204).
If the offset_entry_count is zero, then DW.FORM.loclistx cannot be used to access
a value list or location list; DW.FORM.sec.ooeset must be used instead. If the
offset_entry_count is non-zero, then DW.FORM.loclistx may be used to access a
value list or location list.
Value lists are described in Section 2.5.2 on page 38. Location lists are described
in Section 2.6.2 on page 44.
The DW.AT.loclists.base attribute points to the orst ooeset following the header.
The value lists and location lists are referenced by the index of the position of
their corresponding ooeset in the array of ooesets, which indirectly specioes the
ooeset to the target list.
_________________________________________________________
     15This allows backward compatible support of the deprecated segment_selector_size oeld
which was deoned in DWARF Version 5 and earlier.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 256
                                            Chapter 7.  Data Representation
7.30            Dependencies  and  Constraints
The debugging information in this format is intended to exist in sections of an
object ole, or an equivalent separate ole or database, having names beginning
with the preox ".debug." (see Appendix G on page 441 for a complete list of such
names). Except as speciocally specioed, this information is not aligned on 2-, 4-
or 8-byte boundaries. Consequently:
     #    For the 32-bit DWARF format and a target architecture with 32-bit
          addresses, an assembler or compiler must provide a way to produce 2-byte
          and 4-byte quantities without alignment restrictions, and the linker must be
          able to relocate a 4-byte address or section ooeset that occurs at an arbitrary
          alignment.
     #    For the 32-bit DWARF format and a target architecture with 64-bit
          addresses, an assembler or compiler must provide a way to produce 2-byte,
          4-byte and 8-byte quantities without alignment restrictions, and the linker
          must be able to relocate an 8-byte address or 4-byte section ooeset that
          occurs at an arbitrary alignment.
     #    For the 64-bit DWARF format and a target architecture with 32-bit
          addresses, an assembler or compiler must provide a way to produce 2-byte,
          4-byte and 8-byte quantities without alignment restrictions, and the linker
          must be able to relocate a 4-byte address or 8-byte section ooeset that occurs
          at an arbitrary alignment.
          It is expected that this will be required only for very large 32-bit programs or by
          those architectures which support a mix of 32-bit and 64-bit code and data within
          the same executable object.
     #    For the 64-bit DWARF format and a target architecture with 64-bit
          addresses, an assembler or compiler must provide a way to produce 2-byte,
          4-byte and 8-byte quantities without alignment restrictions, and the linker
          must be able to relocate an 8-byte address or section ooeset that occurs at an
          arbitrary alignment.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 257
                                            Chapter 7.  Data Representation
7.31            Integer  Representation  Names
The sizes of the integers used in the lookup by name, lookup by address, line
number, call frame information and other sections are given in Table 7.31.
                                    Table 7.31: Integer representation names
                           ___________________________________________________________________________________________
                           __Representation_name__||___________________Representation_________________________________
                                           sbyte                 ||    signed, 1-byte integer
                                           ubyte                ||     unsigned, 1-byte integer
                                           uhalf                 ||    unsigned, 2-byte integer
                           _______________uword________________||______unsigned,_4-byte_integer_______________________
7.32            Type  Signature  Computation
A type signature is used by a DWARF consumer to resolve type references to the
type deonitions that are contained in type units (see Section 3.1.4 on page 72).
A type signature is computed only by a DWARF producer; a consumer need only
compare two type signatures to check for equality.
The type signature for a type T0 is formed from the MD516  digest of a AEattened
description of the type. The AEattened description of the type is a byte sequence
derived from the DWARF encoding of the type as follows:
1.    Start with an empty sequence S and a list V of visited types, where V is
      initialized to a list containing the type T0 as its single element. Elements in V
      are indexed from 1, so that V[1] is T0.
2.    If the debugging information entry represents a type that is nested inside
      another type or a namespace, append to S the type's context as follows: For
      each surrounding type or namespace, beginning with the outermost such
      construct, append the letter 'C', the DWARF tag of the construct, and the
      name (taken from the DW.AT.name attribute) of the type or namespace
      (including its trailing null byte).
3.    Append to S the letter 'D', followed by the DWARF tag of the debugging
      information entry.
_________________________________________________________
     16MD5 Message Digest Algorithm, R.L. Rivest, RFC 1321, April 1992
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 258
                                            Chapter 7.  Data Representation
4.    For each of the attributes in Table 7.32 that are present in the debugging
      information entry, in the order listed, append to S a marker letter (see below),
      the DWARF attribute code, and the attribute value.
                     Table 7.32: Attributes used in type signature computation
________________________________________________________________________________________________________________________________________________
  DW.AT.name                                                   DW.AT.endianity
  DW.AT.accessibility                                          DW.AT.enum.class
  DW.AT.address.class                                          DW.AT.explicit
  DW.AT.alignment                                              DW.AT.is.optional
  DW.AT.allocated                                              DW.AT.location
  DW.AT.artiocial                                              DW.AT.lower.bound
  DW.AT.associated                                             DW.AT.mutable
  DW.AT.binary.scale                                           DW.AT.ordering
  DW.AT.bit.size                                               DW.AT.picture.string
  DW.AT.bit.stride                                             DW.AT.prototyped
  DW.AT.byte.size                                              DW.AT.rank
  DW.AT.byte.stride                                            DW.AT.reference
  DW.AT.const.expr                                             DW.AT.rvalue.reference
  DW.AT.const.value                                            DW.AT.scale.divisor
  DW.AT.containing.type                                        DW.AT.scale.multiplier
  DW.AT.count                                                  DW.AT.small
  DW.AT.data.bit.ooeset                                        DW.AT.string.length
  DW.AT.data.location                                          DW.AT.string.length.bit.size
  DW.AT.data.member.location                                   DW.AT.string.length.byte.size
  DW.AT.decimal.scale                                          DW.AT.threads.scaled
  DW.AT.decimal.sign                                           DW.AT.upper.bound
  DW.AT.default.value                                          DW.AT.use.location
  DW.AT.digit.count                                            DW.AT.use.UTF8
  DW.AT.discr                                                  DW.AT.variable.parameter
  DW.AT.discr.list                                             DW.AT.virtuality
  DW.AT.discr.value                                            DW.AT.visibility
  DW.AT.encoding                                               DW.AT.vtable.elem.location
________________________________________________________________________________________________________________________________________________
      Note that except for the initial DW.AT.name attribute, attributes are
      appended in order according to the alphabetical spelling of their identioer.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 259
                                            Chapter 7.  Data Representation
      If an implementation deones any producer-specioc attributes, any such
      attributes that are essential to the deonition of the type are also included at
      the end of the above list, in their own alphabetical suborder.
      An attribute that refers to another type entry T is processed as follows:
       a)    If T is in the list V at some V[x], use the letter 'R' as the marker and use
             the unsigned LEB128 encoding of x as the attribute value.
       b)    Otherwise, append type T to the list V, then use the letter 'T' as the
             marker, process the type T recursively by performing Steps 2 through 7,
             and use the result as the attribute value.
      Other attribute values use the letter 'A' as the marker, and the value consists
      of the form code (encoded as an unsigned LEB128 value) followed by the
      encoding of the value according to the form code. To ensure reproducibility
      of the signature, the set of forms used in the signature computation is limited
      to the following: DW.FORM.sdata, DW.FORM.AEag, DW.FORM.string,
      DW.FORM.exprval, and DW.FORM.block.
5.    If the tag in Step 3 is one of DW.TAG.pointer.type,
      DW.TAG.reference.type, DW.TAG.rvalue.reference.type,
      DW.TAG.ptr.to.member.type, or DW.TAG.friend, and the referenced
      type (via the DW.AT.type or DW.AT.friend attribute) has a DW.AT.name
      attribute, append to S the letter 'N', the DWARF attribute code (DW.AT.type
      or DW.AT.friend), the context of the type (according to the method in Step
      2), the letter 'E', and the name of the type. For DW.TAG.friend, if the
      referenced entry is a DW.TAG.subprogram, the context is omitted and the
      name to be used is the ABI-specioc name of the subprogram (for example, the
      mangled linker name).
6.    If the tag in Step 3 is not one of DW.TAG.pointer.type,
      DW.TAG.reference.type, DW.TAG.rvalue.reference.type,
      DW.TAG.ptr.to.member.type, or DW.TAG.friend, but has a DW.AT.type
      attribute, or if the referenced type (via the DW.AT.type or DW.AT.friend
      attribute) does not have a DW.AT.name attribute, the attribute is processed
      according to the method in Step 4 for an attribute that refers to another type
      entry.
7.    Visit each child C of the debugging information entry as follows: If C is a
      nested type entry or a member function entry, and has a DW.AT.name
      attribute, append to S the letter 'S', the tag of C, and its name; otherwise,
      process C recursively by performing Steps 3 through 7, appending the result
      to S. Following the last child (or if there are no children), append a zero byte.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 260
                                            Chapter 7.  Data Representation
For the purposes of this algorithm, if a debugging information entry S has a
DW.AT.speciocation attribute that refers to another entry D (which has a
DW.AT.declaration attribute), then S inherits the attributes and children of D,
and S is processed as if those attributes and children were present in the entry S.
Exception: if a particular attribute is found in both S and D, the attribute in S is
used and the corresponding one in D is ignored.
DWARF tag and attribute codes are appended to the sequence as unsigned
LEB128 values, using the values deoned earlier in this chapter.
A grammar describing this computation may be found in Appendix E.2.2 on page 411.
An attribute that refers to another type entry is recursively processed or replaced with the
name of the referent (in Step 4, 5 or 6). If neither treatment applies to an attribute that
references another type entry, the entry that contains that attribute is not suitable for a
separate type unit.
If a debugging information entry contains an attribute from the list above that would
require an unsupported form, that entry is not suitable for a separate type unit.
A type is suitable for a separate type unit only if all of the type entries that it contains or
refers to in Steps 6 and 7 are themselves suitable for a separate type unit.
Where the DWARF producer may reasonably choose two or more dioeerent forms for a
given attribute, it should choose the simplest possible form in computing the signature.
(For example, a constant value should be preferred to an expression when possible.)
Once the string S has been formed from the DWARF encoding, an 16-byte MD5
digest is computed for the string and the last eight bytes are taken as the type
signature.
The string S is intended to be a AEattened representation of the type that uniquely
identioes that type (that is, a dioeerent type is highly unlikely to produce the same string).
A debugging information entry is not placed in a separate type unit if any of the
following apply:
     #    The entry has an attribute whose value is a location description, and the location
          description contains a reference to another debugging information entry (for
          example, a DW.OP.call.ref operator), as it is unlikely that the entry will remain
          identical across compilation units.
     #    The entry has an attribute whose value refers to a code location or a location list.
     #    The entry has an attribute whose value refers to another debugging information
          entry that does not represent a type.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 261
                                            Chapter 7.  Data Representation
Certain attributes are not included in the type signature:
     #    The DW.AT.declaration attribute is not included because it indicates that the
          debugging information entry represents an incomplete declaration, and incomplete
          declarations should not be placed in separate type units.
     #    The DW.AT.description attribute is not included because it does not provide any
          information unique to the deoning declaration of the type.
     #    The DW.AT.decl.ole, DW.AT.decl.line, and DW.AT.decl.column attributes
          are not included because they may vary from one source ole to the next, and would
          prevent two otherwise identical type declarations from producing the same MD5
          digest.
     #    The DW.AT.object.pointer attribute is not included because the information it
          provides is not necessary for the computation of a unique type signature.
Nested types and some types referred to by a debugging information entry are encoded by
name rather than by recursively encoding the type to allow for cases where a complete
deonition of the type might not be available in all compilation units.
If a type deonition contains the deonition of a member function, it cannot be moved as is
into a type unit, because the member function contains attributes that are unique to that
compilation unit. Such a type deonition can be moved to a type unit by rewriting the
debugging information entry tree, moving the member function declaration into a
separate declaration tree, and replacing the function deonition in the type with a
non-deoning declaration of the function (as if the function had been deoned out of line).
An example that illustrates the computation of an MD5 digest may be found in
Appendix E.2 on page 401.
7.33            Name  Table  Hash  Function
The hash function used for hashing name strings in the accelerated access name
index table (see Section 6.1 on page 140) is deoned in C as shown in Figure 7.1
following.17
_________________________________________________________
     17  This  hash  function  is  sometimes  known  as  the  "Bernstein  hash  function"  or  the  "DJB
hash   function"   (see,   for   example,   http://en.wikipedia.org/wiki/List.of.hash.functions   or
http://stackoverAEow.com/questions/10696223/reason-for-5381-number-in-djb-hash-function).
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 262
                                             Chapter 7.  Data Representation
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||u/*
 *i*nmtu3s2t_btea32b-iitnttyepgee*r/
|||=============================================================================================================================================|||h(*
 *ausnhscihganre*ds)t r
|||=============================================================================================================================================|||{
|||=============================================================================================================================================|||uh*
 *iansth3=25_3t8 1 ;
|||=============================================================================================================================================|||ic*
 *n;t
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||w(*
 *hci=l*es+t+r)
|||=============================================================================================================================================|||h=*
 *ahsahs*h33+c;
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||rh*
 *eatsuhr;n
|||=============================================================================================================================================|||}_*
 *|_____|
                             Figure 7.1: Name Table Hash Function Deonition
 7.34            Contiguous  Tables
 Tables within each section must be contiguous with the preceding table in that
 section, or the beginning of the section if there is no preceding table.
 Consumers may prefer to have these tables padded so that each subsequent table is
 "aligned" on a certain boundary, typically 4 or 8 bytes. Every table of information has a
 way for the table as a whole to be padded if the producer wishes to do so. Tables from
 multiple object oles that are concatenated by a linker would then each be aligned without
 any special eoeort by the linker; this alignment may provide performance or other beneots.
 This padding is entirely optional, and does not relax any constraint specioed in Section
 7.30 on page 257.
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 263
                                            Chapter 7.  Data Representation
                                                             (empty page)
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 264

Appendix  A
Attributes  by  Tag  Value  (Informative)
The table below enumerates the attributes that are most applicable to each type
of debugging information entry. DWARF does not in general require that a given
debugging information entry contain a particular attribute or set of attributes.
Instead, a DWARF producer is free to generate any, all, or none of the attributes
described in the text as being applicable to a given entry. Other attributes (both
those deoned within this document but not explicitly associated with the entry in
question, and new, producer-deoned ones) may also appear in a given
debugging information entry. Therefore, the table may be taken as instructive,
but cannot be considered deonitive.
In the following table, the following special conventions apply:
1.    The DECL pseudo-attribute stands for all three of the declaration coordinates
      DW.AT.decl.column, DW.AT.decl.ole and DW.AT.decl.line.
2.    The DW.AT.description attribute can be used on any debugging information
      entry that may have a DW.AT.name attribute. For simplicity, this attribute is
      not explicitly shown.
3.    The DW.AT.sibling attribute can be used on any debugging information
      entry. For simplicity, this attribute is not explicitly shown.
4.    The DW.AT.abstract.origin attribute can be used with almost any
      debugging information entry; the exceptions are mostly the compilation
      unit-like entries. For simplicity, this attribute is not explicitly shown.
5.    The DW.AT.artiocial attribute can be used with any declarative debugging
      information entry. For simplicity, this attribute is not shown.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 265
                                Appendix A.  Attributes by Tag (Informative)
                                            Table A.1: Attributes by tag value
     ______________________________________________________________________________________________________________________________________
     __TAG_name_____________________________________________||__________Applicable_attributes______________________________________________
       DW.TAG.access.declaration                ||                      DECL
                                                                      | DW.AT.accessibility
                                                                      |
                                                                      | DW.AT.name
     _________________________________________________________________|____________________________________________________________________
       DW.TAG.array.type                            ||                  DECL
                                                                      | DW.AT.accessibility
                                                                      |
                                                                      | DW.AT.alignment
                                                                      |
                                                                      | DW.AT.allocated
                                                                      |
                                                                      | DW.AT.associated
                                                                      |
                                                                      | DW.AT.bit.size
                                                                      |
                                                                      | DW.AT.bit.stride
                                                                      |
                                                                      | DW.AT.byte.size
                                                                      |
                                                                      | DW.AT.data.location
                                                                      |
                                                                      | DW.AT.declaration
                                                                      |
                                                                      | DW.AT.name
                                                                      |
                                                                      | DW.AT.ordering
                                                                      |
                                                                      | DW.AT.rank
                                                                      |
                                                                      | DW.AT.speciocation
                                                                      |
                                                                      | DW.AT.start.scope
                                                                      |
                                                                      | DW.AT.type
                                                                      |
                                                                      | DW.AT.visibility
     _________________________________________________________________|____________________________________________________________________
       DW.TAG.atomic.type                          ||                   DECL
                                                                      | DW.AT.alignment
                                                                      |
                                                                      | DW.AT.name
                                                                      |
                                                                      | DW.AT.type
     _________________________________________________________________|_____________________________________________________________________
       Continued on next page
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 266
                                Appendix A.  Attributes by Tag (Informative)
     __TAG_name_____________________________________________||_________Applicable_attributes________________________________________________
       DW.TAG.base.type                             ||                 DECL
                                                                     | DW.AT.alignment
                                                                     |
                                                                     | DW.AT.allocated
                                                                     |
                                                                     | DW.AT.associated
                                                                     |
                                                                     | DW.AT.bias
                                                                     |
                                                                      | DW.AT.binary.scale
                                                                      |
                                                                      | DW.AT.bit.size
                                                                      |
                                                                      | DW.AT.byte.size
                                                                      |
                                                                      | DW.AT.data.bit.ooeset
                                                                      |
                                                                      | DW.AT.data.location
                                                                      |
                                                                      | DW.AT.decimal.scale
                                                                      |
                                                                      | DW.AT.decimal.sign
                                                                      |
                                                                      | DW.AT.digit.count
                                                                      |
                                                                      | DW.AT.encoding
                                                                      |
                                                                      | DW.AT.endianity
                                                                      |
                                                                      | DW.AT.name
                                                                      |
                                                                      | DW.AT.picture.string
                                                                      |
                                                                      | DW.AT.scale.divisor
                                                                      |
                                                                      | DW.AT.scale.multiplier
                                                                      |
                                                                      | DW.AT.small
     _________________________________________________________________|____________________________________________________________________
       DW.TAG.call.site                                ||               DW.AT.call.column
                                                                      | DW.AT.call.ole
                                                                      |
                                                                      | DW.AT.call.line
                                                                      |
                                                                      | DW.AT.call.origin
                                                                      |
                                                                      | DW.AT.call.pc
                                                                      |
                                                                      | DW.AT.call.return.pc
                                                                      |
                                                                      | DW.AT.call.tail.call
                                                                      |
                                                                      | DW.AT.call.target
                                                                      |
                                                                      | DW.AT.call.target.clobbered
                                                                      |
                                                                      | DW.AT.type
     _________________________________________________________________|_____________________________________________________________________
       Continued on next page
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 267
                                Appendix A.  Attributes by Tag (Informative)
     __TAG_name_____________________________________________||_________Applicable_attributes________________________________________________
       DW.TAG.call.site.parameter              ||                      DW.AT.call.data.location
                                                                     | DW.AT.call.data.value
                                                                     |
                                                                     | DW.AT.call.parameter
                                                                     |
                                                                     | DW.AT.call.value
                                                                     |
                                                                     | DW.AT.location
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.type
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.catch.block                          ||                  DECL
                                                                     | DW.AT.entry.pc
                                                                     |
                                                                     | DW.AT.high.pc
                                                                     |
                                                                     | DW.AT.low.pc
                                                                     |
                                                                     | DW.AT.ranges
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.class.type                             ||                DECL
                                                                     | DW.AT.accessibility
                                                                     |
                                                                     | DW.AT.alignment
                                                                     |
                                                                     | DW.AT.allocated
                                                                     |
                                                                     | DW.AT.associated
                                                                     |
                                                                     | DW.AT.bit.size
                                                                     |
                                                                     | DW.AT.byte.size
                                                                     |
                                                                     | DW.AT.calling.convention
                                                                     |
                                                                     | DW.AT.data.location
                                                                     |
                                                                     | DW.AT.declaration
                                                                     |
                                                                     | DW.AT.export.symbols
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.signature
                                                                     |
                                                                     | DW.AT.speciocation
                                                                     |
                                                                     | DW.AT.start.scope
                                                                     |
                                                                     | DW.AT.visibility
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.coarray.type                        ||                   DECL
                                                                     | DW.AT.alignment
                                                                     |
                                                                     | DW.AT.bit.size
                                                                     |
                                                                     | DW.AT.byte.size
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.type
     ________________________________________________________________|______________________________________________________________________
       Continued on next page
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 268
                                Appendix A.  Attributes by Tag (Informative)
     __TAG_name_____________________________________________||_________Applicable_attributes________________________________________________
       DW.TAG.common.block                     ||                      DECL
                                                                     | DW.AT.declaration
                                                                     |
                                                                     | DW.AT.linkage.name
                                                                     |
                                                                     | DW.AT.location
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.visibility
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.common.inclusion               ||                        DECL
                                                                     | DW.AT.common.reference
                                                                     |
                                                                     | DW.AT.declaration
                                                                     |
                                                                     | DW.AT.visibility
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.compile.unit                        ||                   DW.AT.addr.base
                                                                     | DW.AT.base.types
                                                                     |
                                                                     | DW.AT.comp.dir
                                                                     |
                                                                     | DW.AT.entry.pc
                                                                     |
                                                                     | DW.AT.identioer.case
                                                                     |
                                                                     | DW.AT.high.pc
                                                                     |
                                                                     | DW.AT.language.name
                                                                     |
                                                                      | DW.AT.language.version
                                                                      |
                                                                      | DW.AT.low.pc
                                                                      |
                                                                      | DW.AT.macros
                                                                      |
                                                                      | DW.AT.main.subprogram
                                                                      |
                                                                      | DW.AT.name
                                                                      |
                                                                      | DW.AT.producer
                                                                      |
                                                                      | DW.AT.ranges
                                                                      |
                                                                      | DW.AT.rnglists.base
                                                                      |
                                                                      | DW.AT.stmt.list
                                                                      |
                                                                      | DW.AT.str.ooesets
                                                                      |
                                                                      | DW.AT.use.UTF8
     _________________________________________________________________|____________________________________________________________________
       DW.TAG.condition                              ||                 DECL
                                                                      | DW.AT.name
     _________________________________________________________________|____________________________________________________________________
       DW.TAG.const.type                            ||                  DECL
                                                                      | DW.AT.alignment
                                                                      |
                                                                      | DW.AT.name
                                                                      |
                                                                      | DW.AT.type
     _________________________________________________________________|_____________________________________________________________________
       Continued on next page
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 269
                                Appendix A.  Attributes by Tag (Informative)
     __TAG_name_____________________________________________||_________Applicable_attributes________________________________________________
       DW.TAG.constant                                ||               DECL
                                                                     | DW.AT.accessibility
                                                                     |
                                                                     | DW.AT.const.value
                                                                     |
                                                                     | DW.AT.declaration
                                                                     |
                                                                     | DW.AT.endianity
                                                                     |
                                                                     | DW.AT.external
                                                                     |
                                                                     | DW.AT.linkage.name
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.start.scope
                                                                     |
                                                                     | DW.AT.type
                                                                     |
                                                                     | DW.AT.visibility
     ________________________________________________________________|_____________________________________________________________________
     __DW.TAG.dwarf.procedure_________________||_______________________DW.AT.location______________________________________________________
       DW.TAG.dynamic.type                      ||                     DECL
                                                                     | DW.AT.alignment
                                                                     |
                                                                     | DW.AT.allocated
                                                                     |
                                                                     | DW.AT.associated
                                                                     |
                                                                     | DW.AT.data.location
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.type
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.entry.point                          ||                  DECL
                                                                     | DW.AT.address.class
                                                                     |
                                                                     | DW.AT.frame.base
                                                                     |
                                                                     | DW.AT.linkage.name
                                                                     |
                                                                     | DW.AT.low.pc
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.return.addr
                                                                     |
                                                                     | DW.AT.static.link
                                                                     |
                                                                     | DW.AT.type
     ________________________________________________________________|______________________________________________________________________
       Continued on next page
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 270
                                Appendix A.  Attributes by Tag (Informative)
     __TAG_name_____________________________________________||_________Applicable_attributes________________________________________________
       DW.TAG.enumeration.type                ||                       DECL
                                                                     | DW.AT.accessibility
                                                                     |
                                                                     | DW.AT.alignment
                                                                     |
                                                                     | DW.AT.allocated
                                                                     |
                                                                     | DW.AT.associated
                                                                     |
                                                                     | DW.AT.bit.size
                                                                     |
                                                                     | DW.AT.bit.stride
                                                                     |
                                                                     | DW.AT.byte.size
                                                                     |
                                                                     | DW.AT.byte.stride
                                                                     |
                                                                     | DW.AT.data.location
                                                                     |
                                                                     | DW.AT.declaration
                                                                     |
                                                                     | DW.AT.enum.class
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.signature
                                                                     |
                                                                     | DW.AT.speciocation
                                                                     |
                                                                     | DW.AT.start.scope
                                                                     |
                                                                     | DW.AT.type
                                                                     |
                                                                     | DW.AT.visibility
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.enumerator                          ||                   DECL
                                                                     | DW.AT.const.value
                                                                     |
                                                                     | DW.AT.name
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.ole.type                               ||                DECL
                                                                     | DW.AT.alignment
                                                                     |
                                                                     | DW.AT.allocated
                                                                     |
                                                                     | DW.AT.associated
                                                                     |
                                                                     | DW.AT.bit.size
                                                                     |
                                                                     | DW.AT.byte.size
                                                                     |
                                                                     | DW.AT.data.location
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.start.scope
                                                                     |
                                                                     | DW.AT.type
                                                                     |
                                                                     | DW.AT.visibility
     ________________________________________________________________|______________________________________________________________________
       Continued on next page
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 271
                                Appendix A.  Attributes by Tag (Informative)
     __TAG_name_____________________________________________||_________Applicable_attributes________________________________________________
       DW.TAG.formal.parameter                ||                       DECL
                                                                     | DW.AT.const.value
                                                                     |
                                                                     | DW.AT.default.value
                                                                     |
                                                                     | DW.AT.endianity
                                                                     |
                                                                     | DW.AT.is.optional
                                                                     |
                                                                     | DW.AT.location
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.type
                                                                     |
                                                                     | DW.AT.variable.parameter
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.friend                                    ||             DECL
                                                                     | DW.AT.friend
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.generic.subrange                 ||                      DECL
                                                                     | DW.AT.accessibility
                                                                     |
                                                                     | DW.AT.alignment
                                                                     |
                                                                     | DW.AT.allocated
                                                                     |
                                                                     | DW.AT.associated
                                                                     |
                                                                     | DW.AT.bit.size
                                                                     |
                                                                     | DW.AT.bit.stride
                                                                     |
                                                                     | DW.AT.byte.size
                                                                     |
                                                                     | DW.AT.byte.stride
                                                                     |
                                                                     | DW.AT.count
                                                                     |
                                                                     | DW.AT.data.location
                                                                     |
                                                                     | DW.AT.declaration
                                                                     |
                                                                     | DW.AT.lower.bound
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.threads.scaled
                                                                     |
                                                                     | DW.AT.type
                                                                     |
                                                                     | DW.AT.upper.bound
                                                                     |
                                                                     | DW.AT.visibility
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.immutable.type                   ||                      DECL
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.type
     ________________________________________________________________|______________________________________________________________________
       Continued on next page
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 272
                                Appendix A.  Attributes by Tag (Informative)
     __TAG_name_____________________________________________||_________Applicable_attributes________________________________________________
       DW.TAG.imported.declaration           ||                        DECL
                                                                     | DW.AT.accessibility
                                                                     |
                                                                     | DW.AT.import
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.start.scope
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.imported.module                ||                        DECL
                                                                     | DW.AT.import
                                                                     |
                                                                     | DW.AT.start.scope
     ________________________________________________________________|_____________________________________________________________________
     __DW.TAG.imported.unit______________________||____________________DW.AT.import________________________________________________________
       DW.TAG.inheritance                           ||                 DECL
                                                                     | DW.AT.accessibility
                                                                     |
                                                                     | DW.AT.data.member.location
                                                                     |
                                                                     | DW.AT.type
                                                                     |
                                                                     | DW.AT.virtuality
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.inlined.subroutine               ||                      DW.AT.call.column
                                                                     | DW.AT.call.ole
                                                                     |
                                                                     | DW.AT.call.line
                                                                     |
                                                                     | DW.AT.const.expr
                                                                     |
                                                                     | DW.AT.entry.pc
                                                                     |
                                                                     | DW.AT.high.pc
                                                                     |
                                                                     | DW.AT.low.pc
                                                                     |
                                                                     | DW.AT.ranges
                                                                     |
                                                                     | DW.AT.return.addr
                                                                     |
                                                                     | DW.AT.start.scope
                                                                     |
                                                                     | DW.AT.trampoline
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.interface.type                      ||                   DECL
                                                                     | DW.AT.accessibility
                                                                     |
                                                                     | DW.AT.alignment
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.signature
                                                                     |
                                                                     | DW.AT.start.scope
     ________________________________________________________________|______________________________________________________________________
       Continued on next page
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 273
                                Appendix A.  Attributes by Tag (Informative)
     __TAG_name_____________________________________________||_________Applicable_attributes________________________________________________
       DW.TAG.label                                      ||            DECL
                                                                     | DW.AT.low.pc
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.start.scope
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.lexical.block                         ||                 DECL
                                                                     | DW.AT.entry.pc
                                                                     |
                                                                     | DW.AT.high.pc
                                                                     |
                                                                     | DW.AT.low.pc
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.ranges
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.member                                ||                 DECL
                                                                     | DW.AT.accessibility
                                                                     |
                                                                     | DW.AT.bit.size
                                                                     |
                                                                     | DW.AT.byte.size
                                                                     |
                                                                     | DW.AT.data.bit.ooeset
                                                                     |
                                                                     | DW.AT.data.member.location
                                                                     |
                                                                     | DW.AT.declaration
                                                                     |
                                                                     | DW.AT.mutable
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.type
                                                                     |
                                                                     | DW.AT.visibility
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.module                                 ||                DECL
                                                                     | DW.AT.accessibility
                                                                     |
                                                                     | DW.AT.declaration
                                                                     |
                                                                     | DW.AT.entry.pc
                                                                     |
                                                                     | DW.AT.high.pc
                                                                     |
                                                                     | DW.AT.low.pc
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.priority
                                                                     |
                                                                     | DW.AT.ranges
                                                                     |
                                                                     | DW.AT.speciocation
                                                                     |
                                                                     | DW.AT.visibility
     ________________________________________________________________|______________________________________________________________________
       Continued on next page
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 274
                                Appendix A.  Attributes by Tag (Informative)
     __TAG_name_____________________________________________||_________Applicable_attributes________________________________________________
       DW.TAG.namelist                                ||               DECL
                                                                     | DW.AT.accessibility
                                                                     |
                                                                     | DW.AT.declaration
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.visibility
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.namelist.item                       ||                   DECL
                                                                     | DW.AT.namelist.item
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.namespace                            ||                  DECL
                                                                     | DW.AT.export.symbols
                                                                     |
                                                                     | DW.AT.extension
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.start.scope
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.packed.type                         ||                   DECL
                                                                     | DW.AT.alignment
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.type
     ________________________________________________________________|______________________________________________________________________
       Continued on next page
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 275
                                Appendix A.  Attributes by Tag (Informative)
     __TAG_name_____________________________________________||_________Applicable_attributes________________________________________________
       DW.TAG.partial.unit                          ||                 DW.AT.addr.base
                                                                     | DW.AT.base.types
                                                                     |
                                                                     | DW.AT.comp.dir
                                                                     |
                                                                     | DW.AT.dwo.name
                                                                     |
                                                                     | DW.AT.entry.pc
                                                                     |
                                                                     | DW.AT.identioer.case
                                                                     |
                                                                     | DW.AT.high.pc
                                                                     |
                                                                     | DW.AT.language.name
                                                                     |
                                                                      | DW.AT.language.version
                                                                      |
                                                                      | DW.AT.low.pc
                                                                      |
                                                                      | DW.AT.macros
                                                                      |
                                                                      | DW.AT.main.subprogram
                                                                      |
                                                                      | DW.AT.name
                                                                      |
                                                                      | DW.AT.producer
                                                                      |
                                                                      | DW.AT.ranges
                                                                      |
                                                                      | DW.AT.rnglists.base
                                                                      |
                                                                      | DW.AT.stmt.list
                                                                      |
                                                                      | DW.AT.str.ooesets
                                                                      |
                                                                      | DW.AT.use.UTF8
     _________________________________________________________________|____________________________________________________________________
       DW.TAG.pointer.type                         ||                   DECL
                                                                      | DW.AT.address.class
                                                                      |
                                                                      | DW.AT.alignment
                                                                      |
                                                                      | DW.AT.bit.size
                                                                      |
                                                                      | DW.AT.byte.size
                                                                      |
                                                                      | DW.AT.name
                                                                      |
                                                                      | DW.AT.type
     _________________________________________________________________|_____________________________________________________________________
       Continued on next page
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 276
                                Appendix A.  Attributes by Tag (Informative)
     __TAG_name_____________________________________________||_________Applicable_attributes________________________________________________
       DW.TAG.ptr.to.member.type           ||                          DECL
                                                                     | DW.AT.address.class
                                                                     |
                                                                     | DW.AT.alignment
                                                                     |
                                                                     | DW.AT.allocated
                                                                     |
                                                                     | DW.AT.associated
                                                                     |
                                                                     | DW.AT.containing.type
                                                                     |
                                                                     | DW.AT.data.location
                                                                     |
                                                                     | DW.AT.declaration
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.type
                                                                     |
                                                                     | DW.AT.use.location
                                                                     |
                                                                     | DW.AT.visibility
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.reference.type                      ||                   DECL
                                                                     | DW.AT.address.class
                                                                     |
                                                                     | DW.AT.alignment
                                                                     |
                                                                     | DW.AT.bit.size
                                                                     |
                                                                     | DW.AT.byte.size
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.type
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.restrict.type                         ||                 DECL
                                                                     | DW.AT.alignment
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.type
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.rvalue.reference.type          ||                        DECL
                                                                     | DW.AT.address.class
                                                                     |
                                                                     | DW.AT.alignment
                                                                     |
                                                                     | DW.AT.bit.size
                                                                     |
                                                                     | DW.AT.byte.size
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.type
     ________________________________________________________________|______________________________________________________________________
       Continued on next page
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 277
                                Appendix A.  Attributes by Tag (Informative)
     __TAG_name_____________________________________________||_________Applicable_attributes________________________________________________
       DW.TAG.set.type                                ||               DECL
                                                                     | DW.AT.accessibility
                                                                     |
                                                                     | DW.AT.alignment
                                                                     |
                                                                     | DW.AT.allocated
                                                                     |
                                                                     | DW.AT.associated
                                                                     |
                                                                     | DW.AT.bit.size
                                                                     |
                                                                     | DW.AT.byte.size
                                                                     |
                                                                     | DW.AT.data.location
                                                                     |
                                                                     | DW.AT.declaration
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.start.scope
                                                                     |
                                                                     | DW.AT.type
                                                                     |
                                                                     | DW.AT.visibility
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.shared.type                          ||                  DECL
                                                                     | DW.AT.count
                                                                     |
                                                                     | DW.AT.alignment
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.type
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.skeleton.unit                        ||                  DW.AT.addr.base
                                                                     | DW.AT.comp.dir
                                                                     |
                                                                     | DW.AT.dwo.name
                                                                     |
                                                                     | DW.AT.high.pc
                                                                     |
                                                                     | DW.AT.low.pc
                                                                     |
                                                                     | DW.AT.ranges
                                                                     |
                                                                     | DW.AT.rnglists.base
                                                                     |
                                                                     | DW.AT.stmt.list
                                                                     |
                                                                     | DW.AT.str.ooesets
                                                                     |
                                                                      | DW.AT.use.UTF8
     _________________________________________________________________|_____________________________________________________________________
       Continued on next page
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 278
                                Appendix A.  Attributes by Tag (Informative)
     __TAG_name_____________________________________________||_________Applicable_attributes________________________________________________
       DW.TAG.string.type                           ||                 DECL
                                                                     | DW.AT.alignment
                                                                     |
                                                                     | DW.AT.accessibility
                                                                     |
                                                                     | DW.AT.allocated
                                                                     |
                                                                     | DW.AT.associated
                                                                     |
                                                                     | DW.AT.bit.size
                                                                     |
                                                                     | DW.AT.byte.size
                                                                     |
                                                                     | DW.AT.data.location
                                                                     |
                                                                     | DW.AT.declaration
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.start.scope
                                                                     |
                                                                     | DW.AT.string.length
                                                                     |
                                                                     | DW.AT.string.length.bit.size
                                                                     |
                                                                     | DW.AT.string.length.byte.size
                                                                     |
                                                                     | DW.AT.visibility
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.structure.type                      ||                   DECL
                                                                     | DW.AT.accessibility
                                                                     |
                                                                     | DW.AT.alignment
                                                                     |
                                                                     | DW.AT.allocated
                                                                     |
                                                                     | DW.AT.associated
                                                                     |
                                                                     | DW.AT.bit.size
                                                                     |
                                                                     | DW.AT.byte.size
                                                                     |
                                                                     | DW.AT.calling.convention
                                                                     |
                                                                     | DW.AT.data.location
                                                                     |
                                                                     | DW.AT.declaration
                                                                     |
                                                                     | DW.AT.export.symbols
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.signature
                                                                     |
                                                                     | DW.AT.speciocation
                                                                     |
                                                                     | DW.AT.start.scope
                                                                     |
                                                                     | DW.AT.visibility
     ________________________________________________________________|______________________________________________________________________
       Continued on next page
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 279
                                Appendix A.  Attributes by Tag (Informative)
     __TAG_name_____________________________________________||_________Applicable_attributes________________________________________________
       DW.TAG.subprogram                          ||                   DECL
                                                                     | DW.AT.accessibility
                                                                     |
                                                                     | DW.AT.address.class
                                                                     |
                                                                     | DW.AT.alignment
                                                                     |
                                                                     | DW.AT.calling.convention
                                                                     |
                                                                     | DW.AT.declaration
                                                                     |
                                                                     | DW.AT.defaulted
                                                                     |
                                                                     | DW.AT.deleted
                                                                     |
                                                                     | DW.AT.elemental
                                                                     |
                                                                     | DW.AT.entry.pc
                                                                     |
                                                                     | DW.AT.explicit
                                                                     |
                                                                     | DW.AT.external
                                                                     |
                                                                     | DW.AT.frame.base
                                                                     |
                                                                     | DW.AT.high.pc
                                                                     |
                                                                     | DW.AT.inline
                                                                     |
                                                                     | DW.AT.linkage.name
                                                                     |
                                                                     | DW.AT.low.pc
                                                                     |
                                                                     | DW.AT.main.subprogram
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.noreturn
                                                                     |
                                                                     | DW.AT.object.pointer
                                                                     |
                                                                     | DW.AT.prototyped
                                                                     |
                                                                     | DW.AT.pure
                                                                     |
                                                                     | DW.AT.ranges
                                                                     |
                                                                     | DW.AT.recursive
                                                                     |
                                                                     | DW.AT.reference
                                                                     |
                                                                     | DW.AT.return.addr
                                                                     |
                                                                     | DW.AT.rvalue.reference
                                                                     |
                                                                     | DW.AT.speciocation
                                                                     |
                                                                     | Additional attributes continue on next page
     ________________________________________________________________|_____________________________________________________________________
       Continued on next page
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 280
                                Appendix A.  Attributes by Tag (Informative)
     __TAG_name_____________________________________________||_________Applicable_attributes_______________________________________________
       DW.TAG.subprogram (cont.)              ||                       DW.AT.start.scope
                                                                     | DW.AT.static.link
                                                                     |
                                                                     | DW.AT.trampoline
                                                                     |
                                                                     | DW.AT.type
                                                                     |
                                                                     | DW.AT.visibility
                                                                     |
                                                                     | DW.AT.virtuality
                                                                     |
                                                                     | DW.AT.vtable.elem.location
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.subrange.type                      ||                    DECL
                                                                     | DW.AT.accessibility
                                                                     |
                                                                     | DW.AT.alignment
                                                                     |
                                                                     | DW.AT.allocated
                                                                     |
                                                                     | DW.AT.associated
                                                                     |
                                                                     | DW.AT.bit.size
                                                                     |
                                                                     | DW.AT.bit.stride
                                                                     |
                                                                     | DW.AT.byte.size
                                                                     |
                                                                     | DW.AT.byte.stride
                                                                     |
                                                                     | DW.AT.count
                                                                     |
                                                                     | DW.AT.data.location
                                                                     |
                                                                     | DW.AT.declaration
                                                                     |
                                                                     | DW.AT.lower.bound
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.threads.scaled
                                                                     |
                                                                     | DW.AT.type
                                                                     |
                                                                     | DW.AT.upper.bound
                                                                     |
                                                                     | DW.AT.visibility
     ________________________________________________________________|______________________________________________________________________
       Continued on next page
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 281
                                Appendix A.  Attributes by Tag (Informative)
     __TAG_name_____________________________________________||_________Applicable_attributes________________________________________________
       DW.TAG.subroutine.type                   ||                     DECL
                                                                     | DW.AT.accessibility
                                                                     |
                                                                     | DW.AT.address.class
                                                                     |
                                                                     | DW.AT.alignment
                                                                     |
                                                                     | DW.AT.allocated
                                                                     |
                                                                     | DW.AT.associated
                                                                     |
                                                                     | DW.AT.data.location
                                                                     |
                                                                     | DW.AT.declaration
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.prototyped
                                                                     |
                                                                     | DW.AT.reference
                                                                     |
                                                                     | DW.AT.rvalue.reference
                                                                     |
                                                                     | DW.AT.start.scope
                                                                     |
                                                                     | DW.AT.type
                                                                     |
                                                                     | DW.AT.visibility
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.template.alias                      ||                   DECL
                                                                     | DW.AT.accessibility
                                                                     |
                                                                     | DW.AT.allocated
                                                                     |
                                                                     | DW.AT.associated
                                                                     |
                                                                     | DW.AT.data.location
                                                                     |
                                                                     | DW.AT.declaration
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.signature
                                                                     |
                                                                     | DW.AT.start.scope
                                                                     |
                                                                     | DW.AT.type
                                                                     |
                                                                     | DW.AT.visibility
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.template.type.parameter    ||                            DECL
                                                                     | DW.AT.default.value
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.type
     ________________________________________________________________|______________________________________________________________________
       Continued on next page
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 282
                                Appendix A.  Attributes by Tag (Informative)
     __TAG_name_____________________________________________||_________Applicable_attributes________________________________________________
       DW.TAG.template.value.parameter  ||                             DECL
                                                                     | DW.AT.const.value
                                                                     |
                                                                     | DW.AT.default.value
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.type
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.thrown.type                         ||                   DECL
                                                                     | DW.AT.alignment
                                                                     |
                                                                     | DW.AT.allocated
                                                                     |
                                                                     | DW.AT.associated
                                                                     |
                                                                     | DW.AT.data.location
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.type
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.try.block                              ||                DECL
                                                                     | DW.AT.entry.pc
                                                                     |
                                                                     | DW.AT.high.pc
                                                                     |
                                                                     | DW.AT.low.pc
                                                                     |
                                                                     | DW.AT.ranges
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.typedef                                 ||               DECL
                                                                     | DW.AT.accessibility
                                                                     |
                                                                     | DW.AT.alignment
                                                                     |
                                                                     | DW.AT.allocated
                                                                     |
                                                                     | DW.AT.associated
                                                                     |
                                                                     | DW.AT.data.location
                                                                     |
                                                                     | DW.AT.declaration
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.start.scope
                                                                     |
                                                                     | DW.AT.type
                                                                     |
                                                                     | DW.AT.visibility
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.type.unit                              ||                DW.AT.language.name
                                                                      | DW.AT.language.version
                                                                      |
                                                                      | DW.AT.stmt.list
                                                                      |
                                                                      | DW.AT.str.ooesets
                                                                      |
                                                                      | DW.AT.use.UTF8
     _________________________________________________________________|_____________________________________________________________________
       Continued on next page
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 283
                                Appendix A.  Attributes by Tag (Informative)
     __TAG_name_____________________________________________||_________Applicable_attributes________________________________________________
       DW.TAG.union.type                           ||                  DECL
                                                                     | DW.AT.accessibility
                                                                     |
                                                                     | DW.AT.alignment
                                                                     |
                                                                     | DW.AT.allocated
                                                                     |
                                                                     | DW.AT.associated
                                                                     |
                                                                     | DW.AT.bit.size
                                                                     |
                                                                     | DW.AT.byte.size
                                                                     |
                                                                     | DW.AT.calling.convention
                                                                     |
                                                                     | DW.AT.data.location
                                                                     |
                                                                     | DW.AT.declaration
                                                                     |
                                                                     | DW.AT.export.symbols
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.signature
                                                                     |
                                                                     | DW.AT.speciocation
                                                                     |
                                                                     | DW.AT.start.scope
                                                                     |
                                                                     | DW.AT.visibility
     ________________________________________________________________|_____________________________________________________________________
     __DW.TAG.unspecioed.parameters_______||___________________________DECL________________________________________________________________
       DW.TAG.unspecioed.type                  ||                      DECL
                                                                     | DW.AT.name
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.variable                                ||               DECL
                                                                     | DW.AT.accessibility
                                                                     |
                                                                     | DW.AT.alignment
                                                                     |
                                                                     | DW.AT.const.expr
                                                                     |
                                                                     | DW.AT.const.value
                                                                     |
                                                                     | DW.AT.declaration
                                                                     |
                                                                     | DW.AT.endianity
                                                                     |
                                                                     | DW.AT.external
                                                                     |
                                                                     | DW.AT.linkage.name
                                                                     |
                                                                     | DW.AT.location
                                                                     |
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.speciocation
                                                                     |
                                                                     | DW.AT.start.scope
                                                                     |
                                                                     | DW.AT.type
                                                                     |
                                                                     | DW.AT.visibility
     ________________________________________________________________|______________________________________________________________________
       Continued on next page
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 284
                                Appendix A.  Attributes by Tag (Informative)
     __TAG_name_____________________________________________||_________Applicable_attributes________________________________________________
       DW.TAG.variant                                  ||              DECL
                                                                     | DW.AT.accessibility
                                                                     |
                                                                     | DW.AT.declaration
                                                                     |
                                                                     | DW.AT.discr.list
                                                                     |
                                                                     | DW.AT.discr.value
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.variant.part                         ||                  DECL
                                                                     | DW.AT.accessibility
                                                                     |
                                                                     | DW.AT.declaration
                                                                     |
                                                                     | DW.AT.discr
                                                                     |
                                                                     | DW.AT.type
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.volatile.type                        ||                  DECL
                                                                     | DW.AT.name
                                                                     |
                                                                     | DW.AT.type
     ________________________________________________________________|_____________________________________________________________________
       DW.TAG.with.stmt                             ||                 DECL
                                                                     | DW.AT.accessibility
                                                                     |
                                                                     | DW.AT.address.class
                                                                     |
                                                                     | DW.AT.declaration
                                                                     |
                                                                     | DW.AT.entry.pc
                                                                     |
                                                                     | DW.AT.high.pc
                                                                     |
                                                                     | DW.AT.location
                                                                     |
                                                                     | DW.AT.low.pc
                                                                     |
                                                                     | DW.AT.ranges
                                                                     |
                                                                     | DW.AT.type
                                                                     |
                                                                     | DW.AT.visibility
     ________________________________________________________________|_____________________________________________________________________
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 285
                                Appendix A.  Attributes by Tag (Informative)
                                                             (empty page)
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 286

Appendix  B
Debug  Section  Relationships
(Informative)
DWARF information is organized into multiple program sections, each of which
holds a particular kind of information. In some cases, information in one section
refers to information in one or more of the others. These relationships are
illustrated by the diagrams and associated notes on the following pages.
In the ogures, a section is shown as a shaded oval with the name of the section
inside. References from one section to another are shown by an arrow. In the orst
ogure, the arrow is annotated with an unshaded box which contains an
indication of the construct (such as an attribute or form) that encodes the
reference. In the second ogure, this box is left out for reasons of space in favor of
a label annotation that is explained in the subsequent notes.
B.1           Normal  DWARF  Section  Relationships
Figure B.1 following illustrates the DWARF section relations without split
DWARF object oles involved. Similarly, it does not show the relationships
between the main debugging sections of an executable or sharable ole and a
related supplementary object ole.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 287
                       Appendix B.  Debug Section Relationships (Informative)
B.2           Split  DWARF  Section  Relationships
Figure B.2 on page 293 illustrates the DWARF section relationships for split
DWARF object oles. However, it does not show the relationships between the
main debugging sections of an executable or shareable ole and a related
supplementary object ole. For space reasons, the ogure omits some details that
are shown in Figure B.1, such as indirect references using indexing sections (such
as .debug_str_offsets).
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 288
                       Appendix B.  Debug Section Relationships (Informative)
                                                                                                                                                     *
 *                 DW.MADW.AT.addr.baseCRO.deone.strxDW.OP.addrxDW.MACRO.deone.strpDW.RLE.base.addressx
                                                                                                                                                     *
 *               .debug_namesTo.compilationduniteb(a)ug_infoATo.abbreviationsde(b)bug_abbrevWhenWstr_formathisenDstr_formatWis.FORM.strp[8]DW(d).AT.s*
 *tr.ooesetsDW.(e)OP.call.refDW.A(f)T.macrosDW(g).A@
                                                                                                                                                     *
 *                 DW.FORM.strp[8]DW(c).FORM.strx4DW(u).FORM.strx[1,2,3,4]DW.FORM.ref.addrDW.AT.rnglists.baseDW.OP.addrx(m)DW.MACRO.start.oleDW.LLE.**
 *x*(p)(q)DW.RLE.startx.length
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 289             *
 *                      DW.OP.constx     (k)
                                                                                                                                                     *
 *                                                          Figure B.1: Debug section relationships
                       Appendix B.  Debug Section Relationships (Informative)
                                                     Notes for Figure B.1
  (a) .debug_names to .debug_info
          The list of compilation units following the header contains the ooesets in the
          .debug_info section of the corresponding compilation unit headers (not the
          compilation unit entries).
  (b) .debug_info to .debug_abbrev
          The debug_abbrev_offset value in the header is the ooeset in the
          .debug_abbrev section of the abbreviations for that compilation unit.
  (c) .debug_names to .debug_info
          When str_format of the section header equals DW.FORM.strp or
          DW.FORM.strp8, the orst array of the name table oeld contains pointers
          into the .debug_str section. See also item (u) below.
  (d) .debug_info to .debug_str
          Attribute values of class string may have form DW.FORM.strp or
          DW.FORM.strp8, whose value is the ooeset in the .debug_str section of
          the corresponding string.
  (e) .debug_info to .debug_str_offsets
          The value of the DW.AT.str.ooesets attribute in a DW.TAG.compile.unit,
          DW.TAG.type.unit or DW.TAG.partial.unit DIE is the ooeset in the
          .debug_str_offsets section of the header of the string ooesets information
          for that unit. In addition, attribute values of class string may have one of
          the forms DW.FORM.strx, DW.FORM.strx1, DW.FORM.strx2,
          DW.FORM.strx3 or DW.FORM.strx4, whose value is an index into the
          string ooesets table.
  (f) .debug_info to .debug_info
          The operand of the DW.OP.call.ref DWARF expression operator is the
          ooeset of a debugging information entry in the .debug_info section of
          another compilation. Similarly for attribute operands that use
          DW.FORM.ref.addr.
  (g) .debug_info to .debug_macro
          An attribute value of class macptr (speciocally form DW.FORM.sec.ooeset)
          is an ooeset within the .debug_macro section of the beginning of the macro
          information for the referencing unit.
  (h) .debug_info to .debug_line
          An attribute value of class lineptr (speciocally form DW.FORM.sec.ooeset)
          is an ooeset in the .debug_line section of the beginning of the line number
          information for the referencing unit.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 290
                       Appendix B.  Debug Section Relationships (Informative)
  (i) .debug_info to .debug_rnglists
          An attribute value of class rnglist (speciocally form DW.FORM.rnglistx or
          DW.FORM.sec.ooeset) is an index or ooeset within the .debug_rnglists
          section of a range list.
  (j) .debug_info to .debug_loclists
          An attribute value of class loclist (speciocally form DW.FORM.loclistx or
          DW.FORM.sec.ooeset) is an index or ooeset within the .debug_loclists
          section of a value list or location list.
  (k) .debug_info to .debug_addr
          The value of the DW.AT.addr.base attribute in the
          DW.TAG.compile.unit or DW.TAG.partial.unit DIE is the ooeset in the
          .debug_addr section of the machine addresses for that unit.
          DW.FORM.addrx, DW.FORM.addrx1, DW.FORM.addrx2,
          DW.FORM.addrx3, DW.FORM.addrx4, DW.OP.addrx and
          DW.OP.constx contain indices relative to that ooeset.
  (l) .debug_str_offsets to .debug_str
          Entries in the string ooesets table are ooesets to the corresponding string text
          in the .debug_str section.
  (m) .debug_macro to .debug_str_offsets
          The second operand of a DW.MACRO.deone.strx or
          DW.MACRO.undef.strx macro information entry is an index into the
          string ooeset table in the .debug_str_offsets section.
  (n) .debug_macro to .debug_line
          The second operand of DW.MACRO.start.ole refers to a ole entry in the
          .debug_line section relative to the start of that section given in the macro
          information header.
  (o) .debug_loclists to .debug_addr
          DW.OP.addrx and DW.OP.constx operators that occur in the
          .debug_loclists section refer indirectly to the .debug_addr section by way
          of the DW.AT.addr.base attribute in the associated .debug_info section.
          Also, some operands of the DW.LLE.base.addressx,
          DW.LLE.startx.endx and DW.LLE.startx.length value list or location list
          entries have operands that are an index into the .debug_addr section.
  (p) .debug_macro to .debug_str
          The second operand of a DW.MACRO.deone.strp or
          DW.MACRO.undef.strp macro information entry is an index into the
          string table in the .debug_str section.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 291
                       Appendix B.  Debug Section Relationships (Informative)
  (q) .debug_macro to .debug_macro
          The operand of a DW.MACRO.import macro information entry is an
          ooeset into another part of the .debug_macro section to the header for the
          sequence to be replicated.
  (r) .debug_line to .debug_line_str
          The value of a DW.FORM.line.strp form refers to a string section specioc
          to the line number table. This form can be used in a .debug_line section (as
          well as in a .debug_info section).
  (s) .debug_info to .debug_line_str
          The value of a DW.FORM.line.strp form refers to a string section specioc
          to the line number table. This form can be used in a .debug_info section (as
          well as in a .debug_line section).1
  (t) .debug_rnglists to .debug_addr
          Some operands of DW.RLE.base.addressx, DW.RLE.startx.endx and
          DW.RLE.startx.length range list entries are an an index into the
          .debug_addr section.
  (u) .debug_names to .debug_str_offsets
          When str_format of the section header equals DW.FORM.strx4, the orst
          array of the name table oeld contains indexes into the .debug_str_offsets
          section, which indirectly refers to the relevant string. See also item (c)
          above.
  (v) .debug_aranges to .debug_info
          The debug_info_offset value in the header is the ooeset in the .debug_info
          section of the corresponding compilation unit header (not the compilation
          unit entry).
_________________________________________________________
      1The circled (A) of the left connects to the circled (A) on the right via hyperspace (a wormhole).
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 292
                       Appendix B.  Debug Section Relationships (Informative)
                                                                                                                                                     *
 *                 .debug_info.dwo
                                                                                                                                                     *
 *               S.debug_info(onekCU,epossiblyletonSDWARFplit DWARF
                                                                                                                                                     *
 *             .debug_abbrev.debug_addr.debug_aranges.debug_frame.debug_line.debug_line_str.debug_names.debug_rnglists.debug_str.debug_str_offsets.de*
 *bug_abbrev.dwo.debug_loclists.dwo.debug_rnglists.@
                                                                                                                                                     *
 *               (skeletonmCU)ultipleiCOMDATniexecutablen separate object
                                                                                                                                                     *
 *                       type units)
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 293
                                                                                                                                                     *
 *                                                    Figure B.2: Split DWARF section relationships
                       Appendix B.  Debug Section Relationships (Informative)
                                                     Notes for Figure B.2
  (a) .debug_aranges to .debug_info
          The debug_info_offset oeld in the header is the ooeset in the .debug_info
          section of the corresponding compilation unit header of the skeleton
          .debug_info section (not the compilation unit entry). The
          DW.AT.dwo.name attribute in the .debug_info skeleton connects the
          ranges to the full compilation unit in .debug_info.dwo.
  (b) .debug_names to .debug_info
          The .debug_names section ooesets lists provide an ooeset for the skeleton
          compilation unit and eight byte signatures for the type units that appear
          only in the .debug_info.dwo. The DIE ooesets for these compilation units
          and type units refer to the DIEs in the .debug_info.dwo section for the
          respective compilation unit and type units.
  (c) .debug_info skeleton to .debug_abbrev
          The debug_abbrev_offset value in the header is the ooeset in the
          .debug_abbrev section of the abbreviations for that compilation unit
          skeleton.
  (co) .debug_info.dwo to .debug_abbrev.dwo
          The debug_abbrev_offset value in the header is the ooeset in the
          .debug_abbrev.dwo section of the abbreviations for that compilation unit.
  (d) .debug_info to .debug_str
          Attribute values of class string may have form DW.FORM.strp or
          DW.FORM.strp8, whose value is an ooeset in the .debug_str section of the
          corresponding string.
  (did) .debug_info to .debug_info.dwo
          The DW.AT.dwo.name attribute in a skeleton unit identioes the ole
          containing the corresponding .dwo (split) data.
  (e) .debug_info to .debug_str_offsets
          Attribute values of class string may have one of the forms DW.FORM.strx,
          DW.FORM.strx1, DW.FORM.strx2, DW.FORM.strx3 or
          DW.FORM.strx4, whose value is an index into the .debug_str_offsets
          section for the corresponding string.
  (eo).debug_info.dwo to .debug_str_offsets.dwo
          Attribute values of class string may have one of the forms DW.FORM.strx,
          DW.FORM.strx1, DW.FORM.strx2, DW.FORM.strx3 or
          DW.FORM.strx4, whose value is an index into the
          .debug_str_offsets.dwo section for the corresponding string.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 294
                       Appendix B.  Debug Section Relationships (Informative)
  (go) .debug_info.dwo to .debug_macro.dwo
          An attribute of class macptr (speciocally DW.AT.macros with form
          DW.FORM.sec.ooeset) is an ooeset within the .debug_macro.dwo section of
          the beginning of the macro information for the referencing unit.
  (h) .debug_info (skeleton) to .debug_line
          An attribute value of class lineptr (speciocally DW.AT.stmt.list with form
          DW.FORM.sec.ooeset) is an ooeset within the .debug_line section of the
          beginning of the line number information for the referencing unit.
  (ho) .debug_info.dwo to .debug_line.dwo (skeleton)
          An attribute value of class lineptr (speciocally DW.AT.stmt.list with form
          DW.FORM.sec.ooeset) is an ooeset within the .debug_line.dwo section of
          the beginning of the line number header information for the referencing
          unit (the line table details are not in .debug_line.dwo but the line header
          with its list of ole names is present).
  (i) .debug_info to .debug_rnglists
          An attribute value of class rnglist (speciocally form DW.FORM.rnglistx or
          DW.FORM.sec.ooeset) is an index or ooeset within the .debug_rnglists
          section of a range list.
  (io) .debug_info.dwo to .debug_rnglists.dwo
          An attribute value of class rnglist (speciocally DW.AT.ranges with form
          DW.FORM.rnglistx or DW.FORM.sec.ooeset) is an index or ooeset within
          the .debug_rnglists.dwo section of a range list. The format of
          .debug_rnglists.dwo value list or location list entries is restricted to a
          subset of those in .debug_rnglists. See Section 2.17.3 on page 54 for
          details.
  (jo) .debug_info.dwo to .debug_loclists.dwo
          An attribute value of class loclist (speciocally with form
          DW.FORM.loclistx or DW.FORM.sec.ooeset) is an index or ooeset within
          the .debug_loclists.dwo section of a value list or location list. The format
          of .debug_loclists.dwo location list entries is restricted to a subset of
          those in .debug_loclists. See Section 2.6.2 on page 44 for details.
  (k) .debug_info to .debug_addr
          The value of the DW.AT.addr.base attribute in the
          DW.TAG.compile.unit, DW.TAG.partial.unit or DW.TAG.type.unit
          DIE is the ooeset in the .debug_addr section of the machine addresses for
          that unit. DW.FORM.addrx, DW.FORM.addrx1, DW.FORM.addrx2,
          DW.FORM.addrx3, DW.FORM.addrx4, DW.OP.addrx and
          DW.OP.constx contain indices relative to that ooeset.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 295
                       Appendix B.  Debug Section Relationships (Informative)
  (lo) .debug_str_offsets.dwo to .debug_str.dwo
          Entries in the string ooesets table are ooesets to the corresponding string text
          in the .debug_str.dwo section.
  (mo) .debug_macro.dwo to .debug_str_offsets.dwo
          Within the .debug_macro.dwo sections, the second operand of
          DW.MACRO.deone.strx and DW.MACRO.undef.strx operations is an
          unsigned LEB128 value interpreted as an index into the
          .debug_str_offsets.dwo section.
  (n) .debug_line to .debug_str_offsets
          The value of a DW.FORM.line.strp form refers to a string section specioc
          to the line number table. This form can be used in a .debug_line section (as
          well as in a .debug_info section).
  (no) .debug_line.dwo to .debug_str_offsets.dwo
          Unlike item (n) above, DW.FORM.line.strp is not used. One of the
          DW.FORM.strx[n] forms is used to index into the
          .debug_str_offsets.dwo section.
  (qo) .debug_macro.dwo to .debug_line.dwo
          Within the .debug_macro.dwo sections, if a DW.MACRO.start.ole entry is
          present, the macro header contains an ooeset into the .debug_line.dwo
          section.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 296

 Appendix  C
 Variable  Length  Data:
 Encoding/Decoding  (Informative)
 Here are algorithms expressed in a C-like pseudo-code to encode and decode
 signed and unsigned numbers in LEB128 representation.
 The encode and decode algorithms given here do not take account of C/C++
 rules that mean that in E1<<E2 the type of E1 should be a suOEciently large
 unsigned type to hold the correct mathematical result. The decode algorithms do
 not take account of or protect from possibly invalid LEB values, such as values
 that are too large to ot in the target type or that lack a proper terminator byte.
 Implementation languages may have additional or dioeerent rules.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||do
|||=============================================================================================================================================|||{
|||=============================================================================================================================================|||b=*
 *yltoewo7rbdietrsofv;a l u e
|||=============================================================================================================================================|||v>*
 *a>l=u7e;
|||=============================================================================================================================================|||if*
 *(v!a=l0u)e/*mboyrteetsoc*o/m e
|||=============================================================================================================================================|||sh*
 *eitgohrbdietrofb;y t e
|||=============================================================================================================================================|||eb*
 *myitte;
|||=============================================================================================================================================|||}w*
 *(hvialleu!e=0);_|_____|
                          Figure C.1: Algorithm to encode an unsigned integer
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 297
                              Appendix C.  Encoding/Decoding (Informative)
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||m=*
 *o1r;e
|||=============================================================================================================================================|||n=*
 *e(gvaatliuvee<0);
|||=============================================================================================================================================|||s=*
 *inzoe.ofbiintssiignnteedg;e r
|||=============================================================================================================================================|||w(*
 *hmiolree)
|||=============================================================================================================================================|||{
|||=============================================================================================================================================|||b=*
 *yltoewo7rbdietrsofv;a l u e
|||=============================================================================================================================================|||v>*
 *a>l=u7e;
|||=============================================================================================================================================|||/**
 *tfhoelilsouwninnegciefstshaer y
|||=============================================================================================================================================|||*i*
 *omfp>l>e=muesnetsaatniaornirtahtmheetri c
|||=============================================================================================================================================|||*t*
 *lhoagnischailfftoarsliegfnteodp e r a n d
|||=============================================================================================================================================|||*/
|||=============================================================================================================================================|||if*
 *(n)e g a t i v e
|||=============================================================================================================================================|||/**
 *seixgtne*n/d
|||=============================================================================================================================================|||v|*
 *a=l-u(e1<s<(i-z7e));
|||=============================================================================================================================================|||/**
 *sbiigtnofbiystseehciognhdobridte(r0x)4*0/
|||=============================================================================================================================================|||if*
 *((v=a=l0u&e&sbiigtnofbiystcel)e|a|r
|||=============================================================================================================================================|||(v*
 *=a=l-u1e&&sbiigtnofbiystsee)t)
|||=============================================================================================================================================|||m=*
 *o0r;e
|||=============================================================================================================================================|||e *
 *l s e
|||=============================================================================================================================================|||sh*
 *eitgohrbdietrofb;y t e
|||=============================================================================================================================================|||eb*
 *myitte;
|||=============================================================================================================================================|||}_*
 *|_____|
                              Figure C.2: Algorithm to encode a signed integer
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||r=*
 *e0s;u l t
|||=============================================================================================================================================|||s=*
 *h0i;f t
|||=============================================================================================================================================|||w(*
 *htirluee)
|||=============================================================================================================================================|||{
|||=============================================================================================================================================|||b=*
 *ynteexbtyitnei;n p u t
|||=============================================================================================================================================|||r|*
 *e=s(ullotwo7rbdietrsofb<y<tseh)i;f t
|||=============================================================================================================================================|||if*
 *(hoirgdhebriotfb=y=t0e)
|||=============================================================================================================================================|||b;*
 *r e a k
|||=============================================================================================================================================|||s+*
 *h=i7f;t
|||=============================================================================================================================================|||}_*
 *|_____|
                   Figure C.3: Algorithm to decode an unsigned LEB128 integer
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 298
                              Appendix C.  Encoding/Decoding (Informative)
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||r=*
 *e0s;u l t
|||=============================================================================================================================================|||s=*
 *h0i;f t
|||=============================================================================================================================================|||s=*
 *inzuemobfebriitnssiingtneegde;r
|||=============================================================================================================================================|||w(*
 *htirluee)
|||=============================================================================================================================================|||{
|||=============================================================================================================================================|||b=*
 *ynteexbtyitnei;n p u t
|||=============================================================================================================================================|||r|*
 *e=s(ullotwo7rbdietrsofb<y<tseh)i;f t
|||=============================================================================================================================================|||s+*
 *h=i7f;t
|||=============================================================================================================================================|||/**
 *sbiigtnofbiystseehciognhdobridte(r0x)4*0/
|||=============================================================================================================================================|||if*
 *(hoirgdhebriotfb=y=t0e)
|||=============================================================================================================================================|||b;*
 *r e a k
|||=============================================================================================================================================|||}
|||=============================================================================================================================================|||if*
 *((s<hsiifzte)&&(sbiigtnofbiystsee)t)
|||=============================================================================================================================================|||/**
 *seixgtne*n/d
|||=============================================================================================================================================|||r|*
 *e=s-u(l1t<s<h)i;f_t|_____|
                      Figure C.4: Algorithm to decode a signed LEB128 integer
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 299
                             Appendix C.  Encoding/Decoding (Informative)
                                                             (empty page)
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 300

 Appendix  D
 Examples  (Informative)
 The following sections provide examples that illustrate various aspects of the
 DWARF debugging information format.
 D.1            General  Description  Examples
 D.1.1           Compilation Units and Abbreviations Table Example
 Figure D.1 on the next page depicts the relationship of the abbreviations tables
 contained  in the .debug_abbrev section to the information contained in the
 .debug_info section. Values are given in symbolic form, where possible.
 The ogure corresponds to the following two trivial source oles:
 File myole.c
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||tc*
 *yhpaerd*ePfO;I_N|T_E_R_|
 File myole2.c
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||tc*
 *yhpaerd*esft;r_p|_____|
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 301
                                       Appendix D.  Examples (Informative)
              Compilation Unit #1:                                                  |           Abbreviation Table:                            |
      |                                                      |                      |                                                          |
      |              .debug_info                             |                      |               .debug_abbrev                              |
      _______________________________________________________||||                   ___________________________________________________________||||
      |                                                      |                      |                                                          |
      |  length                                              |                 a1:  || 1                                                       ||
      || 4                                                   ||                     |  DW_TAG_compile_unit                                     |
      |  a1  (abbreviations  table  offset)                  |                      |  DW_CHILDREN_yes                                         |
      |  4                                                   |                      || DW_AT_name           DW_FORM_string                     ||
      || ________________________________________________    ||                     |  DW_AT_producer     DW_FORM_string                       |
      |  1                                                   |                      |  DW_AT_comp_dir     DW_FORM_string                       |
      |  "myfile.c"                                          |                      || DW_AT_language_name  DW_FORM_data1                      ||
      || "Best  Compiler  Corp,  V1.3"                       ||                     |  DW_AT_low_pc        DW_FORM_addr                        |
      |  "/home/mydir/src"                                   |                      |  DW_AT_high_pc      DW_FORM_data1                        |
      |  DW_LNAME_C                                          |                      || DW_AT_stmt_list   DW_FORM_indirect                      ||
      || 0x0                                                 ||                     |  0                                                       |
      |  0x55                                                |                      |  _____________________________________________________   |
      |  DW_FORM_sec_offset                                  |                      || 2                                                       ||
      || 0x0                                                 ||                     |  DW_TAG_base_type                                        |
      |  ________________________________________________    |                      |  DW_CHILDREN_no                                          |
e1:   || 2                                                   ||                     || DW_AT_name           DW_FORM_string                     ||
      |  "char"                                              |                      |  DW_AT_encoding     DW_FORM_data1                        |
      |  DW_ATE_unsigned_char                                |                      |  DW_AT_byte_size   DW_FORM_data1                         |
      |  1                                                   |                      || 0                                                       ||
      || ________________________________________________    ||                     |  _____________________________________________________   |
e2:   |  3                                                   |                      |  3                                                       |
      |  e1   (debug  info  offset)                          |                      || DW_TAG_pointer_type                                     ||
      || ________________________________________________    ||                     |  DW_CHILDREN_no                                          |
      |  4                                                   |                      |  DW_AT_type           DW_FORM_ref4                       |
      |  "POINTER"                                           |                      || 0                                                       ||
      || e2___(debug__info__offset)______________________    ||                     |  _____________________________________________________   |
      |                                                      |                      || 4                                                       ||
      || 0                                                   ||                     |  DW_TAG_typedef                                          |
      |______________________________________________________|                      |  DW_CHILDREN_no                                          |
                                                                                    || DW_AT_name          DW_FORM_string                      ||
              Compilation Unit #2:                                                  || DW_AT_type0         DW_FORM_ref_addr                    ||
      |              .debug_info                             |                      |  _____________________________________________________   |
      _______________________________________________________||                     |  0                                                       |
      |                                                      |                      ||_________________________________________________________||
      || length                                              ||
      |  4                                                   |
      || a1  (abbreviations  table  offset)                  ||
      |  4                                                   |
      |  ________________________________________________    |
      || ...                                                 ||
      |  ________________________________________________    |
      |  4                                                   |
      || "strp"                                              ||
      |  e2   (debug  info  offset)                          |
      |  ________________________________________________    |
      || ...                                                 ||
      |______________________________________________________|
                        Figure D.1: Compilation units and abbreviations table
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 302
                                       Appendix D.  Examples (Informative)
D.1.2           DWARF Stack Operation Examples
The stack operations deoned in Section 2.5.1.3 on page 29. are fairly conventional, but
the following examples illustrate their behavior graphically.
                                      ___Before_______________Operation_____________________After__________
                                        0        17        DW.OP.dup                     0         17
                                        1        29                                      1         17
                                        2    1000                                        2         29
                                                                                         3     1000
                                        0        17        DW.OP.drop                    0         29
                                        1        29                                      1     1000
                                        2    1000
                                        0        17      DW.OP.pick, 2                   0     1000
                                        1        29                                      1         17
                                        2    1000                                        2         29
                                                                                         3     1000
                                        0        17        DW.OP.over                    0         29
                                        1        29                                      1         17
                                        2    1000                                        2         29
                                                                                         3     1000
                                        0        17       DW.OP.swap                     0         29
                                        1        29                                      1         17
                                        2    1000                                        2     1000
                                        0        17          DW.OP.rot                   0         29
                                        1        29                                      1     1000
                                        2    1000                                        2         17
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 303
                                       Appendix D.  Examples (Informative)
D.1.3           DWARF Location Description Examples
Following are examples of DWARF operations used to form location
descriptions:
DW_OP_reg3
         The value is in register 3.
DW_OP_regx  (54)
         The value is in register 54.
DW_OP_addr  (0x80d0045c)
         The value of a static variable is at machine address 0x80d0045c.
DW_OP_breg11  (44)
         Add 44 to the value in register 11 to get the address of an automatic variable
          instance.
DW_OP_fbreg  (-50)
         Given a DW.AT.frame.base value of iDW.OP.breg31 64,j this example
          computes the address of a local variable that is -50 bytes from a logical
          frame pointer that is computed by adding 64 to the current stack pointer
          (register 31).
DW_OP_bregx  (54,  32)
DW_OP_deref
         A call-by-reference parameter whose address is in the location beginning 32
          bytes from where register 54 points.
DW_OP_plus_uconst  (4)
         A structure member is four bytes from the start of the structure instance.
          The base address is assumed to be already on the stack.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 304
                                       Appendix D.  Examples (Informative)
DW_OP_reg3
DW_OP_piece  (4)
DW_OP_reg10
DW_OP_piece  (2)
         A variable whose orst four bytes reside in register 3 and whose next two
          bytes reside in register 10.
DW_OP_reg0
DW_OP_piece  (4)
DW_OP_piece  (4)
DW_OP_fbreg  (-12)
DW_OP_piece  (4)
         A twelve byte value whose orst four bytes reside in register zero, whose
          middle four bytes are unavailable (perhaps due to optimization), and
          whose last four bytes are in memory, 12 bytes before the frame base.
DW_OP_breg1  (0)
DW_OP_breg2  (0)
DW_OP_plus
DW_OP_stack_value
         Add the contents of r1 and r2 to compute a value. This value is the
          icontentsj of an otherwise anonymous location.
DW_OP_lit1
DW_OP_stack_value
DW_OP_piece  (4)
DW_OP_breg3  (0)
DW_OP_breg4  (0)
DW_OP_plus
DW_OP_stack_value
DW_OP_piece  (4)
         The object value is found in an anonymous (virtual) location whose value
          consists of two parts, given in memory address order: the 4 byte value 1
          followed by the four byte value computed from the sum of the contents of
          r3 and r4.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 305
                                       Appendix D.  Examples (Informative)
DW_OP_entry_value  (2,  DW_OP_breg1  0)
                                 !  The  first  operand  gives  the  number  of  bytes  in  the
                                 !  second  operand  (see  Section  2.5.1.7  on  page  37).
         The variable's address is the value that register 1 contained upon entering
          the current subprogram.
DW_OP_entry_value  (1,  DW_OP_reg1)
         Same as the previous example but uses the more compact register location
          description as an operand.
DW_OP_entry_value  (2,  DW_OP_breg1  0)
DW_OP_stack_value
         The variables's value is the value that register 1 contained upon entering the
          current subprogram. This value is the icontentsj of an otherwise
          anonymous location.
DW_OP_entry_value  (1,  DW_OP_reg1)
DW_OP_stack_value
         Same as the previous example, but uses the more compact register location
          description.
DW_OP_entry_value  (3,  DW_OP_breg4  16  DW_OP_deref)
DW_OP_stack_value
         Add 16 to the value register 4 had upon entering the current subprogram to
          form an address and then push the value of the memory location at that
          address. This value is the icontentsj of an otherwise anonymous location.
DW_OP_entry_value  (1,  DW_OP_reg5)
DW_OP_plus_uconst  (16)
         The address of the memory location is calculated by adding 16 to the value
          contained in register 5 upon entering the current subprogram.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 306
                                        Appendix D.  Examples (Informative)
 DW_OP_reg0
 DW_OP_bit_piece  (1,  31)
 DW_OP_bit_piece  (7,  0)
 DW_OP_reg1
 DW_OP_piece  (1)
          A variable whose orst bit resides in the 31st bit of register 0, whose next
           seven bits are undeoned and whose second byte resides in register 1.
 D.2            Aggregate  Examples
 The following examples illustrate how to represent some of the more
 complicated forms of array and record aggregates using DWARF.
 D.2.1           Fortran Simple Array Example
 Consider the Fortran array source fragment in Figure D.2 following.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||Ta*
 *YrPrEa y _ p t r
|||=============================================================================================================================================|||R:*
 *E:AmLy v a r
|||=============================================================================================================================================|||RE*
 *AL,D(I:M)E,NPSOIIONNT:E:Rap
|||=============================================================================================================================================|||ET*
 *NYDPaEr r a y _ p t r
|||=============================================================================================================================================|||T(*
 *YaPrEr)a,yA_LpLtOrC,ADTIAMBELNES(I:O)N::a r r a y v a r
|||=============================================================================================================================================|||A(*
 *LaLrOrCaAyTvEa(r2)0 )
|||=============================================================================================================================================|||DO*
 *I=12,0
|||=============================================================================================================================================|||A(*
 *LaLrOrCaAyTvEa(ri)%ap(i+)1 0 )
|||=============================================================================================================================================|||ED*
 *NOD_|_____|
                           Figure D.2: Fortran array example: source fragment
 For allocatable and pointer arrays, it is essentially required by theFortran array
 semantics that each array consist of two parts, which we here call 1) the
 descriptor and 2) the raw data. (A descriptor has often been called a dope vector
 in other contexts, although it is often a structure of some kind rather than a
 simple vector.) Because there are two parts, and because the lifetime of the
 descriptor is necessarily longer than and includes that of the raw data, there must
 be an address somewhere in the descriptor that points to the raw data when, in
 fact, there is some (that is, when the ivariablej is allocated or associated).
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 307
                                        Appendix D.  Examples (Informative)
 For concreteness, suppose that a descriptor looks something like the C structure
 in Figure D.3. Note, however, that it is a property of the design that 1) a debugger
 needs no builtin knowledge of this structure and 2) there does not need to be an
 explicit representation of this structure in the DWARF input to the debugger.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||sd*
 *tersucc{t
|||=============================================================================================================================================|||le*
 *oln_gl;e/n/Elleenmgetnht
|||=============================================================================================================================================|||v**
 *obiads;e//Aodfdrraewsdsa t a
|||=============================================================================================================================================|||ip*
 *nttr:_1a;s/s/oPcoiisnatsesrofcliaagt e d
|||=============================================================================================================================================|||ip*
 *nttr:_1a;l/l/oPcoiisnatlelrofclaatge d
|||=============================================================================================================================================|||in*
 *nutm:_6d;i/m/sNoufmdbiemre n s i o n s
|||=============================================================================================================================================|||sd*
 *tirmusc_ts{t/r/Feoarcdhi.m.e.n s i o n
|||=============================================================================================================================================|||ll*
 *oonwg_;b o u n d
|||=============================================================================================================================================|||lu*
 *opnpge;r _ b o u n d
|||=============================================================================================================================================|||ls*
 *otnrgi;d e
|||=============================================================================================================================================|||}d*
 *[i6m3s] ;
|||=============================================================================================================================================|||};*
 *_|_____|
                   Figure D.3: Fortran array example: descriptor representation
 In practice, of course, a irealj descriptor will have dimension substructures only
 for as many dimensions as are specioed in the num_dims component. Let us use
 the notation desc<n> to indicate a specialization of the desc struct in which n is
 the bound for the dims component as well as the contents of the num_dims
 component.
 Because the arrays considered here come in two parts, it is necessary to
 distinguish the parts carefully. In particular, the iaddress of the variablej or
 equivalently, the ibase address of the objectj always refers to the descriptor. For
 arrays that do not come in two parts, an implementation can provide a descriptor
 anyway, thereby giving it two parts. (This may be convenient for general runtime
 support unrelated to debugging.) In this case the above vocabulary applies as
 stated. Alternatively, an implementation can do without a descriptor, in which
 case the iaddress of the variable,j or equivalently the ibase address of the
 objectj, refers to the iraw dataj (the real data, the only thing around that can be
 the object).
 If an object has a descriptor, then the DWARF type for that object will have a
 DW.AT.data.location attribute. If an object does not have a descriptor, then
 usually the DWARF type for the object will not have a DW.AT.data.location
 attribute. (See the following Ada example for a case where the type for an object
 without a descriptor does have a DW.AT.data.location attribute. In that case
 the object doubles as its own descriptor.)
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 308
                                        Appendix D.  Examples (Informative)
 The Fortran derived type array_ptr can now be re-described in C-like terms that
 expose some of the representation as in
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||sa*
 *trrruacyt_{p t r
|||=============================================================================================================================================|||fm*
 *lyovaatr;
|||=============================================================================================================================================|||de*
 *sc<1a>p;
|||=============================================================================================================================================|||};*
 *_|_____|
 Similarly for variable arrayvar:
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||de*
 *sc<1a>r;r_a|y_v_a_r|
  Recall that desc<1> indicates the 1-dimensional version of desc.
 Finally, the following notation is useful:
 1.    sizeof(type): size in bytes of entities of the given type
 2.    ooeset(type, comp): ooeset in bytes of the comp component within an entity of
       the given type
 The DWARF description is shown in Figure D.4 on page 311.
 Suppose the program is stopped immediately following completion of the do
 loop. Suppose further that the user enters the following debug command:
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||de*
 *bug>parrirnaty(v5a)r%ap(_2|)____|
 Interpretation of this expression proceeds as follows:
 1.    Lookup name arrayvar. We ond that it is a variable, whose type is given by
       the unnamed type at 6$. Notice that the type is an array type.
 2.    Find the 5th  element of that array object. To do array indexing requires
       several pieces of information:
       a)     the address of the array data
       b)     the lower bounds of the array
              [To check that 5 is within bounds would require the upper bound too, but
              we will skip that for this example. ]
        c)    the stride
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 309
                                       Appendix D.  Examples (Informative)
      For a), check for a DW.AT.data.location attribute. Since there is one, go
      execute the expression, whose result is the address needed. The object
      address used in this case is the object we are working on, namely the variable
      named arrayvar, whose address was found in step 1. (Had there been no
      DW.AT.data.location attribute, the desired address would be the same as
      the address from step 1.)
      For b), for each dimension of the array (only one in this case), go interpret the
      usual lower bound attribute. Again this is an expression, which again begins
      with DW.OP.push.object.address. This object is still arrayvar, from step 1,
      because we have not begun to actually perform any indexing yet.
      For c), the default stride applies. Since there is no DW.AT.byte.stride
      attribute, use the size of the array element type, which is the size of type
      array_ptr (at 3$).
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 310
                                       Appendix D.  Examples (Informative)
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
____________________________________________________________________________________________________________________________________part_1_of_2___||
|!| Description  for  type  of  'ap'                                                                                                               ||
|!|                                                                                                                                                ||
|1$:  DW_TAG_array_type                                                                                                                            |
||             !  No  name,  default  (Fortran)  ordering,  default  stride                                                                        ||
|              DW_AT_type(reference  to  REAL)                                                                                                     |
||             DW_AT_associated(expression=       !  Test  'ptr_assoc'  flag                                                                       ||
||                    DW_OP_push_object_address                                                                                                    ||
|                     DW_OP_lit<n>                            !  where  n  ==  offset(ptr_assoc)                                                   |
||                    DW_OP_plus                                                                                                                   ||
|                     DW_OP_deref                                                                                                                  |
||                    DW_OP_lit1                               !  mask  for  'ptr_assoc'  flag                                                     ||
||                    DW_OP_and)                                                                                                                   ||
|              DW_AT_data_location(expression=  !  Get  raw  data  address                                                                         |
||                    DW_OP_push_object_address                                                                                                    ||
|                     DW_OP_lit<n>                            !  where  n  ==  offset(base)                                                        |
||                    DW_OP_plus                                                                                                                   ||
|                     DW_OP_deref)                            !  Type  of  index  of  array  'ap'                                                  |
|2$:|        DW_TAG_subrange_type                                                                                                                  ||
||                    !  No  name,  default  stride                                                                                                ||
|                     DW_AT_type(reference  to  INTEGER)                                                                                           |
||                    DW_AT_lower_bound(expression=                                                                                                ||
|                            DW_OP_push_object_address                                                                                             |
||                           DW_OP_lit<n>                       !  where  n  ==                                                                    ||
||                                                                      !     offset(desc,  dims)  +                                               ||
|                                                                       !     offset(dims_str,  lower_bound)                                       |
||                           DW_OP_plus                                                                                                            ||
|                            DW_OP_deref)                                                                                                          |
||                    DW_AT_upper_bound(expression=                                                                                                ||
||                           DW_OP_push_object_address                                                                                             ||
|                            DW_OP_lit<n>                     !  where  n  ==                                                                      |
||                                                                     !     offset(desc,  dims)  +                                                ||
|                                                                      !     offset(dims_str,  upper_bound)                                        |
||                           DW_OP_plus                                                                                                            ||
|                            DW_OP_deref)                                                                                                          |
||                    !    Note:  for  the  m'th  dimension,  the  second  operator  becomes                                                       ||
||                    !    DW_OP_lit<n>  where                                                                                                     ||
|                     !            n  ==  offset(desc,  dims)                  +                                                                   |
||                    !                            (m-1)*sizeof(dims_str)    +                                                                     ||
|                     !                              offset(dims_str,  [lower|upper]_bound)                                                        |
||                    !    That  is,  the  expression  does  not  get  longer  for  each  successive                                               ||
||____________________!____dimension__(other__than__to__express__the__larger__offsets__involved)._________________________________________________ ||
                       Figure D.4: Fortran array example: DWARF description
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 311
|                                      Appendix D.  Examples (Informative)                                                                         |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
____________________________________________________________________________________________________________________________________part_2_of_2___||||
|3$:  DW_TAG_structure_type                                                                                                                        |
||             DW_AT_name("array_ptr")                                                                                                             ||
|              DW_AT_byte_size(constant  sizeof(REAL)  +  sizeof(desc<1>))                                                                         |
|4$:|        DW_TAG_member                                                                                                                         ||
||                    DW_AT_name("myvar")                                                                                                          ||
|                     DW_AT_type(reference  to  REAL)                                                                                              |
||                    DW_AT_data_member_location(constant  0)                                                                                      ||
|5$:         DW_TAG_member                                                                                                                         |
||                    DW_AT_name("ap");                                                                                                            ||
||                    DW_AT_type(reference  to  1$)                                                                                                ||
|                     DW_AT_data_member_location(constant  sizeof(REAL))                                                                           |
|6$:| DW_TAG_array_type                                                                                                                            ||
|              !  No  name,  default  (Fortran)  ordering,  default  stride                                                                        |
||             DW_AT_type(reference  to  3$)                                                                                                       ||
||             DW_AT_allocated(expression=            !  Test  'ptr_alloc'  flag                                                                   ||
|                     DW_OP_push_object_address                                                                                                    |
||                    DW_OP_lit<n>                               !  where  n  ==  offset(ptr_alloc)                                                ||
|                     DW_OP_plus                                                                                                                   |
||                    DW_OP_deref                                                                                                                  ||
|                     DW_OP_lit2                                   !  Mask  for  'ptr_alloc'  flag                                                 |
||                    DW_OP_and)                                                                                                                   ||
||             DW_AT_data_location(expression=     !  Get  raw  data  address                                                                      ||
|                     DW_OP_push_object_address                                                                                                    |
||                    DW_OP_lit<n>                               !  where  n  ==  offset(base)                                                     ||
|                     DW_OP_plus                                                                                                                   |
||                    DW_OP_deref)                                                                                                                 ||
|7$:|        DW_TAG_subrange_type                                                                                                                  ||
|                     !  No  name,  default  stride                                                                                                |
||                    DW_AT_type(reference  to  INTEGER)                                                                                           ||
|                     DW_AT_lower_bound(expression=                                                                                                |
||                           DW_OP_push_object_address                                                                                             ||
||                           DW_OP_lit<n>                         !  where  n  ==  ...                                                             ||
|                            DW_OP_plus                                                                                                            |
||                           DW_OP_deref)                                                                                                          ||
|                     DW_AT_upper_bound(expression=                                                                                                |
||                           DW_OP_push_object_address                                                                                             ||
|                            DW_OP_lit<n>                         !  where  n  ==  ...                                                             |
||                           DW_OP_plus                                                                                                            ||
||                           DW_OP_deref)                                                                                                          ||
|8$:  DW_TAG_variable                                                                                                                              |
||             DW_AT_name("arrayvar")                                                                                                              ||
|              DW_AT_type(reference  to  6$)                                                                                                       |
||             DW_AT_location(expression=                                                                                                          ||
||____________________...as__appropriate...)____________!__Assume__static__allocation_____________________________________________________________ ||
             Figure D.4: Fortran array example: DWARF description (concluded)
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 312
                                       Appendix D.  Examples (Informative)
      Having acquired all the necessary data, perform the indexing operation in the
      usual manner~which has nothing to do with any of the attributes involved up
      to now. Those just provide the actual values used in the indexing step.
      The result is an object within the memory that was dynamically allocated for
      arrayvar.
3.    Find the ap component of the object just identioed, whose type is array_ptr.
      This is a conventional record component lookup and interpretation. It
      happens that the ap component in this case begins at ooeset 4 from the
      beginning of the containing object. Component ap has the unnamed array
      type deoned at 1$ in the symbol table.
4.    Find the second element of the array object found in step 3. To do array
      indexing requires several pieces of information:
      a)     the address of the array storage
      b)     the lower bounds of the array
             [To check that 2 is within bounds we would require the upper bound too,
             but we will skip that for this example ]
       c)    the stride
This is just like step 2), so the details are omitted. Recall that because the DWARF
type 1$ has a DW.AT.data.location, the address that results from step 4) is that
of a descriptor, and that address is the address pushed by the
DW.OP.push.object.address operations in 1$ and 2$.
Note: we happen to be accessing a pointer array here instead of an allocatable
array; but because there is a common underlying representation, the mechanics
are the same. There could be completely dioeerent descriptor arrangements and
the mechanics would still be the same~only the stack machines would be
dioeerent.
D.2.2           Fortran Coarray Examples
D.2.2.1         Fortran Scalar Coarray Example
The Fortran scalar coarray example  in Figure D.5 on the following page can be
described as illustrated in Figure D.6 on the next page.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 313
                                        Appendix D.  Examples (Informative)
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||Ix*
 *N[T*E]G_E|R____|
                           Figure D.5: Fortran scalar coarray: source fragment
 __________________________________________________________________________________________________________________________________________________||
 |10$:    DW_TAG_coarray_type                                                                                                                       |
 ||                 DW_AT_type(reference  to  INTEGER)                                                                                              ||
 ||                 DW_TAG_subrange_type                            !  Note  omitted  upper  bound                                                  ||
 |                  DW_AT_lower_bound(constant  1)            !  Can  be  omitted  (default  is  1)                                                 |
 |                                                                                                                                                  |
 |                                                                                                                                                  |
 |11$:    DW_TAG_variable                                                                                                                           |
 ||                 DW_AT_name("x")                                                                                                                 ||
 ||_________________DW_AT_type(reference__to__coarray__type__at__10$)______________________________________________________________________________ ||
                        Figure D.6: Fortran scalar coarray: DWARF description
 D.2.2.2         Fortran Array Coarray Example
 The Fortran (simple) array coarray example  in Figure D.7 can be described as
 illustrated in Figure D.8.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||Ix*
 *N(T1E0G)E[R*_]|_____|
                            Figure D.7: Fortran array coarray: source fragment
 __________________________________________________________________________________________________________________________________________________||
 |10$:|   DW_TAG_array_type                                                                                                                         ||
 ||                 DW_AT_ordering(DW_ORD_col_major)                                                                                                ||
 |                  DW_AT_type(reference  to  INTEGER)                                                                                              |
 |11$:|          DW_TAG_subrange_type                                                                                                               ||
 |                     !  DW_AT_lower_bound(constant  1)      !  Omitted  (default  is  1)                                                          |
 ||                        DW_AT_upper_bound(constant  10)                                                                                          ||
 |                                                                                                                                                  |
 |12$:|   DW_TAG_coarray_type                                                                                                                       ||
 ||                 DW_AT_type(reference  to  array  type  at  10$)                                                                                 ||
 |13$:           DW_TAG_subrange_type                            !  Note  omitted  upper  &  lower  bounds                                          |
 |                                                                                                                                                  |
 |                                                                                                                                                  |
 |14$:    DW_TAG_variable                                                                                                                           |
 ||                 DW_AT_name("x")                                                                                                                 ||
 ||_________________DW_AT_type(reference__to__coarray__type__at__12$)______________________________________________________________________________ ||
                        Figure D.8: Fortran array coarray: DWARF description
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 314
                                        Appendix D.  Examples (Informative)
 D.2.2.3         Fortran Multidimensional Coarray Example
 The Fortran multidimensional coarray of a multidimensional array example  in
 Figure D.9 can be described as illustrated in Figure D.10 following.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||Ix*
 *N(T1E0G,E1R1[,21,23),*]_|_____|
                 Figure D.9: Fortran multidimensional coarray: source fragment
 |                                                                                                                                                  |
 |                                                                                                                                                  |
 __________________________________________________________________________________________________________________________________________________||*
 *||
 |10$:|   DW_TAG_array_type                            !  Note  omitted  lower  bounds  (default  to  1)                                            ||
 |                  DW_AT_ordering(DW_ORD_col_major)                                                                                                |
 ||                 DW_AT_type(reference  to  INTEGER)                                                                                              ||
 |11$:           DW_TAG_subrange_type                                                                                                               |
 ||                        DW_AT_upper_bound(constant  10)                                                                                          ||
 |12$:           DW_TAG_subrange_type                                                                                                               |
 ||                        DW_AT_upper_bound(constant  11)                                                                                          ||
 |13$:|          DW_TAG_subrange_type                                                                                                               ||
 |                         DW_AT_upper_bound(constant  12)                                                                                          |
 |                                                                                                                                                  |
 |                                                                                                                                                  |
 |14$:    DW_TAG_coarray_type                         !  Note  omitted  lower  bounds  (default  to  1)                                             |
 ||                 DW_AT_type(reference  to  array_type  at  10$)                                                                                  ||
 |15$:|          DW_TAG_subrange_type                                                                                                               ||
 |                         DW_AT_upper_bound(constant  2)                                                                                           |
 |16$:|          DW_TAG_subrange_type                                                                                                               ||
 |                         DW_AT_upper_bound(constant  3)                                                                                           |
 |17$:|          DW_TAG_subrange_type                !  Note  omitted  upper  (&  lower)  bound                                                     ||
 |                                                                                                                                                  |
 |18$:|   DW_TAG_variable                                                                                                                           ||
 ||                 DW_AT_name("x")                                                                                                                 ||
 |                  DW_AT_type(reference  to  coarray  type  at  14$)                                                                               |
 |                                                                                                                                                  |
 |_________________________________________________________________________________________________________________________________________________ |
            Figure D.10: Fortran multidimensional coarray: DWARF description
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 315
                                        Appendix D.  Examples (Informative)
 D.2.3           Fortran 2008 Assumed-rank Array Example
 Consider the example in Figure D.11, which shows an assumed-rank array in
 Fortran 2008 with supplement 29113:1
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||SF*
 *UoBoR(OxU)T I N E
|||=============================================================================================================================================|||R:*
 *E:AxL( . . )
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||!x*
 *hnadsi m e n s i o n s
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||ES*
 *NUDB_R|O_U_T_I|N E
                  Figure D.11: Declaration of a Fortran 2008 assumed-rank array
 Let's assume the Fortran compiler used an array descriptor that (in C) looks like
 the one shown in Figure D.12.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||sa*
 *trrruacyt_{d e s c r i p t o r
|||=============================================================================================================================================|||v**
 *obiads;e _ a d d r
|||=============================================================================================================================================|||ir*
 *natn;k
|||=============================================================================================================================================|||sd*
 *tirmudcitm[s] ;
|||=============================================================================================================================================|||}
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||sd*
 *tirmu{c t
|||=============================================================================================================================================|||il*
 *notw;e r _ b o u n d
|||=============================================================================================================================================|||iu*
 *nptp;e r _ b o u n d
|||=============================================================================================================================================|||is*
 *nttr;i d e
|||=============================================================================================================================================|||if*
 *nlta;g s
|||=============================================================================================================================================|||}_*
 *|_____|
               Figure D.12: One of many possible layouts for an array descriptor
 The DWARF type for the array x can be described as shown in Figure D.13 on the
 next page.
 The layout of the array descriptor is not specioed by the Fortran standard unless
 the array is explicitly marked as C-interoperable. To get the bounds of an
 assumed-rank array, the expressions in the DW.TAG.generic.subrange entry
 need to be evaluated for each of the DW.AT.rank dimensions as shown by the
 pseudocode in Figure D.14 on page 318.
 _________________________________________________________
       1Technical Speciocation ISO/IEC TS 29113:2012 Further Interoperability of Fortran with C
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 316
                                       Appendix D.  Examples (Informative)
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
__________________________________________________________________________________________________________________________________________________||||
|10$:    DW_TAG_array_type                                                                                                                         |
||                 DW_AT_type(reference  to  real)                                                                                                 ||
|                  DW_AT_rank(expression=                                                                                                          |
||                        DW_OP_push_object_address                                                                                                ||
|                         DW_OP_lit<n>                                          !  offset  of  rank  in  descriptor                                |
||                        DW_OP_plus                                                                                                               ||
||                        DW_OP_deref)                                                                                                             ||
|                  DW_AT_data_location(expression=                                                                                                 |
||                        DW_OP_push_object_address                                                                                                ||
|                         DW_OP_lit<n>                                          !  offset  of  data  in  descriptor                                |
||                        DW_OP_plus                                                                                                               ||
||                        DW_OP_deref)                                                                                                             ||
|11$:         DW_TAG_generic_subrange                                                                                                              |
||                        DW_AT_type(reference  to  integer)                                                                                       ||
|                         DW_AT_lower_bound(expression=                                                                                            |
||                        !     Looks  up  the  lower  bound  of  dimension  i.                                                                    ||
|                         !     Operation                                        !  Stack  effect                                                  |
||                        !     (implicit)                                      !  i                                                               ||
||                              DW_OP_lit<n>                                   !  i  sizeof(dim)                                                   ||
|                               DW_OP_mul                                        !  dim[i]                                                         |
||                              DW_OP_lit<n>                                   !  dim[i]  offsetof(dim)                                            ||
|                               DW_OP_plus                                      !  dim[i]+offset                                                   |
||                              DW_OP_push_object_address            !  dim[i]+offsetof(dim)  objptr                                               ||
||                              DW_OP_plus                                      !  objptr.dim[i]                                                   ||
|                               DW_OP_lit<n>                                   !  objptr.dim[i]  offsetof(lb)                                      |
||                              DW_OP_plus                                      !  objptr.dim[i].lowerbound                                        ||
|                               DW_OP_deref)                                   !  *objptr.dim[i].lowerbound                                        |
||                        DW_AT_upper_bound(expression=                                                                                            ||
||                        !     Looks  up  the  upper  bound  of  dimension  i.                                                                    ||
|                               DW_OP_lit<n>                                   !  sizeof(dim)                                                      |
||                              DW_OP_mul                                                                                                          ||
|                               DW_OP_lit<n>                                   !  offsetof(dim)                                                    |
||                              DW_OP_plus                                                                                                         ||
|                               DW_OP_push_object_address                                                                                          |
||                              DW_OP_plus                                                                                                         ||
||                              DW_OP_lit<n>                                   !  offset  of  upperbound  in  dim                                  ||
|                               DW_OP_plus                                                                                                         |
||                              DW_OP_deref)                                                                                                       ||
|                         DW_AT_byte_stride(expression=                                                                                            |
||                        !     Looks  up  the  byte  stride  of  dimension  i.                                                                    ||
||                              ...                                                                                                                ||
|                         !     (analogous  to  DW_AT_upper_bound)                                                                                 |
||______________________________)_________________________________________________________________________________________________________________ ||
            Figure D.13: Sample DWARF for the array descriptor in Figure D.12
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 317
                                        Appendix D.  Examples (Informative)
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||ts*
 *ytpreudcetf{
|||=============================================================================================================================================|||il*
 *notwer,upper,s;t r i d e
|||=============================================================================================================================================|||}d*
 *;i m s _ t
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||ts*
 *ytpreudcetf{
|||=============================================================================================================================================|||ir*
 *natn;k
|||=============================================================================================================================================|||sd*
 *tirmusc_tt*d;i m s
|||=============================================================================================================================================|||}a*
 *;r r a y _ t
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||ag*
 *rerta_yd_ytn(aDmWi_cT_AaGr_raaryr_adyiam)s{
|||=============================================================================================================================================|||ar*
 *rersauyl_tt;
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||//*
 *EtvhaelDuWa_tAeTe_xrparnekstsoigoentt h e
|||=============================================================================================================================================|||//*
 *noufmdbiemre.n s i o n s
|||=============================================================================================================================================|||ds*
 *wtaarcfk_;s t a c k _ t
|||=============================================================================================================================================|||d(*
 *wsatrafc_ke,vaa.lr)a;n k _ e x p r
|||=============================================================================================================================================|||r.*
 *ersaunlkt=d(wsatrafc_kp)o;p
|||=============================================================================================================================================|||r.*
 *edsiumlst=ndeiwm[sr_atn]k;
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||//*
 *Iotveerraatleldainmdefnisnidotnhsebioru.n d s
|||=============================================================================================================================================|||f(*
 *oirnit=0;i<r.ersaunlkt;i+{+ )
|||=============================================================================================================================================|||//*
 *Etvhaelgueanteersiucb'rsaDnWg_eA T _ l o w e r
|||=============================================================================================================================================|||//*
 *efxoprrdeismseinosniio.n
|||=============================================================================================================================================|||d(*
 *wsatrafc_kp,uis)h;
|||=============================================================================================================================================|||a(*
 *ssstearctk.s=i=z1e);
|||=============================================================================================================================================|||d(*
 *wsatrafc_ke,vaa.lg.elnoewreirc__esxupbrr)a;n g e
|||=============================================================================================================================================|||r.*
 *edsiumlst[i].l=odwwearr(fs_tpaocpk);
|||=============================================================================================================================================|||a(*
 *ssstearctk.s=i=z0e);
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||d(*
 *wsatrafc_kp,uis)h;
|||=============================================================================================================================================|||d(*
 *wsatrafc_ke,vaa.lg.eunpepreirc__esxupbrr)a;n g e
|||=============================================================================================================================================|||r.*
 *edsiumlst[i].u=pdpwearr(fs_tpaocpk);
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||d(*
 *wsatrafc_kp,uis)h;
|||=============================================================================================================================================|||d(*
 *wsatrafc_ke,vaa.lg.ebnyetrei_cs_tsruibdrea_negxep)r;
|||=============================================================================================================================================|||r.*
 *edsiumlst[i].s=tdrwiadref(_sptoapc)k;
|||=============================================================================================================================================|||}
|||=============================================================================================================================================|||rr*
 *eetsuurlnt;
|||=============================================================================================================================================|||}_*
 *|_____|
                    Figure D.14: How to interpret the DWARF from Figure D.13
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 318
                                        Appendix D.  Examples (Informative)
 D.2.4           Fortran Dynamic Type Example
 Consider the Fortran 90 example of dynamic properties in Figure D.15. This can
 be represented in DWARF as illustrated in Figure D.16 on the following page.
 Note that unnamed dynamic types are used to avoid replicating the full
 description of the underlying type dt that is shared by several variables.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||PS*
 *RaOmGpRlAeM
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||T:*
 *Y:PdEt(l)
|||=============================================================================================================================================|||I,*
 *NLTEENG:E:Rl
|||=============================================================================================================================================|||I:*
 *N:TaErGrE(Rl)
|||=============================================================================================================================================|||ET*
 *NYDP E
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||I:*
 *N:TnE=G4E R
|||=============================================================================================================================================|||C *
 *O N T A I N S
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||SS*
 *U(B)R O U T I N E
|||=============================================================================================================================================|||T(*
 *YdPtE(n))::t1
|||=============================================================================================================================================|||T(*
 *YdPtE(n)),p:o:itn2t e r
|||=============================================================================================================================================|||T(*
 *YdPtE(n)),a:l:lto3c,att4a b l e
|||=============================================================================================================================================|||ES*
 *NUDB R O U T I N E
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||ES*
 *NaDm_p|l_e___|
                           Figure D.15: Fortran dynamic type example: source
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 319
                                       Appendix D.  Examples (Informative)
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
__________________________________________________________________________________________________________________________________________________||||
|11$:       DW_TAG_structure_type                                                                                                                  |
||                    DW_AT_name("dt")                                                                                                             ||
|                     DW_TAG_member                                                                                                                |
||                           ...                                                                                                                   ||
|...                                                                                                                                               |
|                                                                                                                                                  |
|                                                                                                                                                  |
|13$:|      DW_TAG_dynamic_type                       !  plain  version                                                                            ||
|                     DW_AT_data_location  (dwarf  expression  to  locate  raw  data)                                                              |
||                    DW_AT_type  (11$)                                                                                                            ||
|                                                                                                                                                  |
|14$:|      DW_TAG_dynamic_type                       !  'pointer'  version                                                                        ||
|                     DW_AT_data_location  (dwarf  expression  to  locate  raw  data)                                                              |
||                    DW_AT_associated  (dwarf  expression  to  test  if  associated)                                                              ||
||                    DW_AT_type  (11$)                                                                                                            ||
|                                                                                                                                                  |
|15$:|      DW_TAG_dynamic_type                       !  'allocatable'  version                                                                    ||
|                     DW_AT_data_location  (dwarf  expression  to  locate  raw  data)                                                              |
||                    DW_AT_allocated  (dwarf  expression  to  test  is  allocated)                                                                ||
||                    DW_AT_type  (11$)                                                                                                            ||
|                                                                                                                                                  |
|16$:|      DW_TAG_variable                                                                                                                        ||
|                     DW_AT_name  ("t1")                                                                                                           |
||                    DW_AT_type  (13$)                                                                                                            ||
||                    DW_AT_location  (dwarf  expression  to  locate  descriptor)                                                                  ||
|17$:       DW_TAG_variable                                                                                                                        |
||                    DW_AT_name  ("t2")                                                                                                           ||
|                     DW_AT_type  (14$)                                                                                                            |
||                    DW_AT_location  (dwarf  expression  to  locate  descriptor)                                                                  ||
|18$:       DW_TAG_variable                                                                                                                        |
||                    DW_AT_name  ("t3")                                                                                                           ||
||                    DW_AT_type  (15$)                                                                                                            ||
|                     DW_AT_location  (dwarf  expression  to  locate  descriptor)                                                                  |
|19$:|      DW_TAG_variable                                                                                                                        ||
|                     DW_AT_name  ("t4")                                                                                                           |
||                    DW_AT_type  (15$)                                                                                                            ||
||____________________DW_AT_location__(dwarf__expression__to__locate__descriptor)_________________________________________________________________ ||
              Figure D.16: Fortran dynamic type example: DWARF description
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 320
                                        Appendix D.  Examples (Informative)
 D.2.5           C/C++ Anonymous Structure Example
 An example of a C/C++ structure is shown in Figure D.17. For this source, the
 DWARF description in Figure D.18 is appropriate. In this example, b is
 referenced as if it were deoned in the enclosing structure foo.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||sf*
 *torou{c t
|||=============================================================================================================================================|||ia*
 *n;t
|||=============================================================================================================================================|||s{*
 *t r u c t
|||=============================================================================================================================================|||ib*
 *n;t
|||=============================================================================================================================================|||};
|||=============================================================================================================================================|||}x;
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||vb*
 *oaird(v)o i d
|||=============================================================================================================================================|||{
|||=============================================================================================================================================|||sf*
 *toroutc;t
|||=============================================================================================================================================|||t.*
 *a=1;
|||=============================================================================================================================================|||t.*
 *b=2;
|||=============================================================================================================================================|||}_*
 *|_____|
                  Figure D.17: Anonymous structure example: source fragment
 __________________________________________________________________________________________________________________________________________________||
 |1$:|    DW_TAG_structure_type                                                                                                                     ||
 |                  DW_AT_name("foo")                                                                                                               |
 |2$:|           DW_TAG_member                                                                                                                      ||
 |                         DW_AT_name("a")                                                                                                          |
 |3$:|           DW_TAG_structure_type                                                                                                              ||
 ||                        DW_AT_export_symbols                                                                                                     ||
 |4$:                   DW_TAG_member                                                                                                               |
 ||______________________________DW_AT_name("b")___________________________________________________________________________________________________ ||
               Figure D.18: Anonymous structure example: DWARF description
 D.2.6           Ada Example
 Figure D.19 on the next page illustrates two kinds of Ada parameterized array,
 one embedded in a record.
 VEC1 illustrates an (unnamed) array type where the upper bound of the orst and
 only dimension is determined at runtime. Ada semantics require that the value
 of an array bound is oxed at the time the array type is elaborated (where
 elaboration refers to the runtime executable aspects of type processing). For the
 purposes of this example, we assume that there are no other assignments to M so
 that it safe for the REC1 type description to refer directly to that variable (rather
 than a compiler-generated copy).
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 321
                                        Appendix D.  Examples (Informative)
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||M:*
 *I:N=T<EeGxEpR>;
|||=============================================================================================================================================|||V:*
 *EaCr1r(a1y.M.)ofI;N T E G E R
|||=============================================================================================================================================|||sT*
 *uEbEtNyYpiesIrNaTnEgGeE1R. . 1 0 0 ;
|||=============================================================================================================================================|||tA*
 *yRpReisa(rIrNaTyErGaEnRg<e>)ofI;N T E G E R
|||=============================================================================================================================================|||tR*
 *yEpCe2(N:T:E=E1N0Y0i)sr e c o r d
|||=============================================================================================================================================|||V:*
 *EACR2R(N1).;.
|||=============================================================================================================================================|||er*
 *nedc;o r d
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||O:*
 *BRJE2CB2;_|_____|
                                  Figure D.19: Ada example: source fragment
 REC2 illustrates another array type (the unnamed type of component VEC2) where
 the upper bound of the orst and only bound is also determined at runtime. In
 this case, the upper bound is contained in a discriminant of the containing record
 type. (A discriminant is a component of a record whose value cannot be changed
 independently of the rest of the record because that value is potentially used in
 the speciocation of other components of the record.)
 The DWARF description is shown in Figure D.20 on the following page.
 Interesting aspects about this example are:
 1.    The array VEC2 is iimmediatelyj contained within structure REC2 (there is no
       intermediate descriptor or indirection), which is reAEected in the absence of a
       DW.AT.data.location attribute on the array type at 28$.
 2.    One of the bounds of VEC2 is nonetheless dynamic and part of the same
       containing record. It is described as a reference to a member, and the location
       of the upper bound is determined as for any member. That is, the location is
       determined using an address calculation relative to the base of the containing
       object.
       A consumer must notice that the referenced bound is a member of the same
       containing object and implicitly push the base address of the containing
       object just as for accessing a data member generally.
 3.    The lack of a subtype concept in DWARF means that DWARF types serve the
       role of subtypes and must replicate information from the parent type. For this
       reason, DWARF for the unconstrained array type ARR is not needed for the
       purposes of this example and therefore is not shown.
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 322
|                                                                                                                                                  |
||                                     Appendix D.  Examples (Informative)                                                                         ||
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
__________________________________________________________________________________________________________________________________________________||
|11$:|   DW_TAG_variable                                                                                                                           ||
|                  DW_AT_name("M")                                                                                                                 |
||                 DW_AT_type(reference  to  INTEGER)                                                                                              ||
|12$:    DW_TAG_array_type                                                                                                                         |
||                 !  No  name,  default  (Ada)  order,  default  stride                                                                           ||
||                 DW_AT_type(reference  to  INTEGER)                                                                                              ||
|13$:           DW_TAG_subrange_type                                                                                                               |
||                        DW_AT_type(reference  to  INTEGER)                                                                                       ||
|                         DW_AT_lower_bound(constant  1)                                                                                           |
||                        DW_AT_upper_bound(reference  to  variable  M  at  11$)                                                                   ||
|14$:|   DW_TAG_variable                                                                                                                           ||
|                  DW_AT_name("VEC1")                                                                                                              |
||                 DW_AT_type(reference  to  array  type  at  12$)                                                                                 ||
|           .  .  .                                                                                                                                |
|21$:|   DW_TAG_subrange_type                                                                                                                      ||
||                 DW_AT_name("TEENY")                                                                                                             ||
|                  DW_AT_type(reference  to  INTEGER)                                                                                              |
||                 DW_AT_lower_bound(constant  1)                                                                                                  ||
|                  DW_AT_upper_bound(constant  100)                                                                                                |
||          .  .  .                                                                                                                                ||
|26$:    DW_TAG_structure_type                                                                                                                     |
||                 DW_AT_name("REC2")                                                                                                              ||
|27$:|          DW_TAG_member                                                                                                                      ||
|                         DW_AT_name("N")                                                                                                          |
||                        DW_AT_type(reference  to  subtype  TEENY  at  21$)                                                                       ||
|                         DW_AT_data_member_location(constant  0)                                                                                  |
|28$:|          DW_TAG_array_type                                                                                                                  ||
||                        !  No  name,  default  (Ada)  order,  default  stride                                                                    ||
|                         !  Default  data  location                                                                                               |
||                        DW_AT_type(reference  to  INTEGER)                                                                                       ||
|29$:                  DW_TAG_subrange_type                                                                                                        |
||                              DW_AT_type(reference  to  subrange  TEENY  at  21$)                                                                ||
||                              DW_AT_lower_bound(constant  1)                                                                                     ||
|                               DW_AT_upper_bound(reference  to  member  N  at  27$)                                                               |
|30$:|          DW_TAG_member                                                                                                                      ||
|                         DW_AT_name("VEC2")                                                                                                       |
||                        DW_AT_type(reference  to  array  "subtype"  at  28$)                                                                     ||
|                         DW_AT_data_member_location(machine=                                                                                      |
||                              DW_OP_lit<n>                            !  where  n  ==  offset(REC2,  VEC2)                                       ||
||                              DW_OP_plus)                                                                                                        ||
|           .  .  .                                                                                                                                |
|41$:|   DW_TAG_variable                                                                                                                           ||
|                  DW_AT_name("OBJ2B")                                                                                                             |
||                 DW_AT_type(reference  to  REC2  at  26$)                                                                                        ||
||_________________DW_AT_location(...as__appropriate...)__________________________________________________________________________________________ ||
                              Figure D.20: Ada example: DWARF description
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 323
                                        Appendix D.  Examples (Informative)
 D.2.7           Pascal Example
 The Pascal source in Figure D.21 following is used to illustrate the representation
 of packed unaligned bit oelds.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||TT*
 *Y:PPEARCEKCEODR{Dbsiitzies2}
|||=============================================================================================================================================|||F5*
 *:B;O{ObLiEtAoNfifss0e}t
|||=============================================================================================================================================|||F6*
 *:B;O{ObLiEtAoNfifss1e}t
|||=============================================================================================================================================|||E;*
 *N D
|||=============================================================================================================================================|||VV*
 *A:RPRAECCKOERDD
|||=============================================================================================================================================|||F1*
 *:B;O{ObLiEtAoNfifss0e}t
|||=============================================================================================================================================|||F2*
 *:PRAECCKOERDD{boiftfisse1t}
|||=============================================================================================================================================|||F3*
 *:I;N{TbEiGtEoRfifss0eitnF2,
|||=============================================================================================================================================|||1i*
 *nV}
|||=============================================================================================================================================|||E;*
 *N D
|||=============================================================================================================================================|||F4*
 *:PAARCRKAEYD[O0F.T.;1{]boiftfisse3t3}
|||=============================================================================================================================================|||F7*
 *:T;{boiftfisse3t7}
|||=============================================================================================================================================|||E;*
 *N_D|_____|
                         Figure D.21: Packed record example: source fragment
 The DWARF representation in Figure D.22 is appropriate.
 DW.TAG.packed.type entries could be added to better represent the source, but
 these do not otherwise aoeect the example and are omitted for clarity. Note that
 this same representation applies to both typical big- and little-endian
 architectures using the conventions described in Section 5.7.6 on page 122.
 ____________________________________________________________________________________________________________________________________part_1_of_2___||
 |10$:|   DW_TAG_base_type                                                                                                                          ||
 ||                 DW_AT_name("BOOLEAN")                                                                                                           ||
 |                         ...                                                                                                                      |
 |11$:|   DW_TAG_base_type                                                                                                                          ||
 |                  DW_AT_name("INTEGER")                                                                                                           |
 ||                        ...                                                                                                                      ||
 |20$:|   DW_TAG_structure_type                                                                                                                     ||
 |                  DW_AT_name("T")                                                                                                                 |
 ||                 DW_AT_bit_size(2)                                                                                                               ||
 |                  DW_TAG_member                                                                                                                   |
 ||                        DW_AT_name("F5")                                                                                                         ||
 ||                        DW_AT_type(reference  to  10$)                                                                                           ||
 |                         DW_AT_data_bit_offset(0)              !  may  be  omitted                                                                |
 ||________________________DW_AT_bit_size(1)_______________________________________________________________________________________________________ ||
                      Figure D.22: Packed record example: DWARF description
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 324
                                       Appendix D.  Examples (Informative)
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
____________________________________________________________________________________________________________________________________part_2_of_2___||||
||                 DW_TAG_member                                                                                                                   ||
|                         DW_AT_name("F6")                                                                                                         |
||                        DW_AT_type(reference  to  10$)                                                                                           ||
|                         DW_AT_data_bit_offset(1)                                                                                                 |
||                        DW_AT_bit_size(1)                                                                                                        ||
|21$:    DW_TAG_structure_type                               !  anonymous  type  for  F2                                                           |
||                 DW_TAG_member                                                                                                                   ||
||                        DW_AT_name("F3")                                                                                                         ||
|                         DW_AT_type(reference  to  11$)                                                                                           |
|22$:|   DW_TAG_array_type                                      !  anonymous  type  for  F4                                                        ||
|                  DW_AT_type(reference  to  20$)                                                                                                  |
||                 DW_TAG_subrange_type                                                                                                            ||
||                        DW_AT_type(reference  to  11$)                                                                                           ||
|                         DW_AT_lower_bound(0)                                                                                                     |
||                        DW_AT_upper_bound(1)                                                                                                     ||
|                  DW_AT_bit_stride(2)                                                                                                             |
||                 DW_AT_bit_size(4)                                                                                                               ||
|23$:|   DW_TAG_structure_type                               !  anonymous  type  for  V                                                            ||
|                  DW_AT_bit_size(39)                                                                                                              |
||                 DW_TAG_member                                                                                                                   ||
|                         DW_AT_name("F1")                                                                                                         |
||                        DW_AT_type(reference  to  10$)                                                                                           ||
||                        DW_AT_data_bit_offset(0)              !  may  be  omitted                                                                ||
|                         DW_AT_bit_size(1)  !  may  be  omitted                                                                                   |
||                 DW_TAG_member                                                                                                                   ||
|                         DW_AT_name("F2")                                                                                                         |
||                        DW_AT_type(reference  to  21$)                                                                                           ||
|                         DW_AT_data_bit_offset(1)                                                                                                 |
||                        DW_AT_bit_size(32)  !  may  be  omitted                                                                                  ||
||                 DW_TAG_member                                                                                                                   ||
|                         DW_AT_name("F4")                                                                                                         |
||                        DW_AT_type(reference  to  22$)                                                                                           ||
|                         DW_AT_data_bit_offset(33)                                                                                                |
||                        DW_AT_bit_size(4)  !  may  be  omitted                                                                                   ||
||                 DW_TAG_member                                                                                                                   ||
|                         DW_AT_name("F7")                                                                                                         |
||                        DW_AT_type(reference  to  20$)       !  type  T                                                                          ||
|                         DW_AT_data_bit_offset(37)                                                                                                |
||                        DW_AT_bit_size(2)                          !  may  be  omitted                                                           ||
||           DW_TAG_variable                                                                                                                       ||
|                  DW_AT_name("V")                                                                                                                 |
||                 DW_AT_type(reference  to  23$)                                                                                                  ||
|                  DW_AT_location(...)                                                                                                             |
||_________________...____________________________________________________________________________________________________________________________ ||
           Figure D.22: Packed record example: DWARF description (concluded)
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 325
                                        Appendix D.  Examples (Informative)
 D.2.8           C/C++ Bit-Field Examples
 Bit oelds in C and C++ typically require the use of the DW.AT.data.bit.ooeset and
 DW.AT.bit.size attributes.
 This Standard uses the following bit numbering and direction conventions in examples.
 These conventions are for illustrative purposes and other conventions may apply on
 particular architectures.
      #    For big-endian architectures, bit ooesets are counted from high-order to low-order
           bits within a byte (or larger storage unit); in this case, the bit ooeset identioes the
           high-order bit of the object.
      #    For little-endian architectures, bit ooesets are counted from low-order to high-order
           bits within a byte (or larger storage unit); in this case, the bit ooeset identioes the
           low-order bit of the object.
 In either case, the bit so identioed is deoned as the beginning of the object.
 This section illustrates one possible representation of the following C structure
 deonition in both big- and little-endian byte orders:
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||sS*
 *t{r u c t
|||=============================================================================================================================================|||ij*
 *n:t5 ;
|||=============================================================================================================================================|||ik*
 *n:t6 ;
|||=============================================================================================================================================|||im*
 *n:t5 ;
|||=============================================================================================================================================|||in*
 *n:t8 ;
|||=============================================================================================================================================|||};*
 *_|_____|
 Figures D.23 and D.24 on the next page show the structure layout and data bit
 ooesets for example big- and little-endian architectures, respectively. Both
 diagrams show a structure that begins at address A and whose size is four bytes.
 Also, high order bits are to the left and low order bits are to the right.
 Note that data member bit ooesets in this example are the same for both big- and
 little-endian architectures even though the oelds are allocated in dioeerent
 directions (high-order to low-order versus low-order to high-order); the bit
 naming conventions for memory and/or registers of the target architecture may
 or may not make this seem natural.
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 326
                                       Appendix D.  Examples (Informative)
|                                                                                                                                                  |
__________________________________________________________________________________________________________________________________________________||||
||      j:0                                                                                                                                        ||
|       k:5                                                                                                                                        |
||      m:11                                                                                                                                       ||
||      n:16                                                                                                                                       ||
|                                                                                                                                                  |
||      Addresses  increase  ->                                                                                                                    ||
|       |            A            |         A  +  1         |       A  +  2           |       A  +  3           |                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
|       Data  bit  offsets  increase  ->                                                                                                           |
||      +---------------+---------------+---------------+---------------+                                                                          ||
||      |0         4|5                10|11           15|16                   23|24                   31|                                          ||
|       |     j     |         k           |  m              |              n           |            <pad>     |                                    |
||      |            |                     |                  |                          |                          |                              ||
|       +---------------------------------------------------------------+                                                                          |
|                                                                                                                                                  |
|_________________________________________________________________________________________________________________________________________________ |
                                     Figure D.23: Big-endian data bit ooesets
|                                                                                                                                                  |
__________________________________________________________________________________________________________________________________________________||
|                                                                                                                                                  |
|       j:0                                                                                                                                        |
||      k:5                                                                                                                                        ||
|       m:11                                                                                                                                       |
||      n:16                                                                                                                                       ||
||                                                                                 <-  Addresses  increase                                         ||
|       |         A  +  3         |         A  +  2         |       A  +  1           |            A            |                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                      <-    Data  bit  offsets  increase                                          |
||      +---------------+---------------+---------------+---------------+                                                                          ||
||      |31                   24|23                   16|15         11|10            5|4              0|                                           ||
|       |         <pad>         |              n           |       m       |       k         |         j       |                                   |
||      |                          |                          |                |                  |                  |                             ||
|       +---------------------------------------------------------------+                                                                          |
|                                                                                                                                                  |
|_________________________________________________________________________________________________________________________________________________ |
                                   Figure D.24: Little-endian data bit ooesets
D.2.9           Ada Biased Bit-Field Example
The Ada source in Figure D.25 on the following page demonstrates how a
member of a record, which normally occupies six bits, can be biased to ot into
three bits when the range is known. The encoded values [  0..7  ] correspond to
the source values [  50..57  ] used by the application.
The DWARF description is shown in Figure D.26 on the next page. The bias
chosen, which in this case corresponds to the lower bound, is specioed in the
base type at 1$.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 327
                                        Appendix D.  Examples (Informative)
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||tS*
 *ympaelilsRraannggeeT5y0p.e.5 7 ;
|||=============================================================================================================================================|||tR*
 *yepceoirsdrTeycpoer d
|||=============================================================================================================================================|||A:*
 *S;m a l l R a n g e T y p e
|||=============================================================================================================================================|||er*
 *nedc;o r d
|||=============================================================================================================================================|||fR*
 *oercuosredrTeycpoer d
|||=============================================================================================================================================|||Aa*
 *t0r0a.n.g2e;
|||=============================================================================================================================================|||er*
 *nedc;o r d
|||=============================================================================================================================================|||L:*
 *oRceacloRredcToyrpde;_|_____|
 |                       Figure D.25: Ada biased bit-oeld example: Ada source                                                                       |
 __________________________________________________________________________________________________________________________________________________||*
 *||
 |1$:  DW_TAG_base_type                                                                                                                             |
 ||             DW_AT_byte_size(1)                                                                                                                  ||
 ||             DW_AT_encoding(DW_ATE_unsigned)                                                                                                     ||
 |              DW_AT_bias(50)                                                                                                                      |
 ||             DW_AT_artificial(1)                                                                                                                 ||
 |2$:  DW_TAG_subrange_type                                                                                                                         |
 ||             DW_AT_name("SmallRangeType")                                                                                                        ||
 ||             DW_AT_lower_bound(50)                                                                                                               ||
 |              DW_AT_upper_bound(57)                                                                                                               |
 ||             DW_AT_type(reference  to  1$)                                                                                                       ||
 |3$:  DW_TAG_structure_type                                                                                                                        |
 ||             DW_AT_name("RecordType")                                                                                                            ||
 |              DW_AT_byte_size(1)                                                                                                                  |
 |4$:|      DW_TAG_member                                                                                                                           ||
 ||                    DW_AT_name("A")                                                                                                              ||
 |                     DW_AT_type(reference  to  2$)                                                                                                |
 ||                    DW_AT_bit_size(3)                                                                                                            ||
 |                     DW_AT_data_bit_offset(0)                                                                                                     |
 |5$:| DW_TAG_variable                                                                                                                              ||
 ||                    DW_AT_name("LocalRecord")                                                                                                    ||
 |                     DW_AT_type(reference  to  3$)                                                                                                |
 ||____________________DW_AT_location__..._________________________________________________________________________________________________________ ||
                 Figure D.26: Ada biased bit-oeld example: DWARF description
 Note that other choices of encoding and bias lead to the same result. For example,
 the DW.ATE.signed encoding can be used in combination with a bias of 54.
 If the valid range of values is completely negative (for example, -57..-50) then
 only signed encoding is valid, and the bias will also need to be negative (-53).
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 328
                                        Appendix D.  Examples (Informative)
 D.2.10             Variant Entry Examples
 The following examples illustrate some of the diverse ways that the DWARF
 variant entry constructs are used in various programming languages.
 D.2.10.1          Pascal Variant Entry Example
 A Pascal record example without a variant part is shown in D.2.7 on page 324.
 Here a Pascal record with a variant part is shown in Figure D.27 following. The
 corresponding DWARF representation follows in Figure D.28 on the next page.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||R=*
 *PRoeicnotr d
|||=============================================================================================================================================|||CU*
 *asseeP:oBloaorloefa n
|||=============================================================================================================================================|||F:*
 *a(lXs,eY:R)e;a l
|||=============================================================================================================================================|||T:*
 *r(uRea,dTihuest:aR)e;a l
|||=============================================================================================================================================|||e;*
 *n d
|||=============================================================================================================================================|||e;*
 *n_d|_____|
                            Figure D.27: Pascal variant record example: source
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 329
|                                      Appendix D.  Examples (Informative)                                                                         |
|                                                                                                                                                  |
__________________________________________________________________________________________________________________________________________________||||
|!  Description  for  type  RPoint                                                                                                                 |
|!|                                                                                                                                                ||
|1$:  DW_TAG_structure_type                                                                                                                        |
||             DW_AT_name("RPoint")                                                                                                                ||
||             DW_TAG_variant_part                                                                                                                 ||
|                     DW_AT_discr  (reference  to  2$)                                                                                             |
|2$:|               DW_TAG_member                                                                                                                  ||
|                            DW_AT_name("UsePolar")                                                                                                |
||                           DW_AT_type(reference  to  Boolean)                                                                                    ||
||                    DW_TAG_variant                                                                                                               ||
|                            DW_AT_discr_value(constant  0)                                                                                        |
||                           DW_TAG_member                                                                                                         ||
|                                   DW_AT_name("X")                                                                                                |
||                                  DW_AT_type(reference  to  Real)                                                                                ||
||                                  DW_AT_data_member_location(1)                                                                                  ||
|                            DW_TAG_member                                                                                                         |
||                                  DW_AT_name("Y")                                                                                                ||
|                                   DW_AT_type(reference  to  Real)                                                                                |
||                                  DW_AT_data_member_location(5)                                                                                  ||
|                     DW_TAG_variant                                                                                                               |
||                           DW_AT_discr_value(constant  1)                                                                                        ||
||                           DW_TAG_member                                                                                                         ||
|                                   DW_AT_name("Radius")                                                                                           |
||                                  DW_AT_type(reference  to  Real)                                                                                ||
|                                   DW_AT_data_member_location(1)                                                                                  |
||                           DW_TAG_member                                                                                                         ||
||                                  DW_AT_name("Theta")                                                                                            ||
|                                   DW_AT_type(reference  to  Real)                                                                                |
||__________________________________DW_AT_data_member_location(5)_________________________________________________________________________________ ||
               Figure D.28: Pascal variant record example: DWARF description
Notice that the "tag" (member UsePolar in this case) is the orst child of the
variant part. A "tagless" version of this example would simply delete "UsePolar :"
from the second line of the source (so that the tag has no name, hence is not
visible). In the DWARF description, the member entry and name for UsePolar
are then deleted, as is the DW.AT.discr attribute, and the remaining type
attribute is made an attribute of the containing variant part entry.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 330
                                        Appendix D.  Examples (Informative)
 D.2.10.2          Ada Variant Entry Example
 An Ada example variant part is illustrated in Figure D.29 following. The
 corresponding DWARF is shown in Figure D.30 on the following page.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||tR*
 *y(pDe:i)nitse g e r
|||=============================================================================================================================================|||r *
 *e c o r d
|||=============================================================================================================================================|||A:*
 *i;n t e g e r
|||=============================================================================================================================================|||cD*
 *aisse
|||=============================================================================================================================================|||w0*
 *h=e>n
|||=============================================================================================================================================|||F:*
 *f;l o a t
|||=============================================================================================================================================|||w1*
 *h=e>n
|||=============================================================================================================================================|||N:*
 *i;n t e g e r
|||=============================================================================================================================================|||wo*
 *htehne=r>s
|||=============================================================================================================================================|||n;*
 *u l l
|||=============================================================================================================================================|||ec*
 *nads;e
|||=============================================================================================================================================|||er*
 *nedc;o_r|d____|
                              Figure D.29: Ada variant record example: source
 For Ada, note that the tag is not "declared" as part of the variant part construct.
 Rather the variant part refers to a discriminant of the containing type which
 necessarily occurs as an initial member in the sequence of record components.
 This reference is implemented as a DW.AT.discr attribute of the
 DW.TAG.variant.part entry.
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 331
 |                                      Appendix D.  Examples (Informative)                                                                         |
 |                                                                                                                                                  |
 __________________________________________________________________________________________________________________________________________________||*
 *||
 |       DW_TAG_structure_type                                                                                                                      |
 ||             DW_AT_name("r")                                                                                                                     ||
 |1$:         DW_TAG_member                                                   !  Discriminant                                                       |
 ||                  DW_AT_type(reference  to  integer)                                                                                             ||
 ||                  DW_AT_data_member_location(DW_OP_plus_uconst  0)                                                                               ||
 |                   DW_AT_name("d")                                                                                                                |
 ||           DW_TAG_member                                                                                                                         ||
 |                   DW_AT_type(reference  to  integer)                                                                                             |
 ||                  DW_AT_data_member_location(DW_OP_plus_uconst  4)                                                                               ||
 |                   DW_AT_name("a")                                                                                                                |
 ||           DW_TAG_variant_part                                                                                                                   ||
 ||                  DW_AT_discr(reference  to  1$)                                                                                                 ||
 |                   DW_TAG_variant                                                                                                                 |
 ||                         DW_AT_discr_value(0)                                                                                                    ||
 |                          DW_TAG_member                                                                                                           |
 ||                              DW_AT_type(reference  to  float)                                                                                   ||
 ||                              DW_AT_data_member_location(DW_OP_plus_uconst  8)                                                                   ||
 |                               DW_AT_name("f")                                                                                                    |
 ||                 DW_TAG_variant                                                                                                                  ||
 |                         DW_AT_discr_value(1)                                                                                                     |
 ||                        DW_TAG_member                                                                                                            ||
 ||                              DW_AT_type(reference  to  integer)                                                                                 ||
 |                               DW_AT_data_member_location(DW_OP_plus_uconst  8)                                                                   |
 ||                              DW_AT_name("n")                                                                                                    ||
 |                  DW_TAG_variant                                                                                                                  |
 ||________________________!__No__members__described__for__the__"others"__variant__________________________________________________________________ ||
                  Figure D.30: Ada variant record example: DWARF description
 D.2.10.3          Rust Enum Example
 While Rust does not have a variant record concept similar to that in Pascal or
 Ada, it does use a similar mechanism in the implementation of enums. To
 illustrate, consider the enumeration in Figure D.31 following. This can be
 described in DWARF as shown in Figure D.32 on the next page.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||eM*
 *neusms{a g e
|||=============================================================================================================================================|||F(*
 *f)6,4
|||=============================================================================================================================================|||U(*
 *u)3,2
|||=============================================================================================================================================|||N(*
 *i)3 2
|||=============================================================================================================================================|||}_*
 *|_____|
                                     Figure D.31: Rust enum example: source
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 332
                                       Appendix D.  Examples (Informative)
|                                                                                                                                                  |
|                                                                                                                                                  |
__________________________________________________________________________________________________________________________________________________||||
|       DW_TAG_structure_type                                                                                                                      |
||             DW_AT_name("Message")                                                                                                               ||
|              DW_TAG_variant_part                                                                                                                 |
||                    DW_AT_discr(reference  to  $1)                                                                                               ||
|$1:                DW_TAG_member                                     !  Artificial  discriminant                                                  |
||                           DW_AT_type(reference  to  u32)                                                                                        ||
||                           DW_AT_data_member_location(0)                                                                                         ||
|                            DW_AT_artificial(1)                                                                                                   |
||                    DW_TAG_variant                                                                                                               ||
|                            DW_AT_discr_value(0)                                                                                                  |
||                           DW_TAG_member                                                                                                         ||
||                                  DW_AT_type(reference  to  f32)                                                                                 ||
|                                   DW_AT_name("F")                                                                                                |
||                                  DW_AT_data_member_location(4)                                                                                  ||
|                     DW_TAG_variant                                                                                                               |
||                           DW_AT_discr_value(1)                                                                                                  ||
|                            DW_TAG_member                                                                                                         |
||                                  DW_AT_type(reference  to  u32)                                                                                 ||
||                                  DW_AT_name("U")                                                                                                ||
|                                   DW_AT_data_member_location(4)                                                                                  |
||                    DW_TAG_variant                                                                                                               ||
|                            DW_AT_discr_value(2)                                                                                                  |
||                           DW_TAG_member                                                                                                         ||
||                                  DW_AT_type(reference  to  i32)                                                                                 ||
|                                   DW_AT_name("N")                                                                                                |
||__________________________________DW_AT_data_member_location(4)_________________________________________________________________________________ ||
                        Figure D.32: Rust enum example: DWARF description
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 333
                                        Appendix D.  Examples (Informative)
 D.3            Namespace  Examples
 The C++ example in Figure D.33 is used to illustrate the representation of
 namespaces. The DWARF representation in Figure D.34 on the next page is
 appropriate.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||n{*
 *a m e s p a c e
|||=============================================================================================================================================|||ii*
 *n;t
|||=============================================================================================================================================|||}
|||=============================================================================================================================================|||nA*
 *a{m e s p a c e
|||=============================================================================================================================================|||nB*
 *a{m e s p a c e
|||=============================================================================================================================================|||ij*
 *n;t
|||=============================================================================================================================================|||im*
 *nytf(uinncta);
|||=============================================================================================================================================|||fm*
 *lyofautn(cffl)o{arteft-u2r.n0};
|||=============================================================================================================================================|||im*
 *nytf(uinnct2a){rae+t2u;r}n
|||=============================================================================================================================================|||}
|||=============================================================================================================================================|||}
|||=============================================================================================================================================|||nY*
 *a{m e s p a c e
|||=============================================================================================================================================|||uA*
 *s:i:nBg::j;//(u1s)idnegc l a r a t i o n
|||=============================================================================================================================================|||if*
 *noto;
|||=============================================================================================================================================|||}
|||=============================================================================================================================================|||uA*
 *s:i:nBg::j;//(u2s)idnegc l a r a t i o n
|||=============================================================================================================================================|||nF*
 *aomoe=sAp:a:cBe;//(n3a)maelsipaasc e
|||=============================================================================================================================================|||uF*
 *soion:g:m;y/f/u(n4c)udseicnlga r a t i o n
|||=============================================================================================================================================|||un*
 *saimnegsFpoaoc;e//(u5s)idnigr e c t i v e
|||=============================================================================================================================================|||nA*
 *a{m e s p a c e
|||=============================================================================================================================================|||nB*
 *a{m e s p a c e
|||=============================================================================================================================================|||un*
 *saimnegsYp;a/c/e(u6s)idnigr e c t i v e
|||=============================================================================================================================================|||ik*
 *n;t
|||=============================================================================================================================================|||}
|||=============================================================================================================================================|||}
|||=============================================================================================================================================|||iF*
 *noto::m(yifnutnac)
|||=============================================================================================================================================|||{
|||=============================================================================================================================================|||i=*
 *3;
|||=============================================================================================================================================|||j=*
 *4;
|||=============================================================================================================================================|||rm*
 *eytfuurnnc(23+)j+i+a+2;
|||=============================================================================================================================================|||}_*
 *|_____|
                         Figure D.33: Namespace example #1: source fragment
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 334
                                       Appendix D.  Examples (Informative)
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
____________________________________________________________________________________________________________________________________part_1_of_2___||
|                                                                                                                                                  |
|1$:|    DW_TAG_base_type                                                                                                                          ||
|                  DW_AT_name("int")                                                                                                               |
||                 ...                                                                                                                             ||
|2$:     DW_TAG_base_type                                                                                                                          |
||                 DW_AT_name("float")                                                                                                             ||
||                 ...                                                                                                                             ||
|6$:     DW_TAG_namespace                                                                                                                          |
||                 !  no  DW_AT_name  attribute                                                                                                    ||
|                  DW_AT_export_symbols                         !  Implied  by  C++,  but  can  be  explicit                                       |
||                 DW_TAG_variable                                                                                                                 ||
||                        DW_AT_name("i")                                                                                                          ||
|                         DW_AT_type(reference  to  1$)                                                                                            |
||                        DW_AT_location  ...                                                                                                      ||
|                         ...                                                                                                                      |
|10$:|   DW_TAG_namespace                                                                                                                          ||
||                 DW_AT_name("A")                                                                                                                 ||
|20$:           DW_TAG_namespace                                                                                                                   |
||                        DW_AT_name("B")                                                                                                          ||
|30$:                  DW_TAG_variable                                                                                                             |
||                              DW_AT_name("j")                                                                                                    ||
|                               DW_AT_type(reference  to  1$)                                                                                      |
||                              DW_AT_location  ...                                                                                                ||
||                              ...                                                                                                                ||
|34$:                  DW_TAG_subprogram                                                                                                           |
||                              DW_AT_name("myfunc")                                                                                               ||
|                               DW_AT_type(reference  to  1$)                                                                                      |
||                              ...                                                                                                                ||
|36$:|                 DW_TAG_subprogram                                                                                                           ||
|                               DW_AT_name("myfunc")                                                                                               |
||                              DW_AT_type(reference  to  2$)                                                                                      ||
|                               ...                                                                                                                |
|38$:|                 DW_TAG_subprogram                                                                                                           ||
||                              DW_AT_name("myfunc2")                                                                                              ||
|                               DW_AT_low_pc  ...                                                                                                  |
||                              DW_AT_high_pc  ...                                                                                                 ||
|                               DW_AT_type(reference  to  1$)                                                                                      |
||______________________________..._______________________________________________________________________________________________________________ ||
                     Figure D.34: Namespace example #1: DWARF description
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 335
                                       Appendix D.  Examples (Informative)
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
____________________________________________________________________________________________________________________________________part_2_of_2___||||
|40$:    DW_TAG_namespace                                                                                                                          |
||                 DW_AT_name("Y")                                                                                                                 ||
|                  DW_TAG_imported_declaration                     !  (1)  using-declaration                                                       |
||                        DW_AT_import(reference  to  30$)                                                                                         ||
||                 DW_TAG_variable                                                                                                                 ||
|                         DW_AT_name("foo")                                                                                                        |
||                        DW_AT_type(reference  to  1$)                                                                                            ||
|                         DW_AT_location  ...                                                                                                      |
||                        ...                                                                                                                      ||
||          DW_TAG_imported_declaration                            !  (2)  using  declaration                                                      ||
|                  DW_AT_import(reference  to  30$)                                                                                                |
||          DW_TAG_imported_declaration                            !  (3)  namespace  alias                                                        ||
|                  DW_AT_name("Foo")                                                                                                               |
||                 DW_AT_import(reference  to  20$)                                                                                                ||
||          DW_TAG_imported_declaration                            !  (4)  using  declaration                                                      ||
|                  DW_AT_import(reference  to  34$)                !         -  part  1                                                            |
||          DW_TAG_imported_declaration                            !  (4)  using  declaration                                                      ||
|                  DW_AT_import(reference  to  36$)                !         -  part  2                                                            |
||          DW_TAG_imported_module                                     !  (5)  using  directive                                                    ||
|                  DW_AT_import(reference  to  20$)                                                                                                |
||          DW_TAG_namespace                                                                                                                       ||
||                 DW_AT_extension(reference  to  10$)                                                                                             ||
|                  DW_TAG_namespace                                                                                                                |
||                        DW_AT_extension(reference  to  20$)                                                                                      ||
|                         DW_TAG_imported_module                       !  (6)  using  directive                                                    |
||                              DW_AT_import(reference  to  40$)                                                                                   ||
||                        DW_TAG_variable                                                                                                          ||
|                               DW_AT_name("k")                                                                                                    |
||                              DW_AT_type(reference  to  1$)                                                                                      ||
|                               DW_AT_location  ...                                                                                                |
||                              ...                                                                                                                ||
|60$:|   DW_TAG_subprogram                                                                                                                         ||
|                  DW_AT_specification(reference  to  34$)                                                                                         |
||                 DW_AT_low_pc  ...                                                                                                               ||
|                  DW_AT_high_pc  ...                                                                                                              |
||_________________...____________________________________________________________________________________________________________________________ ||
           Figure D.34: Namespace example #1: DWARF description (concluded)
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 336
                                        Appendix D.  Examples (Informative)
 As a further namespace example, consider the inlined namespace shown in
 Figure D.35. For this source, the DWARF description in Figure D.36 is
 appropriate. In this example, a may be referenced either as a member of the fully
 qualioed namespace A::B, or as if it were deoned in the enclosing namespace, A.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||nA*
 *a{m e s p a c e
|||=============================================================================================================================================|||in*
 *nalmiensepBa{c/e/(i1n)lnianmee s p a c e
|||=============================================================================================================================================|||ia*
 *n;t
|||=============================================================================================================================================|||}
|||=============================================================================================================================================|||}
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||vf*
 *ooiod(v)o i d
|||=============================================================================================================================================|||{
|||=============================================================================================================================================|||uA*
 *s:i:nBg::a;
|||=============================================================================================================================================|||a=*
 *1;
|||=============================================================================================================================================|||}
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||vb*
 *oaird(v)o i d
|||=============================================================================================================================================|||{
|||=============================================================================================================================================|||uA*
 *s:i:nag;
|||=============================================================================================================================================|||a=*
 *2;
|||=============================================================================================================================================|||}_*
 *|_____|
                         Figure D.35: Namespace example #2: source fragment
 __________________________________________________________________________________________________________________________________________________||
 |1$:     DW_TAG_namespace                                                                                                                          |
 ||                 DW_AT_name("A")                                                                                                                 ||
 |2$:            DW_TAG_namespace                                                                                                                   |
 ||                        DW_AT_name("B")                                                                                                          ||
 ||                        DW_AT_export_symbols                                                                                                     ||
 |3$:                   DW_TAG_variable                                                                                                             |
 ||______________________________DW_AT_name("a")___________________________________________________________________________________________________ ||
                      Figure D.36: Namespace example #2: DWARF description
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 337
                                        Appendix D.  Examples (Informative)
 D.4            Member  Function  Examples
 Consider the member function example fragment in Figure D.37. The DWARF
 representation in Figure D.38 is appropriate.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||cA*
 *l a s s
|||=============================================================================================================================================|||{
|||=============================================================================================================================================|||vf*
 *ouindc(1ixn1t);
|||=============================================================================================================================================|||vf*
 *ouindc(2)c;o n s t
|||=============================================================================================================================================|||sv*
 *toaitdifcu(nicn3tx3);
|||=============================================================================================================================================|||};
|||=============================================================================================================================================|||vA*
 *o:i:df(uinnct1x){}_|_____|
                       Figure D.37: Member function example: source fragment
 |                                                                                                                                                  |
 ____________________________________________________________________________________________________________________________________part_1_of_2___||*
 *||
 |                                                                                                                                                  |
 |2$:  DW_TAG_base_type                                                                                                                             |
 ||             DW_AT_name("int")                                                                                                                   ||
 ||             ...                                                                                                                                 ||
 |3$:  DW_TAG_class_type                                                                                                                            |
 ||             DW_AT_name("A")                                                                                                                     ||
 |              ...                                                                                                                                 |
 |4$:|        DW_TAG_pointer_type                                                                                                                   ||
 |                     DW_AT_type(reference  to  3$)                                                                                                |
 ||                    ...                                                                                                                          ||
 |5$:|        DW_TAG_const_type                                                                                                                     ||
 |                     DW_AT_type(reference  to  3$)                                                                                                |
 ||                    ...                                                                                                                          ||
 |6$:         DW_TAG_pointer_type                                                                                                                   |
 ||                    DW_AT_type(reference  to  5$)                                                                                                ||
 ||                    ...                                                                                                                          ||
 |                                                                                                                                                  |
 |7$:|        DW_TAG_subprogram                                                                                                                     ||
 |                     DW_AT_declaration                                                                                                            |
 ||                    DW_AT_name("func1")                                                                                                          ||
 ||                    DW_AT_object_pointer(reference  to  8$)                                                                                      ||
 |                            !  References  a  formal  parameter  in  this                                                                         |
 ||                           !  member  function                                                                                                   ||
 |                     ...                                                                                                                          |
 |                                                                                                                                                  |
 |_________________________________________________________________________________________________________________________________________________ |
                   Figure D.38: Member function example: DWARF description
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 338
                                       Appendix D.  Examples (Informative)
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
____________________________________________________________________________________________________________________________________part_2_of_2___||||
|                                                                                                                                                  |
|8$:                DW_TAG_formal_parameter                                                                                                        |
||                           DW_AT_artificial(true)                                                                                                ||
||                           DW_AT_name("this")                                                                                                    ||
|                            DW_AT_type(reference  to  4$)                                                                                         |
||                                  !  Makes  type  of  'this'  as  'A*'  =>                                                                       ||
|                                   !  func1  has  not  been  marked  const                                                                        |
||                                  !  or  volatile                                                                                                ||
||                           DW_AT_location  ...                                                                                                   ||
|                            ...                                                                                                                   |
|9$:|               DW_TAG_formal_parameter                                                                                                        ||
|                            DW_AT_name(x1)                                                                                                        |
||                           DW_AT_type(reference  to  2$)                                                                                         ||
||                           ...                                                                                                                   ||
|10$:       DW_TAG_subprogram                                                                                                                      |
||                    DW_AT_declaration                                                                                                            ||
|                     DW_AT_name("func2")                                                                                                          |
||                    DW_AT_object_pointer(reference  to  11$)                                                                                     ||
||                    !  References  a  formal  parameter  in  this                                                                                ||
|                     !  member  function                                                                                                          |
||                    ...                                                                                                                          ||
|11$:              DW_TAG_formal_parameter                                                                                                         |
||                           DW_AT_artificial(true)                                                                                                ||
|                            DW_AT_name("this")                                                                                                    |
||                           DW_AT_type(reference  to  6$)                                                                                         ||
||                           !  Makes  type  of  'this'  as  'A  const*'  =>                                                                       ||
|                            !         func2  marked  as  const                                                                                    |
||                           DW_AT_location  ...                                                                                                   ||
|                            ...                                                                                                                   |
|12$:|      DW_TAG_subprogram                                                                                                                      ||
||                    DW_AT_declaration                                                                                                            ||
|                     DW_AT_name("func3")                                                                                                          |
||                    ...                                                                                                                          ||
|                            !  No  object  pointer  reference  formal  parameter                                                                  |
||                           !  implies  func3  is  static                                                                                         ||
|13$:|             DW_TAG_formal_parameter                                                                                                         ||
|                            DW_AT_name(x3)                                                                                                        |
||                           DW_AT_type(reference  to  2$)                                                                                         ||
|                            ...                                                                                                                   |
|                                                                                                                                                  |
|_________________________________________________________________________________________________________________________________________________ |
        Figure D.38: Member function example: DWARF description (concluded)
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 339
                                        Appendix D.  Examples (Informative)
 As a further example illustrating &- and &&-qualiocation of member functions,
 consider the member function example fragment in Figure D.39. The DWARF
 representation in Figure D.40 on the following page is appropriate.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||cA*
 *l{a s s
|||=============================================================================================================================================|||p:*
 *u b l i c
|||=============================================================================================================================================|||vf*
 *o(i)dc&o&n;s t
|||=============================================================================================================================================|||};
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||vg*
 *o(i)d{
|||=============================================================================================================================================|||Aa;
|||=============================================================================================================================================|||//*
 *Tthyepoefpiosi"nvtoeird(A:(:)*c)o&n&s"t.
|||=============================================================================================================================================|||ap*
 *uotion=t&eAr:_:tfo;_ m e m b e r _ f u n c t i o n
|||=============================================================================================================================================|||}_*
 *|_____|
 Figure   D.39:    Reference-   and   rvalue-reference-qualiocation   example:    source
 fragment
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 340
                                       Appendix D.  Examples (Informative)
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
__________________________________________________________________________________________________________________________________________________||||
|100$:|    DW_TAG_class_type                                                                                                                       ||
||                    DW_AT_name("A")                                                                                                              ||
|                     DW_TAG_subprogram                                                                                                            |
||                           DW_AT_name("f")                                                                                                       ||
|                            DW_AT_rvalue_reference(0x01)                                                                                          |
||                           DW_TAG_formal_parameter                                                                                               ||
||                                  DW_AT_type(ref  to  200$)         !  to  const  A*                                                             ||
|                                   DW_AT_artificial(0x01)                                                                                         |
|                                                                                                                                                  |
|                                                                                                                                                  |
|200$:     !  const  A*                                                                                                                            |
||             DW_TAG_pointer_type                                                                                                                 ||
||                    DW_AT_type(ref  to  300$)                       !  to  const  A                                                              ||
|                                                                                                                                                  |
|300$:|    !  const  A                                                                                                                             ||
|              DW_TAG_const_type                                                                                                                   |
||                    DW_AT_type(ref  to  100$)                       !  to  class  A                                                              ||
|                                                                                                                                                  |
|400$:|    !  mfptr                                                                                                                                ||
||             DW_TAG_ptr_to_member_type                                                                                                           ||
|                     DW_AT_type(ref  to  500$)                       !  to  functype                                                              |
||                    DW_AT_containing_type(ref  to  100$)    !  to  class  A                                                                      ||
|                                                                                                                                                  |
|500$:|    !  functype                                                                                                                             ||
||             DW_TAG_subroutine_type                                                                                                              ||
|                     DW_AT_rvalue_reference(0x01)                                                                                                 |
||                    DW_TAG_formal_parameter                                                                                                      ||
|                            DW_AT_type(ref  to  200$)                !  to  const  A*                                                             |
||                           DW_AT_artificial(0x01)                                                                                                ||
|                                                                                                                                                  |
|600$:|    DW_TAG_subprogram                                                                                                                       ||
||                    DW_AT_name("g")                                                                                                              ||
|                     DW_TAG_variable                                                                                                              |
||                           DW_AT_name("a")                                                                                                       ||
||                           DW_AT_type(ref  to  100$)                !  to  class  A                                                              ||
|                     DW_TAG_variable                                                                                                              |
||                           DW_AT_name("pointer_to_member_function")                                                                              ||
|                            DW_AT_type(ref  to  400$)                                                                                             |
|                                                                                                                                                  |
|_________________________________________________________________________________________________________________________________________________ |
Figure  D.40:   Reference-  and  rvalue-reference-qualiocation  example:   DWARF
description
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 341
                                       Appendix D.  Examples (Informative)
D.5            Line  Number  Examples
D.5.1           Line Number Header Example
Figure D.41 illustrates a line number header (see Section 6.2.4 on page 160).
There|are multiple alternative olename formats, which include the source and                                                                       |
|                                                                                                                                                  |
URL|types.                                                                                                                                         |
|                                                                                                                                                  |
__________________________________________________________________________________________________________________________________________________||||
|    Field                   Field  Name                                      Value(s)                                                             |
||   Number                                                                                                                                        ||
|         1       unit_length                                 <unit  length>                                                                       |
||        2       version                                        6                                                                                 ||
|         3       address_size                               4  or  8                                                                              |
||        4       Reserved                                       0                                                                                 ||
||        5       header_length                              <header  length>                                                                      ||
|         6       minimum_instruction_length       1                                                                                               |
||        7       maximum_operations_per_instruction  1                                                                                            ||
|         8       default_is_stmt                          1  (true)                                                                               |
||        9       line_base                                     -3                                                                                 ||
|       10       line_range                                   12                                                                                   |
||      11       opcode_base                                 13                                                                                    ||
||      12       standard_opcode_lengths            [0,1,1,1,1,0,0,0,0,0,0,1]                                                                      ||
|       13       directory_format_count              1                                                                                             |
||      14       directory_format_table              [DW_LNCT_path,  DW_FORM_string],                                                              ||
|                                                                      [0,  0]                                                                     |
||      15       directories_count                       1                                                                                         ||
||      16       directories                                 [0,  <directory  path  string>]                                                       ||
|       17       file_name_format_count              3                                                                                             |
||      18       file_name_format_table              [DW_LNCT_source,  DW_FORM_strp],                                                              ||
|                                                                      [0,  0]                                                                     |
||                                                                     [DW_LNCT_path,  DW_FORM_string],                                            ||
||                                                                     [DW_LNCT_directory_index,  DW_FORM_udata],                                  ||
|                                                                      [DW_LNCT_timestamp,  DW_FORM_udata],                                        |
||                                                                     [DW_LNCT_size,  DW_FORM_udata],                                             ||
|                                                                      [0,  0],                                                                    |
||                                                                     [DW_LNCT_URL,  DW_FORM_strp],                                               ||
|                                                                      [0,  0]                                                                     |
||      19       file_names_count                         4                                                                                        ||
||      20       file_names                                   [0,  {<source  string  offset>}],                                                    ||
|                                                                      [2,  {<URL  string  offset>}],                                              |
||                                                                     [1,  {<name  string  1>,  <directory  index=0>,                             ||
|                                                                              <timestamp  1>,  <size  1>}],                                       |
||                                                                     [1,  {<name  string  2>,  <directory  index=0>,                             ||
||_____________________________________________________________________________<timestamp__2>,__<size__2>}]_______________________________________ ||
                          Figure D.41: Example line number program header
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 342
                                       Appendix D.  Examples (Informative)
D.5.2           Line Number Special Opcode Example
Given the example header in Figure D.41 on the previous page, we can use a
special opcode whenever two successive rows in the matrix have source line
numbers dioeering by any value within the range [-3, 8]    and (because of the
limited number of opcodes available) when the dioeerence between addresses is
within the range [0, 20]. The resulting opcode mapping is shown in Figure D.42.
Note in the bottom row of the ogure that not all line advances are available for
the maximum operation advance.
                                                 Line  Advance
      Operation
          Advance        -3    -2    -1      0      1      2      3      4      5      6      7      8
      ---------      -----------------------------------------------
                       0        13    14    15    16    17    18    19    20    21    22    23    24
                       1        25    26    27    28    29    30    31    32    33    34    35    36
                       2        37    38    39    40    41    42    43    44    45    46    47    48
                       3        49    50    51    52    53    54    55    56    57    58    59    60
                       4        61    62    63    64    65    66    67    68    69    70    71    72
                       5        73    74    75    76    77    78    79    80    81    82    83    84
                       6        85    86    87    88    89    90    91    92    93    94    95    96
                       7        97    98    99  100  101  102  103  104  105  106  107  108
                       8      109  110  111  112  113  114  115  116  117  118  119  120
                       9      121  122  123  124  125  126  127  128  129  130  131  132
                     10      133  134  135  136  137  138  139  140  141  142  143  144
                     11      145  146  147  148  149  150  151  152  153  154  155  156
                     12      157  158  159  160  161  162  163  164  165  166  167  168
                     13      169  170  171  172  173  174  175  176  177  178  179  180
                     14      181  182  183  184  185  186  187  188  189  190  191  192
                     15      193  194  195  196  197  198  199  200  201  202  203  204
                     16      205  206  207  208  209  210  211  212  213  214  215  216
                     17      217  218  219  220  221  222  223  224  225  226  227  228
                     18      229  230  231  232  233  234  235  236  237  238  239  240
                     19      241  242  243  244  245  246  247  248  249  250  251  252
                     20      253  254  255
                   Figure D.42: Example line number special opcode mapping
There is no requirement that the expression 255 - line_base + 1 be an integral
multiple of line_range.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 343
                                        Appendix D.  Examples (Informative)
 D.5.3           Line Number Program Example
 Consider the simple source ole and the resulting machine code for the Intel 8086
 processor in Figure D.43.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||1:*
 *i n t
|||=============================================================================================================================================|||2:*
 *m(a)i n
|||=============================================================================================================================================|||0x*
 *:2p3u9sphb
|||=============================================================================================================================================|||0x*
 *:2m3oavbp,sp
|||=============================================================================================================================================|||3:{
|||=============================================================================================================================================|||4:*
 *p(r"iOnmtiftnweoerddlse\sns");
|||=============================================================================================================================================|||0x*
 *:2m3ocvax,0x a a
|||=============================================================================================================================================|||0x*
 *:2p3ufsahx
|||=============================================================================================================================================|||0x*
 *:2c4a0l_lp r i n t f
|||=============================================================================================================================================|||0x*
 *:2p4o3pcx
|||=============================================================================================================================================|||5:*
 *e(x0i)t;
|||=============================================================================================================================================|||0x*
 *:2x4o4rax,ax
|||=============================================================================================================================================|||0x*
 *:2p4u6sahx
|||=============================================================================================================================================|||0x*
 *:2c4a7l_le x i t
|||=============================================================================================================================================|||0x*
 *:2p4oapcx
|||=============================================================================================================================================|||6:}
|||=============================================================================================================================================|||0x*
 *:2p4obpbp
|||=============================================================================================================================================|||0x*
 *:2r4ect
|||=============================================================================================================================================|||7:*
 *0x:2_4|d____|
                    Figure D.43: Line number program example: machine code
 Suppose the line number program header includes the same values and resulting
 encoding illustrated in the previous Section D.5.2 on the preceding page.
 Table D.2 on the next page shows one encoding of the line number program,
 which occupies 12 bytes.
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 344
                                       Appendix D.  Examples (Informative)
                       Table   D.2:     Line   number   program   example:     one
                       encoding
                _________________________________________________________________________________________________________________
                __Opcode________________________________||________Operand____________||________Byte_Stream_______________________
                  DW.LNS.advance.pc       ||                      LEB128(0x239)  ||            0x2, 0xb9, 0x04
                  SPECIAL# (2, 0)                  ||                                        ||0x12  (1810 )
                  SPECIAL# (2, 3)                  ||                                        ||0x36  (5410 )
                  SPECIAL# (1, 8)                  ||                                        ||0x71  (11310 )
                  SPECIAL# (1, 7)                  ||                                        ||0x65  (10110 )
                  DW.LNS.advance.pc       ||                      LEB128(2)          ||        0x2, 0x2
                __DW.LNE.end.sequence__||____________________________________________________||0x0,_0x1,_0x1_____________________
                  #  The  opcode  notation  SPECIAL(m,n)  indicates  the  special
                  opcode        generated  for  a  line  advance  of  m  and  an  operation
                  advance of n.
Table D.3 shows an alternate encoding of the same program using standard
opcodes to advance the program counter; this encoding occupies 22 bytes.
                       Table  D.3:   Line  number  program  example:   alternate
                       encoding
                _________________________________________________________________________________________________________________
                __Opcode______________________________________||________Operand__||_________Byte_Stream__________________________
                  DW.LNS.oxed.advance.pc  ||                            0x239        ||     0x9, 0x39, 0x2
                  SPECIAL# (2, 0)                        ||                               ||0x12  (1810 )
                  DW.LNS.oxed.advance.pc  ||                            0x3            ||   0x9, 0x3, 0x0
                  SPECIAL# (2, 0)                        ||                               ||0x12  (1810 )
                  DW.LNS.oxed.advance.pc  ||                            0x8            ||   0x9, 0x8, 0x0
                  SPECIAL# (1, 0)                        ||                               ||0x11  (1710 )
                  DW.LNS.oxed.advance.pc  ||                            0x7            ||   0x9, 0x7, 0x0
                  SPECIAL# (1, 0)                        ||                               ||0x11  (1710 )
                  DW.LNS.oxed.advance.pc  ||                            0x2            ||   0x9, 0x2, 0x0
                __DW.LNE.end.sequence_________||__________________________________________||0x0,_0x1,_0x1________________________
                  # SPECIAL is deoned the same as in the preceding Table D.2.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 345
                                       Appendix D.  Examples (Informative)
D.6            Call  Frame  Information  Example
The following example uses a hypothetical RISC machine in the style of the
Motorola 88000.
     #    Memory is byte addressed.
     #    Instructions are all 4 bytes each and word aligned.
     #    Instruction operands are typically of the form:
                  <destination.reg>,  <source.reg>,  <constant>
     #    The address for the load and store instructions is computed by adding the
          contents of the source register with the constant.
     #    There are eight 4-byte registers:
                     R0 always 0
                     R1 holds return address on call
                     R2-R3 temp registers (not preserved on call)
                     R4-R6 preserved on call
                     R7 stack pointer
     #    The stack grows in the negative direction.
     #    The architectural ABI committee specioes that the stack pointer (R7) is the
          same as the CFA
Figure D.44 following shows two code fragments from a subroutine called foo
that uses a frame pointer (in addition to the stack pointer). The orst column
values are byte addresses. !fs? denotes the stack frame size in bytes, namely 12.
An abstract table (see Section 6.4.1 on page 180) for the foo subroutine is shown
in Table D.4 following. Corresponding fragments from the .debug_frame section
are shown in Table D.5 on page 348.
The following notations apply in Table D.4 on the next page:
           1. R8 is the return address
           2. s = same.value rule
           3. u = undeoned rule
           4. rN = register(N) rule
           5. cN = ooeset(N) rule
           6. a = architectural rule
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 346
                                        Appendix D.  Examples (Informative)
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||;;*
 *sptraorlto g u e
|||=============================================================================================================================================|||fs*
 *ouobR7,R7,<fs>;Aflrlaomcea t e
|||=============================================================================================================================================|||f+*
 *o4osRt1o,rRe7,(f<s>;-4)Stahveeraedtdurrens s
|||=============================================================================================================================================|||f+*
 *o8osRt6o,rRe7,(f<s>;-8)SRa6v e
|||=============================================================================================================================================|||f+*
 *o1o2aRd6d,R7,0;R6isntohweFprtarm e
|||=============================================================================================================================================|||f+*
 *o1o6sRt4o,rRe6,(f<s>;-12)Saapvreerseegr v e d
|||=============================================================================================================================================|||;;*
 *TshuibsrdoouetsinnoetcRh5a n g e
|||=============================================================================================================================================|||. *
 *. .
|||=============================================================================================================================================|||;;*
 *Setpairlto(gRu7eisrteoteunrtnreydv)a l u e
|||=============================================================================================================================================|||f+*
 *o6o4lRo4a,dR6,(f<s>;-12)RRe4s t o r e
|||=============================================================================================================================================|||f+*
 *o6o8lRo6a,dR7,(f<s>;-8)RRe6s t o r e
|||=============================================================================================================================================|||f+*
 *o7o2lRo1a,dR7,(f<s>;-4)Rreesttuorrnea d d r e s s
|||=============================================================================================================================================|||f+*
 *o7o6aRd7d,R7,<fs>;Dferaalmleo c a t e
|||=============================================================================================================================================|||f+*
 *o8o0jRu1m;pR e t u r n
|||=============================================================================================================================================|||f+*
 *o8o4_|_____|
          Figure D.44: Call frame information example: machine code fragments
                        Table D.4: Call frame information example: conceptual
                        matrix
  _______________________________________________________________________________________________________________________________________________
  __Location_________________________||_______CFA______________R0_______R1______R2_______R3_______R4_________R5_______R6_______R7_______R8_______
    foo                                   ||  [R7]+0           s        u       u        u        s          s        s        a        r1
    foo+4                              ||     [R7]+fs          s        u       u        u        s          s        s        a        r1
    foo+8                              ||     [R7]+fs          s        u       u        u        s          s        s        a        c-4
    foo+12                            ||      [R7]+fs          s        u       u        u        s          s        c-8      a        c-4
    foo+16                            ||      [R6]+fs          s        u       u        u        s          s        c-8      a        c-4
    foo+20                            ||      [R6]+fs          s        u       u        u        c-12       s        c-8      a        c-4
    ...                                      ||
    foo+64                            ||      [R6]+fs          s        u       u        u        c-12       s        c-8      a        c-4
    foo+68                            ||      [R6]+fs          s        u       u        u        s          s        c-8      a        c-4
    foo+72                            ||      [R7]+fs          s        u       u        u        s          s        s        a        c-4
    foo+76                            ||      [R7]+fs          s        u       u        u        s          s        s        a        r1
  __foo+80____________________________||______[R7]+0___________s________u_______u________u________s__________s________s________a________r1_______
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 347
                                       Appendix D.  Examples (Informative)
                          Table  D.5:  Call  frame  information  example:  common
                          information entry encoding
______________________________________________________________________________________________________________________________________________________
__Address__________________________||________Value____________________________________________Comment_________________________________________________
  cie                                    ||  36                                               length
  cie+4                               ||     0xffffffff                                       CIE.id
  cie+8                               ||     4                                                version
  cie+9                               ||     0                                                augmentation
  cie+10                             ||      4                                                address size
  cie+11                             ||      0                                                Reserved
  cie+12                             ||      4                                                code.alignment.factor, !caf ?
  cie+13                             ||      -4                                               data.alignment.factor, !daf ?
  cie+14                             ||      8                                                R8 is the return addr.
  cie+15                             ||      DW.CFA.def.cfa (7, 0)                            CFA = [R7]+0
  cie+18                             ||      DW.CFA.same.value (0)                            R0 not modioed (=0)
  cie+20                             ||      DW.CFA.undeoned (1)                              R1 scratch
  cie+22                             ||      DW.CFA.undeoned (2)                              R2 scratch
  cie+24                             ||      DW.CFA.undeoned (3)                              R3 scratch
  cie+26                             ||      DW.CFA.same.value (4)                            R4 preserve
  cie+28                             ||      DW.CFA.same.value (5)                            R5 preserve
  cie+30                             ||      DW.CFA.same.value (6)                            R6 preserve
  cie+32                             ||      DW.CFA.same.value (7)                            R7 preserve
  cie+34                             ||      DW.CFA.register (8, 1)                           R8 is in R1
  cie+37                             ||      DW.CFA.nop                                       padding
  cie+38                             ||      DW.CFA.nop                                       padding
  cie+39                             ||      DW.CFA.nop                                       padding
__cie+40_____________________________||_______________________________________________________________________________________________________________
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 348
                                       Appendix D.  Examples (Informative)
                          Table D.6:  Call frame information example:  frame de-
                          scription entry encoding
______________________________________________________________________________________________________________________________________________________
__Address__________________________||________Value__________________________________________________Comment#__________________________________________
  fde                                   ||   40                                                     length
  fde+4                              ||      cie                                                    CIE.ptr
  fde+8                              ||      foo                                                    initial.location
  fde+12                            ||       84                                                     address.range
  fde+16                            ||       DW.CFA.advance.loc(1)                                  instructions
  fde+17                            ||       DW.CFA.def.cfa.ooeset(12)                              !fs?
  fde+19                            ||       DW.CFA.advance.loc(1)                                  4/!caf?
  fde+20                            ||       DW.CFA.ooeset(8,1)                                     -4/!daf?(2nd parameter)
  fde+22                            ||       DW.CFA.advance.loc(1)
  fde+23                            ||       DW.CFA.ooeset(6,2)                                     -8/!daf?(2nd parameter)
  fde+25                            ||       DW.CFA.advance.loc(1)
  fde+26                            ||       DW.CFA.def.cfa.register(6)
  fde+28                            ||       DW.CFA.advance.loc(1)
  fde+29                            ||       DW.CFA.ooeset(4,3)                                     -12/!daf?(2nd parameter)
  fde+31                            ||       DW.CFA.advance.loc(12)                                 44/!caf?
  fde+32                            ||       DW.CFA.restore(4)
  fde+33                            ||       DW.CFA.advance.loc(1)
  fde+34                            ||       DW.CFA.restore(6)
  fde+35                            ||       DW.CFA.def.cfa.register(7)
  fde+37                            ||       DW.CFA.advance.loc(1)
  fde+38                            ||       DW.CFA.restore(8)
  fde+39                            ||       DW.CFA.advance.loc(1)
  fde+40                            ||       DW.CFA.def.cfa.ooeset(0)
  fde+42                            ||       DW.CFA.nop                                             padding
  fde+43                            ||       DW.CFA.nop                                             padding
__fde+44____________________________||________________________________________________________________________________________________________________
#The following notations apply: <fs>  = frame size, <caf>  = code alignment
factor, and <daf>  = data alignment factor.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 349
                                        Appendix D.  Examples (Informative)
 D.7            Inlining  Examples
 The pseudo-source in Figure D.45 following is used to illustrate the use of
 DWARF to describe inlined subroutine calls. This example involves a nested
 subprogram INNER that makes uplevel references to the formal parameter and
 local variable of the containing subprogram OUTER.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||ip*
 *nrloicneedOuUrTeE(RO:UiTnEtRe_gFeOrR)M=A L
|||=============================================================================================================================================|||b *
 *e g i n
|||=============================================================================================================================================|||O:*
 *UiTnEtRe_gLeOrC;A L
|||=============================================================================================================================================|||pI*
 *rNoNcEeRd(uIrNeN:EiRn_tFeOgReMrA)L=
|||=============================================================================================================================================|||b *
 *e g i n
|||=============================================================================================================================================|||I:*
 *NiNnEtRe_gLeOrC;A L
|||=============================================================================================================================================|||p(*
 *rIiNnNtE+RO_UFTOERRM_ALLO)C;A L
|||=============================================================================================================================================|||e;*
 *n d
|||=============================================================================================================================================|||I(*
 *NONUETRE)R;_ L O C A L
|||=============================================================================================================================================|||. *
 *. .
|||=============================================================================================================================================|||I(*
 *N3N1E)R;
|||=============================================================================================================================================|||e;*
 *n d
|||=============================================================================================================================================|||!C*
 *OaUlTlE R
|||=============================================================================================================================================|||!
|||=============================================================================================================================================|||O(*
 *U7T)E;R_|_____|
                     Figure D.45: Inlining examples: pseudo-source fragmment
 There are several approaches that a compiler might take to inlining for this sort
 of example. This presentation considers three such approaches, all of which
 involve inline expansion of subprogram OUTER. (If OUTER is not inlined, the
 inlining reduces to a simpler single level subset of the two level approaches
 considered here.)
 The approaches are:
 1.    Inline both OUTER and INNER in all cases
 2.    Inline OUTER, multiple INNERs
       Treat INNER as a non-inlinable part of OUTER, compile and call a distinct
       normal version of INNER deoned within each inlining of OUTER.
 3.    Inline OUTER, one INNER
       Compile INNER as a single normal subprogram which is called from every
       inlining of OUTER.
 This discussion does not consider why a compiler might choose one of these
 approaches; it considers only how to describe the result.
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 350
                                       Appendix D.  Examples (Informative)
In the examples that follow in this section, the debugging information entries are
given mnemonic labels of the following form
        <io>.<ac>.<n>.<s>
where
!io?      is either INNER or OUTER to indicate to which subprogram the debugging
          information entry applies,
!ac?      is either AI or CI to indicate iabstract instancej or iconcrete instancej
          respectively,
!n?      is the number of the alternative being considered, and
!s?     is a sequence number that distinguishes the individual entries.
There is no implication that symbolic labels, nor any particular naming
convention, are required in actual use.
For conciseness, declaration coordinates and call coordinates are omitted.
D.7.1           Alternative #1:  inline both OUTER and INNER
A suitable abstract instance for an alternative where both OUTER and INNER are
always inlined is shown in Figure D.46 on the following page.
Notice in Figure D.46 that the debugging information entry for INNER (labelled
INNER.AI.1.1$) is nested in (is a child of) that for OUTER (labelled
OUTER.AI.1.1$). Nonetheless, the abstract instance tree for INNER is considered
to be separate and distinct from that for OUTER.
The call of OUTER shown in Figure D.45 on the previous page might be described
as shown in Figure D.47 on page 353.
D.7.2           Alternative #2:  Inline OUTER, multiple INNERs
In the second alternative we assume that subprogram INNER is not inlinable for
some reason, but subprogram OUTER is inlinable. Each concrete inlined instance
of OUTER has its own normal instance of INNER. The abstract instance for OUTER,
which includes INNER, is shown in Figure D.48 on page 355.
Note that the debugging information in Figure D.48 dioeers from that in Figure
D.46 on the following page in that INNER lacks a DW.AT.inline attribute and
therefore is not a distinct abstract instance. INNER is merely an out-of-line routine
that is part of OUTER's abstract instance. This is reAEected in the Figure by the fact
that the labels for INNER use the substring OUTER instead of INNER.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 351
                                       Appendix D.  Examples (Informative)
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
__________________________________________________________________________________________________________________________________________________||||
|       !  Abstract  instance  for  OUTER                                                                                                          |
||      !                                                                                                                                          ||
|OUTER.AI.1.1$:                                                                                                                                    |
||      DW_TAG_subprogram                                                                                                                          ||
||             DW_AT_name("OUTER")                                                                                                                 ||
|              DW_AT_inline(DW_INL_declared_inlined)                                                                                               |
||             !  No  low/high  PCs                                                                                                                ||
|OUTER.AI.1.2$:                                                                                                                                    |
||             DW_TAG_formal_parameter                                                                                                             ||
||                    DW_AT_name("OUTER_FORMAL")                                                                                                   ||
|                     DW_AT_type(reference  to  integer)                                                                                           |
||                    !  No  location                                                                                                              ||
|OUTER.AI.1.3$:                                                                                                                                    |
||             DW_TAG_variable                                                                                                                     ||
||                    DW_AT_name("OUTER_LOCAL")                                                                                                    ||
|                     DW_AT_type(reference  to  integer)                                                                                           |
||                    !  No  location                                                                                                              ||
|              !                                                                                                                                   |
||             !  Abstract  instance  for  INNER                                                                                                   ||
||             !                                                                                                                                   ||
|INNER.AI.1.1$:                                                                                                                                    |
||             DW_TAG_subprogram                                                                                                                   ||
|                     DW_AT_name("INNER")                                                                                                          |
||                    DW_AT_inline(DW_INL_declared_inlined)                                                                                        ||
|                     !  No  low/high  PCs                                                                                                         |
|INNER.AI.1.2$:|                                                                                                                                   ||
||                    DW_TAG_formal_parameter                                                                                                      ||
|                            DW_AT_name("INNER_FORMAL")                                                                                            |
||                           DW_AT_type(reference  to  integer)                                                                                    ||
|                            !  No  location                                                                                                       |
|INNER.AI.1.3$:|                                                                                                                                   ||
||                    DW_TAG_variable                                                                                                              ||
|                            DW_AT_name("INNER_LOCAL")                                                                                             |
||                           DW_AT_type(reference  to  integer)                                                                                    ||
|                            !  No  location                                                                                                       |
||                    ...                                                                                                                          ||
||                    0                                                                                                                            ||
|              !  No  DW_TAG_inlined_subroutine  (concrete  instance)                                                                              |
||             !  for  INNER  corresponding  to  calls  of  INNER                                                                                  ||
|              ...                                                                                                                                 |
||_____________0__________________________________________________________________________________________________________________________________ ||
                           Figure D.46: Inlining example #1: abstract instance
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 352
|                                                                                                                                                  |
||                                     Appendix D.  Examples (Informative)                                                                         ||
|                                                                                                                                                  |
|                                                                                                                                                  |
__________________________________________________________________________________________________________________________________________________||||
|!  Concrete  instance  for  call  "OUTER(7)"                                                                                                      |
|!|                                                                                                                                                ||
|OUTER.CI.1.1$:|                                                                                                                                   ||
|       DW_TAG_inlined_subroutine                                                                                                                  |
||             !  No  name                                                                                                                         ||
|              DW_AT_abstract_origin(reference  to  OUTER.AI.1.1$)                                                                                 |
||             DW_AT_low_pc(...)                                                                                                                   ||
|              DW_AT_high_pc(...)                                                                                                                  |
|OUTER.CI.1.2$:|                                                                                                                                   ||
||             DW_TAG_formal_parameter                                                                                                             ||
|                     !  No  name                                                                                                                  |
||                    DW_AT_abstract_origin(reference  to  OUTER.AI.1.2$)                                                                          ||
|                     DW_AT_const_value(7)                                                                                                         |
|OUTER.CI.1.3$:|                                                                                                                                   ||
||             DW_TAG_variable                                                                                                                     ||
|                     !  No  name                                                                                                                  |
||                    DW_AT_abstract_origin(reference  to  OUTER.AI.1.3$)                                                                          ||
|                     DW_AT_location(...)                                                                                                          |
||             !                                                                                                                                   ||
||             !  No  DW_TAG_subprogram  (abstract  instance)  for  INNER                                                                          ||
|              !                                                                                                                                   |
||             !  Concrete  instance  for  call  INNER(OUTER_LOCAL)                                                                                ||
|              !                                                                                                                                   |
|INNER.CI.1.1$:|                                                                                                                                   ||
||             DW_TAG_inlined_subroutine                                                                                                           ||
|                     !  No  name                                                                                                                  |
||                    DW_AT_abstract_origin(reference  to  INNER.AI.1.1$)                                                                          ||
|                     DW_AT_low_pc(...)                                                                                                            |
||                    DW_AT_high_pc(...)                                                                                                           ||
|                     DW_AT_static_link(...)                                                                                                       |
|INNER.CI.1.2$:|                                                                                                                                   ||
||                    DW_TAG_formal_parameter                                                                                                      ||
|                            !  No  name                                                                                                           |
||                           DW_AT_abstract_origin(reference  to  INNER.AI.1.2$)                                                                   ||
|                            DW_AT_location(...)                                                                                                   |
|INNER.CI.1.3$:|                                                                                                                                   ||
||                    DW_TAG_variable                                                                                                              ||
|                            !  No  name                                                                                                           |
||                           DW_AT_abstract_origin(reference  to  INNER.AI.1.3$)                                                                   ||
|                            DW_AT_location(...)                                                                                                   |
||                    ...                                                                                                                          ||
||                    0                                                                                                                            ||
|              !  Another  concrete  instance  of  INNER  within  OUTER                                                                            |
||             !  for  the  call  "INNER(31)"                                                                                                      ||
|              ...                                                                                                                                 |
||_____________0__________________________________________________________________________________________________________________________________ ||
                           Figure D.47: Inlining example #1: concrete instance
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 353
                                       Appendix D.  Examples (Informative)
A resulting concrete inlined instance of OUTER is shown in Figure D.49 on
page 357.
Notice in Figure D.49 that OUTER is expanded as a concrete inlined instance, and
that INNER is nested within it as a concrete out-of-line subprogram. Because
INNER is cloned for each inline expansion of OUTER, only the invariant attributes
of INNER (for example, DW.AT.name) are specioed in the abstract instance of
OUTER, and the low-level, instance-specioc attributes of INNER (for example,
DW.AT.low.pc) are specioed in each concrete instance of OUTER.
The several calls of INNER within OUTER are compiled as normal calls to the
instance of INNER that is specioc to the same instance of OUTER that contains the
calls.
D.7.3           Alternative #3:  inline OUTER, one normal INNER
In the third approach, one normal subprogram for INNER is compiled which is
called from all concrete inlined instances of  OUTER. The abstract instance for
OUTER is shown in Figure D.50 on page 358.
The most distinctive aspect of that Figure is that subprogram INNER exists only
within the abstract instance of OUTER, and not in OUTER's concrete instance. In the
abstract  instance of OUTER, the description of INNER has the full complement of
attributes that would be expected for a normal subprogram. While attributes
such as DW.AT.low.pc, DW.AT.high.pc, DW.AT.location, and so on,
typically are omitted from an abstract instance because they are not invariant
across instances of the containing abstract instance, in this case those same
attributes are included precisely because they are invariant ~ there is only one
subprogram INNER to be described and every description is the same.
A concrete inlined instance of OUTER is illustrated in Figure D.51 on page 359.
Notice in Figure D.51 that there is no DWARF representation for INNER at all; the
representation of INNER does not vary across instances of OUTER and the abstract
instance of OUTER includes the complete description of INNER, so that the
description of INNER may be (and for reasons of space eOEciency, should be)
omitted from each concrete instance of OUTER.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 354
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                      Appendix D.  Examples (Informative)                                                                         |
|                                                                                                                                                  |
|                                                                                                                                                  |
__________________________________________________________________________________________________________________________________________________||
|       !  Abstract  instance  for  OUTER                                                                                                          |
||      !  abstract  instance                                                                                                                      ||
|OUTER.AI.2.1$:|                                                                                                                                   ||
|       DW_TAG_subprogram                                                                                                                          |
||             DW_AT_name("OUTER")                                                                                                                 ||
|              DW_AT_inline(DW_INL_declared_inlined)                                                                                               |
||             !  No  low/high  PCs                                                                                                                ||
|OUTER.AI.2.2$:|                                                                                                                                   ||
|              DW_TAG_formal_parameter                                                                                                             |
||                    DW_AT_name("OUTER_FORMAL")                                                                                                   ||
|                     DW_AT_type(reference  to  integer)                                                                                           |
||                    !  No  location                                                                                                              ||
|OUTER.AI.2.3$:|                                                                                                                                   ||
|              DW_TAG_variable                                                                                                                     |
||                    DW_AT_name("OUTER_LOCAL")                                                                                                    ||
|                     DW_AT_type(reference  to  integer)                                                                                           |
||                    !  No  location                                                                                                              ||
||             !                                                                                                                                   ||
|              !  Nested  out-of-line  INNER  subprogram                                                                                           |
||             !                                                                                                                                   ||
|OUTER.AI.2.4$:                                                                                                                                    |
||             DW_TAG_subprogram                                                                                                                   ||
|                     DW_AT_name("INNER")                                                                                                          |
||                    !  No  DW_AT_inline                                                                                                          ||
||                    !  No  low/high  PCs,  frame_base,  etc.                                                                                     ||
|OUTER.AI.2.5$:                                                                                                                                    |
||                    DW_TAG_formal_parameter                                                                                                      ||
|                            DW_AT_name("INNER_FORMAL")                                                                                            |
||                           DW_AT_type(reference  to  integer)                                                                                    ||
||                           !  No  location                                                                                                       ||
|OUTER.AI.2.6$:                                                                                                                                    |
||                    DW_TAG_variable                                                                                                              ||
|                            DW_AT_name("INNER_LOCAL")                                                                                             |
||                           DW_AT_type(reference  to  integer)                                                                                    ||
||                           !  No  location                                                                                                       ||
|                     ...                                                                                                                          |
||                    0                                                                                                                            ||
|              ...                                                                                                                                 |
||_____________0__________________________________________________________________________________________________________________________________ ||
                           Figure D.48: Inlining example #2: abstract instance
There is one aspect of this approach that is problematical from the DWARF
perspective. The single compiled instance of INNER is assumed to access up-level
variables of OUTER; however, those variables may well occur at varying positions
within the frames that contain the concrete inlined instances. A compiler might
implement this in several ways, including the use of additional
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 355
                                       Appendix D.  Examples (Informative)
compiler-generated parameters that provide reference parameters for the
up-level variables, or a compiler-generated static link like parameter that points
to the group of up-level entities, among other possibilities. In either of these
cases, the DWARF description for the location attribute of each uplevel variable
needs to be dioeerent if accessed from within INNER compared to when accessed
from within the instances of OUTER. An implementation is likely to require
producer-specioc DWARF attributes and/or debugging information entries to
describe such cases.
Note that in C++, a member function of a class deoned within a function
deonition does not require any producer-specioc extensions because the C++
language disallows access to entities that would give rise to this problem.
(Neither extern variables nor static members require any form of static link for
accessing purposes.)
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 356
|                                      Appendix D.  Examples (Informative)                                                                         |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
__________________________________________________________________________________________________________________________________________________||||
||      !  Concrete  instance  for  call  "OUTER(7)"                                                                                               ||
||      !                                                                                                                                          ||
|OUTER.CI.2.1$:                                                                                                                                    |
||      DW_TAG_inlined_subroutine                                                                                                                  ||
|              !  No  name                                                                                                                         |
||             DW_AT_abstract_origin(reference  to  OUTER.AI.2.1$)                                                                                 ||
||             DW_AT_low_pc(...)                                                                                                                   ||
|              DW_AT_high_pc(...)                                                                                                                  |
|OUTER.CI.2.2$:|                                                                                                                                   ||
|              DW_TAG_formal_parameter                                                                                                             |
||                    !  No  name                                                                                                                  ||
||                    DW_AT_abstract_origin(reference  to  OUTER.AI.2.2$)                                                                          ||
|                     DW_AT_location(...)                                                                                                          |
|OUTER.CI.2.3$:|                                                                                                                                   ||
|              DW_TAG_variable                                                                                                                     |
||                    !  No  name                                                                                                                  ||
||                    DW_AT_abstract_origin(reference  to  OUTER.AI.2.3$)                                                                          ||
|                     DW_AT_location(...)                                                                                                          |
||             !                                                                                                                                   ||
|              !  Nested  out-of-line  INNER  subprogram                                                                                           |
||             !                                                                                                                                   ||
|OUTER.CI.2.4$:|                                                                                                                                   ||
|              DW_TAG_subprogram                                                                                                                   |
||                    !  No  name                                                                                                                  ||
|                     DW_AT_abstract_origin(reference  to  OUTER.AI.2.4$)                                                                          |
||                    DW_AT_low_pc(...)                                                                                                            ||
|                     DW_AT_high_pc(...)                                                                                                           |
||                    DW_AT_frame_base(...)                                                                                                        ||
||                    DW_AT_static_link(...)                                                                                                       ||
|OUTER.CI.2.5$:                                                                                                                                    |
||                    DW_TAG_formal_parameter                                                                                                      ||
|                            !  No  name                                                                                                           |
||                           DW_AT_abstract_origin(reference  to  OUTER.AI.2.5$)                                                                   ||
||                           DW_AT_location(...)                                                                                                   ||
|OUTER.CI.2.6$:                                                                                                                                    |
||                    DW_TAG_variable                                                                                                              ||
|                            !  No  name                                                                                                           |
||                           DW_AT_abstract_origin(reference  to  OUTER.AT.2.6$)                                                                   ||
||                           DW_AT_location(...)                                                                                                   ||
|                     ...                                                                                                                          |
||                    0                                                                                                                            ||
|              ...                                                                                                                                 |
||_____________0__________________________________________________________________________________________________________________________________ ||
                           Figure D.49: Inlining example #2: concrete instance
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 357
                                       Appendix D.  Examples (Informative)
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
__________________________________________________________________________________________________________________________________________________||||
|       !  Abstract  instance  for  OUTER                                                                                                          |
||      !                                                                                                                                          ||
|OUTER.AI.3.1$:                                                                                                                                    |
||      DW_TAG_subprogram                                                                                                                          ||
||             DW_AT_name("OUTER")                                                                                                                 ||
|              DW_AT_inline(DW_INL_declared_inlined)                                                                                               |
||             !  No  low/high  PCs                                                                                                                ||
|OUTER.AI.3.2$:                                                                                                                                    |
||             DW_TAG_formal_parameter                                                                                                             ||
||                    DW_AT_name("OUTER_FORMAL")                                                                                                   ||
|                     DW_AT_type(reference  to  integer)                                                                                           |
||                    !  No  location                                                                                                              ||
|OUTER.AI.3.3$:                                                                                                                                    |
||             DW_TAG_variable                                                                                                                     ||
||                    DW_AT_name("OUTER_LOCAL")                                                                                                    ||
|                     DW_AT_type(reference  to  integer)                                                                                           |
||                    !  No  location                                                                                                              ||
|              !                                                                                                                                   |
||             !  Normal  INNER                                                                                                                    ||
||             !                                                                                                                                   ||
|OUTER.AI.3.4$:                                                                                                                                    |
||             DW_TAG_subprogram                                                                                                                   ||
|                     DW_AT_name("INNER")                                                                                                          |
||                    DW_AT_low_pc(...)                                                                                                            ||
|                     DW_AT_high_pc(...)                                                                                                           |
||                    DW_AT_frame_base(...)                                                                                                        ||
||                    DW_AT_static_link(...)                                                                                                       ||
|OUTER.AI.3.5$:                                                                                                                                    |
||                    DW_TAG_formal_parameter                                                                                                      ||
|                            DW_AT_name("INNER_FORMAL")                                                                                            |
||                           DW_AT_type(reference  to  integer)                                                                                    ||
||                           DW_AT_location(...)                                                                                                   ||
|OUTER.AI.3.6$:                                                                                                                                    |
||                    DW_TAG_variable                                                                                                              ||
|                            DW_AT_name("INNER_LOCAL")                                                                                             |
||                           DW_AT_type(reference  to  integer)                                                                                    ||
||                           DW_AT_location(...)                                                                                                   ||
|                     ...                                                                                                                          |
||                    0                                                                                                                            ||
|              ...                                                                                                                                 |
||_____________0__________________________________________________________________________________________________________________________________ ||
                           Figure D.50: Inlining example #3: abstract instance
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 358
 |                                      Appendix D.  Examples (Informative)                                                                         |
 |                                                                                                                                                  |
 __________________________________________________________________________________________________________________________________________________||*
 *||
 |       !  Concrete  instance  for  call  "OUTER(7)"                                                                                               |
 ||      !                                                                                                                                          ||
 |OUTER.CI.3.1$:|                                                                                                                                   ||
 |       DW_TAG_inlined_subroutine                                                                                                                  |
 ||             !  No  name                                                                                                                         ||
 |              DW_AT_abstract_origin(reference  to  OUTER.AI.3.1$)                                                                                 |
 ||             DW_AT_low_pc(...)                                                                                                                   ||
 |              DW_AT_high_pc(...)                                                                                                                  |
 ||             DW_AT_frame_base(...)                                                                                                               ||
 |OUTER.CI.3.2$:|                                                                                                                                   ||
 |              DW_TAG_formal_parameter                                                                                                             |
 ||                    !  No  name                                                                                                                  ||
 |                     DW_AT_abstract_origin(reference  to  OUTER.AI.3.2$)                                                                          |
 ||                    !  No  type                                                                                                                  ||
 ||                    DW_AT_location(...)                                                                                                          ||
 |OUTER.CI.3.3$:                                                                                                                                    |
 ||             DW_TAG_variable                                                                                                                     ||
 |                     !  No  name                                                                                                                  |
 ||                    DW_AT_abstract_origin(reference  to  OUTER.AI.3.3$)                                                                          ||
 ||                    !  No  type                                                                                                                  ||
 |                     DW_AT_location(...)                                                                                                          |
 ||             !  No  DW_TAG_subprogram  for  "INNER"                                                                                              ||
 |              ...                                                                                                                                 |
 ||_____________0__________________________________________________________________________________________________________________________________ ||
                            Figure D.51: Inlining example #3: concrete instance
 D.8            Constant  Expression  Example
 C++ generalizes the notion of constant expressions to include constant
 expression user-deoned literals and functions. The constant declarations in
 Figure D.52 can be represented as illustrated in Figure D.53 on the next page.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||cd*
 *oonusbtleexmpars=s9 . 8 ;
|||=============================================================================================================================================|||ci*
 *onntsstqeuxaprre(ixn)t{rxe*txu;r}n
|||=============================================================================================================================================|||fa*
 *lrora[ts(q9u)a]r;e//s(q)ucaarlelaenddi_n|l_i_n_e|d
                               Figure D.52: Constant expressions: C++ source
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 359
                                       Appendix D.  Examples (Informative)
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
__________________________________________________________________________________________________________________________________________________||
||             !  For  variable  mass                                                                                                              ||
|              !                                                                                                                                   |
|1$:|        DW_TAG_const_type                                                                                                                     ||
|                     DW_AT_type(reference  to  "double")                                                                                          |
|2$:|        DW_TAG_variable                                                                                                                       ||
||                    DW_AT_name("mass")                                                                                                           ||
|                     DW_AT_type(reference  to  1$)                                                                                                |
||                    DW_AT_const_expr(true)                                                                                                       ||
|                     DW_AT_const_value(9.8)                                                                                                       |
||             !  Abstract  instance  for  square                                                                                                  ||
||             !                                                                                                                                   ||
|10$:       DW_TAG_subprogram                                                                                                                      |
||                    DW_AT_name("square")                                                                                                         ||
|                     DW_AT_type(reference  to  "int")                                                                                             |
||                    DW_AT_inline(DW_INL_inlined)                                                                                                 ||
|11$:              DW_TAG_formal_parameter                                                                                                         |
||                           DW_AT_name("x")                                                                                                       ||
||                           DW_AT_type(reference  to  "int")                                                                                      ||
|              !  Concrete  instance  for  square(9)                                                                                               |
||             !                                                                                                                                   ||
|20$:       DW_TAG_inlined_subroutine                                                                                                              |
||                    DW_AT_abstract_origin(reference  to  10$)                                                                                    ||
||                    DW_AT_const_expr(present)                                                                                                    ||
|                     DW_AT_const_value(81)                                                                                                        |
||                    DW_TAG_formal_parameter                                                                                                      ||
|                            DW_AT_abstract_origin(reference  to  11$)                                                                             |
||                           DW_AT_const_value(9)                                                                                                  ||
||             !  Anonymous  array  type  for  arr                                                                                                 ||
|              !                                                                                                                                   |
|30$:|      DW_TAG_array_type                                                                                                                      ||
|                     DW_AT_type(reference  to  "float")                                                                                           |
||                    DW_AT_byte_size(324)  !  81*4                                                                                                ||
|                     DW_TAG_subrange_type                                                                                                         |
||                           DW_AT_type(reference  to  "int")                                                                                      ||
||                           DW_AT_upper_bound(reference  to  20$)                                                                                 ||
|              !  Variable  arr                                                                                                                    |
||             !                                                                                                                                   ||
|40$:       DW_TAG_variable                                                                                                                        |
||                    DW_AT_name("arr")                                                                                                            ||
||____________________DW_AT_type(reference__to__30$)______________________________________________________________________________________________ ||
                       Figure D.53: Constant expressions: DWARF description
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 360
                                        Appendix D.  Examples (Informative)
 D.9            Unicode  Character  Example
 The Unicode character encodings in Figure D.54 can be described in DWARF as
 illustrated in Figure D.55.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||//*
 *C++s o u r c e
|||=============================================================================================================================================|||//
|||=============================================================================================================================================|||cc*
 *hharr_1a6=_ut'h';
|||=============================================================================================================================================|||cc*
 *hharr_3b2=_Ut'h';_|_____|
                              Figure D.54: Unicode character example: source
 |                                                                                                                                                  |
 __________________________________________________________________________________________________________________________________________________||*
 *||
 |!| DWARF  description                                                                                                                             ||
 |!                                                                                                                                                 |
 |1$:| DW_TAG_base_type                                                                                                                             ||
 ||             DW_AT_name("char16_t")                                                                                                              ||
 |              DW_AT_encoding(DW_ATE_UTF)                                                                                                          |
 ||             DW_AT_byte_size(2)                                                                                                                  ||
 |2$:  DW_TAG_base_type                                                                                                                             |
 ||             DW_AT_name("char32_t")                                                                                                              ||
 |              DW_AT_encoding(DW_ATE_UTF)                                                                                                          |
 ||             DW_AT_byte_size(4)                                                                                                                  ||
 |3$:| DW_TAG_variable                                                                                                                              ||
 |              DW_AT_name("chr_a")                                                                                                                 |
 ||             DW_AT_type(reference  to  1$)                                                                                                       ||
 |4$:  DW_TAG_variable                                                                                                                              |
 ||             DW_AT_name("chr_b")                                                                                                                 ||
 ||_____________DW_AT_type(reference__to__2$)______________________________________________________________________________________________________ ||
                  Figure D.55: Unicode character example: DWARF description
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 361
                                        Appendix D.  Examples (Informative)
 D.10              Type-Safe  Enumeration  Example
 The C++ type-safe enumerations in Figure D.56 can be described in DWARF as
 illustrated in Figure D.57.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||//*
 *C++s o u r c e
|||=============================================================================================================================================|||//
|||=============================================================================================================================================|||ec*
 *nluamsEs{E1,E2=}1;0 0
|||=============================================================================================================================================|||Ee*
 *1;_|_____|
                          Figure D.56: Type-safe enumeration example: source
 __________________________________________________________________________________________________________________________________________________||*
 *||
 |!  DWARF  description                                                                                                                             |
 |!|                                                                                                                                                ||
 |11$:|   DW_TAG_enumeration_type                                                                                                                   ||
 |                  DW_AT_name("E")                                                                                                                 |
 ||                 DW_AT_type(reference  to  "int")                                                                                                ||
 |                  DW_AT_enum_class(present)                                                                                                       |
 |12$:|          DW_TAG_enumerator                                                                                                                  ||
 |                         DW_AT_name("E1")                                                                                                         |
 ||                        DW_AT_const_value(0)                                                                                                     ||
 |13$:|          DW_TAG_enumerator                                                                                                                  ||
 |                         DW_AT_name("E2")                                                                                                         |
 ||                        DW_AT_const_value(100)                                                                                                   ||
 |14$:    DW_TAG_variable                                                                                                                           |
 ||                 DW_AT_name("e1")                                                                                                                ||
 ||_________________DW_AT_type(reference__to__11$)_________________________________________________________________________________________________ ||
              Figure D.57: Type-safe enumeration example: DWARF description
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 362
                                        Appendix D.  Examples (Informative)
 D.11              Template  Examples
 The C++ template example in Figure D.58 can be described in DWARF as
 illustrated in Figure D.59.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||//*
 *C++s o u r c e
|||=============================================================================================================================================|||//
|||=============================================================================================================================================|||t<*
 *ecmlpalsastTe>
|||=============================================================================================================================================|||sw*
 *trraupcpte{r
|||=============================================================================================================================================|||Tc*
 *;o m p
|||=============================================================================================================================================|||};
|||=============================================================================================================================================|||w<*
 *rianptp>eorb;j_|_____|
                                Figure D.58: C++ template example #1: source
 |                                                                                                                                                  |
 __________________________________________________________________________________________________________________________________________________||
 |!| DWARF  description                                                                                                                             ||
 |!                                                                                                                                                 |
 |11$:|   DW_TAG_structure_type                                                                                                                     ||
 |                  DW_AT_name("wrapper")                                                                                                           |
 |12$:|          DW_TAG_template_type_parameter                                                                                                     ||
 |                         DW_AT_name("T")                                                                                                          |
 ||                        DW_AT_type(reference  to  "int")                                                                                         ||
 |13$:|          DW_TAG_member                                                                                                                      ||
 |                         DW_AT_name("comp")                                                                                                       |
 ||                        DW_AT_type(reference  to  12$)                                                                                           ||
 |14$:    DW_TAG_variable                                                                                                                           |
 ||                 DW_AT_name("obj")                                                                                                               ||
 ||_________________DW_AT_type(reference__to__11$)_________________________________________________________________________________________________ ||
                    Figure D.59: C++ template example #1: DWARF description
 The actual type of the component comp is int, but in the DWARF the type
 references the DW.TAG.template.type.parameter for T, which in turn
 references int. This implies that in the original template comp was of type T and
 that was replaced with int in the instance.
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 363
                                        Appendix D.  Examples (Informative)
 There exist situations where it is not possible for the DWARF to imply anything
 about the nature of the original template. Consider the C++ template source in
 Figure D.60 and the DWARF that can describe it in Figure D.61.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||//*
 *C++s o u r c e
|||=============================================================================================================================================|||//
|||=============================================================================================================================================|||t<*
 *ecmlpalsastTe>
|||=============================================================================================================================================|||sw*
 *trraupcpte{r
|||=============================================================================================================================================|||Tc*
 *;o m p
|||=============================================================================================================================================|||};
|||=============================================================================================================================================|||t<*
 *ecmlpalsastUe>
|||=============================================================================================================================================|||vc*
 *ooinds(uwmrea<pUp>efro)r m a l
|||=============================================================================================================================================|||{
|||=============================================================================================================================================|||. *
 *. .
|||=============================================================================================================================================|||}
|||=============================================================================================================================================|||w<*
 *rianptp>eorb;j
|||=============================================================================================================================================|||c(*
 *oonbsju)m;e_|_____|
                                Figure D.60: C++ template example #2: source
 |                                                                                                                                                  |
 |                                                                                                                                                  |
 __________________________________________________________________________________________________________________________________________________||
 |!| DWARF  description                                                                                                                             ||
 |!                                                                                                                                                 |
 |11$:|   DW_TAG_structure_type                                                                                                                     ||
 ||                 DW_AT_name("wrapper")                                                                                                           ||
 |12$:           DW_TAG_template_type_parameter                                                                                                     |
 ||                        DW_AT_name("T")                                                                                                          ||
 |                         DW_AT_type(reference  to  "int")                                                                                         |
 |13$:|          DW_TAG_member                                                                                                                      ||
 ||                        DW_AT_name("comp")                                                                                                       ||
 |                         DW_AT_type(reference  to  12$)                                                                                           |
 |14$:|   DW_TAG_variable                                                                                                                           ||
 |                  DW_AT_name("obj")                                                                                                               |
 ||                 DW_AT_type(reference  to  11$)                                                                                                  ||
 |21$:    DW_TAG_subprogram                                                                                                                         |
 ||                 DW_AT_name("consume")                                                                                                           ||
 |22$:|          DW_TAG_template_type_parameter                                                                                                     ||
 |                         DW_AT_name("U")                                                                                                          |
 ||                        DW_AT_type(reference  to  "int")                                                                                         ||
 |23$:           DW_TAG_formal_parameter                                                                                                            |
 ||                        DW_AT_name("formal")                                                                                                     ||
 ||________________________DW_AT_type(reference__to__11$)__________________________________________________________________________________________ ||
                    Figure D.61: C++ template example #2: DWARF description
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 364
                                        Appendix D.  Examples (Informative)
 In the DW.TAG.subprogram entry for the instance of consume, U is described as
 int. The type of formal is wrapper<U> in the source. DWARF only represents
 instantiations of templates; there is no entry which represents wrapper<U> which
 is neither a template parameter nor a template instantiation. The type of formal is
 described as wrapper<int>, the instantiation of wrapper<U>, in the DW.AT.type
 attribute at 23$. There is no description of the relationship between template type
 parameter T at 12$ and U at 22$ which was used to instantiate wrapper<U>.
 A consequence of this is that the DWARF information would not distinguish
 between the existing example and one where the formal parameter of consume
 were declared in the source to be wrapper<int>.
 D.12              Template  Alias  Examples
 The C++ template alias shown in Figure D.62 can be described in DWARF as
 illustrated in Figure D.63 on the next page.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||//*
 *C++s,otuermcpelaaltieaesx1a m p l e
|||=============================================================================================================================================|||//
|||=============================================================================================================================================|||t<*
 *etmyppleantaemTe,tUy>p e n a m e
|||=============================================================================================================================================|||sA*
 *tlrpuhcat{
|||=============================================================================================================================================|||Tt*
 *;a n g o
|||=============================================================================================================================================|||Uu*
 *;n i f o r m
|||=============================================================================================================================================|||};
|||=============================================================================================================================================|||t<*
 *etmyppleantaemVe>uBseitnag=Alpha<V,V>;
|||=============================================================================================================================================|||Be*
 *ta<long>b;_|_____|
                           Figure D.62: C++ template alias example #1: source
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 365
 |                                      Appendix D.  Examples (Informative)                                                                         |
 |                                                                                                                                                  |
 |                                                                                                                                                  |
 __________________________________________________________________________________________________________________________________________________||
 |!  DWARF  representation  for  variable  'b'                                                                                                      |
 |!|                                                                                                                                                ||
 |20$:|   DW_TAG_structure_type                                                                                                                     ||
 |                  DW_AT_name("Alpha")                                                                                                             |
 |21$:|          DW_TAG_template_type_parameter                                                                                                     ||
 |                         DW_AT_name("T")                                                                                                          |
 ||                        DW_AT_type(reference  to  "long")                                                                                        ||
 |22$:|          DW_TAG_template_type_parameter                                                                                                     ||
 |                         DW_AT_name("U")                                                                                                          |
 ||                        DW_AT_type(reference  to  "long")                                                                                        ||
 |23$:           DW_TAG_member                                                                                                                      |
 ||                        DW_AT_name("tango")                                                                                                      ||
 ||                        DW_AT_type(reference  to  21$)                                                                                           ||
 |24$:           DW_TAG_member                                                                                                                      |
 ||                        DW_AT_name("uniform")                                                                                                    ||
 |                         DW_AT_type(reference  to  22$)                                                                                           |
 |25$:|   DW_TAG_template_alias                                                                                                                     ||
 |                  DW_AT_name("Beta")                                                                                                              |
 ||                 DW_AT_type(reference  to  20$)                                                                                                  ||
 |26$:|          DW_TAG_template_type_parameter                                                                                                     ||
 |                         DW_AT_name("V")                                                                                                          |
 ||                        DW_AT_type(reference  to  "long")                                                                                        ||
 |27$:    DW_TAG_variable                                                                                                                           |
 ||                 DW_AT_name("b")                                                                                                                 ||
 ||_________________DW_AT_type(reference__to__25$)_________________________________________________________________________________________________ ||
               Figure D.63: C++ template alias example #1: DWARF description
 Similarly, the C++ template alias shown in Figure D.64 can be described in
 DWARF as illustrated in Figure D.65 on the next page.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||//*
 *C++s,otuermcpelaaltieaesx2a m p l e
|||=============================================================================================================================================|||//
|||=============================================================================================================================================|||t<*
 *ecmlpalsastTeX>sXt{r}u;c t
|||=============================================================================================================================================|||t<*
 *ecmlpalsastTeY>sYt{r}u;c t
|||=============================================================================================================================================|||t<*
 *ecmlpalsastTe>uZs=iYn<gT>;
|||=============================================================================================================================================|||X<*
 *Y<int>y>;
|||=============================================================================================================================================|||X<*
 *Z<int>z>;_|_____|
                           Figure D.64: C++ template alias example #2: source
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 366
                                       Appendix D.  Examples (Informative)
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
__________________________________________________________________________________________________________________________________________________||
|!| DWARF  representation  for  X<Y<int>>                                                                                                          ||
|!                                                                                                                                                 |
|30$:|   DW_TAG_structure_type                                                                                                                     ||
|                  DW_AT_name("Y")                                                                                                                 |
|31$:|          DW_TAG_template_type_parameter                                                                                                     ||
||                        DW_AT_name("TY")                                                                                                         ||
|                         DW_AT_type(reference  to  "int")                                                                                         |
|32$:|   DW_TAG_structure_type                                                                                                                     ||
|                  DW_AT_name("X")                                                                                                                 |
|33$:|          DW_TAG_template_type_parameter                                                                                                     ||
|                         DW_AT_name("TX")                                                                                                         |
||                        DW_AT_type(reference  to  30$)                                                                                           ||
|!|                                                                                                                                                ||
|!  DWARF  representation  for  X<Z<int>>                                                                                                          |
|!|                                                                                                                                                ||
|40$:    DW_TAG_template_alias                                                                                                                     |
||                 DW_AT_name("Z")                                                                                                                 ||
||                 DW_AT_type(reference  to  30$)                                                                                                  ||
|41$:           DW_TAG_template_type_parameter                                                                                                     |
||                        DW_AT_name("T")                                                                                                          ||
|                         DW_AT_type(reference  to  "int")                                                                                         |
|42$:|   DW_TAG_structure_type                                                                                                                     ||
||                 DW_AT_name("X")                                                                                                                 ||
|43$:           DW_TAG_template_type_parameter                                                                                                     |
||                        DW_AT_name("TX")                                                                                                         ||
|                         DW_AT_type(reference  to  40$)                                                                                           |
|!|                                                                                                                                                ||
|!  Note  that  32$  and  42$  are  actually  the  same  type                                                                                      |
|!|                                                                                                                                                ||
|50$:|   DW_TAG_variable                                                                                                                           ||
|                  DW_AT_name("y")                                                                                                                 |
||                 DW_AT_type(reference  to  $32)                                                                                                  ||
|51$:    DW_TAG_variable                                                                                                                           |
||                 DW_AT_name("z")                                                                                                                 ||
||_________________DW_AT_type(reference__to__$42)_________________________________________________________________________________________________ ||
              Figure D.65: C++ template alias example #2: DWARF description
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 367
                                        Appendix D.  Examples (Informative)
 D.13              Implicit  Pointer  Examples
 If the compiler determines that the value of an object is constant (either
 throughout the program, or within a specioc range), the compiler may choose to
 materialize that constant only when used, rather than store it in memory or in a
 register. The DW.OP.implicit.value operation can be used to describe such a
 value. Sometimes, the value may not be constant, but still can be easily
 rematerialized when needed. A DWARF expression terminating in
 DW.OP.stack.value can be used for this case. The compiler may also eliminate
 a pointer value where the target of the pointer resides in memory, and the
 DW.OP.stack.value operator may be used to rematerialize that pointer value.
 In other cases, the compiler will eliminate a pointer to an object that itself needs
 to be materialized. Since the location of such an object cannot be represented as a
 memory address, a DWARF expression cannot give either the location or the
 actual value or a pointer variable that would refer to that object. The
 DW.OP.implicit.pointer operation can be used to describe the pointer, and the
 debugging information entry to which its orst operand refers describes the value
 of the dereferenced object. A DWARF consumer will not be able to show the
 location or the value of the pointer variable, but it will be able to show the value
 of the dereferenced pointer.
 Consider the C source shown in Figure D.66. Assume that the function foo is not
 inlined, that the argument x is passed in register 5, and that the function foo is
 optimized by the compiler into just an increment of the volatile variable v. Given
 these assumptions a possible DWARF description is shown in Figure D.67 on the
 next page.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||sS*
 *t{rsuhcotrat;cbh,acr;};
|||=============================================================================================================================================|||vi*
 *onltavt;i l e
|||=============================================================================================================================================|||vf*
 *ooiod(ixn)t
|||=============================================================================================================================================|||{
|||=============================================================================================================================================|||sS*
 *tsr=u{cxt,x+2x,+3};
|||=============================================================================================================================================|||c**
 *hpa=r&s.b;
|||=============================================================================================================================================|||s.*
 *a+ + ;
|||=============================================================================================================================================|||v+*
 * + ;
|||=============================================================================================================================================|||}
|||=============================================================================================================================================|||im*
 *nati(n)
|||=============================================================================================================================================|||{
|||=============================================================================================================================================|||f(*
 *ovo+;1 )
|||=============================================================================================================================================|||r0*
 *e;t u r n
|||=============================================================================================================================================|||}_*
 *|_____|
                            Figure D.66: C implicit pointer example #1: source
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 368
|                                                                                                                                                  |
||                                     Appendix D.  Examples (Informative)                                                                         ||
|                                                                                                                                                  |
__________________________________________________________________________________________________________________________________________________||
|1$:|    DW_TAG_structure_type                                                                                                                     ||
|                  DW_AT_name("S")                                                                                                                 |
||                 DW_AT_byte_size(4)                                                                                                              ||
|10$:|          DW_TAG_member                                                                                                                      ||
|                         DW_AT_name("a")                                                                                                          |
||                        DW_AT_type(reference  to  "short  int")                                                                                  ||
|                         DW_AT_data_member_location(constant  0)                                                                                  |
|11$:|          DW_TAG_member                                                                                                                      ||
|                         DW_AT_name("b")                                                                                                          |
||                        DW_AT_type(reference  to  "char")                                                                                        ||
||                        DW_AT_data_member_location(constant  2)                                                                                  ||
|12$:           DW_TAG_member                                                                                                                      |
||                        DW_AT_name("c")                                                                                                          ||
|                         DW_AT_type(reference  to  "char")                                                                                        |
||                        DW_AT_data_member_location(constant  3)                                                                                  ||
|2$:|    DW_TAG_subprogram                                                                                                                         ||
|                  DW_AT_name("foo")                                                                                                               |
|20$:|          DW_TAG_formal_parameter                                                                                                            ||
|                         DW_AT_name("x")                                                                                                          |
||                        DW_AT_type(reference  to  "int")                                                                                         ||
||                        DW_AT_location(DW_OP_reg5)                                                                                               ||
|21$:           DW_TAG_variable                                                                                                                    |
||                        DW_AT_name("s")                                                                                                          ||
|                         DW_AT_type(reference  to  S  at  1$)                                                                                     |
||                        DW_AT_location(expression=                                                                                               ||
|                               DW_OP_breg5(1)  DW_OP_stack_value  DW_OP_piece(2)                                                                  |
||                              DW_OP_breg5(2)  DW_OP_stack_value  DW_OP_piece(1)                                                                  ||
||                              DW_OP_breg5(3)  DW_OP_stack_value  DW_OP_piece(1))                                                                 ||
|22$:           DW_TAG_variable                                                                                                                    |
||                        DW_AT_name("p")                                                                                                          ||
|                         DW_AT_type(reference  to  "char  *")                                                                                     |
||                        DW_AT_location(expression=                                                                                               ||
||______________________________DW_OP_implicit_pointer(reference__to__21$,__2))___________________________________________________________________ ||
               Figure D.67: C implicit pointer example #1: DWARF description
In Figure D.67, even though variables s and p are both optimized away
completely, this DWARF description still allows a debugger to print the value of
the variable s, namely (2,  3,  4). Similarly, because the variable s does not live
in memory, there is nothing to print for the value of p, but the debugger should
still be able to show that p[0] is 3, p[1] is 4, p[-1] is 0 and p[-2] is 2.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 369
                                       Appendix D.  Examples (Informative)
As a further example, consider the C source shown in Figure D.68. Make the
following assumptions about how the code is compiled:
     #    The function foo is inlined into function main
     #    The body of the main function is optimized to just three blocks of
          instructions which each increment the volatile variable v, followed by a
          block of instructions to return 0 from the function
     #    Label label0 is at the start of the main function, label1 follows the orst v++
          block, label2 follows the second v++ block and label3 is at the end of the
          main function
     #    Variable b is optimized away completely, as it isn't used
     #    The string literal "opq" is optimized away as well
Given these assumptions a possible DWARF description is shown in Figure D.69
on|the|following page.                                                                                                                             ||
__________________________________________________________________________________________________________________________________________________||||
|static| const  char  *b  =  "opq";                                                                                                                ||
|volatile| int  v;                                                                                                                                 ||
|static  inline  void  foo  (int  *p)                                                                                                              |
|{|                                                                                                                                                ||
|       (*p)++;                                                                                                                                    |
||      v++;                                                                                                                                       ||
|       p++;                                                                                                                                       |
||      (*p)++;                                                                                                                                    ||
||      v++;                                                                                                                                       ||
|}                                                                                                                                                 |
|                                                                                                                                                  |
|                                                                                                                                                  |
|int  main  ()                                                                                                                                     |
|{|                                                                                                                                                ||
|label0:|                                                                                                                                          ||
|       int  a[2]  =    1,  2  ;                                                                                                                   |
||      v++;                                                                                                                                       ||
|label1:                                                                                                                                           |
||      foo  (a);                                                                                                                                  ||
|label2:|                                                                                                                                          ||
|       return  a[0]  +  a[1]  -  5;                                                                                                               |
|label3:|                                                                                                                                          ||
|}                                                                                                                                                 |
|                                                                                                                                                  |
|_________________________________________________________________________________________________________________________________________________ |
                           Figure D.68: C implicit pointer example #2: source
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 370
                                       Appendix D.  Examples (Informative)
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
__________________________________________________________________________________________________________________________________________________||
|1$:|    DW_TAG_variable                                                                                                                           ||
|                  DW_AT_name("b")                                                                                                                 |
||                 DW_AT_type(reference  to  "const  char  *")                                                                                     ||
|                  DW_AT_location(expression=                                                                                                      |
||                        DW_OP_implicit_pointer(reference  to  2$,  0))                                                                           ||
|2$:|    DW_TAG_dwarf_procedure                                                                                                                    ||
|                  DW_AT_location(expression=                                                                                                      |
||                        DW_OP_implicit_value(4,  {'o',  'p',  'q',  '\0'}))                                                                      ||
|3$:     DW_TAG_subprogram                                                                                                                         |
||                 DW_AT_name("foo")                                                                                                               ||
|                  DW_AT_inline(DW_INL_declared_inlined)                                                                                           |
|30$:|          DW_TAG_formal_parameter                                                                                                            ||
||                        DW_AT_name("p")                                                                                                          ||
|                         DW_AT_type(reference  to  "int  *")                                                                                      |
|4$:|    DW_TAG_subprogram                                                                                                                         ||
|                  DW_AT_name("main")                                                                                                              |
|40$:|          DW_TAG_variable                                                                                                                    ||
||                        DW_AT_name("a")                                                                                                          ||
|                         DW_AT_type(reference  to  "int[2]")                                                                                      |
||                        DW_AT_location(location  list  98$)                                                                                      ||
|41$:           DW_TAG_inlined_subroutine                                                                                                          |
||                        DW_AT_abstract_origin(reference  to  3$)                                                                                 ||
|42$:|                 DW_TAG_formal_parameter                                                                                                     ||
|                               DW_AT_abstract_origin(reference  to  30$)                                                                          |
||                              DW_AT_location(location  list  99$)                                                                                ||
|                                                                                                                                                  |
|!| .debug_loclists  section                                                                                                                       ||
|98$:|   DW_LLE_start_end[<label0  in  main>  ..  <label1  in  main>)                                                                              ||
|                  DW_OP_lit1  DW_OP_stack_value  DW_OP_piece(4)                                                                                   |
||                 DW_OP_lit2  DW_OP_stack_value  DW_OP_piece(4)                                                                                   ||
|           DW_LLE_start_end[<label1  in  main>  ..  <label2  in  main>)                                                                           |
||                 DW_OP_lit2  DW_OP_stack_value  DW_OP_piece(4)                                                                                   ||
|                  DW_OP_lit2  DW_OP_stack_value  DW_OP_piece(4)                                                                                   |
||          DW_LLE_start_end[<label2  in  main>  ..  <label3  in  main>)                                                                           ||
||                 DW_OP_lit2  DW_OP_stack_value  DW_OP_piece(4)                                                                                   ||
|                  DW_OP_lit3  DW_OP_stack_value  DW_OP_piece(4)                                                                                   |
||          DW_LLE_end_of_list                                                                                                                     ||
|99$:    DW_LLE_start_end[<label1  in  main>  ..  <label2  in  main>)                                                                              |
||                 DW_OP_implicit_pointer(reference  to  40$,  0)                                                                                  ||
||          DW_LLE_start_end[<label2  in  main>  ..  <label3  in  main>)                                                                           ||
|                  DW_OP_implicit_pointer(reference  to  40$,  4)                                                                                  |
||__________DW_LLE_end_of_list____________________________________________________________________________________________________________________ ||
               Figure D.69: C implicit pointer example #2: DWARF description
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 371
                                        Appendix D.  Examples (Informative)
 D.14              String  Type  Examples
 Consider the Fortran 2003 string type example source in Figure D.70 following.
 The DWARF representation in Figure D.71 on the next page is appropriate.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||pc*
 *rhoagrraacmt e r _ k i n d
|||=============================================================================================================================================|||ui*
 *sseo _ f o r t r a n _ e n v
|||=============================================================================================================================================|||in*
 *mopnlei c i t
|||=============================================================================================================================================|||i,*
 *nptaergaemre:t:ears=c i i
|||=============================================================================================================================================|||s(*
 *e"laescctieid"_)c h a r _ k i n d
|||=============================================================================================================================================|||i,*
 *nptaergaemre:t:eurc=s 4
|||=============================================================================================================================================|||s(*
 *e'lIeScOt_e1d0_6c4h6a'r)_ k i n d
|||=============================================================================================================================================|||c(*
 *hkairnadc=taesrcii,l=e2n6:):a l p h a b e t
|||=============================================================================================================================================|||c(*
 *hkairnadc=tuecrs4,l=e3n0:):h e l l o _ w o r l d
|||=============================================================================================================================================|||c(*
 *hlaerna=c*t)e,rp:a:raalmle_tdeirg=i"t0s1 2 3 4 5 6 7 8 9 "
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||a=*
 *lapshcaibie_t"a"b c d e f g h i j k l m n o p q r s t u v w x y z
|||=============================================================================================================================================|||h=*
 *eulclso4__w'oHrelldlWooarnlddNiH-a-o'&
|||=============================================================================================================================================|||//*
 *c(hianrt(z'4F60'),u)c&s 4
|||=============================================================================================================================================|||//*
 *c(hianrt(z'D5'9)7,u)c s 4
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||w(*
 *r*i,t*e)a l p h a b e t
|||=============================================================================================================================================|||w(*
 *r*i,t*e)a l l _ d i g i t s
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||o(*
 *poeunt,peuntc_oudniintg=U'TF-8 ')
|||=============================================================================================================================================|||w(*
 *r*i,t*e)t(rhieml)l o _ w o r l d
|||=============================================================================================================================================|||ep*
 *nrdocghraarma_c|t_e_r__|k i n d
                                     Figure D.70: String type example: source
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 372
                                       Appendix D.  Examples (Informative)
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
__________________________________________________________________________________________________________________________________________________||||
|1$:| DW_TAG_base_type                                                                                                                             ||
||             DW_AT_encoding  (DW_ATE_ASCII)                                                                                                      ||
|                                                                                                                                                  |
|2$:| DW_TAG_base_type                                                                                                                             ||
|              DW_AT_encoding  (DW_ATE_UCS)                                                                                                        |
||             DW_AT_byte_size  (4)                                                                                                                ||
|                                                                                                                                                  |
|3$:| DW_TAG_string_type                                                                                                                           ||
||             DW_AT_byte_size  (10)                                                                                                               ||
|                                                                                                                                                  |
|4$:| DW_TAG_const_type                                                                                                                            ||
||             DW_AT_type  (reference  to  3$)                                                                                                     ||
|                                                                                                                                                  |
|5$:| DW_TAG_string_type                                                                                                                           ||
|              DW_AT_type  (1$)                                                                                                                    |
||             DW_AT_string_length  (  ...  )                                                                                                      ||
|              DW_AT_string_length_byte_size  (  ...  )                                                                                            |
||             DW_AT_data_location  (  ...  )                                                                                                      ||
|                                                                                                                                                  |
|6$:| DW_TAG_string_type                                                                                                                           ||
||             DW_AT_type  (2$)                                                                                                                    ||
|              DW_AT_string_length  (  ...  )                                                                                                      |
||             DW_AT_string_length_byte_size  (  ...  )                                                                                            ||
||             DW_AT_data_location  (  ...  )                                                                                                      ||
|                                                                                                                                                  |
|7$:| DW_TAG_variable                                                                                                                              ||
|              DW_AT_name  (alphabet)                                                                                                              |
||             DW_AT_type  (5$)                                                                                                                    ||
||             DW_AT_location  (  ...  )                                                                                                           ||
|                                                                                                                                                  |
|8$:| DW_TAG_constant                                                                                                                              ||
|              DW_AT_name  (all_digits)                                                                                                            |
||             DW_AT_type  (4$)                                                                                                                    ||
|              DW_AT_const_value  (  ...  )                                                                                                        |
|                                                                                                                                                  |
|                                                                                                                                                  |
|9$:| DW_TAG_variable                                                                                                                              ||
|              DW_AT_name  (hello_world)                                                                                                           |
||             DW_AT_type  (6$)                                                                                                                    ||
|              DW_AT_location  (  ...  )                                                                                                           |
|                                                                                                                                                  |
|_________________________________________________________________________________________________________________________________________________ |
                     Figure D.71: String type example: DWARF representation
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 373
                                        Appendix D.  Examples (Informative)
 D.15              Call  Site  Examples
 The following examples use a hypothetical machine which:
      #    Passes the orst argument in register 0, the second in register 1, and the third
           in register 2.
      #    Keeps the stack pointer is register 3.
      #    Has one call preserved register 4.
      #    Returns a function value in register 0.
 D.15.1             Call Site Example #1 (C)
 Consider the C source in Figure D.72 following.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||ev*
 *xotiedrfnn(1lionntg,lionntg,lionntg);
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||li*
 *onntg
|||=============================================================================================================================================|||f(*
 *nl2oinngta,lionntgb,lionntgc)
|||=============================================================================================================================================|||{
|||=============================================================================================================================================|||li*
 *onntgq=2*a;
|||=============================================================================================================================================|||f(*
 *n51,67,);
|||=============================================================================================================================================|||r0*
 *e;t u r n
|||=============================================================================================================================================|||}
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||li*
 *onntg
|||=============================================================================================================================================|||f(*
 *nl3oinngtx,lionntg(*f)n(4lionntg*))
|||=============================================================================================================================================|||{
|||=============================================================================================================================================|||li*
 *onntgv,w,w2,z;
|||=============================================================================================================================================|||w=*
 *(*f)n(4&w2);
|||=============================================================================================================================================|||v=*
 *(*f)n(4&w2);
|||=============================================================================================================================================|||z=*
 *f(n12,v+1w,);
|||=============================================================================================================================================|||{
|||=============================================================================================================================================|||iv*
 *n1t=v+4;
|||=============================================================================================================================================|||z+*
 *=f(nw2,v*2x,);
|||=============================================================================================================================================|||}
|||=============================================================================================================================================|||rz*
 *e;t u r n
|||=============================================================================================================================================|||}_*
 *|_____|
                                    Figure D.72: Call Site Example #1: Source
 Possible generated code for this source is shown using a suggestive pseudo-
 assembly notation in Figure D.73 on the following page.
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 374
                                        Appendix D.  Examples (Informative)
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||f:*
 *n 2
|||=============================================================================================================================================|||L1:
|||=============================================================================================================================================|||%r*
 *=e7g!2Ltohaed3rdatrogfunm1e n t
|||=============================================================================================================================================|||%r*
 *=e6g!1Ltohaed2ndatrogfunm1e n t
|||=============================================================================================================================================|||%r*
 *=e5g!0Ltohaed1statrogfunm1e n t
|||=============================================================================================================================================|||L2:
|||=============================================================================================================================================|||cf*
 *anl1l
|||=============================================================================================================================================|||%r*
 *=e0g!0Ltohaedrveatluurenftrhoemf u n c t i o n
|||=============================================================================================================================================|||r *
 *e t u r n
|||=============================================================================================================================================|||L3:
|||=============================================================================================================================================|||f:*
 *n 3
|||=============================================================================================================================================|||!D*
 *setcarcekapsoeitnotreersleorcvaelsftraacmke
|||=============================================================================================================================================|||%r*
 *=e%gr3e-g332
|||=============================================================================================================================================|||[%*
 *r]e=g%3r!eSga4vtehceaplrlerseegrivsetdetro
|||=============================================================================================================================================|||!s*
 * t a c k
|||=============================================================================================================================================|||[%*
 *r+e8g]3=%r!ePgr0etsheerxvaervgaulmueen t
|||=============================================================================================================================================|||[%*
 *r+e1g63]=%r!ePgr1etsheerfvne4avragluumee n t
|||=============================================================================================================================================|||%r*
 *=e%gr0e+g234!Laodaddroefsws2asa r g u m e n t
|||=============================================================================================================================================|||c%*
 *arlelg!1Cfanl4l(icnadlilr)e c t
|||=============================================================================================================================================|||L6:
|||=============================================================================================================================================|||%r*
 *=e[g%2r+e1g63]!Ltohaedfanr4gvuamleunet
|||=============================================================================================================================================|||[%*
 *r+e1g63]=%r!eSga0vtehreeosfutlhtefciarlslt(w)
|||=============================================================================================================================================|||%r*
 *=e%gr0e+g234!Laodaddroefsws2asa r g u m e n t
|||=============================================================================================================================================|||c%*
 *arlelg!2Cfanl4l(icnadlilr)e c t
|||=============================================================================================================================================|||L7:
|||=============================================================================================================================================|||%r*
 *=e%gr4e!gS0atvheeroefstuhletsceacloln(dv)
|||=============================================================================================================================================|||!i*
 *rnetgoi.s t e r
|||=============================================================================================================================================|||%r*
 *=e[g%2r+e1g63]!L3oraddatrogfunm2e(nwt)
|||=============================================================================================================================================|||%r*
 *=e%gr1e+g14!C2onmdpaurtgeutmoefnnt2(v+1)
|||=============================================================================================================================================|||%r*
 *=e1g!0L1osatdatrogfunm2e n t
|||=============================================================================================================================================|||cf*
 *anl2l
|||=============================================================================================================================================|||L4:
|||=============================================================================================================================================|||%r*
 *=e[g%2r+e8g]3!Ltohaed3rdatrogfunm2e(nxt)
|||=============================================================================================================================================|||[%*
 *r+e8g]3=%r!eSga0vtehreeosfutlhte3rdc(azl)l
|||=============================================================================================================================================|||%r*
 *=e[g%0r+e1g63]!Ltohaed1statrogfunm2e(nwt)
|||=============================================================================================================================================|||%r*
 *=e%gr1e+g%4r!eCgo4mtphuet2endatrogfunm2e(nvt*2)
|||=============================================================================================================================================|||cf*
 *anl2l
|||=============================================================================================================================================|||L5:
|||=============================================================================================================================================|||%r*
 *=e[g%2r+e8g]3!Ltohaedvoaflzufertohmes t a c k
|||=============================================================================================================================================|||%r*
 *=e%gr0e+g%0r!eAgd2drfersoumltth4ethctaolilt
|||=============================================================================================================================================|||L8:
|||=============================================================================================================================================|||%r*
 *=e[g%4r]e!gR3eosrtiogrienvaalloufecparlels e r v e d
|||=============================================================================================================================================|||!r*
 * e g i s t e r
|||=============================================================================================================================================|||%r*
 *=e%gr3e+g332!Lsetaavcekf r a m e
|||=============================================================================================================================================|||r_*
 *e|t_u_r_n|
                                     Figure D.73: Call Site Example #1: Code
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 375
                                       Appendix D.  Examples (Informative)
The location list for variable a in function fn2 might look like the following
(where the notation iRange [m  ..    n)j specioes the range of addresses from m
through but not including n over which the following location description
applies):
__________________________________________________________________________________________________________________________________________________||||
|       !  Before  the  assignment  to  register  0,  the  argument  a  is  live  in  register  0                                                  |
||      !                                                                                                                                          ||
||      Range   [L1  ..  L2)                                                                                                                       ||
|              DW_OP_reg0                                                                                                                          |
|                                                                                                                                                  |
|                                                                                                                                                  |
|       !  Afterwards,  it  is  not.  The  value  can  perhaps  be  looked  up  in  the  caller                                                    |
||      !                                                                                                                                          ||
||      Range   [L2  ..  L3)                                                                                                                       ||
|              DW_OP_entry_value  (1,  DW_OP_reg0)                                                                                                 |
||             DW_OP_stack_value                                                                                                                   ||
|       End-of-list                                                                                                                                |
|                                                                                                                                                  |
|_________________________________________________________________________________________________________________________________________________ |
Similarly,|the|variable q in fn2 then might have this location list:                                                                               ||
__________________________________________________________________________________________________________________________________________________||
|                                                                                                                                                  |
|       !  Before  the  assignment  to  register  0,  the  value  of  q  can  be  computed  as                                                     |
||      !  two  times  the  contents  of  register  0                                                                                              ||
|       !                                                                                                                                          |
||      Range   [L1  ..  L2)                                                                                                                       ||
||             DW_OP_lit2                                                                                                                          ||
|              DW_OP_breg0  0                                                                                                                      |
||             DW_OP_mul                                                                                                                           ||
||             DW_OP_stack_value                                                                                                                   ||
|                                                                                                                                                  |
||      !  Afterwards.  it  is  not.  It  can  be  computed  from  the  original  value  of                                                        ||
|       !  the  first  parameter,  multiplied  by  two                                                                                             |
||      !                                                                                                                                          ||
|       Range   [L2  ..  L3)                                                                                                                       |
||             DW_OP_lit2                                                                                                                          ||
||             DW_OP_entry_value  (1,  DW_OP_reg0)                                                                                                 ||
|              DW_OP_mul                                                                                                                           |
||             DW_OP_stack_value                                                                                                                   ||
|       End-of-list                                                                                                                                |
|                                                                                                                                                  |
|_________________________________________________________________________________________________________________________________________________ |
Variables b and c each have a location list similar to that for variable a, except for
a dioeerent label between the two ranges and they use DW.OP.reg1 and
DW.OP.reg2, respectively, instead of DW.OP.reg0.
The call sites for all the calls in function fn3 are children of the
DW.TAG.subprogram entry for fn3 (or of its DW.TAG.lexical.block entry if
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 376
                                       Appendix D.  Examples (Informative)
|                                                                                                                                                  |
there|is|any for the whole function). This is shown in Figure D.74.                                                                                ||
|                                                                                                                                                  |
____________________________________________________________________________________________________________________________________part_1_of_2___||||
|       DW_TAG_call_site                                                                                                                           |
||             DW_AT_call_return_pc(L6)  !  First  indirect  call  to  (*fn4)  in  fn3.                                                            ||
||             !  The  address  of  the  call  is  preserved  across  the  call  in  memory  at                                                    ||
|              !  stack  pointer  +  16  bytes.                                                                                                    |
||             DW_AT_call_target(DW_OP_breg3  16  DW_OP_deref)                                                                                     ||
|              DW_TAG_call_site_parameter                                                                                                          |
||                    DW_AT_location(DW_OP_reg0)                                                                                                   ||
||                    !  Value  of  the  first  parameter  is  equal  to  stack  pointer  +  24  bytes.                                            ||
|                     DW_AT_call_value(DW_OP_breg3  24)                                                                                            |
||      DW_TAG_call_site                                                                                                                           ||
|              DW_AT_call_return_pc(L7)  !  Second  indirect  call  to  (*fn4)  in  fn3.                                                           |
||             !  The  address  of  the  call  is  not  preserved  across  the  call  anywhere,  but                                               ||
|              !  could  be  perhaps  looked  up  in  fn3's  caller.                                                                               |
||             DW_AT_call_target(DW_OP_entry_value  (1,  DW_OP_reg1))                                                                              ||
||             DW_TAG_call_site_parameter                                                                                                          ||
|                     DW_AT_location(DW_OP_reg0)                                                                                                   |
||                    DW_AT_call_value(DW_OP_breg3  24)                                                                                            ||
|       DW_TAG_call_site                                                                                                                           |
||             DW_AT_call_return_pc(L4)  !  3rd  call  in  fn3,  direct  call  to  fn2                                                             ||
||             DW_AT_call_origin(reference  to  fn2  DW_TAG_subprogram)                                                                            ||
|              DW_TAG_call_site_parameter                                                                                                          |
||                    DW_AT_call_parameter(reference  to  formal  parameter  a  in  subprogram  fn2)                                               ||
|                     DW_AT_location(DW_OP_reg0)                                                                                                   |
||                    !  First  parameter  to  fn2  is  constant  1                                                                                ||
||                    DW_AT_call_value(DW_OP_lit1)                                                                                                 ||
|              DW_TAG_call_site_parameter                                                                                                          |
||                    DW_AT_call_parameter(reference  to  formal  parameter  b  in  subprogram  fn2)                                               ||
|                     DW_AT_location(DW_OP_reg1)                                                                                                   |
||                    !  Second  parameter  to  fn2  can  be  computed  as  the  value  of  the  call                                              ||
|                     !     preserved  register  4  in  the  fn3  function  plus  one                                                              |
||                    DW_AT_call_value(DW_OP_breg4  1)                                                                                             ||
||             DW_TAG_call_site_parameter                                                                                                          ||
|                     DW_AT_call_parameter(reference  to  formal  parameter  c  in  subprogram  fn2)                                               |
||                    DW_AT_location(DW_OP_reg2)                                                                                                   ||
|                     !  Third  parameter's  value  is  preserved  in  memory  at  fn3's  stack  pointer                                           |
||                    !     plus  16  bytes                                                                                                        ||
||____________________DW_AT_call_value(DW_OP_breg3__16__DW_OP_deref)______________________________________________________________________________ ||
                          Figure D.74: Call site example #1: DWARF encoding
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 377
                                       Appendix D.  Examples (Informative)
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
____________________________________________________________________________________________________________________________________part_2_of_2___||
|DW_TAG_lexical_block|                                                                                                                             ||
||      DW_AT_low_pc(L4)                                                                                                                           ||
|       DW_AT_high_pc(L8)                                                                                                                          |
||      DW_TAG_variable                                                                                                                            ||
|              DW_AT_name("v1")                                                                                                                    |
||             DW_AT_type(reference  to  int)                                                                                                      ||
||             !  Value  of  the  v1  variable  can  be  computed  as  value  of  register  4  plus  4                                             ||
|              DW_AT_location(DW_OP_breg4  4  DW_OP_stack_value)                                                                                   |
||      DW_TAG_call_site                                                                                                                           ||
|              DW_AT_call_return_pc(L5)  !  4th  call  in  fn3,  direct  call  to  fn2                                                             |
||             DW_AT_call_target(reference  to  subprogram  fn2)                                                                                   ||
||             DW_TAG_call_site_parameter                                                                                                          ||
|                     DW_AT_call_parameter(reference  to  formal  parameter  a  in  subprogram  fn2)                                               |
||                    DW_AT_location(DW_OP_reg0)                                                                                                   ||
|                     !  Value  of  the  1st  argument  is  preserved  in  memory  at  fn3's  stack                                                |
||                    !     pointer  +  16  bytes.                                                                                                 ||
||                    DW_AT_call_value(DW_OP_breg3  16  DW_OP_deref)                                                                               ||
|              DW_TAG_call_site_parameter                                                                                                          |
||                    DW_AT_call_parameter(reference  to  formal  parameter  b  in  subprogram  fn2)                                               ||
|                     DW_AT_location(DW_OP_reg1)                                                                                                   |
||                    !  Value  of  the  2nd  argument  can  be  computed  using  the  preserved                                                   ||
|                     !     register  4  multiplied  by  2                                                                                         |
||                    DW_AT_call_value(DW_OP_lit2  DW_OP_reg4  0  DW_OP_mul)                                                                       ||
||             DW_TAG_call_site_parameter                                                                                                          ||
|                     DW_AT_call_parameter(reference  to  formal  parameter  c  in  subprogram  fn2)                                               |
||                    DW_AT_location(DW_OP_reg2)                                                                                                   ||
|                     !  Value  of  the  3rd  argument  is  not  preserved,  but  could  be  perhaps                                               |
||                    !  computed  from  the  value  passed  fn3's  caller.                                                                        ||
||____________________DW_AT_call_value(DW_OP_entry_value__(1,__DW_OP_reg0))_______________________________________________________________________ ||
                Figure D.74 Call site example #1: DWARF encoding (concluded)
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 378
                                        Appendix D.  Examples (Informative)
 D.15.2             Call Site Example #2 (Fortran)
 Consider the Fortran source in Figure D.75 which is used to illustrate how
 Fortran's ipass by referencej parameters can be handled.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||sf*
 *unb4r(onu)t i n e
|||=============================================================================================================================================|||i:*
 *n:tne,gxe r
|||=============================================================================================================================================|||x=n
|||=============================================================================================================================================|||n=*
 *n/2
|||=============================================================================================================================================|||cf*
 *anl6l
|||=============================================================================================================================================|||es*
 *nudb r o u t i n e
|||=============================================================================================================================================|||sf*
 *unb5r(onu)t i n e
|||=============================================================================================================================================|||if*
 *nnt4e r f a c e
|||=============================================================================================================================================|||sf*
 *unb4r(onu)t i n e
|||=============================================================================================================================================|||i:*
 *n:tne g e r
|||=============================================================================================================================================|||es*
 *nudb r o u t i n e
|||=============================================================================================================================================|||ei*
 *nndtfenr4f a c e
|||=============================================================================================================================================|||i:*
 *n:tne,gxe r
|||=============================================================================================================================================|||cf*
 *anl4l(n)
|||=============================================================================================================================================|||x=5
|||=============================================================================================================================================|||cf*
 *anl4l(x)
|||=============================================================================================================================================|||es*
 *nudbfrno5u_t|i_n_e_|
                                     Figure D.75: Call site example #2: source
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 379
                                        Appendix D.  Examples (Informative)
 Possible generated code for this source is shown using a suggestive pseudo-
 assembly notation in Figure D.76.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||f:*
 *n 4
|||=============================================================================================================================================|||%r*
 *=e[g%2r]e!gL0ovaadloufen(pbaysrseefde)r e n c e
|||=============================================================================================================================================|||%r*
 *=e%gr2e/g22!Dbiyv2i d e
|||=============================================================================================================================================|||[%*
 *r]e=g%0r!eUgp2dvaatleuoefn
|||=============================================================================================================================================|||cf*
 *anl6l!Csaolmleoftuhnecrt i o n
|||=============================================================================================================================================|||r *
 *e t u r n
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||f:*
 *n 5
|||=============================================================================================================================================|||%r*
 *=e%gr3e-g83!Dsetcarcekapsoeitnotcerresattaecfkr a m e
|||=============================================================================================================================================|||cf*
 *anl4l!Cfanl4lwtihtehsaarmgeubmyernetf e r e n c e
|||=============================================================================================================================================|||!a*
 *sfhna5sbceaelnlweidt h
|||=============================================================================================================================================|||L9:
|||=============================================================================================================================================|||[%*
 *r]e=g53!Pvaaslsuoef5byrteoffenr4e n c e
|||=============================================================================================================================================|||%r*
 *=e%gr0e!gP3uatdodfrtehsesv5aolnutehset a c k
|||=============================================================================================================================================|||!i*
 *1nsttoarregguimsetnetr
|||=============================================================================================================================================|||cf*
 *anl4l
|||=============================================================================================================================================|||L:*
 *1 0
|||=============================================================================================================================================|||%r*
 *=e%gr3e+g83!Lsetaavcekf r a m e
|||=============================================================================================================================================|||r_*
 *e|t_u_r_n|
                                      Figure D.76: Call site example #2: code
 The location description for variable x in function fn4 might be:
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||D4*
 *WD_WO_PO_Pe_nbtrreyg_0v0aDlWu_eO4P _ d e r e f _ s i z e
|||=============================================================================================================================================|||D_*
 *W|__O_P__|s t a c k _ v a l u e
 The call sites in (just) function fn5 might be as shown in Figure D.77 on the
 following page.
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 380
                                       Appendix D.  Examples (Informative)
|                                                                                                                                                  |
|                                                                                                                                                  |
__________________________________________________________________________________________________________________________________________________||||
|DW_TAG_call_site|                                                                                                                                 ||
||      DW_AT_call_return_pc(L9)                                        !  First  call  to  fn4                                                    ||
|       DW_AT_call_origin(reference  to  subprogram  fn4)                                                                                          |
||      DW_TAG_call_site_parameter                                                                                                                 ||
|              DW_AT_call_parameter(reference  to  formal  parameter  n  in  subprogram  fn4)                                                      |
||             DW_AT_location(DW_OP_reg0)                                                                                                          ||
||             !  The  value  of  register  0  at  the  time  of  the  call  can  be  perhaps                                                      ||
|              !     looked  up  in  fn5's  caller                                                                                                 |
||             DW_AT_call_value(DW_OP_entry_value  (1,  DW_OP_reg0))                                                                               ||
|              !  DW_AT_call_data_location(DW_OP_push_object_address)  !  left  out,  implicit                                                     |
||             !  And  the  actual  value  of  the  parameter  can  be  also  perhaps  looked  up  in                                              ||
|              !  fn5's  caller                                                                                                                    |
||             DW_AT_call_data_value(                                                                                                              ||
||                    DW_OP_entry_value  (4,  DW_OP_breg0  0  DW_OP_deref_size  4))                                                                ||
|                                                                                                                                                  |
|DW_TAG_call_site|                                                                                                                                 ||
|       DW_AT_call_return_pc(L10)                                      !  Second  call  to  fn4                                                    |
||      DW_AT_call_origin(reference  to  subprogram  fn4)                                                                                          ||
||      DW_TAG_call_site_parameter                                                                                                                 ||
|              DW_AT_call_parameter(reference  to  formal  parameter  n  in  subprogram  fn4)                                                      |
||             DW_AT_location(DW_OP_reg0)                                                                                                          ||
|              !  The  value  of  register  0  at  the  time  of  the  call  is  equal  to  the  stack                                             |
||             !  pointer  value  in  fn5                                                                                                          ||
||             DW_AT_call_value(DW_OP_breg3  0)                                                                                                    ||
|              !  DW_AT_call_data_location(DW_OP_push_object_address)  !  left  out,  implicit                                                     |
||             !  And  the  value  passed  by  reference  is  constant  5                                                                          ||
|              DW_AT_call_data_value(DW_OP_lit5)                                                                                                   |
|                                                                                                                                                  |
|_________________________________________________________________________________________________________________________________________________ |
                          Figure D.77: Call site example #2: DWARF encoding
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 381
                                        Appendix D.  Examples (Informative)
 D.16              Macro  Example
 Consider the C source in Figure D.78 following which is used to illustrate the
 DWARF encoding of macro information (see Section 6.3 on page 172).
 File a.c
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||#i*
 *"nac.lhu"d e
|||=============================================================================================================================================|||#d*
 *FeUfNiCnTeI(OxN)_4L+IxK E _ M A C R O
|||=============================================================================================================================================|||#i*
 *"nbc.lhu"d_e|_____|
 File a.h
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||#d*
 *LeOfNiGnEeR1_ M A C R O
|||=============================================================================================================================================|||#d*
 *Be2f i n e
|||=============================================================================================================================================|||#i*
 *"nbc.lhu"d e
|||=============================================================================================================================================|||#d*
 *Be3f_i|n_e___|
 File b.h
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||#u*
 *Bn d e f
|||=============================================================================================================================================|||#d*
 *De3f i n e
|||=============================================================================================================================================|||#d*
 *FeUfNiCnTeI(OxN)_4L+IxK_E|__M_A_C|R O
                                         Figure D.78: Macro example: source
 Two possible encodings are shown. The orst, in Figure D.79 on the following
 page, is perhaps the simplest possible encoding. It includes all macro
 information from the main source ole (a.c) as well as its two included oles (a.h
 and b.h) in a single macro unit. Further, all strings are included as immediate
 operands of the macro operators (that is, there is no string pooling). The size of
 the macro unit is 160 bytes.
 The second encoding, in Figure D.80 on page 384, saves space in two ways:
 1.    Longer strings are pooled by storing them in the .debug_str section where
       they can be referenced more than once.
 2.    Macro information entries contained in included oles are represented as
       separate macro units which are then imported for each #include directive.
 The combined size of the three macro units and their referenced strings is 129
 bytes.
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 382
                                       Appendix D.  Examples (Informative)
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
__________________________________________________________________________________________________________________________________________________||||
|!  ***  Section  .debug_macro  contents                                                                                                           |
|!| Macro  unit  for  "a.c"                                                                                                                        ||
|0$h:|      Version:              5                                                                                                                ||
|              Flags:                  2                                                                                                           |
||                    offset_size_flag:  0                   !  4-byte  offsets                                                                    ||
|                     debug_line_offset_flag:  1         !  Line  number  offset  present                                                          |
||                    opcode_operands_table_flag:  0  !  No  extensions                                                                            ||
||             Offset  in  .debug_line  section:  0    !  Line  number  offset                                                                     ||
|0$m:       DW_MACRO_start_file,  0,  0         !  Implicit  Line:  0,  File:  0  "a.c"                                                            |
||             DW_MACRO_start_file,  1,  1         !  #include  Line:  1,  File:  1  "a.h"                                                         ||
|              DW_MACRO_define,  1,  "LONGER_MACRO  1"                                                                                             |
||                                                                 !  #define  Line:  1,  String:  "LONGER_MACRO  1"                               ||
||             DW_MACRO_define,  2,  "B  2"         !  #define  Line:  2,  String:  "B  2"                                                         ||
|              DW_MACRO_start_file,  3,  2         !  #include  Line:  3,  File:  2  "b.h"                                                         |
||             DW_MACRO_undef,  1,  "B"              !  #undef  Line:  1,  String:  "b"                                                            ||
|              DW_MACRO_define  2,  "D  3"           !  #define  Line:  2,  String:  "D  3"                                                        |
||             DW_MACRO_define,  3,  "FUNCTION_LIKE_MACRO(x)  4+x"                                                                                 ||
|                                                                  !  #define  Line:  3,                                                           |
||                                                                 !     String:  "FUNCTION_LIKE_MACRO(x)  4+x"                                    ||
||             DW_MACRO_end_file                       !  End  "b.h"  ->  back  to  "a.h"                                                          ||
|              DW_MACRO_define,  4,  "B  3"         !  #define  Line:  4,  String:  "B  3"                                                         |
||             DW_MACRO_end_file                       !  End  "a.h"  ->  back  to  "a.c"                                                          ||
|              DW_MACRO_define,  2,  "FUNCTION_LIKE_MACRO(x)  4+x"                                                                                 |
||                                                                 !  #define  Line:  2,                                                           ||
||                                                                 !     String:  "FUNCTION_LIKE_MACRO(x)  4+x"                                    ||
|              DW_MACRO_start_file,  3,  2         !  #include  Line:  3,  File:  2  "b.h"                                                         |
||             DW_MACRO_undef,  1,  "B"              !  #undef  Line:  1,  String:  "b"                                                            ||
|              DW_MACRO_define,  2,  "D  3"         !  #define  Line:  2,  String:  "D  3"                                                         |
||             DW_MACRO_define,  3,  "FUNCTION_LIKE_MACRO(x)  4+x"                                                                                 ||
||                                                                 !  #define  Line:  3,                                                           ||
|                                                                  !     String:  "FUNCTION_LIKE_MACRO(x)  4+x"                                    |
||             DW_MACRO_end_file                       !  End  "b.h"  ->  back  to  "a.c"                                                          ||
|              DW_MACRO_end_file                       !  End  "a.c"  ->  back  to  ""                                                             |
||_____________0___________________________________________________!__End__macro__unit____________________________________________________________ ||
                       Figure D.79: Macro example: simple DWARF encoding
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 383
|                                                                                                                                                  |
||                                     Appendix D.  Examples (Informative)                                                                         ||
|                                                                                                                                                  |
|                                                                                                                                                  |
__________________________________________________________________________________________________________________________________________________||||
|!  ***  Section  .debug_macro  contents                                                                                                           |
|!| Macro  unit  for  "a.c"                                                                                                                        ||
|0$h:       Version:              5                                                                                                                |
||             Flags:                  2                                                                                                           ||
|                     offset_size_flag:  0                   !  4-byte  offsets                                                                    |
||                    debug_line_offset_flag:  1         !  Line  number  offset  present                                                          ||
||                    opcode_operands_table_flag:  0  !  No  extensions                                                                            ||
|              Offset  in  .debug_line  section:  0    !  Line  number  offset                                                                     |
|0$m:|      DW_MACRO_start_file,  0,  0         !  Implicit  Line:  0,  File:  0  "a.c"                                                            ||
|              DW_MACRO_start_file,  1,  1         !  #include  Line:  1,  File:  1  "a.h"                                                         |
||             DW_MACRO_import,  i$1h                !  Import  unit  at  i$1h  (lines  1-2)                                                       ||
||             DW_MACRO_start_file,  3,  2         !  #include  Line:  3,  File:  2  "b.h"                                                         ||
|              DW_MACRO_import,  i$2h                !  Import  unit  i$2h  (lines  all)                                                           |
||             DW_MACRO_end_file                       !  End  "b.h"  ->  back  to  "a.h"                                                          ||
|              DW_MACRO_define,  4,  "B  3"         !  #define  Line:  4,  String:  "B  3"                                                         |
||             DW_MACRO_end_file                       !  End  "a.h"  ->  back  to  "a.c"                                                          ||
||             DW_MACRO_define,  2,  s$1            !  #define  Line:  3,                                                                          ||
|                                                                  !     String:  "FUNCTION_LIKE_MACRO(x)  4+x"                                    |
||             DW_MACRO_start_file,  3,  2         !  #include  Line:  3,  File:  2  "b.h"                                                         ||
|              DW_MACRO_import,  i$2h                !  Import  unit  i$2h  (lines  all)                                                           |
||             DW_MACRO_end_file                       !  End  "b.h"  ->  back  to  "a.c"                                                          ||
|              DW_MACRO_end_file                       !  End  "a.c"  ->  back  to  ""                                                             |
||             0                                                   !  End  macro  unit                                                             ||
|!| Macro  unit  for  "a.h"  lines  1-2                                                                                                            ||
|i$1h:     Version:              5                                                                                                                 |
||             Flags:                  0                                                                                                           ||
|                     offset_size_flag:  0                   !  4-byte  offsets                                                                    |
||                    debug_line_offset_flag:  0         !  No  line  number  offset                                                               ||
||                    opcode_operands_table_flag:  0  !  No  extensions                                                                            ||
|i$1m:     DW_MACRO_define_strp,  1,  s$2    !  #define  Line:  1,  String:  "LONGER_MACRO  1"                                                     |
||             DW_MACRO_define,  2,  "B  2"         !  #define  Line:  2,  String:  "B  2"                                                         ||
|              0                                                   !  End  macro  unit                                                             |
|!| Macro  unit  for  "b.h"                                                                                                                        ||
|i$2h:|    Version:              5                                                                                                                 ||
|              Flags:                  0                                                                                                           |
||                    offset_size_flag:  0                   !  4-byte  offsets                                                                    ||
|                     debug_line_offset_flag:  0         !  No  line  number  offset                                                               |
||                    opcode_operands_table_flag:  0  !  No  extensions                                                                            ||
|i$2m:     DW_MACRO_undef,  1,  "B"              !  #undef  Line:  1,  String:  "B"                                                                |
||             DW_MACRO_define,  2,  "D  3"         !  #define  Line:  2,  String:  "D  3"                                                         ||
||             DW_MACRO_define_strp,  3,  s$1    !  #define  Line:  3,                                                                             ||
|                                                                  !     String:  "FUNCTION_LIKE_MACRO(x)  4+x"                                    |
||             0                                                   !  End  macro  unit                                                             ||
|!  ***  Section  .debug_str  contents                                                                                                             |
|s$1:|      String:  "FUNCTION_LIKE_MACRO(x)  4+x"                                                                                                 ||
|s$2:|______String:__"LONGER_MACRO__1"____________________________________________________________________________________________________________ ||
                      Figure D.80: Macro example: sharable DWARF encoding
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 384
                                       Appendix D.  Examples (Informative)
A number of observations are worth mentioning:
     #    Strings that are the same size as a reference or less are better represented as
          immediate operands. Strings longer than twice the size of a reference are
          better stored in the string table if there are at least two references.
     #    There is a trade-ooe between the size of the macro information of a ole and
          the number of times it is included when evaluating whether to create a
          separate macro unit. However, the amount of overhead (the size of a macro
          header) needed to represent a unit as well as the size of the operation to
          import a macro unit are both small.
     #    A macro unit need not describe all of the macro information in a ole. For
          example, in Figure D.80 the second macro unit (beginning at i$1h) includes
          macros from just the orst two lines of ole a.h.
     #    An implementation may be able to share macro units across object oles (not
          shown in this example). To support this, it may be advantageous to create
          macro units in cases where they do not ooeer an advantage in a single
          compilation of itself.
     #    The header of a macro unit that contains a DW.MACRO.start.ole
          operation must include a reference to the compilation line number header
          to allow interpretation of the ole number operands in those commands.
          However, the presence of those ooesets complicates or may preclude sharing
          across compilations.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 385
                                        Appendix D.  Examples (Informative)
 D.17              Parameter  Default  Value  Examples
 The default expressions for parameters x and y in the C++ function declaration in
 Figure D.81 can be described in DWARF as illustrated in Figure D.82.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||vg*
 *o(iidnxt=1 3 ;
|||=============================================================================================================================================|||iy*
 *n=tf());_|_____|
                            Figure D.81: Default value example #1: C++ source
 __________________________________________________________________________________________________________________________________________________||*
 *||
 ||      DW_TAG_subprogram                                                                                                                          ||
 ||             DW_AT_name  ("g")                                                                                                                   ||
 |                                                                                                                                                  |
 ||             DW_TAG_formal_parameter                                                                                                             ||
 |                   DW_AT_name  ("x")                                                                                                              |
 ||                  DW_AT_type  (reference  to  type  "int")                                                                                       ||
 |                   DW_AT_default_value@DW_FORM_sdata  (13)                                                                                        |
 |                                                                                                                                                  |
 |                                                                                                                                                  |
 ||             DW_TAG_formal_parameter                                                                                                             ||
 |                   DW_AT_name  ("y")                                                                                                              |
 ||                  DW_AT_type  (reference  to  type  "int")                                                                                       ||
 |                   DW_AT_default_value@DW_FORM_string  ("f()")                                                                                    |
 |                                                                                                                                                  |
 |_________________________________________________________________________________________________________________________________________________ |
                      Figure D.82: Default value example #1: DWARF encoding
 In Figure D.82, note the following:
      1.   This ogure explicitly shows the form used by certain attributes (indicated
           by a trailing @DW.FORM.xxx) when it is critical, while the form is left
           implicit in most other examples.
      2.   The string value for y is three characters in length and does not include any
           quotes. (The quotes are an artifact of the presumed dumper tool that
           created this interpretation.)
      3.   The default value for x could also be encoded as
           DW_AT_default_value@DW_FORM_string("13"); however, this is generally a
           less convenient form and less eOEcient for consumers to process. a less
           convenient form and less eOEcient for consumers to process.
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 386
                                        Appendix D.  Examples (Informative)
 A string form in DW.AT.default.value always represents a source code
 fragment, even in languages that have a native string type. For example, the
 default string parameter of the Ada function in Figure D.83 is encoded in
 DWARF as a string containing the Ada string literal, including the source
 quotation marks, as shown in Figure D.84.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||ps*
 *r(oxc:esdturrien:g="a"b;c
|||=============================================================================================================================================|||y:*
 *s:t=r"ianbgc"d+i1s0 )
|||=============================================================================================================================================|||b *
 *e g i n
|||=============================================================================================================================================|||es*
 *n;d_|_____|
                            Figure D.83: Default value example #2: Ada source
 __________________________________________________________________________________________________________________________________________________||*
 *||
 ||      DW_TAG_subprogram                                                                                                                          ||
 ||           DW_AT_name  ("s")                                                                                                                     ||
 |                                                                                                                                                  |
 ||           DW_TAG_formal_parameter                                                                                                               ||
 |                  DW_AT_name  ("x")                                                                                                               |
 ||                 DW_AT_type  (reference  to  type  "string")                                                                                     ||
 |                  DW_AT_default_value@DW_FORM_data4  (0x61626364)       !  Big-endian                                                             |
 |                                                                                                                                                  |
 |                                                                                                                                                  |
 ||           DW_TAG_formal_parameter                                                                                                               ||
 |                  DW_AT_name  ("y")                                                                                                               |
 ||                 DW_AT_type  (reference  to  type  "string")                                                                                     ||
 |                  DW_AT_default_value@DW_FORM_string  (""abcd"+10 ")                                                                              |
 |                                                                                                                                                  |
 |_________________________________________________________________________________________________________________________________________________ |
                      Figure D.84: Default value example #2: DWARF encoding
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 387
                                        Appendix D.  Examples (Informative)
 D.18              SIMD  Lane  Example
 The following example uses a hypothetical machine with 64-bit scalar registers
 r0, r1, ..., and 256-bit vector registers v0, v1, ... that supports SIMD instructions
 with dioeerent SIMD widths. Scalar arguments are passed in scalar registers
 starting with r0 for the orst argument.
 Consider the source code in Figure D.85, which is implicitly widened by a
 vectorization factor of 8 to match the 256-bit vector registers of the target
 machine, resulting in the pseudo-code in Figure D.86 on the following page.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||vv*
 *oeicd_(aidndtd[s]t,isnrtc[]i,nlte)n{
|||=============================================================================================================================================|||#p*
 *ormapgsmiam d
|||=============================================================================================================================================|||f(*
 *oirnit=0;i<l;e+n+i)
|||=============================================================================================================================================|||d[*
 *sit]+=s[ric];
|||=============================================================================================================================================|||}_*
 *|_____|
                          Figure D.85: SIMD Lane Example: C OpenMP Source
 The machine code contains two instances of the source loop: one instance with
 SIMD width 8 beginning at .l1, and one scalar instance beginning at .l2 to handle
 any remaining elements.
 This function may be described in DWARF as shown in Figure D.87 on page 390.
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 388
                                        Appendix D.  Examples (Informative)
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||.l*
 *0:
|||=============================================================================================================================================|||m.*
 *o6v4ebr3,0;i=0
|||=============================================================================================================================================|||.l*
 *1:;i8m-pwliidceivtelcytlooroipzbeodd y
|||=============================================================================================================================================|||a.*
 *d6d4br4,r3,8;i=nie+x8t
|||=============================================================================================================================================|||c.*
 *m6p4br4,r2;cionmepxatrteol e n
|||=============================================================================================================================================|||j.*
 *mgpe.l2;jtuom.pl2ifi>n=elxetn
|||=============================================================================================================================================|||l.*
 *o2a5d6bv0,[r0+r43*];v0[n]=d[sit+n]f o r
|||=============================================================================================================================================|||;n*
 *in[ 0 . . 7 ]
|||=============================================================================================================================================|||.l*
 *1. 1 :
|||=============================================================================================================================================|||l.*
 *o2a5d6bv1,[r1+r43*];v1[n]=s[ric+n]f o r
|||=============================================================================================================================================|||;n*
 *in[ 0 . . 7 ]
|||=============================================================================================================================================|||.l*
 *1.;2a:d8de l e m e n t s
|||=============================================================================================================================================|||a.*
 *dsdimd-8v0,v0,v1;v0[n]=v0[n]+v1[n]f o r
|||=============================================================================================================================================|||;n*
 *in[ 0 . . 7 ]
|||=============================================================================================================================================|||s.*
 *t2o5r6eb[r0+r43*]v,0;d[sit+n]=v0[n]f o r
|||=============================================================================================================================================|||;n*
 *in[ 0 . . 7 ]
|||=============================================================================================================================================|||.l*
 *1. 3 :
|||=============================================================================================================================================|||m.*
 *o6v4br3,r4;i=i n e x t
|||=============================================================================================================================================|||j.*
 *mlp1;lboaocpkfmoorr e
|||=============================================================================================================================================|||.l*
 *2:;slcoaolpabro d y
|||=============================================================================================================================================|||a.*
 *d6d4br4,r3,1;i=nie+x1t
|||=============================================================================================================================================|||c.*
 *m6p4br4,r2;cionmepxatrteol e n
|||=============================================================================================================================================|||j.*
 *mgpe.l3;jtuom.pl3ifi>n=elxetn
|||=============================================================================================================================================|||l.*
 *o3a2dbr5,[r0+r43*];r5=d[sit]
|||=============================================================================================================================================|||.l*
 *2. 1 :
|||=============================================================================================================================================|||l.*
 *o3a2dbr6,[r1+r43*];r6=s[ric]
|||=============================================================================================================================================|||.l*
 *2.;2a:dadseilnegmleen t
|||=============================================================================================================================================|||a.*
 *d3d2br5,r5,r6;r5=r5+r6
|||=============================================================================================================================================|||s.*
 *t3o2rbe[r0+r43*]r,5;d[sit]=r5
|||=============================================================================================================================================|||.l*
 *2. 3 :
|||=============================================================================================================================================|||m.*
 *o6v4br3,r4;i=i n e x t
|||=============================================================================================================================================|||j.*
 *mlp2;lboaocpkfmoorr e
|||=============================================================================================================================================|||.l*
 *3:
|||=============================================================================================================================================|||r_*
 *e|t_u_r_n|
                     Figure D.86: SIMD Lane Example: Pseudo-Assembly Code
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 389
                                       Appendix D.  Examples (Informative)
|                                                                                                                                                  |
|                                                                                                                                                  |
__________________________________________________________________________________________________________________________________________________||||
|                                                                                                                                                  |
|                                                                                                                                                  |
||      DW_TAG_subprogram                                                                                                                          ||
|              DW_AT_name  ("vec_add")                                                                                                             |
||             DW_AT_num_lanes  .vallist.0                                                                                                         ||
|              ...                                                                                                                                 |
||             DW_TAG_variable                                                                                                                     ||
||                    DW_AT_name  ("i")                                                                                                            ||
|                     DW_AT_type  (reference  to  type  int)                                                                                       |
||                    DW_AT_location  .loclist.1                                                                                                   ||
|                     ...                                                                                                                          |
|                                                                                                                                                  |
|                                                                                                                                                  |
|.vallist.0:                                                                                                                                       |
||      range  [.l1,  .l2)                                                                                                                         ||
||           DW_OP_lit8                                                                                                                            ||
|       end-of-list                                                                                                                                |
|                                                                                                                                                  |
|                                                                                                                                                  |
|.loclist.1:                                                                                                                                       |
||      range  [.l0,  .l1)                                                                                                                         ||
||             DW_OP_regx  r3                                                                                                                      ||
|       range  [.l1,  .l2)                                                                                                                         |
||             DW_OP_bregx  r3,  0                                                                                                                 ||
|              DW_OP_push_lane                                                                                                                     |
||             DW_OP_plus                                                                                                                          ||
||             DW_OP_stack_value                                                                                                                   ||
|       range  [.l2,  .l4)                                                                                                                         |
||             DW_OP_regx  r3                                                                                                                      ||
|       end-of-list                                                                                                                                |
|                                                                                                                                                  |
|_________________________________________________________________________________________________________________________________________________ |
                         Figure D.87: SIMD Lane Example: DWARF Encoding
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 390

Appendix  E
DWARF  Compression  and  Duplicate
Elimination  (Informative)
DWARF can use a lot of disk space.
This is especially true for C++, where the depth and complexity of headers can
mean that many, many (possibly thousands of) declarations are repeated in every
compilation unit. C++ templates can also mean that some functions and their
DWARF descriptions get duplicated.
This Appendix describes techniques for using the DWARF representation in
combination with features and characteristics of some common object ole
representations to reduce redundancy without losing information. It is worth
emphasizing that none of these techniques are necessary to provide a complete
and accurate DWARF description; they are solely concerned with reducing the
size of DWARF information.
The techniques described here depend more directly and more obviously on
object ole concepts and linker mechanisms than most other parts of DWARF.
While the presentation tends to use the vocabulary of specioc systems, this is
primarily to aid in describing the techniques by appealing to well-known
terminology. These techniques can be employed on any system that supports
certain general functional capabilities (described below).
E.1           Using  Compilation  Units
E.1.1          Overview
The general approach is to break up the debug information of a compilation into
separate normal and partial compilation units, each consisting of one or more
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 391
                                    Appendix E.  Compression (Informative)
sections. By arranging that a suOEciently similar partitioning occurs in other
compilations, a suitable system linker can delete redundant groups of sections
when combining object oles.
The following uses some traditional section naming here but aside from the DWARF
sections, the names are just meant to suggest traditional contents as a way of explaining
the approach, not to be limiting.
A traditional relocatable object output ole from a single compilation might
contain sections named:
        .data
        .text
        .debug_info
        .debug_abbrev
        .debug_line
        .debug_aranges
A relocatable object ole from a compilation system attempting duplicate DWARF
elimination might contain sections as in:
        .data
        .text
        .debug_info
        .debug_abbrev
        .debug_line
        .debug_aranges
followed (or preceded, the order is not signiocant) by a series of section groups:
====  Section  group  1
        .debug_info
        .debug_abbrev
        .debug_line
====  ...
====  Section  group  N
        .debug_info
        .debug_abbrev
        .debug_line
where each section group might or might not contain executable code (.text
sections) or data (.data sections).
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 392
                                    Appendix E.  Compression (Informative)
A section group is a named set of section contributions within an object ole with
the property that the entire set of section contributions must be retained or
discarded as a whole; no partial elimination is allowed. Section groups can
generally be handled by a linker in two ways:
1.    Given multiple identical (duplicate) section groups, one of them is chosen to
      be kept and used, while the rest are discarded.
2.    Given a section group that is not referenced from any section outside of the
      section group, the section group is discarded.
Which handling applies may be indicated by the section group itself and/or
selection of certain linker options.
For example, if a linker determines that section group 1 from A.o and section
group 3 from B.o are identical, it could discard one group and arrange that all
references in A.o and B.o apply to the remaining one of the two identical section
groups. This saves space.
An important part of making it possible to iredirectj references to the surviving
section group is the use of consistently chosen linker global symbols for referring
to locations within each section group. It follows that references are simply to
external names and the linker already knows how to match up references and
deonitions.
What is minimally needed from the object ole format and system linker (outside
of DWARF itself, and normal object/linker facilities such as simple relocations)
are:
1.    A means to reference the .debug_info information of one compilation unit
      from the .debug_info section of another compilation unit
      (DW.FORM.ref.addr provides this).
2.    A means to combine multiple contributions to specioc sections (for example,
      .debug_info) into a single object ole.
3.    A means to identify a section group (giving it a name).
4.    A means to indicate which sections go together to make up a section group,
      so that the group can be treated as a unit (kept or discarded).
5.    A means to indicate how each section group should be processed by the
      linker.
The notion of section and section contribution used here corresponds closely to the
similarly named concepts in the ELF object ole representation. The notion of section
group is an abstraction of common extensions of the ELF representation widely known as
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 393
                                    Appendix E.  Compression (Informative)
iCOMDATsj or iCOMDAT sections.j (Other object ole representations provide
COMDAT-style mechanisms as well.) There are several variations in the COMDAT
schemes in common use, any of which should be suOEcient for the purposes of the
DWARF duplicate elimination techniques described here.
E.1.2          Naming and Usage Considerations
A precise description of the means of deriving names usable by the linker to
access DWARF entities is not part of this speciocation. Nonetheless, an outline of
a usable approach is given here to make this more understandable and to guide
implementors.
Implementations should clearly document their naming conventions.
In the following, it will be helpful to refer to the examples in Figure E.1 through
Figure E.8 of Section E.1.3 on page 397.
Section Group Names
Section groups must have a section group name. For the subsequent C++
example, a name like
        <producer-prefix>.<file-designator>.<gid-number>
will suOEce, where
!producer-preox?                   is some string specioc to the producer, which has a
          language-designation embedded in the name when appropriate.
          (Alternatively, the language name could be embedded in the
          !gid-number?).
!ole-designator?                names the ole, such as wa.h in the example.
!gid-number?                is a string generated to identify the specioc wa.h header ole in
          such a way that
              #    a 'matching' output from another compile generates the same
                   !gid-number?, and
              #    a non-matching output (say because of #defines) generates a dioeerent
                   !gid-number?.
It may be useful to think of a !gid-number?as a kind of idigital signaturej that allows a
fast test for the equality of two section groups.
So, for example, the section group corresponding to ole wa.h above is given the
name my.compiler.company.cpp.wa.h.123456.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 394
                                    Appendix E.  Compression (Informative)
Debugging Information Entry Names
Global labels for debugging information entries (the need for which is explained
below) within a section group can be given names of the form
        <prefix>.<file-designator>.<gid-number>.<die-number>
such as
        my.compiler.company.wa.h.123456.987
where
!preox?          distinguishes this as a DWARF debug info name, and should identify
          the producer and, when appropriate, the language.
!ole-designator?                and <gid-number> are as above.
!die-number?               could be a number sequentially assigned to entities (tokens,
          perhaps) found during compilation.
In general, every point in the section group .debug_info that could be referenced
from outside by any compilation unit must normally have an external name
generated for it in the linker symbol table, whether the current compilation
references all those points or not.
The completeness of the set of names generated is a quality-of-implementation issue.
It is up to the producer to ensure that if !die-numbers? in separate compilations
would not match properly then a distinct !gid-number? is generated.
Note that only section groups that are designated as duplicate-removal-applies
actually require the
        <prefix>.<file-designator>.<gid-number>.<die-number>
external labels for debugging information entries as all other section group
sections can use 'local' labels (section-relative relocations).
(This is a consequence of separate compilation, not a rule imposed by this
document.)
Local labels use references with form DW.FORM.ref4 or DW.FORM.ref8. (These are
aoeected by relocations so DW.FORM.ref.udata, DW.FORM.ref1 and
DW.FORM.ref2 are normally not usable and DW.FORM.ref.addr is not necessary for
a local label.)
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 395
                                    Appendix E.  Compression (Informative)
E.1.2.1         Use of DW.TAG.compile.unit versus DW.TAG.partial.unit
A section group compilation unit that uses DW.TAG.compile.unit is like any
other compilation unit, in that its contents are evaluated by consumers as though
it were an ordinary compilation unit.
An #include directive appearing outside any other declarations is a good
candidate to be represented using DW.TAG.compile.unit. However, an
#include appearing inside a C++ namespace declaration or a function, for
example, is not a good candidate because the entities included are not necessarily
ole level entities.
This also applies to Fortran INCLUDE lines when declarations are included into
a subprogram or module context.
Consequently a compiler must use DW.TAG.partial.unit (instead of
DW.TAG.compile.unit) in a section group whenever the section group contents
are not necessarily globally visible. This directs consumers to ignore that
compilation unit when scanning top level declarations and deonitions.
The DW.TAG.partial.unit compilation unit will be referenced from elsewhere
and the referencing locations give the appropriate context for interpreting the
partial compilation unit.
A DW.TAG.partial.unit entry may have, as appropriate, any of the attributes
assigned to a DW.TAG.compile.unit.
E.1.2.2         Use of DW.TAG.imported.unit
A DW.TAG.imported.unit debugging information entry has an
DW.AT.import attribute referencing a DW.TAG.compile.unit or
DW.TAG.partial.unit debugging information entry.
A DW.TAG.imported.unit debugging information entry refers to a
DW.TAG.compile.unit or DW.TAG.partial.unit debugging information entry
to specify that the DW.TAG.compile.unit or DW.TAG.partial.unit contents
logically appear at the point of the DW.TAG.imported.unit entry.
E.1.2.3         Use of DW.FORM.ref.addr
Use DW.FORM.ref.addr to reference from one compilation unit's debugging
information entries to those of another compilation unit.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 396
                                    Appendix E.  Compression (Informative)
When referencing into a removable section group .debug_info from another
.debug_info (from anywhere), the
        <prefix>.<file-designator>.<gid-number>.<die-number>
name should be used for an external symbol and a relocation generated based on
that name.
When referencing into a non-section group .debug_info, from another .debug_info
(from anywhere) DW.FORM.ref.addr is still the form to be used, but a section-relative
relocation generated by use of a non-exported name (often called an iinternal namej)
may be used for references within the same object ole.
E.1.3          Examples
This section provides several examples in order to have a concrete basis for
discussion.
In these examples, the focus is on the arrangement of DWARF information into
sections (speciocally the .debug_info section) and the naming conventions used
to achieve references into section groups. In practice, all of the examples that
follow involve DWARF sections other than just .debug_info (for example,
.debug_line, .debug_aranges, or others); however, only the .debug_info section
is shown to keep the examples compact and easier to read.
The grouping of sections into a named set is shown, but the means for achieving
this in terms of the underlying object language is not (and varies from system to
system).
E.1.3.1         C++ Example
The C++ source in Figure E.1 on the next page is used to illustrate the DWARF
representation intended to allow duplicate elimination.
Figure E.2 on the following page shows the section group corresponding to the
included ole wa.h.
Figure E.3 on page 399 shows the inormalj DWARF sections, which are not part
of any section group, and how they make use of the information in the section
group shown above.
This example uses DW.TAG.compile.unit for the section group, implying that
the contents of the compilation unit are globally visible (in accordance with C++
language rules). DW.TAG.partial.unit is not needed for the same reason.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 397
                                     Appendix E.  Compression (Informative)
 File wa.h
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||sA*
 *t{r u c t
|||=============================================================================================================================================|||ii*
 *n;t
|||=============================================================================================================================================|||};*
 *_|_____|
 File wa.c
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||#i*
 *"nwcal.uhd"e;
|||=============================================================================================================================================|||i *
 *n t
|||=============================================================================================================================================|||f(*
 *A&a)
|||=============================================================================================================================================|||{
|||=============================================================================================================================================|||ra*
 *e.tiu+r2n;
|||=============================================================================================================================================|||}_*
 *|_____|
 |                    Figure E.1: Duplicate elimination example #1: C++ Source                                                                      |
 |                                                                                                                                                  |
 __________________________________________________________________________________________________________________________________________________||
 |====| Section  group  name:                                                                                                                       ||
 |       my.compiler.company.cpp.wa.h.123456                                                                                                        |
 |==| section  .debug_info                                                                                                                          ||
 |DW.cpp.wa.h.123456.1:         !  linker  global  symbol                                                                                           |
 ||      DW_TAG_compile_unit                                                                                                                        ||
 |              DW_AT_language_name(DW_LNAME_C_plus_plus)                                                                                           |
 ||             ...    !  other  unit  attributes                                                                                                   ||
 |DW.cpp.wa.h.123456.2:|        !  linker  global  symbol                                                                                           ||
 |       DW_TAG_base_type                                                                                                                           |
 ||             DW_AT_name("int")                                                                                                                   ||
 |DW.cpp.wa.h.123456.3:         !  linker  global  symbol                                                                                           |
 ||      DW_TAG_structure_type                                                                                                                      ||
 ||             DW_AT_name("A")                                                                                                                     ||
 |DW.cpp.wa.h.123456.4:         !  linker  global  symbol                                                                                           |
 ||             DW_TAG_member                                                                                                                       ||
 |              DW_AT_name("i")                                                                                                                     |
 ||             DW_AT_type(DW_FORM_ref<n>  to  DW.cpp.wa.h.123456.2)                                                                                ||
 ||                    !  (This  is  a  local  reference,  so  the  more                                                                            ||
 |                     !  compact  form  DW_FORM_ref<n>                                                                                             |
 ||____________________!__for__n__=__1,2,4,__or__8__can__be__used)_________________________________________________________________________________ ||
            Figure E.2: Duplicate elimination example #1: DWARF section group
 E.1.3.2         C Example
 The C++ example in this Section might appear to be equally valid as a C
 example. However, for C it is prudent to include a DW.TAG.imported.unit in
 the primary unit (see Figure E.3 on the following page) as well as an
 DW.AT.import attribute that refers to the proper unit in the section group.
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 398
                                     Appendix E.  Compression (Informative)
 __________________________________________________________________________________________________________________________________________________||*
 *||
 |==  section  .text                                                                                                                                |
 ||      [generated  code  for  function  f]                                                                                                        ||
 |==  section  .debug_info                                                                                                                          |
 ||      DW_TAG_compile_unit                                                                                                                        ||
 |.L1:|                                              !  local  (non-linker)  symbol                                                                 ||
 |              DW_TAG_reference_type                                                                                                               |
 ||                    DW_AT_type(reference  to  DW.cpp.wa.h.123456.3)                                                                              ||
 |              DW_TAG_subprogram                                                                                                                   |
 ||                    DW_AT_name("f")                                                                                                              ||
 ||                    DW_AT_type(reference  to  DW.cpp.wa.h.123456.2)                                                                              ||
 |                     DW_TAG_variable                                                                                                              |
 ||                           DW_AT_name("a")                                                                                                       ||
 |                            DW_AT_type(reference  to  .L1)                                                                                        |
 ||_____________...________________________________________________________________________________________________________________________________ ||
         Figure E.3: Duplicate elimination example #1: primary compilation unit
 The C rules for consistency of global (ole scope) symbols across compilations are less
 strict than for C++; inclusion of the import unit attribute assures that the declarations of
 the proper section group are considered before declarations from other compilations.
 E.1.3.3         Fortran Example
 For a Fortran example, consider Figure E.4.
 File CommonStuoe.f h
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||II*
 *MNPTLEIGCEIRT(A-Z)
|||=============================================================================================================================================|||C/*
 *OCMoMmOmNo/nC1( 1 0 0 )
|||=============================================================================================================================================|||P(*
 *ASREAVMEENT=E7R)_|_____|
 File Func.f
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||FF*
 *UONOC(TNI)O N
|||=============================================================================================================================================|||I'*
 *NCCoLmUmDoEn.Sfthu'f f
|||=============================================================================================================================================|||F=*
 *OCO(N+S)E V E N
|||=============================================================================================================================================|||R *
 *E T U R N
|||=============================================================================================================================================|||E_*
 *N|D____|
                   Figure E.4: Duplicate elimination example #2: Fortran source
 Figure E.5 on the following page shows the section group corresponding to the
 included ole CommonStuoe.fh.
 Figure E.6 on page 401 shows the sections for the primary compilation unit.
 A companion main program is shown in Figure E.7 on page 401
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 399
                                    Appendix E.  Compression (Informative)
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
__________________________________________________________________________________________________________________________________________________||||
|====  Section  group  name:                                                                                                                       |
|                                                                                                                                                  |
||      my.f90.company.f90.CommonStuff.fh.654321                                                                                                   ||
|                                                                                                                                                  |
|                                                                                                                                                  |
|==  section  .debug_info                                                                                                                          |
|                                                                                                                                                  |
|                                                                                                                                                  |
|DW.myf90.CommonStuff.fh.654321.1:       !  linker  global  symbol                                                                                 |
||      DW_TAG_partial_unit                                                                                                                        ||
||             !  ...compilation  unit  attributes,  including...                                                                                  ||
|              DW_AT_language_name(DW_LNAME_Fortran)                                                                                               |
||             DW_AT_identifier_case(DW_ID_case_insensitive)                                                                                       ||
|                                                                                                                                                  |
|DW.myf90.CommonStuff.fh.654321.2:|      !  linker  global  symbol                                                                                 ||
|3$:| DW_TAG_array_type                                                                                                                            ||
|              !  unnamed                                                                                                                          |
||             DW_AT_type(reference  to  DW.f90.F90$main.f.2)                                                                                      ||
|                     !  base  type  INTEGER                                                                                                       |
||             DW_TAG_subrange_type                                                                                                                ||
||                    DW_AT_type(reference  to  DW.f90.F90$main.f.2)                                                                               ||
|                            !  base  type  INTEGER)                                                                                               |
||                    DW_AT_lower_bound(constant  1)                                                                                               ||
|                     DW_AT_upper_bound(constant  100)                                                                                             |
|                                                                                                                                                  |
|                                                                                                                                                  |
|DW.myf90.CommonStuff.fh.654321.3:|      !  linker  global  symbol                                                                                 ||
|       DW_TAG_common_block                                                                                                                        |
||             DW_AT_name("Common1")                                                                                                               ||
|              DW_AT_location(Address  of  common  block  Common1)                                                                                 |
||             DW_TAG_variable                                                                                                                     ||
|                     DW_AT_name("C")                                                                                                              |
||                    DW_AT_type(reference  to  3$)                                                                                                ||
||                    DW_AT_location(address  of  C)                                                                                               ||
|                                                                                                                                                  |
|DW.myf90.CommonStuff.fh.654321.4:|      !  linker  global  symbol                                                                                 ||
|       DW_TAG_constant                                                                                                                            |
||             DW_AT_name("SEVEN")                                                                                                                 ||
||             DW_AT_type(reference  to  DW.f90.F90$main.f.2)                                                                                      ||
|                     !  base  type  INTEGER                                                                                                       |
||_____________DW_AT_const_value(constant__7)_____________________________________________________________________________________________________ ||
           Figure E.5: Duplicate elimination example #2: DWARF section group
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 400
                                     Appendix E.  Compression (Informative)
 |                                                                                                                                                  |
 __________________________________________________________________________________________________________________________________________________||*
 *||
 |==  section  .text                                                                                                                                |
 ||      [code  for  function  Foo]                                                                                                                 ||
 |                                                                                                                                                  |
 |==| section  .debug_info                                                                                                                          ||
 |       DW_TAG_compile_unit                                                                                                                        |
 ||             DW_TAG_subprogram                                                                                                                   ||
 ||                    DW_AT_name("Foo")                                                                                                            ||
 |                     DW_AT_type(reference  to  DW.f90.F90$main.f.2)                                                                               |
 ||                           !  base  type  INTEGER                                                                                                ||
 |                     DW_TAG_imported_unit                                                                                                         |
 ||                           DW_AT_import(reference  to                                                                                            ||
 |                                   DW.myf90.CommonStuff.fh.654321.1)                                                                              |
 ||                    DW_TAG_common_inclusion  !  For  Common1                                                                                     ||
 ||                           DW_AT_common_reference(reference  to                                                                                  ||
 |                                   DW.myf90.CommonStuff.fh.654321.3)                                                                              |
 ||                    DW_TAG_variable  !  For  function  result                                                                                    ||
 |                            DW_AT_name("Foo")                                                                                                     |
 ||                                  DW_AT_type(reference  to  DW.f90.F90$main.f.2)                                                                 ||
 ||_________________________________________!__base__type__INTEGER_________________________________________________________________________________ ||
                    Figure E.6: Duplicate elimination example #2: primary unit
 File Main.f
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||I'*
 *NCCoLmUmDoEn.Sfthu'f f
|||=============================================================================================================================================|||C(*
 *=580 )
|||=============================================================================================================================================|||P**
 *R,I'NRTe=s'u,lFtO(O5-0S)E V E N
|||=============================================================================================================================================|||E_*
 *N|D____|
               Figure E.7: Duplicate elimination example #2: companion source
 That main program results in an object ole that contained a duplicate of the
 section group named my.f90.company.f90.CommonStuff.fh.654321
 corresponding to the included ole as well as the remainder of the main
 subprogram as shown in Figure E.8 on the next page.
 This example uses DW.TAG.partial.unit for the section group because the
 included declarations are not independently visible as global entities.
 E.2           Using  Type  Units
 A large portion of debug information is type information, and in a typical
 compilation environment, many types are duplicated many times. One method
 of controlling the amount of duplication is separating each type into a separate
 COMDAT .debug_info section and arranging for the linker to recognize and
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 401
|                                   Appendix E.  Compression (Informative)                                                                         |
|                                                                                                                                                  |
__________________________________________________________________________________________________________________________________________________||
|==| section  .debug_info                                                                                                                          ||
|       DW_TAG_compile_unit                                                                                                                        |
||             DW_AT_name(F90$main)                                                                                                                ||
|              DW_TAG_base_type                                                                                                                    |
||                    DW_AT_name("INTEGER")                                                                                                        ||
||                    DW_AT_encoding(DW_ATE_signed)                                                                                                ||
|                     DW_AT_byte_size(...)                                                                                                         |
|                                                                                                                                                  |
|                                                                                                                                                  |
|              DW_TAG_base_type                                                                                                                    |
||                    ...                                                                                                                          ||
||             ...    !  other  base  types                                                                                                        ||
|              DW_TAG_subprogram                                                                                                                   |
||                    DW_AT_name("F90$main")                                                                                                       ||
|                     DW_TAG_imported_unit                                                                                                         |
||                           DW_AT_import(reference  to                                                                                            ||
||                                  DW.myf90.CommonStuff.fh.654321.1)                                                                              ||
|                     DW_TAG_common_inclusion  !  for  Common1                                                                                     |
||                           DW_AT_common_reference(reference  to                                                                                  ||
|                                   DW.myf90.CommonStuff.fh.654321.3)                                                                              |
||____________________..._________________________________________________________________________________________________________________________ ||
             Figure E.8: Duplicate elimination example #2: companion DWARF
eliminate duplicates at the individual type level.
Using this technique, each substantial type deonition is placed in its own
individual section, while the remainder of the DWARF information (non-type
information, incomplete type declarations, and deonitions of trivial types) is
placed in the usual debug information section. In a typical implementation, the
relocatable object ole may contain one of each of these debug sections:
.debug_abbrev
.debug_info
.debug_line
and any number of additional COMDAT .debug_info sections containing type
units.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 402
                                     Appendix E.  Compression (Informative)
 As discussed in the previous section (Section E.1 on page 391), many linkers
 today support the concept of a COMDAT group or linkonce section. The general
 idea is that a ikeyj can be attached to a section or a group of sections, and the
 linker will include only one copy of a section group (or individual section) for
 any given key. For COMDAT .debug_info sections, the key is the type signature
 formed from the algorithm given in Section 7.32 on page 258.
 E.2.1          Signature Computation Example
 As an example, consider a C++ header ole containing the type deonitions shown
 in Figure E.9.
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||nN*
 *a{m e s p a c e
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||sB*
 *t;r u c t
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||sC*
 *t{r u c t
|||=============================================================================================================================================|||ix*
 *n;t
|||=============================================================================================================================================|||iy*
 *n;t
|||=============================================================================================================================================|||};
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||cA*
 *l{a s s
|||=============================================================================================================================================|||p:*
 *u b l i c
|||=============================================================================================================================================|||A(*
 *ivn)t;
|||=============================================================================================================================================|||iv*
 *n(t);
|||=============================================================================================================================================|||p:*
 *r i v a t e
|||=============================================================================================================================================|||iv*
 *n_t;
|||=============================================================================================================================================|||sA*
 *t*rnuecxtt;
|||=============================================================================================================================================|||sB*
 *t*rbupc;t
|||=============================================================================================================================================|||sC*
 *tcr;u c t
|||=============================================================================================================================================|||};
|||=============================================================================================================================================|||}_*
 *|_____|
                             Figure E.9: Type signature examples: C++ source
 Next, consider one possible representation of the DWARF information that
 describes the type istruct Cj as shown in E.10 on the next page.
 In computing a signature for the type N::C, AEatten the type description into a
 byte stream according to the procedure outlined in Section 7.32 on page 258. The
 result is shown in Figure E.11 on page 405.
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 403
|                                   Appendix E.  Compression (Informative)                                                                         |
|                                                                                                                                                  |
|                                                                                                                                                  |
__________________________________________________________________________________________________________________________________________________||
|    DW_TAG_type_unit                                                                                                                              |
||          DW_AT_language_name  :  DW_LNAME_C_plus_plus  (4)                                                                                      ||
||      DW_TAG_namespace                                                                                                                           ||
|              DW_AT_name  :  "N"                                                                                                                  |
|L1:|                                                                                                                                              ||
|           DW_TAG_structure_type                                                                                                                  |
||                 DW_AT_name  :  "C"                                                                                                              ||
||                 DW_AT_byte_size  :  8                                                                                                           ||
|                  DW_AT_decl_file  :  1                                                                                                           |
||                 DW_AT_decl_line  :  5                                                                                                           ||
|              DW_TAG_member                                                                                                                       |
||                    DW_AT_name  :  "x"                                                                                                           ||
||                    DW_AT_decl_file  :  1                                                                                                        ||
|                     DW_AT_decl_line  :  6                                                                                                        |
||                    DW_AT_type  :  reference  to  L2                                                                                             ||
|                     DW_AT_data_member_location  :  0                                                                                             |
||             DW_TAG_member                                                                                                                       ||
|                     DW_AT_name  :  "y"                                                                                                           |
||                    DW_AT_decl_file  :  1                                                                                                        ||
||                    DW_AT_decl_line  :  7                                                                                                        ||
|                     DW_AT_type  :  reference  to  L2                                                                                             |
||                    DW_AT_data_member_location  :  4                                                                                             ||
|L2:                                                                                                                                               |
||        DW_TAG_base_type                                                                                                                         ||
||               DW_AT_byte_size  :  4                                                                                                             ||
|                DW_AT_encoding  :  DW_ATE_signed                                                                                                  |
||_______________DW_AT_name__:__"int"_____________________________________________________________________________________________________________ ||
            Figure E.10: Type signature computation #1: DWARF representation
Running an MD5 hash over this byte stream, and taking the low-order 64 bits,
yields the onal signature: 0xd28081e8 dcf5070a.
Next, consider a representation of the DWARF information that describes the
type iclass Aj as shown in Figure E.12 on page 406.
In this example, the structure types N::A and N::C have each been placed in
separate type units. For N::A, the actual deonition of the type begins at label L1.
The deonition involves references to the int base type and to two pointer types.
The information for each of these referenced types is also included in this type
unit, since base types and pointer types are trivial types that are not worth the
overhead of a separate type unit. The last pointer type contains a reference to an
incomplete type N::B, which is also included here as a declaration, since the
complete type is unknown and its signature is therefore unavailable. There is
also a reference to N::C, using DW.FORM.ref.sig8 to refer to the type signature
for that type.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 404
                                    Appendix E.  Compression (Informative)
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
__________________________________________________________________________________________________________________________________________________||
|//| Step  2:  'C'  DW_TAG_namespace  "N"                                                                                                          ||
|0x43  0x39  0x4e  0x00                                                                                                                            |
|//| Step  3:  'D'  DW_TAG_structure_type                                                                                                          ||
|0x44  0x13                                                                                                                                        |
|//| Step  4:  'A'  DW_AT_name  DW_FORM_string  "C"                                                                                                ||
|0x41| 0x03  0x08  0x43  0x00                                                                                                                      ||
|//  Step  4:  'A'  DW_AT_byte_size  DW_FORM_sdata  8                                                                                              |
|0x41| 0x0b  0x0d  0x08                                                                                                                            ||
|//  Step  7:  First  child  ("x")                                                                                                                 |
||      //  Step  3:  'D'  DW_TAG_member                                                                                                           ||
||      0x44  0x0d                                                                                                                                 ||
|       //  Step  4:  'A'  DW_AT_name  DW_FORM_string  "x"                                                                                         |
||      0x41  0x03  0x08  0x78  0x00                                                                                                               ||
|       //  Step  4:  'A'  DW_AT_data_member_location  DW_FORM_sdata  0                                                                            |
||      0x41  0x38  0x0d  0x00                                                                                                                     ||
||      //  Step  6:  'T'  DW_AT_type  (type  #2)                                                                                                  ||
|       0x54  0x49                                                                                                                                 |
||             //  Step  3:  'D'  DW_TAG_base_type                                                                                                 ||
|              0x44  0x24                                                                                                                          |
||             //  Step  4:  'A'  DW_AT_name  DW_FORM_string  "int"                                                                                ||
||             0x41  0x03  0x08  0x69  0x6e  0x74  0x00                                                                                            ||
|              //  Step  4:  'A'  DW_AT_byte_size  DW_FORM_sdata  4                                                                                |
||             0x41  0x0b  0x0d  0x04                                                                                                              ||
|              //  Step  4:  'A'  DW_AT_encoding  DW_FORM_sdata  DW_ATE_signed                                                                     |
||             0x41  0x3e  0x0d  0x05                                                                                                              ||
|              //  Step  7:  End  of  DW_TAG_base_type  "int"                                                                                      |
||             0x00                                                                                                                                ||
||      //  Step  7:  End  of  DW_TAG_member  "x"                                                                                                  ||
|       0x00                                                                                                                                       |
|//| Step  7:  Second  child  ("y")                                                                                                                ||
|       //  Step  3:  'D'  DW_TAG_member                                                                                                           |
||      0x44  0x0d                                                                                                                                 ||
||      //  Step  4:  'A'  DW_AT_name  DW_FORM_string  "y"                                                                                         ||
|       0x41  0x03  0x08  0x79  0x00                                                                                                               |
||      //  Step  4:  'A'  DW_AT_data_member_location  DW_FORM_sdata  4                                                                            ||
|       0x41  0x38  0x0d  0x04                                                                                                                     |
||      //  Step  6:  'R'  DW_AT_type  (type  #2)                                                                                                  ||
||      0x52  0x49  0x02                                                                                                                           ||
|       //  Step  7:  End  of  DW_TAG_member  "y"                                                                                                  |
||      0x00                                                                                                                                       ||
|//  Step  7:  End  of  DW_TAG_structure_type  "C"                                                                                                 |
|0x00|____________________________________________________________________________________________________________________________________________ ||
              Figure E.11: Type signature computation #1: AEattened byte stream
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 405
                                    Appendix E.  Compression (Informative)
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
____________________________________________________________________________________________________________________________________part_1_of_2___||||
||   DW_TAG_type_unit                                                                                                                              ||
|           DW_AT_language_name  :  DW_LNAME_C_plus_plus  (4)                                                                                      |
||      DW_TAG_namespace                                                                                                                           ||
||             DW_AT_name  :  "N"                                                                                                                  ||
|L1:                                                                                                                                               |
||             DW_TAG_class_type                                                                                                                   ||
|                       DW_AT_name  :  "A"                                                                                                         |
||                      DW_AT_byte_size  :  20                                                                                                     ||
||                      DW_AT_decl_file  :  1                                                                                                      ||
|                       DW_AT_decl_line  :  10                                                                                                     |
||                  DW_TAG_member                                                                                                                  ||
|                            DW_AT_name  :  "v_"                                                                                                   |
||                           DW_AT_decl_file  :  1                                                                                                 ||
|                            DW_AT_decl_line  :  15                                                                                                |
||                           DW_AT_type  :  reference  to  L2                                                                                      ||
||                           DW_AT_data_member_location  :  0                                                                                      ||
|                            DW_AT_accessibility  :  DW_ACCESS_private                                                                             |
||                 DW_TAG_member                                                                                                                   ||
|                          DW_AT_name  :  "next"                                                                                                   |
||                         DW_AT_decl_file  :  1                                                                                                   ||
||                         DW_AT_decl_line  :  16                                                                                                  ||
|                          DW_AT_type  :  reference  to  L3                                                                                        |
||                         DW_AT_data_member_location  :  4                                                                                        ||
|                          DW_AT_accessibility  :  DW_ACCESS_private                                                                               |
||                 DW_TAG_member                                                                                                                   ||
||                         DW_AT_name  :  "bp"                                                                                                     ||
|                          DW_AT_decl_file  :  1                                                                                                   |
||                         DW_AT_decl_line  :  17                                                                                                  ||
|                          DW_AT_type  :  reference  to  L4                                                                                        |
||                         DW_AT_data_member_location  :  8                                                                                        ||
|                          DW_AT_accessibility  :  DW_ACCESS_private                                                                               |
||                 DW_TAG_member                                                                                                                   ||
||                         DW_AT_name  :  "c"                                                                                                      ||
|                          DW_AT_decl_file  :  1                                                                                                   |
||                         DW_AT_decl_line  :  18                                                                                                  ||
|                          DW_AT_type  :  0xd28081e8  dcf5070a  (signature  for  struct  C)                                                        |
||                         DW_AT_data_member_location  :  12                                                                                       ||
||_________________________DW_AT_accessibility__:__DW_ACCESS_private______________________________________________________________________________ ||
            Figure E.12: Type signature computation #2: DWARF representation
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 406
                                    Appendix E.  Compression (Informative)
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
____________________________________________________________________________________________________________________________________part_2_of_2___||
||          DW_TAG_subprogram                                                                                                                      ||
||                  DW_AT_external  :  1                                                                                                           ||
|                   DW_AT_name  :  "A"                                                                                                             |
||                  DW_AT_decl_file  :  1                                                                                                          ||
|                   DW_AT_decl_line  :  12                                                                                                         |
||                  DW_AT_declaration  :  1                                                                                                        ||
|              DW_TAG_formal_parameter                                                                                                             |
||                  DW_AT_type  :  reference  to  L3                                                                                               ||
||                  DW_AT_artificial  :  1                                                                                                         ||
|              DW_TAG_formal_parameter                                                                                                             |
||                  DW_AT_type  :  reference  to  L2                                                                                               ||
|            DW_TAG_subprogram                                                                                                                     |
||                  DW_AT_external  :  1                                                                                                           ||
||                  DW_AT_name  :  "v"                                                                                                             ||
|                   DW_AT_decl_file  :  1                                                                                                          |
||                  DW_AT_decl_line  :  13                                                                                                         ||
|                   DW_AT_type  :  reference  to  L2                                                                                               |
||                  DW_AT_declaration  :  1                                                                                                        ||
||               DW_TAG_formal_parameter                                                                                                           ||
|                   DW_AT_type  :  reference  to  L3                                                                                               |
||                  DW_AT_artificial  :  1                                                                                                         ||
|L2:                                                                                                                                               |
||      DW_TAG_base_type                                                                                                                           ||
||               DW_AT_byte_size  :  4                                                                                                             ||
|                DW_AT_encoding  :  DW_ATE_signed                                                                                                  |
||               DW_AT_name  :  "int"                                                                                                              ||
|L3:                                                                                                                                               |
||      DW_TAG_pointer_type                                                                                                                        ||
|                DW_AT_type  :  reference  to  L1                                                                                                  |
|L4:|                                                                                                                                              ||
||      DW_TAG_pointer_type                                                                                                                        ||
|                DW_AT_type  :  reference  to  L5                                                                                                  |
||      DW_TAG_namespace                                                                                                                           ||
|                DW_AT_name  :  "N"                                                                                                                |
|L5:|                                                                                                                                              ||
||           DW_TAG_structure_type                                                                                                                 ||
|                   DW_AT_name  :  "B"                                                                                                             |
||__________________DW_AT_declaration__:__1_______________________________________________________________________________________________________ ||
  Figure E.12: Type signature computation #2: DWARF representation (concluded)
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 407
                                    Appendix E.  Compression (Informative)
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
____________________________________________________________________________________________________________________________________part_1_of_3___||||
|//| Step  2:  'C'  DW_TAG_namespace  "N"                                                                                                          ||
|0x43  0x39  0x4e  0x00                                                                                                                            |
|//| Step  3:  'D'  DW_TAG_class_type                                                                                                              ||
|0x44| 0x02                                                                                                                                        ||
|//  Step  4:  'A'  DW_AT_name  DW_FORM_string  "A"                                                                                                |
|0x41| 0x03  0x08  0x41  0x00                                                                                                                      ||
|//  Step  4:  'A'  DW_AT_byte_size  DW_FORM_sdata  20                                                                                             |
|0x41| 0x0b  0x0d  0x14                                                                                                                            ||
|//| Step  7:  First  child  ("v_")                                                                                                                ||
|       //  Step  3:  'D'  DW_TAG_member                                                                                                           |
||      0x44  0x0d                                                                                                                                 ||
|       //  Step  4:  'A'  DW_AT_name  DW_FORM_string  "v_"                                                                                        |
||      0x41  0x03  0x08  0x76  0x5f  0x00                                                                                                         ||
||      //  Step  4:  'A'  DW_AT_accessibility  DW_FORM_sdata  DW_ACCESS_private                                                                   ||
|       0x41  0x32  0x0d  0x03                                                                                                                     |
||      //  Step  4:  'A'  DW_AT_data_member_location  DW_FORM_sdata  0                                                                            ||
|       0x41  0x38  0x0d  0x00                                                                                                                     |
||      //  Step  6:  'T'  DW_AT_type  (type  #2)                                                                                                  ||
||      0x54  0x49                                                                                                                                 ||
|              //  Step  3:  'D'  DW_TAG_base_type                                                                                                 |
||             0x44  0x24                                                                                                                          ||
|              //  Step  4:  'A'  DW_AT_name  DW_FORM_string  "int"                                                                                |
||             0x41  0x03  0x08  0x69  0x6e  0x74  0x00                                                                                            ||
|              //  Step  4:  'A'  DW_AT_byte_size  DW_FORM_sdata  4                                                                                |
||             0x41  0x0b  0x0d  0x04                                                                                                              ||
||             //  Step  4:  'A'  DW_AT_encoding  DW_FORM_sdata  DW_ATE_signed                                                                     ||
|              0x41  0x3e  0x0d  0x05                                                                                                              |
||             //  Step  7:  End  of  DW_TAG_base_type  "int"                                                                                      ||
|              0x00                                                                                                                                |
||      //  Step  7:  End  of  DW_TAG_member  "v_"                                                                                                 ||
||      0x00                                                                                                                                       ||
|//  Step  7:  Second  child  ("next")                                                                                                             |
||      //  Step  3:  'D'  DW_TAG_member                                                                                                           ||
|       0x44  0x0d                                                                                                                                 |
||      //  Step  4:  'A'  DW_AT_name  DW_FORM_string  "next"                                                                                      ||
||      0x41  0x03  0x08  0x6e  0x65  0x78  0x74  0x00                                                                                             ||
|       //  Step  4:  'A'  DW_AT_accessibility  DW_FORM_sdata  DW_ACCESS_private                                                                   |
||      0x41  0x32  0x0d  0x03                                                                                                                     ||
|       //  Step  4:  'A'  DW_AT_data_member_location  DW_FORM_sdata  4                                                                            |
||______0x41__0x38__0x0d__0x04____________________________________________________________________________________________________________________ ||
                 Figure E.13: Type signature example #2: AEattened byte stream
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 408
|                                   Appendix E.  Compression (Informative)                                                                         |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
____________________________________________________________________________________________________________________________________part_2_of_3___||||
||      //  Step  6:  'T'  DW_AT_type  (type  #3)                                                                                                  ||
|       0x54  0x49                                                                                                                                 |
||             //  Step  3:  'D'  DW_TAG_pointer_type                                                                                              ||
|              0x44  0x0f                                                                                                                          |
||             //  Step  5:  'N'  DW_AT_type                                                                                                       ||
|              0x4e  0x49                                                                                                                          |
||             //  Step  5:  'C'  DW_TAG_namespace  "N"  'E'                                                                                       ||
||             0x43  0x39  0x4e  0x00  0x45                                                                                                        ||
|              //  Step  5:  "A"                                                                                                                   |
||             0x41  0x00                                                                                                                          ||
|              //  Step  7:  End  of  DW_TAG_pointer_type                                                                                          |
||             0x00                                                                                                                                ||
||      //  Step  7:  End  of  DW_TAG_member  "next"                                                                                               ||
|       0x00                                                                                                                                       |
|//| Step  7:  Third  child  ("bp")                                                                                                                ||
|       //  Step  3:  'D'  DW_TAG_member                                                                                                           |
||      0x44  0x0d                                                                                                                                 ||
||      //  Step  4:  'A'  DW_AT_name  DW_FORM_string  "bp"                                                                                        ||
|       0x41  0x03  0x08  0x62  0x70  0x00                                                                                                         |
||      //  Step  4:  'A'  DW_AT_accessibility  DW_FORM_sdata  DW_ACCESS_private                                                                   ||
|       0x41  0x32  0x0d  0x03                                                                                                                     |
||      //  Step  4:  'A'  DW_AT_data_member_location  DW_FORM_sdata  8                                                                            ||
||      0x41  0x38  0x0d  0x08                                                                                                                     ||
|       //  Step  6:  'T'  DW_AT_type  (type  #4)                                                                                                  |
||      0x54  0x49                                                                                                                                 ||
|              //  Step  3:  'D'  DW_TAG_pointer_type                                                                                              |
||             0x44  0x0f                                                                                                                          ||
|              //  Step  5:  'N'  DW_AT_type                                                                                                       |
||             0x4e  0x49                                                                                                                          ||
||             //  Step  5:  'C'  DW_TAG_namespace  "N"  'E'                                                                                       ||
|              0x43  0x39  0x4e  0x00  0x45                                                                                                        |
||             //  Step  5:  "B"                                                                                                                   ||
|              0x42  0x00                                                                                                                          |
||             //  Step  7:  End  of  DW_TAG_pointer_type                                                                                          ||
||             0x00                                                                                                                                ||
|       //  Step  7:  End  of  DW_TAG_member  "next"                                                                                               |
||      0x00                                                                                                                                       ||
|//  Step  7:  Fourth  child  ("c")                                                                                                                |
||      //  Step  3:  'D'  DW_TAG_member                                                                                                           ||
||      0x44  0x0d                                                                                                                                 ||
|       //  Step  4:  'A'  DW_AT_name  DW_FORM_string  "c"                                                                                         |
||      0x41  0x03  0x08  0x63  0x00                                                                                                               ||
|       //  Step  4:  'A'  DW_AT_accessibility  DW_FORM_sdata  DW_ACCESS_private                                                                   |
||______0x41__0x32__0x0d__0x03____________________________________________________________________________________________________________________ ||
        Figure E.13: Type signature example #2: AEattened byte stream (continued)
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 409
|                                                                                                                                                  |
|                                   Appendix E.  Compression (Informative)                                                                         |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
____________________________________________________________________________________________________________________________________part_3_of_3___||||
|       //  Step  4:  'A'  DW_AT_data_member_location  DW_FORM_sdata  12                                                                           |
||      0x41  0x38  0x0d  0x0c                                                                                                                     ||
||      //  Step  6:  'T'  DW_AT_type  (type  #5)                                                                                                  ||
|       0x54  0x49                                                                                                                                 |
||             //  Step  2:  'C'  DW_TAG_namespace  "N"                                                                                            ||
|              0x43  0x39  0x4e  0x00                                                                                                              |
||             //  Step  3:  'D'  DW_TAG_structure_type                                                                                            ||
|              0x44  0x13                                                                                                                          |
||             //  Step  4:  'A'  DW_AT_name  DW_FORM_string  "C"                                                                                  ||
||             0x41  0x03  0x08  0x43  0x00                                                                                                        ||
|              //  Step  4:  'A'  DW_AT_byte_size  DW_FORM_sdata  8                                                                                |
||             0x41  0x0b  0x0d  0x08                                                                                                              ||
|              //  Step  7:  First  child  ("x")                                                                                                   |
||                    //  Step  3:  'D'  DW_TAG_member                                                                                             ||
||                    0x44  0x0d                                                                                                                   ||
|                     //  Step  4:  'A'  DW_AT_name  DW_FORM_string  "x"                                                                           |
||                    0x41  0x03  0x08  0x78  0x00                                                                                                 ||
|                     //  Step  4:  'A'  DW_AT_data_member_location  DW_FORM_sdata  0                                                              |
||                    0x41  0x38  0x0d  0x00                                                                                                       ||
||                    //  Step  6:  'R'  DW_AT_type  (type  #2)                                                                                    ||
|                     0x52  0x49  0x02                                                                                                             |
||                    //  Step  7:  End  of  DW_TAG_member  "x"                                                                                    ||
|                     0x00                                                                                                                         |
||             //  Step  7:  Second  child  ("y")                                                                                                  ||
||                    //  Step  3:  'D'  DW_TAG_member                                                                                             ||
|                     0x44  0x0d                                                                                                                   |
||                    //  Step  4:  'A'  DW_AT_name  DW_FORM_string  "y"                                                                           ||
|                     0x41  0x03  0x08  0x79  0x00                                                                                                 |
||                    //  Step  4:  'A'  DW_AT_data_member_location  DW_FORM_sdata  4                                                              ||
|                     0x41  0x38  0x0d  0x04                                                                                                       |
||                    //  Step  6:  'R'  DW_AT_type  (type  #2)                                                                                    ||
||                    0x52  0x49  0x02                                                                                                             ||
|                     //  Step  7:  End  of  DW_TAG_member  "y"                                                                                    |
||                    0x00                                                                                                                         ||
|              //  Step  7:  End  of  DW_TAG_structure_type  "C"                                                                                   |
||             0x00                                                                                                                                ||
||      //  Step  7:  End  of  DW_TAG_member  "c"                                                                                                  ||
|       0x00                                                                                                                                       |
|//| Step  7:  Fifth  child  ("A")                                                                                                                 ||
|       //  Step  3:  'S'  DW_TAG_subprogram  "A"                                                                                                  |
||      0x53  0x2e  0x41  0x00                                                                                                                     ||
|//| Step  7:  Sixth  child  ("v")                                                                                                                 ||
|       //  Step  3:  'S'  DW_TAG_subprogram  "v"                                                                                                  |
||      0x53  0x2e  0x76  0x00                                                                                                                     ||
|//  Step  7:  End  of  DW_TAG_structure_type  "A"                                                                                                 |
|0x00|____________________________________________________________________________________________________________________________________________ ||
        Figure E.13: Type signature example #2: AEattened byte stream (concluded)
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 410
                                    Appendix E.  Compression (Informative)
In computing a signature for the type N::A, AEatten the type description into a
byte stream according to the procedure outlined in Section 7.32 on page 258. The
result is shown in Figure E.13 on page 408.
Running an MD5 hash over this byte stream, and taking the low-order 64 bits,
yields the onal signature: 0xd6d160f5 5589f6e9.
A source ole that includes this header ole may declare a variable of type N::A,
and its DWARF information may look like that shown in Figure E.14.
__________________________________________________________________________________________________________________________________________________||
|    DW_TAG_compile_unit                                                                                                                           |
||   ...                                                                                                                                           ||
|    DW_TAG_subprogram                                                                                                                             |
||      ...                                                                                                                                        ||
||      DW_TAG_variable                                                                                                                            ||
|           DW_AT_name  :  "a"                                                                                                                     |
||          DW_AT_type  :  (signature)  0xd6d160f5  5589f6e9                                                                                       ||
|           DW_AT_location  :  ...                                                                                                                 |
||______..._______________________________________________________________________________________________________________________________________ ||
                                  Figure E.14: Type signature example usage
E.2.2          Type Signature Computation Grammar
Figure E.15 on the following page presents a semi-formal grammar that may aid
in understanding how the bytes of the AEattened type description are formed
during the type signature computation algorithm of Section 7.32 on page 258.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 411
|                                                                                                                                                  |
|                                                                                                                                                  |
||                                  Appendix E.  Compression (Informative)                                                                         ||
|                                                                                                                                                  |
__________________________________________________________________________________________________________________________________________________||||
|signature                                                                                                                                         |
||      :  opt-context  debug-entry  attributes  children                                                                                          ||
|opt-context                          //  Step  2                                                                                                  |
||      :  'C'  tag-code  string  opt-context                                                                                                      ||
||      :  empty                                                                                                                                   ||
|debug-entry                          //  Step  3                                                                                                  |
||      :  'D'  tag-code                                                                                                                           ||
|attributes                            //  Steps  4,  5,  6                                                                                        |
||      :  attribute  attributes                                                                                                                   ||
|       :  empty                                                                                                                                   |
|attribute|                                                                                                                                        ||
||      :  'A'  at-code  form-encoded-value         //  Normal  attributes                                                                         ||
|       :  'N'  at-code  opt-context  'E'  string  //  Reference  to  type  by  name                                                               |
||      :  'R'  at-code  back-ref                          //  Back-reference  to  visited  type                                                   ||
|       :  'T'  at-code  signature                         //  Recursive  type                                                                     |
|children|                             //    Step  7                                                                                               ||
||      :  child  children                                                                                                                         ||
|       :  '\0'                                                                                                                                    |
|child|                                                                                                                                            ||
|       :  'S'  tag-code  string                                                                                                                   |
||      :  signature                                                                                                                               ||
|tag-code|                                                                                                                                         ||
|       :  <ULEB128>                                                                                                                               |
|at-code|                                                                                                                                          ||
|       :  <ULEB128>                                                                                                                               |
|form-encoded-value|                                                                                                                               ||
||      :  DW_FORM_sdata  value                                                                                                                    ||
|       :  DW_FORM_flag  value                                                                                                                     |
||      :  DW_FORM_string  string                                                                                                                  ||
|       :  DW_FORM_block  block                                                                                                                    |
|DW_FORM_string|                                                                                                                                   ||
|       :  '\x08'                                                                                                                                  |
|DW_FORM_block|                                                                                                                                    ||
||      :  '\x09'                                                                                                                                  ||
|DW_FORM_flag                                                                                                                                      |
||      :  '\x0c'                                                                                                                                  ||
|DW_FORM_sdata                                                                                                                                     |
||      :  '\x0d'                                                                                                                                  ||
|value|                                                                                                                                            ||
|       :  <SLEB128>                                                                                                                               |
|block|                                                                                                                                            ||
|       :  <ULEB128>  <fixed-length-block>  //  The  ULEB128  gives  the  length  of  the  block                                                   |
|back-ref|                                                                                                                                         ||
||      :  <ULEB128>                                                                                                                               ||
|string                                                                                                                                            |
||      :  <null-terminated-string>                                                                                                                ||
|empty                                                                                                                                             |
||______:_________________________________________________________________________________________________________________________________________ ||
                           Figure E.15: Type signature computation grammar
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 412
                                    Appendix E.  Compression (Informative)
E.2.3          Declarations Completing Non-Deoning Declarations
Consider a compilation unit that contains a deonition of the member function
N::A::v()|from|Figure E.9 on page 403. A possible representation of the debug                                                                      ||
information|for|this function in the compilation unit is shown in Figure E.16.                                                                     ||
__________________________________________________________________________________________________________________________________________________||||
|    DW_TAG_namespace                                                                                                                              |
||          DW_AT_name  :  "N"                                                                                                                     ||
|L1:                                                                                                                                               |
||      DW_TAG_class_type                                                                                                                          ||
|              DW_AT_name  :  "A"                                                                                                                  |
||             DW_AT_declaration  :  true                                                                                                          ||
||             DW_AT_signature  :  0xd6d160f5  5589f6e9                                                                                            ||
|L2:                                                                                                                                               |
||          DW_TAG_subprogram                                                                                                                      ||
|                  DW_AT_external  :  1                                                                                                            |
||                 DW_AT_name  :  "v"                                                                                                              ||
||                 DW_AT_decl_file  :  1                                                                                                           ||
|                  DW_AT_decl_line  :  13                                                                                                          |
||                 DW_AT_type  :  reference  to  L3                                                                                                ||
|                  DW_AT_declaration  :  1                                                                                                         |
||             DW_TAG_formal_parameter                                                                                                             ||
||                    DW_AT_type  :  reference  to  L4                                                                                             ||
|                     DW_AT_artificial  :  1                                                                                                       |
|...|                                                                                                                                              ||
|L3:                                                                                                                                               |
||   DW_TAG_base_type                                                                                                                              ||
|           DW_AT_byte_size  :  4                                                                                                                  |
||          DW_AT_encoding  :  DW_ATE_signed                                                                                                       ||
||          DW_AT_name  :  "int"                                                                                                                   ||
|...                                                                                                                                               |
|L4:|                                                                                                                                              ||
|    DW_TAG_pointer_type                                                                                                                           |
||          DW_AT_type  :  reference  to  L1                                                                                                       ||
|...|                                                                                                                                              ||
|    DW_TAG_subprogram                                                                                                                             |
||          DW_AT_specification  :  reference  to  L2                                                                                              ||
|           DW_AT_decl_file  :  2                                                                                                                  |
||          DW_AT_decl_line  :  25                                                                                                                 ||
||          DW_AT_low_pc  :  ...                                                                                                                   ||
|           DW_AT_high_pc  :  ...                                                                                                                  |
||      DW_TAG_lexical_block                                                                                                                       ||
|       ...                                                                                                                                        |
|...|_____________________________________________________________________________________________________________________________________________ ||
   Figure E.16: Completing declaration of a member function: DWARF encoding
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 413
                                    Appendix E.  Compression (Informative)
E.3           Summary  of  Compression  Techniques
E.3.1          #include compression
C++ has a much greater problem than C with the number and size of the headers
included and the amount of data in each, but even with C there is substantial
header ole information duplication.
A reasonable approach is to put each header ole in its own section group, using
the naming rules mentioned above. The section groups are marked to ensure
duplicate removal.
All data instances and code instances (even if they came from the header oles
above) are put into non-section group sections such as the base object ole
.debug_info section.
E.3.2          Eliminating function duplication
Function templates (C++) result in code for the same template instantiation being
compiled into multiple archives or relocatable object oles. The linker wants to
keep only one of a given entity. The DWARF description, and everything else for
this function, should be reduced to just a single copy.
For each such code group (function template in this example) the compiler
assigns a name for the group which will match all other instantiations of this
function but match nothing else. The section groups are marked to ensure
duplicate removal, so that the second and subsequent deonitions seen by the
static linker are simply discarded.
References to other .debug_info sections follow the approach suggested above,
but the naming rule is slightly dioeerent in that the <file-designator> should be
interpreted as a <function-designator>.
E.3.3          Single-function-per-DWARF-compilation-unit
Section groups can help make it easy for a linker to completely remove unused
functions.
Such section groups are not marked for duplicate removal, since the functions
are not duplicates of anything.
Each function is given a compilation unit and a section group. Each such
compilation unit is complete, with its own text, data, and DWARF sections.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 414
                                    Appendix E.  Compression (Informative)
There will also be a compilation unit that has the ole-level declarations and
deonitions. Other per-function compilation unit DWARF information
(.debug_info) points to this common ole-level compilation unit using
DW.TAG.imported.unit.
Section groups can use DW.FORM.ref.addr and internal labels (section-relative
relocations) to refer to the main object ole sections, as the section groups here are
either deleted as unused or kept. There is no possibility (aside from error) of a
group from some other compilation being used in place of one of these groups.
E.3.4          Inlining and out-of-line-instances
Abstract instances  and concrete-out-of-line instances may be put in distinct
compilation units using section groups. This makes possible some useful
duplicate DWARF elimination.
No special provision for eliminating class duplication resulting from template
instantiation is made here, though nothing prevents eliminating such duplicates using
section groups.
E.3.5          Separate Type Units
Each complete declaration of a globally-visible type can be placed in its own
separate type section, with a group key derived from the type signature. The
linker can then remove all duplicate type declarations based on the key.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 415
                                    Appendix E.  Compression (Informative)
                                                             (empty page)
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 416

Appendix  F
Split  DWARF  Object  Files
(Informative)
With the traditional DWARF format, debug information is designed with the
expectation that it will be processed by the linker to produce an output binary
with complete debug information, and with fully-resolved references to locations
within the application. For very large applications, however, this approach can
result in excessively large link times and excessively large output oles.
Several producers have independently developed proprietary approaches that
allow the debug information to remain in the relocatable object oles, so that the
linker does not have to process the debug information or copy it to the output
ole. These approaches have all required that additional information be made
available to the debug information consumer, and that the consumer perform
some minimal amount of relocation in order to interpret the debug info correctly.
The additional information required, in the form of load maps or symbol tables,
and the details of the relocation are not covered by the DWARF speciocation, and
vary with each producer 's implementation.
Section 7.3.2 on page 195 describes a platform-independent mechanism that
allows a producer to split the debugging information into relocatable and
non-relocatable partitions. This Appendix describes the use of split DWARF
object oles and provides some illustrative examples.
F.1          Overview
DWARF Version 5 introduces an optional set of debugging sections that allow the
compiler to partition the debugging information into a set of (small) sections that
require link-time relocation and a set of (large) sections that do not. The sections
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 417
                          Appendix F.  Split DWARF Object Files (Informative)
that require relocation are written to the relocatable object ole as usual, and are
linked into the onal executable. The sections that do not require relocation,
however, can be written to the relocatable object (.o) ole but ignored by the
linker, or they can be written to a separate DWARF object (.dwo) ole that need
not be accessed by the linker.
The optional set of debugging sections includes the following:
     #    .debug_abbrev.dwo - Contains the abbreviations table(s) used by the
          .debug_info.dwo section.
     #    .debug_info.dwo - Contains the DW.TAG.compile.unit and
          DW.TAG.type.unit DIEs and their descendants. This is the bulk of the
          debugging information for the compilation unit that is normally found in
          the .debug_info section.
     #    .debug_loclists.dwo - Contains the location lists referenced by the
          debugging information entries in the .debug_info.dwo section. This
          contains the value lists and location lists normally found in the
          .debug_loclists section.
     #    .debug_str.dwo - Contains the string table for all indirect strings
          referenced by the debugging information in the .debug_info.dwo sections.
     #    .debug_str_offsets.dwo - Contains the string ooesets table for the strings
          in the .debug_str.dwo section.
     #    .debug_macro.dwo - Contains macro deonition information, normally
          found in the .debug_macro section.
     #    .debug_line.dwo - Contains specialized line number tables for the type
          units in the .debug_info.dwo section. These tables contain only the
          directory and olename lists needed to interpret DW.AT.decl.ole attributes
          in the debugging information entries. Actual line number tables remain in
          the .debug_line section, and remain in the relocatable object (.o) oles.
In a .dwo ole, there is no beneot to having a separate string section for directories
and ole names because the primary string table will never be stripped.
Accordingly, no .debug_line_str.dwo section is deoned. Content descriptions
corresponding to DW.FORM.line.strp in an executable ole (for example, in the
skeleton compilation unit) instead use one of the forms DW.FORM.strx,
DW.FORM.strx1, DW.FORM.strx2, DW.FORM.strx3 or DW.FORM.strx4.
This allows directory and ole name strings to be merged with general strings and
across compilations in package oles (where they are not subject to potential
stripping). This merge is facilitated by the requirement that all references to the
.debug_str.dwo string table are made indirectly through the
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 418
                          Appendix F.  Split DWARF Object Files (Informative)
.debug_str_offsets.dwo section so that only that section needs to be modioed
during string merging (see Section 7.3.2.2 on page 196).
In order for the consumer to locate and process the debug information, the
compiler must produce a small amount of debug information that passes through
the linker into the output binary. A skeleton .debug_info section for each
compilation unit contains a reference to the corresponding .o or .dwo ole, and
the .debug_line section (which is typically small compared to the .debug_info
sections) is linked into the output binary, as is the .debug_addr section.
The debug sections that continue to be linked into the output binary include the
following:
     #    .debug_abbrev - Contains the abbreviation codes used by the skeleton
          .debug_info section.
     #    .debug_addr - Contains references to loadable sections, indexed by
          attributes of one of the forms DW.FORM.addrx, DW.FORM.addrx1,
          DW.FORM.addrx2, DW.FORM.addrx3, DW.FORM.addrx4, or location
          expression DW.OP.addrx opcodes.
     #    .debug_aranges - Contains the accelerated range lookup table for the
          compilation unit.
     #    .debug_frame - Contains the frame tables.
     #    .debug_info - Contains a skeleton skeleton compilation unit DIE, which
          has no children.
     #    .debug_line - Contains the line number tables. (These could be moved to
          the .dwo ole, but in order to do so, each DW.LNE.set.address opcode
          would need to be replaced by a new opcode that referenced an entry in the
          .debug_addr section. Furthermore, leaving this section in the .o ole allows
          many debug info consumers to remain unaware of .dwo oles.)
     #    .debug_line_str - Contains strings for ole names used in combination
          with the .debug_line section.
     #    .debug_names - Contains the names for use in building an index section.
          The section header refers to a compilation unit ooeset, which is the ooeset of
          the skeleton compilation unit in the .debug_info section.
     #    .debug_str - Contains any strings referenced by the skeleton .debug_info
          sections (via DW.FORM.strp, DW.FORM.strp8, DW.FORM.strx,
          DW.FORM.strx1, DW.FORM.strx2, DW.FORM.strx3 or
          DW.FORM.strx4).
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 419
                          Appendix F.  Split DWARF Object Files (Informative)
     #    .debug_str_offsets - Contains the string ooesets table for the strings in the
          .debug_str section (if one of the forms DW.FORM.strx, DW.FORM.strx1,
          DW.FORM.strx2, DW.FORM.strx3 or DW.FORM.strx4 is used).
The skeleton compilation unit DIE may have the following attributes:
   DW.AT.addr.base                       DW.AT.high.pc                          DW.AT.stmt.list
   DW.AT.comp.dir                        DW.AT.low.pc                           DW.AT.str.ooesets
   DW.AT.dwo.name                        DW.AT.ranges
All other attributes of the compilation unit DIE are moved to the full DIE in the
.debug_info.dwo section.
The dwo_id oeld is present in headers of the skeleton DIE and the header of the
full DIE, so that a consumer can verify a match.
Relocations are neither necessary nor useful in .dwo oles, because the .dwo oles
contain only debugging information that does not need to be processed by a
linker. Relocations are rendered unnecessary by these strategies:
1.    Some values needing relocation are kept in the .o ole (for example, references
      to the line number program from the skeleton compilation unit).
2.    Some values do not need a relocation because they refer from one .dwo
      section to another .dwo section in the same compilation unit.
3.    Some values that need a relocation to refer to a relocatable program address
      use one of the DW.FORM.addrx, DW.FORM.addrx1, DW.FORM.addrx2,
      DW.FORM.addrx3 or DW.FORM.addrx4 forms, referencing a relocatable
      value in the .debug_addr section (which remains in the .o ole).
Table F.1 on the following page summarizes which attributes are deoned for use
in the various kinds of compilation units (see Section 3.1 on page 61). It compares
and contrasts both conventional and split object-related kinds.
The split dwarf object ole design depends on having an index of debugging
information available to the consumer. For name lookups, the consumer can use
the .debug_names index section (see Section 6.1 on page 140) to locate a skeleton
compilation unit. The DW.AT.comp.dir and DW.AT.dwo.name attributes in
the skeleton compilation unit can then be used to locate the corresponding
DWARF object ole for the compilation unit. Similarly, for an address lookup, the
consumer can use the .debug_aranges table, which will also lead to a skeleton
compilation unit. For a ole and line number lookup, the skeleton compilation
units can be used to locate the line number tables.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 420
                          Appendix F.  Split DWARF Object Files (Informative)
                                       Table F.1: Unit attributes by unit kind
__________________________________________________________________________________________________________________________________________________
                                                        |                                   Unit Kind
                                                        |
                                                        | Conventional                            Skeleton and Split
                                                        |
  Attribute                                             ||Full &          Type  ||     Skeleton           Split Full          Split Type
                                                        | Partial                    |
________________________________________________________|____________________________|____________________________________________________________##
__DW.AT.addr.base_______________________________________||___________________________||___________________________________________________________
                                                              #
__DW.AT.base.types______________________________________||___________________________||___________________________________________________________
                                                              #                              #
__DW.AT.comp.dir________________________________________||___________________________||___________________________________________________________
                                                                                             #
__DW.AT.dwo.name________________________________________||___________________________||___________________________________________________________
                                                              #                                                 #
__DW.AT.entry.pc________________________________________||___________________________||___________________________________________________________
                                                              #                              #
__DW.AT.high.pc_________________________________________||___________________________||___________________________________________________________
                                                              #                                                 #
__DW.AT.identioer.case__________________________________||___________________________||___________________________________________________________
                                                              #              #                                  #                    #
__DW.AT.language.name___________________________________||___________________________||___________________________________________________________
                                                              #              #                                  #                    #
__DW.AT.language.version________________________________||___________________________||___________________________________________________________
                                                              #                                                 #
__DW.AT.loclists.base___________________________________||___________________________||___________________________________________________________
                                                              #                              #
__DW.AT.low.pc__________________________________________||___________________________||___________________________________________________________
                                                              #                                                 #
__DW.AT.macros__________________________________________||___________________________||___________________________________________________________
                                                              #                                                 #
__DW.AT.main.subprogram_________________________________||___________________________||___________________________________________________________
                                                              #                                                 #
__DW.AT.name____________________________________________||___________________________||___________________________________________________________
                                                              #                                                 #
__DW.AT.producer________________________________________||___________________________||___________________________________________________________
                                                              #                                                 #
__DW.AT.ranges__________________________________________||___________________________||___________________________________________________________
                                                              #                              #                  #
__DW.AT.rnglists.base___________________________________||___________________________||___________________________________________________________
                                                              #              #               #                                       #
__DW.AT.stmt.list_______________________________________||___________________________||___________________________________________________________
                                                              #              #               #                  #
__DW.AT.str.ooesets_____________________________________||___________________________||___________________________________________________________
                                                              #              #               #                  #                    #
__DW.AT.use.UTF8________________________________________||___________________________||___________________________________________________________
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 421
                           Appendix F.  Split DWARF Object Files (Informative)
 F.2          Split  DWARF  Object  File  Example
 Consider the example source code in Figure F.1, Figure F.2 on the following page
 and Figure F.3 on page 424. When compiled with split DWARF, we will have two
 DWARF object oles, demo1.o and demo2.o, and two split DWARF object oles,
 demo1.dwo and demo2.dwo.
 In this section, we will use this example to show how the connections between
 the relocatable object ole and the split DWARF object ole are maintained through
 the linking process. In the next section, we will use this same example to show
 how two or more split DWARF object oles are combined into a DWARF package
 ole.
 File demo1.cc
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||#i*
 *"ndcelmuod.eh"
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||bB*
 *oooxl::c(ocnotnasitnPso&ipn)tc o n s t
|||=============================================================================================================================================|||{
|||=============================================================================================================================================|||r(*
 *ept.uxr(n)>=l.lx_()&&p.x()<=u.rx_()&&
|||=============================================================================================================================================|||p.*
 *y()>=l.ly_()&&p.y()<=u.ry_());
|||=============================================================================================================================================|||}_*
 *|_____|
                           Figure F.1: Split object example: source fragment #1
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 422
                           Appendix F.  Split DWARF Object Files (Informative)
 File demo2.cc
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||#i*
 *"ndcelmuod.eh"
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||bL*
 *oionle::c(lciopnBsotx&b)
|||=============================================================================================================================================|||{
|||=============================================================================================================================================|||fs*
 *llooapte=(e.nyd(_)-s.tya(r)t)_/(e.nxd(_)-s.txa(r)t)_;
|||=============================================================================================================================================|||w(*
 *h1i)l{e
|||=============================================================================================================================================|||//*
 *Tarcicveipatla.n c e
|||=============================================================================================================================================|||if*
 *(b.c(osnttaaritn_s)&&b.c(oenntda_i)n)srtertuuer;n
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||//*
 *Trreijveicatli.o n
|||=============================================================================================================================================|||if*
 *(s.txa(r)t<_b.l()&&e.nxd(_)<b.l())rfeatlusren;
|||=============================================================================================================================================|||if*
 *(s.txa(r)t>_b.r()&&e.nxd(_)>b.r())rfeatlusren;
|||=============================================================================================================================================|||if*
 *(s.tya(r)t<_b.b()&&e.nyd(_)<b.b())rfeatlusren;
|||=============================================================================================================================================|||if*
 *(s.tya(r)t>_b.t()&&e.nyd(_)>b.t())rfeatlusren;
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||if*
 *(b.c(osnttaaritn_s)){
|||=============================================================================================================================================|||//*
 *Spwoaipnstostshtaatrits_otuhtescildiep p i n g
|||=============================================================================================================================================|||//*
 *r.e c t a n g l e
|||=============================================================================================================================================|||Pt*
 *oeimnpt=s;t a r t _
|||=============================================================================================================================================|||s=*
 *teanrdt__;
|||=============================================================================================================================================|||e=*
 *ntde_m;p
|||=============================================================================================================================================|||}
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||if*
 *(s.txa(r)t<_b.l())
|||=============================================================================================================================================|||s=*
 *tPaoritn_t(b.l(),
|||=============================================================================================================================================|||s.*
 *tya(r)t+_(b.l()-s.txa(r)t)_*s)l;o p e
|||=============================================================================================================================================|||ei*
 *lfs(es.txa(r)t>_b.r())
|||=============================================================================================================================================|||s=*
 *tPaoritn_t(b.r(),
|||=============================================================================================================================================|||s.*
 *tya(r)t+_(b.r()-s.txa(r)t)_*s)l;o p e
|||=============================================================================================================================================|||ei*
 *lfs(es.tya(r)t<_b.b())
|||=============================================================================================================================================|||s=*
 *tPaoritn_t(s.txa(r)t+_(b.b()-s.tya(r)t)_/slope,
|||=============================================================================================================================================|||b.*
 *b());
|||=============================================================================================================================================|||ei*
 *lfs(es.tya(r)t>_b.t())
|||=============================================================================================================================================|||s=*
 *tPaoritn_t(s.txa(r)t+_(b.t()-s.tya(r)t)_/slope,
|||=============================================================================================================================================|||b.*
 *t());
|||=============================================================================================================================================|||}
|||=============================================================================================================================================|||}_*
 *|_____|
                           Figure F.2: Split object example: source fragment #2
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 423
                           Appendix F.  Split DWARF Object Files (Informative)
 File demo.h
_________________________________________________________________________________________________________________________________________________|___*
 *_|
|||=============================================================================================================================================|||cA*
 *l{a s s
|||=============================================================================================================================================|||p:*
 *u b l i c
|||=============================================================================================================================================|||P(*
 *ofilnotaxt,fyl)o:axt_(x),y_(y){}
|||=============================================================================================================================================|||fx*
 *l(o)acto{nrsettxu_r;n}
|||=============================================================================================================================================|||fy*
 *l(o)acto{nrsettyu_r;n}
|||=============================================================================================================================================|||p:*
 *r i v a t e
|||=============================================================================================================================================|||fx*
 *l_o;a t
|||=============================================================================================================================================|||fy*
 *l_o;a t
|||=============================================================================================================================================|||};
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||cL*
 *lianses{
|||=============================================================================================================================================|||p:*
 *u b l i c
|||=============================================================================================================================================|||L(*
 *iPnoeisnttart,Peonidn)t:s(tsatratr_t),e(nedn_d){}
|||=============================================================================================================================================|||bc*
 *oloilp(cBoonxs&tb);
|||=============================================================================================================================================|||Ps*
 *otianrtt()c{ornesttusrtna;r}t _
|||=============================================================================================================================================|||Pe*
 *onidn(t)c{ornesttuernnd;_}
|||=============================================================================================================================================|||p:*
 *r i v a t e
|||=============================================================================================================================================|||Ps*
 *otianrtt;_
|||=============================================================================================================================================|||Pe*
 *onidn_t;
|||=============================================================================================================================================|||};
|||=============================================================================================================================================|||
|||=============================================================================================================================================|||cB*
 *loaxs{s
|||=============================================================================================================================================|||p:*
 *u b l i c
|||=============================================================================================================================================|||B(*
 *ofxllo,aftlro,aftlbo,aftlto)a:tl(ll_,b),u(rr_,t){}
|||=============================================================================================================================================|||B(*
 *oPxoliln,tPuori)n:tl(ll_l),u(ru_r){}
|||=============================================================================================================================================|||bc*
 *ooonlt(acionnssPto&ipn)tc;o n s t
|||=============================================================================================================================================|||fl*
 *l(o)acto{nrsettlulr_n.x();}
|||=============================================================================================================================================|||fr*
 *l(o)acto{nrsettuurr_n.x();}
|||=============================================================================================================================================|||fb*
 *l(o)acto{nrsettlulr_n.y();}
|||=============================================================================================================================================|||ft*
 *l(o)acto{nrsettuurr_n.y();}
|||=============================================================================================================================================|||p:*
 *r i v a t e
|||=============================================================================================================================================|||Pl*
 *oli_n;t
|||=============================================================================================================================================|||Pu*
 *ori_n;t
|||=============================================================================================================================================|||};*
 *_|_____|
                           Figure F.3: Split object example: source fragment #3
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 424
                          Appendix F.  Split DWARF Object Files (Informative)
F.2.1         Contents of the Object Files
The object oles each contain the following sections of debug information:
    .debug_abbrev
    .debug_info
    .debug_line
    .debug_str
    .debug_addr
    .debug_names
    .debug_aranges
The .debug_abbrev section contains just a single entry describing the skeleton
compilation unit DIE.
The DWARF description in the .debug_info section contains just a single DIE,
the skeleton compilation unit, which may look like Figure F.4 following.
__________________________________________________________________________________________________________________________________________________||
||      DW_TAG_skeleton_unit                                                                                                                       ||
||             DW_AT_comp_dir:  (reference  to  directory  name  in  .debug_str)                                                                   ||
|              DW_AT_dwo_name:  (reference  to  "demo1.dwo"  in  .debug_str)                                                                       |
||             DW_AT_addr_base:  (reference  to  .debug_addr  section)                                                                             ||
|              DW_AT_stmt_list:  (reference  to  .debug_line  section)                                                                             |
|                                                                                                                                                  |
|_________________________________________________________________________________________________________________________________________________ |
                 Figure F.4: Split object example: skeleton DWARF description
The DW.AT.comp.dir and DW.AT.dwo.name attributes provide the location
of the corresponding split DWARF object ole that contains the full debug
information; that ole is normally expected to be in the same directory as the
object ole itself.
The dwo_id oeld in the header of the skeleton unit provides an ID or key for the
debug information contained in the DWARF object ole. This ID serves two
purposes: it can be used to verify that the debug information in the split DWARF
object ole matches the information in the object ole, and it can be used to ond the
debug information in a DWARF package ole.
The DW.AT.addr.base attribute contains the relocatable ooeset of this object
ole's contribution to the .debug_addr section.
The DW.AT.stmt.list attribute contains the relocatable ooeset of this ole's
contribution to the .debug_line table.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 425
                          Appendix F.  Split DWARF Object Files (Informative)
The .debug_line section contains the full line number table for the compiled
code in the object ole. As shown in Figure F.1 on page 422, the line number
program header lists the two ole names, demo.h and demo1.cc, and contains line
number programs for Box::contains, Point::x, and Point::y.
The .debug_str section contains the strings referenced indirectly by the
compilation unit DIE and by the line number program.
The .debug_addr section contains relocatable addresses of locations in the
loadable text and data that are referenced by debugging information entries in
the split DWARF object. In the example in F.3 on page 424, demo1.o may have
three entries:
                                   __Slot_______Location_referenced________________________________________
                                        0       low PC value for Box::contains
                                        1       low PC value for Point::x
                                        2       low PC value for Point::y
The .debug_names section contains the names deoned by the debugging
information in the split DWARF object ole (see Section 6.1.1.1 on page 142), and
references the skeleton compilation unit. When linked together into a onal
executable, they can be used by a DWARF consumer to lookup a name to ond
one or more skeleton compilation units that provide information about that
name. From the skeleton compilation unit, the consumer can ond the split
DWARF object ole that it can then read to get the full DWARF information.
The .debug_aranges section contains the PC ranges deoned in this compilation
unit, and allow a DWARF consumer to map a PC value to a skeleton compilation
unit, and then to a split DWARF object ole.
F.2.2         Contents of the Linked Executable File
When demo1.o and demo2.o are linked together (along with a main program and
other necessary library routines that we will ignore here for simplicity), the
resulting executable ole will contain at least the two skeleton compilation units
in the .debug_info section, as shown in Figure F.5 following.
Each skeleton compilation unit has a DW.AT.stmt.list attribute, which provides
the relocated ooeset to that compilation unit's contribution in the executable's
.debug_line section. In this example, the line number information for demo1.dwo
begins at ooeset 120, and for demo2.dwo, it begins at ooeset 200.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 426
                          Appendix F.  Split DWARF Object Files (Informative)
__________________________________________________________________________________________________________________________________________________||||
||      DW_TAG_skeleton_unit                                                                                                                       ||
||             DW_AT_comp_dir:  (reference  to  directory  name  in  .debug_str)                                                                   ||
|              DW_AT_dwo_name:  (reference  to  "demo1.dwo"  in  .debug_str)                                                                       |
||             DW_AT_addr_base:  48  (offset  in  .debug_addr)                                                                                     ||
|              DW_AT_stmt_list:  120  (offset  in  .debug_line)                                                                                    |
||      DW_TAG_skeleton_unit                                                                                                                       ||
||             DW_AT_comp_dir:  (reference  to  directory  name  in  .debug_str)                                                                   ||
|              DW_AT_dwo_name:  (reference  to  "demo2.dwo"  in  .debug_str)                                                                       |
||             DW_AT_addr_base:  80  (offset  in  .debug_addr)                                                                                     ||
|              DW_AT_stmt_list:  200  (offset  in  .debug_line)                                                                                    |
|                                                                                                                                                  |
|_________________________________________________________________________________________________________________________________________________ |
               Figure F.5: Split object example: executable ole DWARF excerpts
Each skeleton compilation unit also has a DW.AT.addr.base attribute, which
provides the relocated ooeset to that compilation unit's contribution in the
executable's .debug_addr section. Unlike the DW.AT.stmt.list attribute, the
ooeset refers to the orst address table slot, not to the section header. In this
example, we see that the orst address (slot 0) from demo1.o begins at ooeset 48.
Because the .debug_addr section contains an 8-byte header, the object ole's
contribution to the section actually begins at ooeset 40 (for a 64-bit DWARF object,
the header would be 16 bytes long, and the value for the DW.AT.addr.base
attribute would then be 56). All attributes in demo1.dwo that use
DW.FORM.addrx, DW.FORM.addrx1, DW.FORM.addrx2,
DW.FORM.addrx3 or DW.FORM.addrx4 would then refer to address table
slots relative to that ooeset. Likewise, the .debug_addr contribution from
demo2.dwo begins at ooeset 72, and its orst address slot is at ooeset 80. Because
these contributions have been processed by the linker, they contain relocated
values for the addresses in the program that are referred to by the debug
information.
The linked executable will also contain .debug_abbrev, .debug_str,
.debug_names and .debug_aranges sections, each the result of combining and
relocating the contributions from the relocatable object oles.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 427
                          Appendix F.  Split DWARF Object Files (Informative)
F.2.3         Contents of the Split DWARF Object Files
The split DWARF object oles each contain the following sections:
    .debug_abbrev.dwo
    .debug_info.dwo  (for  the  compilation  unit)
    .debug_info.dwo  (one  COMDAT  section  for  each  type  unit)
    .debug_loclists.dwo
    .debug_line.dwo
    .debug_macro.dwo
    .debug_rnglists.dwo
    .debug_str_offsets.dwo
    .debug_str.dwo
The .debug_abbrev.dwo section contains the abbreviation declarations for the
debugging information entries in the .debug_info.dwo section.
The .debug_info.dwo section containing the compilation unit contains the full
debugging information for the compile unit, and looks much like a normal
.debug_info section in a non-split object ole, with the following exceptions:
     #    The DW.TAG.compile.unit DIE does not need to repeat the
          DW.AT.ranges, DW.AT.low.pc, DW.AT.high.pc, and DW.AT.stmt.list
          attributes that are provided in the skeleton compilation unit.
     #    References to strings in the string table use the form code DW.FORM.strx,
          DW.FORM.strx1, DW.FORM.strx2, DW.FORM.strx3 or
          DW.FORM.strx4, referring to slots in the .debug_str_offsets.dwo
          section.
     #    References to relocatable addresses in the object ole use one of the form
          codes DW.FORM.addrx, DW.FORM.addrx1, DW.FORM.addrx2,
          DW.FORM.addrx3 or DW.FORM.addrx4, referring to slots in the
          .debug_addr table, relative to the base ooeset given by DW.AT.addr.base
          in the skeleton compilation unit.
Figure F.6 following presents excerpts from the .debug_info.dwo section for
demo1.dwo.
In the deoning declaration for Box::contains at 5$, the DW.AT.low.pc
attribute is represented using DW.FORM.addrx, which refers to slot 0 in the
.debug_addr table from demo1.o. That slot contains the relocated address of the
beginning of the function.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 428
|                         Appendix F.  Split DWARF Object Files (Informative)                                                                      |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
____________________________________________________________________________________________________________________________________part_1_of_2___||||
||      DW_TAG_compile_unit                                                                                                                        ||
|              DW_AT_producer  [DW_FORM_strx]:  (slot  15)  (producer  string)                                                                     |
||             DW_AT_language_name:  DW_LNAME_C_plus_plus                                                                                          ||
||             DW_AT_name  [DW_FORM_strx]:  (slot  7)  "demo1.cc"                                                                                  ||
|              DW_AT_comp_dir  [DW_FORM_strx]:  (slot  4)  (directory  name)                                                                       |
|1$:|        DW_TAG_class_type                                                                                                                     ||
|                     DW_AT_name  [DW_FORM_strx]:  (slot  12)  "Point"                                                                             |
||                    DW_AT_signature  [DW_FORM_ref_sig8]:  0x2f33248f03ff18ab                                                                     ||
||                    DW_AT_declaration:  true                                                                                                     ||
|2$:                DW_TAG_subprogram                                                                                                              |
||                           DW_AT_external:  true                                                                                                 ||
|                            DW_AT_name  [DW_FORM_strx]:  (slot  12)  "Point"                                                                      |
||                           DW_AT_decl_file:  1                                                                                                   ||
||                           DW_AT_decl_line:  5                                                                                                   ||
|                            DW_AT_linkage_name  [DW_FORM_strx]:  (slot  16)  "_ZN5PointC4Eff"                                                     |
||                           DW_AT_accessibility:  DW_ACCESS_public                                                                                ||
|                            DW_AT_declaration:  true                                                                                              |
||                    ...                                                                                                                          ||
|3$:         DW_TAG_class_type                                                                                                                     |
||                    DW_AT_name  [DW_FORM_string]:  "Box"                                                                                         ||
||                    DW_AT_signature  [DW_FORM_ref_sig8]:  0xe97a3917c5a6529b                                                                     ||
|                     DW_AT_declaration:  true                                                                                                     |
||                 ...                                                                                                                             ||
|4$:                DW_TAG_subprogram                                                                                                              |
||                           DW_AT_external:  true                                                                                                 ||
||                           DW_AT_name  [DW_FORM_strx]:  (slot  0)  "contains"                                                                    ||
|                            DW_AT_decl_file:  1                                                                                                   |
||                           DW_AT_decl_line:  28                                                                                                  ||
|                            DW_AT_linkage_name  [DW_FORM_strx:  (slot  8)                                                                         |
||                                                                                      "_ZNK3Box8containsERK5Point"                               ||
||                           DW_AT_type:  (reference  to  7$)                                                                                      ||
|                            DW_AT_accessibility:  DW_ACCESS_public                                                                                |
||                           DW_AT_declaration:  true                                                                                              ||
|                  ...                                                                                                                             |
|                                                                                                                                                  |
|_________________________________________________________________________________________________________________________________________________ |
                          Figure F.6: Split object example: demo1.dwo excerpts
Each type unit is contained in its own COMDAT .debug_info.dwo section, and
looks like a normal type unit in a non-split object, except that the
DW.TAG.type.unit DIE contains a DW.AT.stmt.list attribute that refers to a
specialized .debug_line.dwo  section. This section contains a normal line
number program header with a list of include directories and olenames, but no
line number program. This section is used only as a reference for olenames
needed for DW.AT.decl.ole attributes within the type unit.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 429
                          Appendix F.  Split DWARF Object Files (Informative)
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
|                                                                                                                                                  |
____________________________________________________________________________________________________________________________________part_2_of_2___||||
|                                                                                                                                                  |
|5$:     DW_TAG_subprogram                                                                                                                         |
||                 DW_AT_specification:  (reference  to  4$)                                                                                       ||
|                  DW_AT_decl_file:  2                                                                                                             |
||                 DW_AT_decl_line:  3                                                                                                             ||
||                 DW_AT_low_pc  [DW_FORM_addrx]:  (slot  0)                                                                                       ||
|                  DW_AT_high_pc  [DW_FORM_data8]:  0xbb                                                                                           |
||                 DW_AT_frame_base:  DW_OP_call_frame_cfa                                                                                         ||
|                  DW_AT_object_pointer:  (reference  to  6$)                                                                                      |
|6$:|           DW_TAG_formal_parameter                                                                                                            ||
||                        DW_AT_name  [DW_FORM_strx]:  (slot  13):  "this"                                                                         ||
|                         DW_AT_type:  (reference  to  8$)                                                                                         |
||                        DW_AT_artificial:  true                                                                                                  ||
|                         DW_AT_location:  DW_OP_fbreg(-24)                                                                                        |
||                 DW_TAG_formal_parameter                                                                                                         ||
||                        DW_AT_name  [DW_FORM_string]:  "p"                                                                                       ||
|                         DW_AT_decl_file:  2                                                                                                      |
||                        DW_AT_decl_line:  3                                                                                                      ||
|                         DW_AT_type:  (reference  to  11$)                                                                                        |
||                        DW_AT_location:  DW_OP_fbreg(-32)                                                                                        ||
||          ...                                                                                                                                    ||
|7$:     DW_TAG_base_type                                                                                                                          |
||                 DW_AT_byte_size:  1                                                                                                             ||
|                  DW_AT_encoding:  DW_ATE_boolean                                                                                                 |
||                 DW_AT_name  [DW_FORM_strx]:  (slot  5)  "bool"                                                                                  ||
|           ...                                                                                                                                    |
|8$:|    DW_TAG_const_type                                                                                                                         ||
||                 DW_AT_type:  (reference  to  9$)                                                                                                ||
|9$:     DW_TAG_pointer_type                                                                                                                       |
||                 DW_AT_byte_size:  8                                                                                                             ||
|                  DW_AT_type:  (reference  to  10$)                                                                                               |
|10$:|   DW_TAG_const_type                                                                                                                         ||
||                 DW_AT_type:  (reference  to  3$)                                                                                                ||
|           ...                                                                                                                                    |
|11$:|   DW_TAG_const_type                                                                                                                         ||
|                  DW_AT_type:  (reference  to  12$)                                                                                               |
|12$:|   DW_TAG_reference_type                                                                                                                     ||
||                 DW_AT_byte_size:  8                                                                                                             ||
|                  DW_AT_type:  (reference  to  13$)                                                                                               |
|13$:|   DW_TAG_const_type                                                                                                                         ||
|                  DW_AT_type:  (reference  to  1$)                                                                                                |
||__________...___________________________________________________________________________________________________________________________________ ||
        Figure F.6: Split object example: demo1.dwo DWARF excerpts (concluded)
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 430
                          Appendix F.  Split DWARF Object Files (Informative)
The .debug_str_offsets.dwo section contains an entry for each unique string in
the string table. Each entry in the table is the ooeset of the string, which is
contained in the .debug_str.dwo section.
In a split DWARF object ole, all references to strings go through this table (there
are no other ooesets to .debug_str.dwo in a split DWARF object ole). That is,
there is no use of DW.FORM.strp in a split DWARF object ole.
The ooesets in these slots have no associated relocations, because they are not part
of a relocatable object ole. When combined into a DWARF package ole, however,
each slot must be adjusted to refer to the appropriate ooeset within the merged
string table (.debug_str.dwo). The tool that builds the DWARF package ole must
understand the structure of the .debug_str_offsets.dwo section in order to
apply the necessary adjustments. Section F.3 on page 435 presents an example of
a DWARF package ole.
The .debug_rnglists.dwo section contains range lists referenced by any
DW.AT.ranges attributes in the split DWARF object. In our example, demo1.o
would have just a single range list for the compilation unit, with range list entries
for the function Box::contains and for out-of-line copies of the inline functions
Point::x and Point::y.
The .debug_loclists.dwo section contains the value lists and location lists
referenced by DW.AT.location attributes in the .debug_info.dwo section. This
section has a similar format to the .debug_loclists section in a non-split object,
but the section has some small dioeerences as explained in Section 7.7.3 on
page 236.
In demo2.dwo as shown in Figure F.7 on the next page, the debugging information
for Line::clip starting at 2$ describes a local variable slope at 7$ whose
location varies based on the PC. Figure F.8 on page 434 presents some excerpts
from the .debug_info.dwo section for demo2.dwo.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 431
                          Appendix F.  Split DWARF Object Files (Informative)
____________________________________________________________________________________________________________________________________part_1_of_2___||||
|1$:| DW_TAG_class_type                                                                                                                            ||
||             DW_AT_name  [DW_FORM_strx]:  (slot  20)  "Line"                                                                                     ||
|              DW_AT_signature  [DW_FORM_ref_sig8]:  0x79c7ef0eae7375d1                                                                            |
||             DW_AT_declaration:  true                                                                                                            ||
|              ...                                                                                                                                 |
|2$:|        DW_TAG_subprogram                                                                                                                     ||
||                    DW_AT_external:  true                                                                                                        ||
|                     DW_AT_name  [DW_FORM_strx]:  (slot  19)  "clip"                                                                              |
||                    DW_AT_decl_file:  2                                                                                                          ||
|                     DW_AT_decl_line:  16                                                                                                         |
||                    DW_AT_linkage_name  [DW_FORM_strx]:  (slot  2)  "_ZN4Line4clipERK3Box"                                                       ||
||                    DW_AT_type:  (reference  to  DIE  for  bool)                                                                                 ||
|                     DW_AT_accessibility:  DW_ACCESS_public                                                                                       |
||                    DW_AT_declaration:  true                                                                                                     ||
|              ...                                                                                                                                 |
|                                                                                                                                                  |
|_________________________________________________________________________________________________________________________________________________ |
  Figure F.7: Split object example: demo2.dwo DWARF .debug_info.dwo excerpts
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 432
                          Appendix F.  Split DWARF Object Files (Informative)
|                                                                                                                                                  |
|                                                                                                                                                  |
____________________________________________________________________________________________________________________________________part_2_of_2___||||
|                                                                                                                                                  |
|3$:     DW_TAG_subprogram                                                                                                                         |
||                 DW_AT_specification:  (reference  to  2$)                                                                                       ||
||                 DW_AT_decl_file:  1                                                                                                             ||
|                  DW_AT_decl_line:  3                                                                                                             |
||                 DW_AT_low_pc  [DW_FORM_addrx]:  (slot  32)                                                                                      ||
|                  DW_AT_high_pc  [DW_FORM_data8]:  0x1ec                                                                                          |
||                 DW_AT_frame_base:  DW_OP_call_frame_cfa                                                                                         ||
||                 DW_AT_object_pointer:  (reference  to  4$)                                                                                      ||
|4$:            DW_TAG_formal_parameter                                                                                                            |
||                        DW_AT_name:  (indexed  string:  0x11):  this                                                                             ||
|                         DW_AT_type:  (reference  to  DIE  for  type  const  Point*  const)                                                       |
||                        DW_AT_artificial:  1                                                                                                     ||
|                         DW_AT_location:  0x0  (location  list)                                                                                   |
|5$:|           DW_TAG_formal_parameter                                                                                                            ||
||                        DW_AT_name:  b                                                                                                           ||
|                         DW_AT_decl_file:  1                                                                                                      |
||                        DW_AT_decl_line:  3                                                                                                      ||
|                         DW_AT_type:  (reference  to  DIE  for  type  const  Box&  const)                                                         |
||                        DW_AT_location  [DW_FORM_sec_offset]:  0x2a                                                                              ||
|6$:|           DW_TAG_lexical_block                                                                                                               ||
|                         DW_AT_low_pc  [DW_FORM_addrx]:  (slot  17)                                                                               |
||                        DW_AT_high_pc:  0x1d5                                                                                                    ||
|7$:                   DW_TAG_variable                                                                                                             |
||                              DW_AT_name  [DW_FORM_strx]:  (slot  28):  "slope"                                                                  ||
||                              DW_AT_decl_file:  1                                                                                                ||
|                               DW_AT_decl_line:  5                                                                                                |
||                              DW_AT_type:  (reference  to  DIE  for  type  float)                                                                ||
|                               DW_AT_location  [DW_FORM_sec_offset]:  0x49                                                                        |
|                                                                                                                                                  |
|_________________________________________________________________________________________________________________________________________________ |
  Figure F.7: Split object example: demo2.dwo DWARF .debug_info.dwo excerpts
                                                              (concluded)
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 433
                          Appendix F.  Split DWARF Object Files (Informative)
In Figure F.7 on page 432, the DW.TAG.formal.parameter entries at 4$ and 5$
refer to the location lists at ooeset 0x0 and 0x2a, respectively, and the
DW.TAG.variable entry for slope refers to the location list at ooeset 0x49. Figure
F.8 shows a representation of the location lists at those ooesets in the
.debug_loclists.dwo|section.|                                                                                                                      ||
|                                                                                                                                                  |
__________________________________________________________________________________________________________________________________________________||
||                       Entry type                       Range                    Counted Location Description                                    ||
||             __ooeset______(DW.LLE.*)__||_________start_______length__||___length________expression______________________________                ||
|                                                 |                        |                                                                       |
||                                                |                        |                                                                       ||
|                  0x00      start.length   ||         [9]      0x002f  ||      0x01      DW.OP.reg5 (rdi)                                         |
||                 0x09      start.length   ||       [11]      0x01b9  ||       0x01      DW.OP.reg3 (rbx)                                         ||
||                 0x12      start.length   ||       [29]      0x0003  ||       0x03      DW.OP.breg12 (r12): -8;                                  ||
|                                                 |                        |                                                                       |
|                                                 |                        |              DW.OP.stack.value                                        |
||                0x1d       start.length   ||       [31]      0x0001  ||       0x03      DW.OP.entry.value:                                       ||
|                                                 |                        |                                                                       |
|                                                 |                        |              (DW.OP.reg5 (rdi));                                      |
|                                                 |                        |                                                                       |
|                                                 |                        |              DW.OP.stack.value                                        |
||                 0x29      end.of.list     ||                            ||                                                                      ||
||                 ~~                             ||                       ||                                                                      ||
||                 0x2a      start.length   ||         [9]      0x002f  ||      0x01      DW.OP.reg4 (rsi))                                        ||
||                 0x33      start.length   ||       [11]      0x01ba  ||       0x03      DW.OP.reg6 (rbp))                                        ||
||                 0x3c      start.length   ||       [30]      0x0003  ||       0x03      DW.OP.entry.value:                                       ||
|                                                 |                        |                                                                       |
|                                                 |                        |              (DW.OP.reg4 (rsi));                                      |
|                                                 |                        |                                                                       |
|                                                 |                        |              DW.OP.stack.value                                        |
||                 0x48      end.of.list     ||                            ||                                                                      ||
||                 ~~                             ||                       ||                                                                      ||
||                 0x49      start.length   ||       [10]      0x0004  ||       0x01      DW.OP.reg18 (xmm1)                                       ||
||                 0x52      start.length   ||       [11]      0x01bd  ||       0x02      DW.OP.fbreg: -36                                         ||
|                  0x5c      end.of.list     ||                            ||                                                                      |
||                                                |                        |                                                                       ||
|_________________________________________________|________________________|______________________________________________________________________ |
Figure   F.8:    Split   object   example:    demo2.dwo   DWARF   .debug_loclists.dwo
excerpts
In each DW.LLE.start.length entry, the start oeld is the index of a slot in the
.debug_addr section, relative to the base ooeset deoned by the compilations unit's
DW.AT.addr.base attribute. The .debug_addr slots referenced by these entries
give the relocated address of a label within the function where the address range
begins. The following length oeld gives the length of the address range. The
location, consisting of its own length and a DWARF expression, is last.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 434
                          Appendix F.  Split DWARF Object Files (Informative)
F.3          DWARF  Package  File  Example
A DWARF package ole (see Section 7.3.5 on page 198) is a collection of split
DWARF object oles. In general, it will be much smaller than the sum of the split
DWARF object oles, because the packaging process removes duplicate type units
and merges the string tables. Aside from those two optimizations, however, each
compilation unit and each type unit from a split DWARF object ole is copied
verbatim into the package ole.
The package ole contains the same set of sections as a split DWARF object ole,
plus two additional sections described below.
The packaging utility, like a linker, combines sections of the same name by
concatenation. While a split DWARF object may contain multiple
.debug_info.dwo sections, one for the compilation unit, and one for each type
unit, a package ole contains a single .debug_info.dwo section. The combined
.debug_info.dwo section contains each compilation unit and one copy of each
type unit (discarding any duplicate type signatures).
As part of merging the string tables, the packaging utility treats the
.debug_str.dwo and .debug_str_offsets.dwo sections specially. Rather than
combining them by simple concatenation, it instead builds a new string table
consisting of the unique strings from each input string table. Because all
references to these strings use form DW.FORM.strx, the packaging utility only
needs to adjust the string ooesets in each .debug_str_offsets.dwo contribution
after building the new .debug_str.dwo section.
Each compilation unit or type unit consists of a set of inter-related contributions
to each section in the package ole. For example, a compilation unit may have
contributions in .debug_info.dwo, .debug_abbrev.dwo, .debug_line.dwo,
.debug_str_offsets.dwo, and so on. In order to maintain the ability for a
consumer to follow references between these sections, the package ole contains
two additional sections: a compilation unit (CU) index, and a type unit (TU)
index. These indexes allow a consumer to look up a compilation unit (by its
compilation unit ID) or a type unit (by its type unit signature), and locate each
contribution that belongs to that unit.
For example, consider a package ole, demo.dwp, formed by combining demo1.dwo
and demo2.dwo from the previous example (see Appendix F.2 on page 422). For
an executable ole named "demo" (or "demo.exe"), a debugger would typically
expect to ond demo.dwp in the same directory as the executable ole. The resulting
package ole would contain the sections shown in Figure F.9 on the next page,
with contributions from each input ole as shown.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 435
                          Appendix F.  Split DWARF Object Files (Informative)
        ________________________________________________________________________________________________________________________________
        __Section_______________________________________||_Source_of_section_contributions______________________________________________
          .debug_abbrev.dwo                             || .debug_abbrev.dwo from demo1.dwo
                                                        |  .debug_abbrev.dwo from demo2.dwo
        ________________________________________________|_______________________________________________________________________________
                                                        |
                                                        |  compilation unit from demo1.dwo
          .debug_info.dwo                               || compilation unit from demo2.dwo
          (for the compilation                          || type unit for class Box from demo1.dwo
          units and type units)                         || type unit for class Point from demo1.dwo
                                                        |  type unit for class Line from demo2.dwo
        ________________________________________________|_______________________________________________________________________________
          .debug_rnglists.dwo                           || .debug_rnglists.dwo from demo1.dwo
                                                        |  .debug_rnglists.dwo from demo2.dwo
        ________________________________________________|_______________________________________________________________________________
          .debug_loclists.dwo                           || .debug_loclists.dwo from demo1.dwo
                                                        |  .debug_loclists.dwo from demo2.dwo
        ________________________________________________|_______________________________________________________________________________
          .debug_line.dwo                               || .debug_line.dwo from demo1.dwo
                                                        |  .debug_line.dwo from demo2.dwo
        ________________________________________________|_______________________________________________________________________________
                                                        |
                                                        |  .debug_str_offsets.dwo from demo1.dwo,
          .debug_str_offsets.dwo                        ||      adjusted
                                                        |
                                                        |  .debug_str_offsets.dwo from demo2.dwo,
                                                        |       adjusted
        ________________________________________________|_______________________________________________________________________________
          .debug_str.dwo                                || merged string table generated by package
                                                        |  utility
        ________________________________________________|_______________________________________________________________________________
        __.debug_cu_index_______________________________||_CU_index_generated_by_package_utility________________________________________
        __.debug_tu_index_______________________________||_TU_index_generated_by_package_utility________________________________________
         Figure F.9: Sections and contributions in example package ole demo.dwp
The .debug_abbrev.dwo, .debug_rnglists.dwo, .debug_loclists.dwo and
.debug_line.dwo sections are copied over from the two .dwo oles as individual
contributions to the corresponding sections in the .dwp ole. The ooeset of each
contribution within the combined section and the size of each contribution is
recorded as part of the CU and TU index sections.
The .debug_info.dwo sections corresponding to each compilation unit are copied
as individual contributions to the combined .debug_info.dwo section, and one
copy of each type unit is also copied. The type units for class Box and class Point,
for example, are contained in both demo1.dwo and demo2.dwo, but only one
instance of each is copied into the package ole.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 436
                          Appendix F.  Split DWARF Object Files (Informative)
The .debug_str.dwo sections from each ole are merged to form a new string
table with no duplicates, requiring the adjustment of all references to those
strings. The .debug_str_offsets.dwo sections from the .dwo oles are copied as
individual contributions, but the string table ooeset in each slot of those
contributions is adjusted to point to the correct ooeset in the merged string table.
The .debug_cu_index and .debug_tu_index sections provide a directory to these
contributions. Figure F.10 following shows an example CU index section
containing the two compilation units from demo1.dwo and demo2.dwo. The CU
index shows that for the compilation unit from demo1.dwo, with compilation unit
ID 0x044e413b8a2d1b8f, its contribution to the .debug_info.dwo section begins
at ooeset 0, and is 325 bytes long. For the compilation unit from demo2.dwo, with
compilation unit ID 0xb5f0ecf455e7e97e, its contribution to the
.debug_info.dwo section begins at ooeset 325, and is 673 bytes long.
Likewise, we can ond the contributions to the related sections. In Figure F.8 on
page 434, we see that the DW.TAG.variable DIE at 7$ has a reference to a
location list at ooeset 0x49 (decimal 73). Because this is part of the compilation
unit for demo2.dwo, with unit signature 0xb5f0ecf455e7e97e, we see that its
contribution to .debug_loclists.dwo begins at ooeset 84, so the location list from
Figure F.8 on page 434 can be found in demo.dwp at ooeset 157 (84 + 73) in the
combined .debug_loclists.dwo section.
Figure F.11 following shows an example TU index section containing the three
type units for classes Box, Point, and Line. Each type unit contains contributions
from .debug_info.dwo, .debug_abbrev.dwo, .debug_line.dwo and
.debug_str_offsets.dwo. In this example, the type units for classes Box and
Point come from demo1.dwo, and share the abbreviations table, line number
table, and string ooesets table with the compilation unit from demo1.dwo.
Likewise, the type unit for class Line shares tables from demo2.dwo.
The sharing of these tables between compilation units and type units is typical
for some implementations, but is not required by the DWARF standard.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 437
                          Appendix F.  Split DWARF Object Files (Informative)
          ___________________________________________Section_header__________________________________________________________________
            Version:                                                5
            Number of columns:                                      6
            Number of used entries:                                 2
            Number of slots:                                      16
          _______________________________________________Ooeset_table________________________________________________________________
            slot                           signature           info       abbrev          loc      line       str.ooe        rng
            14         0xb5f0ecf455e7e97e                       325             452        84         52             72      350
            15         0x044e413b8a2d1b8f                           0               0        0          0              0         0
          ________________________________________________Size_table_________________________________________________________________
            slot                                               info       abbrev          loc      line       str.ooe        rng
            14                                                  673             593        93         52           120         34
            15                                                  325             452        84         52             72        15
          ___________________________________________________________________________________________________________________________
                                     Figure F.10: Example CU index section
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 438
                          Appendix F.  Split DWARF Object Files (Informative)
                   _______________________________________Section_header____________________________________________________
                     Version:                                                 5
                     Number of columns:                                       4
                     Number of used entries:                                  3
                     Number of slots:                                       32
                   ___________________________________________Ooeset_table__________________________________________________
                     slot                           signature            info       abbrev          line       str.ooe
                     11         0x2f33248f03ff18ab                      1321                  0          0              0
                     17         0x79c7ef0eae7375d1                      1488              452          52             72
                     27         0xe97a3917c5a6529b                        998                 0          0              0
                   ____________________________________________Size_table___________________________________________________
                     slot                                                info       abbrev          line       str.ooe
                     11                                                   167             452          52             72
                     17                                                   217             593          52           120
                     27                                                   323             452          52             72
                   _________________________________________________________________________________________________________
                                      Figure F.11: Example TU index section
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 439
                          Appendix F.  Split DWARF Object Files (Informative)
                                                             (empty page)
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 440

Appendix  G
DWARF  Section  Version  Numbers
(Informative)
Most DWARF sections have a version number in the section header. This version
number is not tied to the DWARF standard revision numbers, but instead is
incremented when incompatible changes to that section are made. The DWARF
standard that a producer is following is not explicitly encoded in the ole. Version
numbers in the section headers are represented as two-byte unsigned integers.
Table G.1 on the following page shows what version numbers are in use for each
section. In that table:
     #    iV2j means DWARF Version 2, published July 27, 1993.
     #    iV3j means DWARF Version 3, published December 20, 2005.
     #    iV4j means DWARF Version 4, published June 10, 2010.
     #    iV5j means DWARF Version 5, published February 13, 2017.
     #    iV6j means DWARF Version 61 , published !to be determined?.
There are sections with no version number encoded in them; they are only
accessed via the .debug_info sections and so an incompatible change in those
sections' format would be represented by a change in the .debug_info section
version number.
_________________________________________________________
      1Higher numbers are reserved for future use.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 441
                         Appendix G.  Section Version Numbers (Informative)
                                        Table G.1: Section version numbers
                        ________________________________________________________________________________________________
                        __Section_Name_____________________________________V2_______V3_______V4_______V5_______V6_______
                          .debug_abbrev                                      *        *        *        *        *
                          .debug_addr                                        -        -        -        5        5
                          .debug_aranges                                     2        2        2        2        2
                          .debug_frame2                                      1        3        4        4        4
                          .debug_info                                        2        3        4        5        5
                          .debug_line                                        2        3        4        5        6
                          .debug_line_str                                    -        -        -        *        *
                          .debug_loc                                         *        *        *        -        -
                          .debug_loclists                                    -        -        -        5        5
                          .debug_macinfo                                     *        *        *        -        -
                          .debug_macro                                       -        -        -        5        5
                          .debug_names                                       -        -        -        5        6
                          .debug_pubnames                                    2        2        2        -        -
                          .debug_pubtypes                                    -        2        2        -        -
                          .debug_ranges                                      -        *        *        -        -
                          .debug_rnglists                                    -        -        -        5        5
                          .debug_str                                         *        *        *        *        *
                          .debug_str_offsets                                 -        -        -        5        5
                          .debug_sup                                         -        -        -        5        5
                          .debug_types                                       -        -        4        -        -
                                                       (split object sections)
                          .debug_abbrev.dwo                                  -        -        -        *        *
                          .debug_info.dwo                                    -        -        -        5        5
                          .debug_line.dwo                                    -        -        -        5        5
                          .debug_loclists.dwo                                -        -        -        5        5
                          .debug_macro.dwo                                   -        -        -        5        5
                          .debug_rnglists.dwo                                -        -        -        5        5
                          .debug_str.dwo                                     -        -        -        *        *
                        __.debug_str_offsets.dwo_____________________________-________-________-________5________5______
                          Continued on next page
_________________________________________________________
      2For the .debug_frame section, version 2 is unused.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 442
                         Appendix G.  Section Version Numbers (Informative)
                        __Section_Name_____________________________________V2_______V3_______V4_______V5_______V6_______
                                                      (package ole sections)
                          .debug_cu_index                                    -        -        -       5        6
                        __.debug_tu_index____________________________________-________-________-________5________6______
Notes:
     #    i*j means that a version number is not applicable (the section does not
          include a header or the section's header does not include a version).
     #    i-j means that the section was not deoned in that version of the DWARF
          standard.
     #    The version numbers for corresponding .debug.!kind? and
          .debug.!kind?.dwo sections are the same.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 443
                         Appendix G.  Section Version Numbers (Informative)
                                                             (empty page)
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 444

Appendix  H
GNU  Free  Documentation  License
                                             Version 1.3, 3 November 2008
         Copyright #2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
                                                          http://fsf.org/
Everyone is permitted to copy and distribute verbatim copies of this license
document, but changing it is not allowed.
PREAMBLE
The purpose of this License is to make a manual, textbook, or other functional
and useful document ifreej in the sense of freedom: to assure everyone the
eoeective freedom to copy and redistribute it, with or without modifying it, either
commercially or noncommercially. Secondarily, this License preserves for the
author and publisher a way to get credit for their work, while not being
considered responsible for modiocations made by others.
This License is a kind of icopyleft,j which means that derivative works of the
document must themselves be free in the same sense. It complements the GNU
General Public License, which is a copyleft license designed for free software.
We have designed this License in order to use it for manuals for free software,
because free software needs free documentation: a free program should come
with manuals providing the same freedoms that the software does. But this
License is not limited to software manuals; it can be used for any textual work,
regardless of subject matter or whether it is published as a printed book. We
recommend this License principally for works whose purpose is instruction or
reference.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 445
                             Appendix H.  GNU Free Documentation License
H.1            APPLICABILITY  AND  DEFINITIONS
This License applies to any manual or other work, in any medium, that contains
a notice placed by the copyright holder saying it can be distributed under the
terms of this License. Such a notice grants a world-wide, royalty-free license,
unlimited in duration, to use that work under the conditions stated herein. The
iDocumentj, below, refers to any such manual or work. Any member of the
public is a licensee, and is addressed as iyou.j You accept the license if you copy,
modify or distribute the work in a way requiring permission under copyright
law.
A iModioed Versionj of the Document means any work containing the
Document or a portion of it, either copied verbatim, or with modiocations
and/or translated into another language.
A iSecondary Sectionj is a named appendix or a front-matter section of the
Document that deals exclusively with the relationship of the publishers or
authors of the Document to the Document's overall subject (or to related matters)
and contains nothing that could fall directly within that overall subject. (Thus, if
the Document is in part a textbook of mathematics, a Secondary Section may not
explain any mathematics.) The relationship could be a matter of historical
connection with the subject or with related matters, or of legal, commercial,
philosophical, ethical or political position regarding them.
The iInvariant Sectionsj are certain Secondary Sections whose titles are
designated, as being those of Invariant Sections, in the notice that says that the
Document is released under this License. If a section does not ot the above
deonition of Secondary then it is not allowed to be designated as Invariant. The
Document may contain zero Invariant Sections. If the Document does not
identify any Invariant Sections then there are none.
The iCover Textsj are certain short passages of text that are listed, as
Front-Cover Texts or Back-Cover Texts, in the notice that says that the Document
is released under this License. A Front-Cover Text may be at most 5 words, and a
Back-Cover Text may be at most 25 words.
A iTransparentj copy of the Document means a machine-readable copy,
represented in a format whose speciocation is available to the general public,
that is suitable for revising the document straightforwardly with generic text
editors or (for images composed of pixels) generic paint programs or (for
drawings) some widely available drawing editor, and that is suitable for input to
text formatters or for automatic translation to a variety of formats suitable for
input to text formatters. A copy made in an otherwise Transparent ole format
whose markup, or absence of markup, has been arranged to thwart or
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 446
                             Appendix H.  GNU Free Documentation License
discourage subsequent modiocation by readers is not Transparent. An image
format is not Transparent if used for any substantial amount of text. A copy that
is not iTransparentj is called iOpaque.j
Examples of suitable formats for Transparent copies include plain ASCII without
markup, Texinfo input format, LaTeX input format, SGML or XML using a
publicly available DTD, and standard-conforming simple HTML, PostScript or
PDF designed for human modiocation. Examples of transparent image formats
include PNG, XCF and JPG. Opaque formats include proprietary formats that
can be read and edited only by proprietary word processors, SGML or XML for
which the DTD and/or processing tools are not generally available, and the
machine-generated HTML, PostScript or PDF produced by some word
processors for output purposes only.
The iTitle Pagej means, for a printed book, the title page itself, plus such
following pages as are needed to hold, legibly, the material this License requires
to appear in the title page. For works in formats which do not have any title page
as such, iTitle Pagej means the text near the most prominent appearance of the
work's title, preceding the beginning of the body of the text.
The ipublisherj means any person or entity that distributes copies of the
Document to the public.
A section iEntitled XYZj means a named subunit of the Document whose title
either is precisely XYZ or contains XYZ in parentheses following text that
translates XYZ in another language. (Here XYZ stands for a specioc section name
mentioned below, such as iAcknowledgements,j iDedications,j
iEndorsements,j or iHistory.j) To iPreserve the Titlej of such a section when
you modify the Document means that it remains a section iEntitled XYZj
according to this deonition.
The Document may include Warranty Disclaimers next to the notice which states
that this License applies to the Document. These Warranty Disclaimers are
considered to be included by reference in this License, but only as regards
disclaiming warranties: any other implication that these Warranty Disclaimers
may have is void and has no eoeect on the meaning of this License.
H.2            VERBATIM  COPYING
You may copy and distribute the Document in any medium, either commercially
or noncommercially, provided that this License, the copyright notices, and the
license notice saying this License applies to the Document are reproduced in all
copies, and that you add no other conditions whatsoever to those of this License.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 447
                             Appendix H.  GNU Free Documentation License
You may not use technical measures to obstruct or control the reading or further
copying of the copies you make or distribute. However, you may accept
compensation in exchange for copies. If you distribute a large enough number of
copies you must also follow the conditions in section H.3.
You may also lend copies, under the same conditions stated above, and you may
publicly display copies.
H.3            COPYING  IN  QUANTITY
If you publish printed copies (or copies in media that commonly have printed
covers) of the Document, numbering more than 100, and the Document's license
notice requires Cover Texts, you must enclose the copies in covers that carry,
clearly and legibly, all these Cover Texts: Front-Cover Texts on the front cover,
and Back-Cover Texts on the back cover. Both covers must also clearly and
legibly identify you as the publisher of these copies. The front cover must
present the full title with all words of the title equally prominent and visible. You
may add other material on the covers in addition. Copying with changes limited
to the covers, as long as they preserve the title of the Document and satisfy these
conditions, can be treated as verbatim copying in other respects.
If the required texts for either cover are too voluminous to ot legibly, you should
put the orst ones listed (as many as ot reasonably) on the actual cover, and
continue the rest onto adjacent pages.
If you publish or distribute Opaque copies of the Document numbering more
than 100, you must either include a machine-readable Transparent copy along
with each Opaque copy, or state in or with each Opaque copy a
computer-network location from which the general network-using public has
access to download using public-standard network protocols a complete
Transparent copy of the Document, free of added material. If you use the latter
option, you must take reasonably prudent steps, when you begin distribution of
Opaque copies in quantity, to ensure that this Transparent copy will remain thus
accessible at the stated location until at least one year after the last time you
distribute an Opaque copy (directly or through your agents or retailers) of that
edition to the public.
It is requested, but not required, that you contact the authors of the Document
well before redistributing any large number of copies, to give them a chance to
provide you with an updated version of the Document.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 448
                              Appendix H.  GNU Free Documentation License
 H.4            MODIFICATIONS
 You may copy and distribute a Modioed Version of the Document under the
 conditions of sections H.2 and H.3 above, provided that you release the Modioed
 Version under precisely this License, with the Modioed Version olling the role of
 the Document, thus licensing distribution and modiocation of the Modioed
 Version to whoever possesses a copy of it. In addition, you must do these things
 in the Modioed Version:
 A.    Use in the Title Page (and on the covers, if any) a title distinct from that of the
       Document, and from those of previous versions (which should, if there were
       any, be listed in the History section of the Document). You may use the same
       title as a previous version if the original publisher of that version gives
       permission.
 B.    List on the Title Page, as authors, one or more persons or entities responsible
       for authorship of the modiocations in the Modioed Version, together with at
       least ove of the principal authors of the Document (all of its principal authors,
       if it has fewer than ove), unless they release you from this requirement.
 C.    State on the Title page the name of the publisher of the Modioed Version, as
       the publisher.
 D.    Preserve all the copyright notices of the Document.
 E.    Add an appropriate copyright notice for your modiocations adjacent to the
       other copyright notices.
  F.   Include, immediately after the copyright notices, a license notice giving the
       public permission to use the Modioed Version under the terms of this
       License, in the form shown in the Addendum below.
 G.    Preserve in that license notice the full lists of Invariant Sections and required
       Cover Texts given in the Document's license notice.
H.     Include an unaltered copy of this License.
  I.   Preserve the section Entitled iHistory,j Preserve its Title, and add to it an
       item stating at least the title, year, new authors, and publisher of the Modioed
       Version as given on the Title Page. If there is no section Entitled iHistoryj in
       the Document, create one stating the title, year, authors, and publisher of the
       Document as given on its Title Page, then add an item describing the
       Modioed Version as stated in the previous sentence.
  J.   Preserve the network location, if any, given in the Document for public access
       to a Transparent copy of the Document, and likewise the network locations
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 449
                              Appendix H.  GNU Free Documentation License
       given in the Document for previous versions it was based on. These may be
       placed in the iHistoryj section. You may omit a network location for a work
       that was published at least four years before the Document itself, or if the
       original publisher of the version it refers to gives permission.
 K.    For any section Entitled iAcknowledgementsj or iDedicationsj, Preserve the
       Title of the section, and preserve in the section all the substance and tone of
       each of the contributor acknowledgements and/or dedications given therein.
 L.    Preserve all the Invariant Sections of the Document, unaltered in their text
       and in their titles. Section numbers or the equivalent are not considered part
       of the section titles.
M.     Delete any section Entitled iEndorsementsj. Such a section may not be
       included in the Modioed Version.
N.     Do not retitle any existing section to be Entitled iEndorsementsj or to conAEict
       in title with any Invariant Section.
 O.    Preserve any Warranty Disclaimers.
 If the Modioed Version includes new front-matter sections or appendices that
 qualify as Secondary Sections and contain no material copied from the
 Document, you may at your option designate some or all of these sections as
 invariant. To do this, add their titles to the list of Invariant Sections in the
 Modioed Version's license notice. These titles must be distinct from any other
 section titles.
 You may add a section Entitled iEndorsements,j provided it contains nothing
 but endorsements of your Modioed Version by various parties~for example,
 statements of peer review or that the text has been approved by an organization
 as the authoritative deonition of a standard.
 You may add a passage of up to ove words as a Front-Cover Text, and a passage
 of up to 25 words as a Back-Cover Text, to the end of the list of Cover Texts in the
 Modioed Version. Only one passage of Front-Cover Text and one of Back-Cover
 Text may be added by (or through arrangements made by) any one entity. If the
 Document already includes a cover text for the same cover, previously added by
 you or by arrangement made by the same entity you are acting on behalf of, you
 may not add another; but you may replace the old one, on explicit permission
 from the previous publisher that added the old one.
 The author(s) and publisher(s) of the Document do not by this License give
 permission to use their names for publicity for or to assert or imply endorsement
 of any Modioed Version.
 November 1, 2024                                  ***WORKING DRAFT***                                                           Page 450
                             Appendix H.  GNU Free Documentation License
H.5            COMBINING  DOCUMENTS
You may combine the Document with other documents released under this
License, under the terms deoned in section H.5 above for modioed versions,
provided that you include in the combination all of the Invariant Sections of all
of the original documents, unmodioed, and list them all as Invariant Sections of
your combined work in its license notice, and that you preserve all their
Warranty Disclaimers.
The combined work need only contain one copy of this License, and multiple
identical Invariant Sections may be replaced with a single copy. If there are
multiple Invariant Sections with the same name but dioeerent contents, make the
title of each such section unique by adding at the end of it, in parentheses, the
name of the original author or publisher of that section if known, or else a unique
number. Make the same adjustment to the section titles in the list of Invariant
Sections in the license notice of the combined work.
In the combination, you must combine any sections Entitled iHistoryj in the
various original documents, forming one section Entitled iHistory;j likewise
combine any sections Entitled iAcknowledgements,j and any sections Entitled
iDedications.j You must delete all sections Entitled iEndorsements.j
H.6            COLLECTIONS  OF  DOCUMENTS
You may make a collection consisting of the Document and other documents
released under this License, and replace the individual copies of this License in
the various documents with a single copy that is included in the collection,
provided that you follow the rules of this License for verbatim copying of each of
the documents in all other respects.
You may extract a single document from such a collection, and distribute it
individually under this License, provided you insert a copy of this License into
the extracted document, and follow this License in all other respects regarding
verbatim copying of that document.
H.7            AGGREGATION  WITH  INDEPENDENT
               WORKS
A compilation of the Document or its derivatives with other separate and
independent documents or works, in or on a volume of a storage or distribution
medium, is called an iaggregatej if the copyright resulting from the compilation
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 451
                             Appendix H.  GNU Free Documentation License
is not used to limit the legal rights of the compilation's users beyond what the
individual works permit. When the Document is included in an aggregate, this
License does not apply to the other works in the aggregate which are not
themselves derivative works of the Document.
If the Cover Text requirement of section H.3 is applicable to these copies of the
Document, then if the Document is less than one half of the entire aggregate, the
Document's Cover Texts may be placed on covers that bracket the Document
within the aggregate, or the electronic equivalent of covers if the Document is in
electronic form. Otherwise they must appear on printed covers that bracket the
whole aggregate.
H.8            TRANSLATION
Translation is considered a kind of modiocation, so you may distribute
translations of the Document under the terms of section H.4. Replacing Invariant
Sections with translations requires special permission from their copyright
holders, but you may include translations of some or all Invariant Sections in
addition to the original versions of these Invariant Sections. You may include a
translation of this License, and all the license notices in the Document, and any
Warranty Disclaimers, provided that you also include the original English
version of this License and the original versions of those notices and disclaimers.
In case of a disagreement between the translation and the original version of this
License or a notice or disclaimer, the original version will prevail.
If a section in the Document is Entitled iAcknowledgementsj, iDedicationsj, or
iHistoryj, the requirement (section H.4) to Preserve its Title (section H.1) will
typically require changing the actual title.
H.9            TERMINATION
You may not copy, modify, sublicense, or distribute the Document except as
expressly provided under this License. Any attempt otherwise to copy, modify,
sublicense, or distribute it is void, and will automatically terminate your rights
under this License.
However, if you cease all violation of this License, then your license from a
particular copyright holder is reinstated (a) provisionally, unless and until the
copyright holder explicitly and onally terminates your license, and (b)
permanently, if the copyright holder fails to notify you of the violation by some
reasonable means prior to 60 days after the cessation.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 452
                             Appendix H.  GNU Free Documentation License
Moreover, your license from a particular copyright holder is reinstated
permanently if the copyright holder notioes you of the violation by some
reasonable means, this is the orst time you have received notice of violation of
this License (for any work) from that copyright holder, and you cure the
violation prior to 30 days after your receipt of the notice.
Termination of your rights under this section does not terminate the licenses of
parties who have received copies or rights from you under this License. If your
rights have been terminated and not permanently reinstated, receipt of a copy of
some or all of the same material does not give you any rights to use it.
H.10              FUTURE  REVISIONS  OF  THIS  LICENSE
The Free Software Foundation may publish new, revised versions of the GNU
Free Documentation License from time to time. Such new versions will be similar
in spirit to the present version, but may dioeer in detail to address new problems
or concerns. See http://www.gnu.org/copyleft/.
Each version of the License is given a distinguishing version number. If the
Document specioes that a particular numbered version of this License ior any
later versionj applies to it, you have the option of following the terms and
conditions either of that specioed version or of any later version that has been
published (not as a draft) by the Free Software Foundation. If the Document does
not specify a version number of this License, you may choose any version ever
published (not as a draft) by the Free Software Foundation. If the Document
specioes that a proxy can decide which future versions of this License can be
used, that proxy's public statement of acceptance of a version permanently
authorizes you to choose that version for the Document.
H.11              RELICENSING
iMassive Multiauthor Collaboration Sitej (or iMMC Sitej) means any World
Wide Web server that publishes copyrightable works and also provides
prominent facilities for anybody to edit those works. A public wiki that anybody
can edit is an example of such a server. A iMassive Multiauthor Collaborationj
(or iMMCj) contained in the site means any set of copyrightable works thus
published on the MMC site.
iCC-BY-SAj means the Creative Commons Attribution-Share Alike 3.0 license
published by Creative Commons Corporation, a not-for-proot corporation with a
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 453
                             Appendix H.  GNU Free Documentation License
principal place of business in San Francisco, California, as well as future copyleft
versions of that license published by that same organization.
iIncorporatej means to publish or republish a Document, in whole or in part, as
part of another Document.
An MMC is ieligible for relicensingj if it is licensed under this License, and if all
works that were orst published under this License somewhere other than this
MMC, and subsequently incorporated in whole or in part into the MMC, (1) had
no cover texts or invariant sections, and (2) were thus incorporated prior to
November 1, 2008.
The operator of an MMC Site may republish an MMC contained in the site under
CC-BY-SA on the same site at any time before August 1, 2009, provided the MMC
is eligible for relicensing.
ADDENDUM:  How  to  use  this  License  for  your
documents
To use this License in a document you have written, include a copy of the License
in the document and put the following copyright and license notices just after the
title page:
                   Copyright (C) YEAR YOUR NAME.
                   Permission is granted to copy, distribute and/or modify this
                   document under the terms of the GNU Free Documentation License,
                   Version 1.3 or any later version published by the Free Software
                   Foundation; with no Invariant Sections, no Front-Cover Texts, and no
                   Back-Cover Texts.
                   A copy of the license is included in the section entitled iGNU Free
                   Documentation License.j
If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts, replace
the iwith. . . Texts.j line with this:
                   with the Invariant Sections being LIST THEIR TITLES, with the
                   Front-Cover Texts being LIST, and with the Back-Cover Texts being
                   LIST.
If you have Invariant Sections without Cover Texts, or some other combination of
the three, merge those two alternatives to suit the situation.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 454
                             Appendix H.  GNU Free Documentation License
If your document contains nontrivial examples of program code, we recommend
releasing these examples in parallel under your choice of free software license,
such as the GNU General Public License, to permit their use in free software.
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 455
                             Appendix H.  GNU Free Documentation License
                                                             (empty page)
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 456

Index
&-qualioed non-static member                                                  .debug_info, 8, 9, 13, 15, 24, 28, 31,
             function, 21                                                                  36, 42, 69, 140, 141, 143, 150,
&&-qualioed non-static member                                                              152, 154, 155, 182, 192~195,
             function, 22                                                                  197, 205~212, 216, 226~229,
!caf?, see code alignment factor                                                           246, 289~296, 301, 302, 392,
!daf?, see data alignment factor                                                           393, 395, 397~403, 414, 415,
... parameters, see unspecioed                                                             418, 419, 425, 426, 428, 441,
             parameters entry                                                              442
.data, 392                                                                           example, 301
.debug_abbrev.dwo, 8, 196, 198, 199,                                          .debug_line.dwo, 8, 72, 165, 174, 177,
             202, 293, 294, 418, 428,                                                      196, 198, 199, 202, 224, 293,
             435~437, 442                                                                  295, 296, 418, 428, 429,
.debug_abbrev, 146, 193, 195, 206,                                                         435~437, 442
             209~212, 289, 290, 293, 294,                                     .debug_line_str, 8, 155, 160,
             301, 302, 392, 402, 419, 425,                                                 163~165, 195, 206, 207, 228,
             427, 442                                                                      289, 292, 293, 419, 442
       example, 301                                                           .debug_line, 65, 155, 160, 165, 174,
.debug_addr, 8, 28, 45, 46, 55, 69, 194,                                                   177, 192, 194, 195, 206, 207,
             195, 223, 254, 289, 291~293,                                                  224, 289~293, 295, 296, 383,
             295, 419, 420, 425~428, 434,                                                  384, 392, 397, 402, 418, 419,
             442                                                                           425~427, 442
.debug_aranges, 154, 192, 194, 195,                                           .debug_loclists.dwo, 8, 44, 196, 198,
             206, 246, 289, 292~294, 392,                                                  199, 202, 256, 293, 295, 418,
             397, 419, 420, 425~427, 442                                                   428, 431, 434, 436, 437, 442
.debug_cu_index, 8, 199, 200, 436,                                            .debug_loclists, 9, 10, 44, 47, 69,
             437, 443                                                                      192, 194, 207, 225, 256, 289,
.debug_frame, 182, 183, 192, 195, 206,                                                     291, 295, 418, 431, 442
             289, 293, 346, 419, 442                                          .debug_loc (pre-Version 5), 10, 442
.debug_info.dwo, 8, 15, 196~199, 202,                                         .debug_macinfo (pre-Version 5), 8,
             205, 293~295, 418, 420, 428,                                                  199, 442
             429, 431~433, 435~437, 442                                       .debug_macro.dwo, 8, 174, 196, 198,
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 457
                                                                   Index
             199, 202, 225, 293, 295, 296,                                    .dwp ole extension, 198
             418, 428, 442                                                    .text, 392, 399, 401
.debug_macro, 8, 66, 173, 174, 178,                                           segment_selector_size
             194, 204, 225, 289~292, 383,                                                  (deprecated), 154, 160, 183,
             384, 418, 442                                                                 246, 254~256
.debug_names, 9, 10, 141, 148, 150,                                           32-bit DWARF format, 36, 160, 204,
             152, 192, 194, 195, 205~207,                                                  209~212, 223, 225~229, 246,
             289, 290, 292~294, 419, 420,                                                  251, 257
             425~427, 442                                                     64-bit DWARF format, 36, 160, 204,
.debug_pubnames (pre-Version 5), 9,                                                        209~212, 225~229, 246, 251,
             10, 141, 442                                                                  257
.debug_pubtypes (pre-Version 5), 9,
             10, 141, 442                                                     abbrev_table_size, 149, 152, 153,
.debug_ranges (pre-Version 5), 10,                                                         245
             442                                                              abbreviations table, 208
.debug_rnglists.dwo, 54, 196, 198,                                                   dynamic forms in, 216
             199, 202, 255, 293, 295, 428,                                           example, 301
             431, 436, 442                                                    abstract instance, 20, 415
.debug_rnglists, 9, 10, 54, 56, 69,                                                  entry, 86
             192, 194, 207, 226, 255, 289,                                           example, 351, 354
             291~293, 295, 442                                                       nested, 91
.debug_str.dwo, 8, 165, 196~199, 293,                                                root, 86, 87
             296, 418, 428, 431, 435~437,                                            tree, 86
             442                                                              abstract origin attribute, 89, 90, 219
.debug_str_offsets.dwo, 8, 68, 165,                                           accelerated access, 140
             197~199, 202, 205, 253, 293,                                            by address, 154
             294, 296, 418, 419, 428, 431,                                           by name, 141
             435~437, 442                                                     Access declaration, 17
.debug_str_offsets, 8, 68, 73, 149,                                           access declaration entry, 122
             152, 175, 194, 196, 205, 207,                                    accessibility attribute, 17, 48, 121, 122,
             228, 229, 253, 288~294, 296,                                                  124, 219, 239
             420, 442                                                         Accessibility of base or inherited
.debug_str, 149, 152, 165, 175, 178,                                                       class, 17
             194~196, 204~206, 228, 229,                                      activation of call frame, 179, 189
             289~291, 293, 294, 382, 384,                                     Ada, 1, 17, 48, 64, 110, 112, 113, 138,
             419, 420, 425~427, 442                                                        308, 321, 323, 327, 328, 331,
.debug_sup, 203, 442                                                                       332
.debug_tu_index, 8, 199, 200, 436,                                            address, see also address class
             437, 443                                                                dereference operator, 30, 31
.debug_types (Version 4), 8, 442                                                     implicit push for member
.dwo ole extension, 418                                                                    operator, 135
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 458
                                                                   Index
      implicit push of base, 32                                               all tail calls are described, 18
      uplevel, see static link attribute                                      all tail calls summary attribute, 81,
address, 157, 159, 161                                                                     221
address class, 23, 46, 50, 57, 92, 217,                                       all tail, normal and inlined calls are
             218, 220~222, 229~231, 242                                                    described, 18
address class attribute, 82, 114, 219                                         allocated attribute, 138, 220
address index, 45, 55                                                         allocation status of types, 17
address of call instruction, 18                                               anonymous structure, 321
address of called routine, 19                                                 anonymous union, 101, 122
address of called routine, which may                                          ANSI-deoned language names, 63,
             be clobbered, 19                                                              240
address of the value pointed to by an                                         argument value passed, 19
             argument, 18                                                     ARM instruction set architecture, 155
address register                                                              array
      address  register                                                              assumed-rank, 139, 316
          in  line  number  machine, 157                                             declaration of type, 115
address size, see also address_size,                                                 descriptor for, 307
             see size of an address                                                  element ordering, 115
address space                                                                        element type, 116
      multiple, 31                                                            Array bound THREADS scale factor,
address table, 17                                                                          22
address table base                                                            array coarray, see coarray
      encoding, 221                                                           array element stride (of array type),
address table base attribute, 69                                                           18
address_range, 182, 184, 189                                                  array row/column ordering, 21
address_size, 9, 154, 160, 182,                                               array type entry, 115
             209~211, 246, 254~256, 342                                              examples, 307
addrptr, see also addrptr class                                               artiocial attribute, 49, 219
addrptr class, 23, 69, 71, 221~223, 229,                                      artiocial name or description, 20
             230                                                              ASCII (Fortran string kind), 132
adjusted opcode, 169                                                          ASCII (Fortran string kind), 109
alias declaration, see imported                                               ASCII character, 108
             declaration entry                                                Assembly, 64
alignment                                                                     associated attribute, 138, 220
      non-default, 17                                                         associated compilation unit, 222
alignment attribute, 60, 221                                                  association status of types, 17
all calls summary attribute, 81, 221                                          assumed-rank array, see array,
all source calls summary attribute,                                                        assumed-rank
             81, 221                                                          atomic qualioed type entry, 113
all tail and normal calls are                                                 attribute duplication, 17
             described, 18                                                    attribute encodings, 217
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 459
                                                                   Index
attribute ordering, 17                                                        bounded location description, 44, 46,
attribute value classes, 23                                                                47
attributes, 15                                                                bounded range, 54~56
      list of, 17                                                             bucket_count, 149, 151
augmentation, 150, 182                                                        byte order, 104, 198, 203, 224, 231, 326
augmentation sequence, 150                                                    byte size attribute, 106, 124, 136, 217
augmentation string, 182                                                      byte stride attribute, 116, 130, 135,
augmentation_size, 150                                                                     220
auto return type, 82, 112, 126
                                                                              C, 1, 12, 21, 32, 50, 64, 68, 80~82, 96,
base address, 53                                                                           97, 99~102, 107, 109, 112~116,
      of location list, 45                                                                 118, 119, 130, 131, 136, 172,
      of range list, 54                                                                    177, 262, 316, 321, 326, 368,
base address of scope, 21, 53                                                              374, 382, 398, 399, 414
base address selection entry                                                  C++, 1, 9, 11, 12, 17, 21, 22, 32, 48, 49,
      in range list, 252, 253                                                              52, 58, 59, 64, 74~78, 82, 85~88,
base type bit location, 19                                                                 90, 92, 96~98, 101, 102, 104,
base type bit size, 18                                                                     109, 112, 113, 115, 118~122,
base type entry, 106                                                                       124~126, 130, 131, 135~137,
base types attribute, 68, 219                                                              148, 172, 177, 321, 326, 334,
basic block, 156, 157, 167, 169                                                            356, 359, 362~366, 386, 391,
basic_block, 157, 159, 167, 169                                                            394, 396~399, 403, 414
beginning of a data member, 123                                               C++ for OpenCL, 64
beginning of an object, 123, 326                                              C++11, 125, 131
Bernstein hash function, 262                                                  C-interoperable, 316
Bias added to an encoded value, 17                                            C#, 64
bias attribute, 222                                                           call column attribute, 95, 220
big-endian encoding, see endianity                                                   of call site entry, 95
             attribute                                                        call data location attribute, 96, 221
binary scale attribute, 109, 220                                              call data value attribute, 96, 221
binary scale factor for oxed-point                                            call ole attribute, 95, 220
             type, 17                                                                of call site entry, 95
bit oelds, 324, 326                                                           call is a tail call, 18
bit ooeset attribute (Version 3), 217                                         call line attribute, 95, 220
bit size attribute, 106, 107, 124, 136,                                              of call site entry, 95
             217                                                              call origin attribute, 94, 221
bit stride attribute, 116, 130, 135, 218                                      call parameter attribute, 96, 221
BLISS, 64                                                                     call PC attribute, 221
block, see also block class, 25, 83, 99,                                      call pc attribute, 94
             128, 189                                                         call return PC attribute, 221
block class, 23, 218, 219, 223, 229                                           call return pc attribute, 94
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 460
                                                                   Index
call site                                                                     CIE_id, 182, 206
      address of called routine, 19                                           CIE_pointer, 182, 183, 206
      address of called routine, which                                        class of attribute value
             may be clobbered, 19                                                    address, see address class
      address of the call instruction, 18                                            addrptr, see addrptr class
      address of the value pointed to                                                block, see block class
             by an argument, 18                                                      constant, see constant class
      argument value passed, 19                                                      exprloc, see exprloc class
      parameter entry, 18                                                            AEag, see AEag class
      return address, 18                                                             lineptr, see lineptr class
      subprogram called, 18                                                          loclist, see loclist class
      summary                                                                        loclistsptr, see loclistsptr class
          all tail and normal calls are                                              macptr, see macptr class
             described, 18                                                           reference, see reference class
          all tail calls are described, 18                                           rnglist, see rnglist class
          all tail, normal and inlined calls                                         rnglistsptr, see rnglistsptr class
             are described, 18                                                       string, see string class
      tail call, 18                                                                  strooesetsptr, see strooesetsptr class
      value pointed to by an argument,                                        class type entry, 118
             18                                                               class variable entry, 124
call site entry, 94                                                           coarray, 117
call site parameter entry, 95                                                        example, 313~315
call site return pc attribute, 94                                             COBOL, 1, 3, 12, 64
call site summary information, 81                                             code address or range of addresses,
call tail call attribute, 94, 221                                                          21
call target attribute, 95, 221                                                code alignment factor, 183
call target clobbered attribute, 95, 221                                      code_alignment_factor, 183, 185
call type attribute, 95                                                       codimension, see coarray
call value attribute, 96, 221                                                 coindex, see coarray
Calling convention                                                            column, 157, 159
      for subprograms, 19                                                     column position of call site of
      for types, 19                                                                        non-inlined call, 18
calling convention attribute, 219                                             column position of inlined
      for subprogram, 79                                                                   subroutine call, 18
      for types, 120                                                          column position of source
calling convention codes                                                                   declaration, 19
      for subroutines, 79                                                     COMDAT, 11, 394, 401~403
      for types, 120                                                          common, 83
catch block, 98                                                               common block, see Fortran common
catch block entry, 98                                                                      block, 101
Child determination encodings, 216                                            common block entry, 104
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 461
                                                                   Index
common block reference attribute, 83,                                         containing type attribute, 218
             104                                                              containing type of pointer to member
common block usage, 19                                                                     type, 19
common blocks, 52                                                             contiguous range of code addresses,
common information entry, 182                                                              20
common reference attribute, 218                                               conventional compilation unit, see
comp_unit_count, 149                                                                       full compilation unit, partial
compilation directory, 19                                                                  compilation unit, type unit
compilation directory attribute, 66,                                          conventional type unit, 72
             218                                                              count attribute, 114, 134, 219
compilation unit, 61                                                                 default, 134
      see also type unit, 72                                                  counted location description, 45
      full, 62                                                                Crystal, 64
      partial, 62
      skeleton, 69                                                            D, 64, 113
compilation unit ID, 435, 437                                                 data (indirect) location attribute, 137
compilation unit set, 199                                                     data alignment factor, 183
compilation unit uses UTF-8 strings,                                          data bit ooeset, 326
             22                                                               data bit ooeset attribute, 107, 123, 220
compile-time constant function, 19                                            data bit size, 326
compile-time constant object, 19                                              data location attribute, 220
compiler identiocation, 21                                                    data member, see member entry
concrete instance                                                                          (data)
      example, 351, 354, 355                                                  data member attribute, 219
      nested, 91                                                              data member bit location, 19
concrete out-of-line instance, 415                                            data member bit size, 18
condition entry, 129                                                          data member location, 19
const qualioed type entry, 113                                                data member location attribute, 121,
constant, see also constant class, 57                                                      123
constant (data) entry, 101                                                    data object entries, 101
constant class, 23, 57, 60, 99, 103, 107,                                     data object location, 21
             195, 217~222, 224, 229, 230,                                     data object or data type size, 18
             245                                                              data_alignment_factor, 183,
constant expression attribute, 88, 104,                                                    185~187
             220                                                              debug_abbrev_offset, 9, 202, 206,
constant object, 19                                                                        209~211, 290, 294
constant value attribute, 59, 103, 130,                                       debug_info_offset, 154, 194, 206,
             218                                                                           246
constexpr, 86, 88                                                             debug_line_offset, 173, 174
containing type (of pointer) attribute,                                       debug_line_offset_flag, 173, 383,
             135                                                                           384
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 462
                                                                   Index
debugging information entry, 15                                               directory_format_table, 162, 163,
      ownership relation, 25, 395                                                          342
debugging information entry                                                   discontiguous address ranges, see
             relationship, 22                                                              non-contiguous address
decimal scale attribute, 109~112, 220                                                      ranges
decimal scale factor, 19                                                      discriminant (entry), 127
decimal sign attribute, 110, 111                                              discriminant attribute, 127, 218
decimal sign representation, 19                                               discriminant list attribute, 128, 219,
DECL, 265~285                                                                              244
declaration attribute, 50, 51, 74, 101,                                       discriminant of variant part, 20
             102, 119, 219                                                    discriminant value, 20
declaration column attribute, 51, 52,                                         discriminant value attribute, 128, 218
             219                                                              discriminated union, see variant entry
declaration coordinates, 15, 51, 89,                                          discriminator, 156, 158, 159, 167,
             265                                                                           169, 172
      in concrete instance, 89                                                divisor of rational scale factor, 222
declaration ole attribute, 51, 219                                            DJB hash function, 151, 262
declaration line attribute, 51, 219                                           duplication elimination, see DWARF
DEFAULT (Fortran string kind), 132                                                         duplicate elimination
default location description, 45                                              DW.ACCESS.private, 48, 239, 406,
default value attribute, 103, 218                                                          408, 409
default value of parameter, 19                                                DW.ACCESS.protected, 48, 239
default_is_stmt, 159, 161, 342                                                DW.ACCESS.public, 48, 239, 429,
defaulted attribute, 19, 126, 222                                                          432
deleted attribute, 126, 221                                                   DW.ADDR.none, 50, 242
Deletion of member function, 19                                               DW.AT.abstract.origin, 17, 89, 89,
denominator of rational scale factor,                                                      90, 90, 142, 219, 265, 353, 357,
             22                                                                            359, 360, 371
derived type (C++), see inheritance                                           DW.AT.accessibility, 17, 48, 121, 122,
             entry                                                                         124, 219, 239, 259, 266, 268,
description attribute, 58, 220                                                             270~275, 278~285, 406, 408,
descriptor                                                                                 409, 429, 432
      array, 307                                                              DW.AT.addr.base, 17, 28, 45, 55, 69,
DIE, see debugging information entry                                                       70, 71, 196, 221, 223, 254, 269,
digit count attribute, 109~111, 220                                                        276, 278, 289, 291, 295, 420,
digit count for packed decimal or                                                          421, 425, 427, 428, 434
             numeric string type, 20                                          DW.AT.address.class, 17, 50, 82,
directories, 162, 163, 165, 342                                                            114, 219, 259, 270, 276, 277,
directories_count, 162, 342                                                                280, 282, 285
directory_format_count, 162, 342                                              DW.AT.alignment, 17, 60, 221, 259,
                                                                                           266~273, 275~284
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 463
                                                                   Index
DW.AT.allocated, 17, 117, 137, 138,                                                        267, 273
             138, 220, 259, 266~268,                                          DW.AT.call.data.location, 18, 96,
             270~272, 277~279, 281~284,                                                    96, 221, 268
             312, 320                                                         DW.AT.call.data.value, 18, 96, 96,
DW.AT.artiocial, 15, 17, 49, 92, 125,                                                      221, 268, 381
             219, 259, 265, 328, 333, 339,                                    DW.AT.call.ole, 18, 88, 95, 220, 267,
             341, 407, 413, 430, 433                                                       273
DW.AT.associated, 17, 117, 137, 138,                                          DW.AT.call.line, 18, 88, 95, 220, 267,
             138, 220, 259, 266~268,                                                       273
             270~272, 277~279, 281~284,                                       DW.AT.call.origin, 18, 94, 95, 221,
             311, 320                                                                      267, 377, 381
DW.AT.base.types, 17, 68, 70, 71,                                             DW.AT.call.parameter, 18, 96, 221,
             219, 269, 276, 421                                                            268, 377, 378, 381
DW.AT.bias, 17, 107, 222, 267, 328                                            DW.AT.call.pc, 18, 81, 94, 94, 221,
DW.AT.binary.scale, 17, 109, 109,                                                          267
             220, 259, 267                                                    DW.AT.call.return.pc, 18, 81, 94,
DW.AT.bit.ooeset (deprecated), 217                                                         94, 221, 267, 377, 378, 381
DW.AT.bit.size, 18, 58, 58, 106, 107,                                         DW.AT.call.tail.call, 18, 94, 221, 267
             116, 119, 124, 130, 132~134,                                     DW.AT.call.target, 19, 95, 95, 221,
             136, 217, 259, 266~268, 271,                                                  267, 377, 378
             272, 274, 276~279, 281, 284,                                     DW.AT.call.target.clobbered, 19,
             324~326, 328                                                                  95, 95, 221, 267
DW.AT.bit.stride, 18, 58, 116, 130,                                           DW.AT.call.value, 19, 96, 96, 221,
             130, 135, 218, 259, 266, 271,                                                 268, 377, 378, 381
             272, 281, 325                                                    DW.AT.calling.convention, 19, 79,
DW.AT.byte.size, 10, 18, 58, 58, 106,                                                      120, 219, 243, 268, 279, 280,
             116, 119, 124, 130, 132~134,                                                  284
             136, 217, 259, 266~268, 271,                                     DW.AT.common.reference, 19, 83,
             272, 274, 276~279, 281, 284,                                                  218, 269, 401, 402
             302, 312, 328, 360, 361, 369,                                    DW.AT.comp.dir, 19, 63, 66, 66,
             373, 402, 404~408, 410, 413,                                                  69~71, 218, 269, 276, 278, 302,
             430                                                                           420, 421, 425, 427, 429
DW.AT.byte.stride, 18, 58, 116, 130,                                          DW.AT.const.expr, 19, 88, 88, 104,
             130, 135, 220, 259, 271, 272,                                                 220, 259, 273, 284, 360
             281, 310, 317                                                    DW.AT.const.value, 19, 42, 57, 59,
DW.AT.call.all.calls, 18, 81, 81, 221                                                      88, 103, 130, 218, 259, 270~272,
DW.AT.call.all.source.calls, 18, 81,                                                       283, 284, 353, 360, 362, 373,
             81, 221                                                                       400
DW.AT.call.all.tail.calls, 18, 81, 81,                                        DW.AT.containing.type, 19, 135,
             221                                                                           218, 259, 277, 341
DW.AT.call.column, 18, 88, 95, 220,                                           DW.AT.count, 19, 114, 134, 219, 259,
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 464
                                                                   Index
             272, 278, 281                                                                 330~333
DW.AT.data.bit.ooeset, 19, 57, 107,                                           DW.AT.discr.list, 20, 128, 128, 219,
             123, 123, 220, 259, 267, 274,                                                 244, 259, 285
             324~326, 328                                                     DW.AT.discr.value, 20, 128, 128,
DW.AT.data.location, 19, 117, 137,                                                         218, 259, 285, 330, 332, 333
             137, 138, 220, 259, 266~268,                                     DW.AT.dwo.name, 20, 69, 69, 70,
             270~272, 277~279, 281~284,                                                    210, 221, 276, 278, 294, 420,
             308, 310~313, 317, 320, 322,                                                  421, 425, 427
             373                                                              DW.AT.elemental, 20, 80, 220, 280
DW.AT.data.member.location, 19,                                               DW.AT.encoding, 20, 106, 107, 219,
             32, 57, 121, 123, 123, 219, 259,                                              237, 259, 267, 302, 328, 361,
             273, 274, 312, 323, 330, 332,                                                 373, 402, 404, 405, 407, 408,
             333, 369, 404~406, 408~410                                                    413, 430
DW.AT.decimal.scale, 19, 109, 110,                                            DW.AT.endianity, 20, 104, 104, 106,
             111, 112, 220, 259, 267                                                       220, 239, 259, 267, 270, 272,
DW.AT.decimal.sign, 19, 110, 111,                                                          284
             220, 238, 259, 267                                               DW.AT.entry.pc, 20, 57, 57, 68, 71,
DW.AT.decl.column, 19, 51, 52, 219,                                                        74, 82, 87, 97, 98, 142, 220, 268,
             262, 265                                                                      269, 273, 274, 276, 280, 283,
DW.AT.decl.ole, 19, 51, 51, 72, 196,                                                       285, 421
             219, 262, 265, 404, 406, 407,                                    DW.AT.enum.class, 20, 130, 130,
             413, 418, 429, 430, 432, 433                                                  221, 259, 271, 362
DW.AT.decl.line, 19, 51, 51, 219,                                             DW.AT.explicit, 20, 124, 220, 259,
             262, 265, 404, 406, 407, 413,                                                 280
             429, 430, 432, 433                                               DW.AT.export.symbols, 20, 75, 75,
DW.AT.declaration, 19, 50, 51, 74,                                                         118, 221, 268, 275, 279, 284,
             101, 102, 119, 142, 219, 261,                                                 321, 335, 337
             262, 266, 268~272, 274, 275,                                     DW.AT.extension, 20, 74, 220, 275,
             277~285, 338, 339, 407, 413,                                                  336
             429, 432                                                         DW.AT.external, 20, 79, 101, 102,
DW.AT.default.value, 19, 59, 103,                                                          153, 219, 270, 280, 284, 407,
             218, 259, 272, 282, 283, 386,                                                 413, 429, 432
             387                                                              DW.AT.frame.base, 20, 29, 33, 83,
DW.AT.defaulted, 9, 19, 126, 126,                                                          83, 84, 219, 270, 280, 304,
             222, 245, 280                                                                 357~359, 430, 433
DW.AT.deleted, 9, 19, 126, 221, 280                                           DW.AT.friend, 20, 122, 219, 260, 272
DW.AT.description, 15, 20, 58, 220,                                           DW.AT.hi.user, 191, 222
             262, 265                                                         DW.AT.high.pc, 11, 20, 53, 53, 63,
DW.AT.digit.count, 20, 109, 110,                                                           70, 71, 74, 82, 87, 96~98, 142,
             111, 112, 220, 259, 267                                                       218, 268, 269, 273, 274, 276,
DW.AT.discr, 20, 127, 218, 259, 285,                                                       278, 280, 283, 285, 302, 335,
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 465
                                                                   Index
             336, 353, 354, 357~359, 378,                                                  240, 259, 272, 281, 311, 312,
             413, 420, 421, 428, 430, 433                                                  314, 317, 323, 325, 328, 400
DW.AT.identioer.case, 20, 67, 71,                                             DW.AT.macro.info (deprecated),
             219, 243, 269, 276, 400, 421                                                  219
DW.AT.import, 20, 76, 77, 77, 78,                                             DW.AT.macros, 21, 65, 71, 221, 269,
             204, 218, 273, 336, 396, 398,                                                 276, 289, 295, 421
             401, 402                                                         DW.AT.main.subprogram, 11, 21,
DW.AT.inline, 20, 86, 86, 218, 244,                                                        68, 68, 71, 79, 220, 269, 276,
             280, 351, 352, 355, 358, 360,                                                 280, 421
             371                                                              DW.AT.mutable, 21, 123, 220, 259,
DW.AT.is.optional, 20, 103, 218,                                                           274
             259, 272                                                         DW.AT.name, 21, 52, 52, 58, 59, 63,
DW.AT.language (deprecated), 218                                                           67, 71, 74, 76, 79, 90, 96, 97,
DW.AT.language.name, 21, 63, 71,                                                           101, 104~106, 112, 113, 115,
             72, 103, 116, 222, 240, 269, 276,                                             117, 118, 120, 122, 129~133,
             283, 302, 398, 400, 404, 406,                                                 135~137, 142, 164, 217,
             421, 429                                                                      258~260, 265~285, 302, 312,
DW.AT.language.version, 21, 65,                                                            314, 315, 320, 321, 323~325,
             71, 72, 103, 222, 269, 276, 283,                                              328, 330, 332, 333, 335~339,
             421                                                                           341, 352, 354, 355, 358,
DW.AT.linkage.name, 21, 52, 59, 79,                                                        360~364, 366, 367, 369, 371,
             104, 142, 221, 269, 270, 280,                                                 373, 378, 386, 387, 390,
             284, 429, 432                                                                 398~402, 404~411, 413, 421,
DW.AT.lo.user, 191, 222                                                                    429, 430, 432, 433
DW.AT.location, 21, 36, 42, 52, 52,                                           DW.AT.namelist.item, 21, 105, 219,
             59, 87, 95, 98, 102, 104, 142,                                                275
             217, 259, 268~270, 272, 284,                                     DW.AT.noreturn, 9, 21, 80, 221, 280
             285, 289, 312, 320, 323, 325,                                    DW.AT.num.lanes, 21, 84, 85, 222,
             328, 335, 336, 339, 353, 354,                                                 390
             357~359, 369, 371, 373, 377,                                     DW.AT.object.pointer, 21, 125, 125,
             378, 381, 390, 400, 411, 430,                                                 220, 262, 280, 338, 339, 430,
             431, 433                                                                      433
DW.AT.loclists.base, 21, 44, 69, 222,                                         DW.AT.ordering, 21, 115, 217, 244,
             256, 421                                                                      259, 266, 314, 315
DW.AT.low.pc, 11, 21, 53, 53, 63,                                             DW.AT.picture.string, 21, 111, 220,
             69~71, 74, 82, 87, 96~98, 142,                                                259, 267
             217, 268~270, 273, 274, 276,                                     DW.AT.priority, 21, 74, 219, 274
             278, 280, 283, 285, 302, 335,                                    DW.AT.producer, 21, 67, 71, 218,
             336, 353, 354, 357~359, 378,                                                  269, 276, 302, 421, 429
             413, 420, 421, 428, 430, 433                                     DW.AT.prototyped, 21, 80, 131, 218,
DW.AT.lower.bound, 21, 134, 218,                                                           259, 280, 282
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 466
                                                                   Index
DW.AT.pure, 21, 80, 220, 280                                                               295, 302, 420, 421, 425~429
DW.AT.ranges, 21, 53, 53, 54, 63, 70,                                         DW.AT.str.ooesets, 22, 68, 70, 72, 73,
             71, 74, 82, 87, 96~98, 142, 220,                                              222, 254, 269, 276, 278, 283,
             268, 269, 273, 274, 276, 278,                                                 289, 290, 420, 421
             280, 283, 285, 289, 295, 420,                                    DW.AT.str.ooesets.base
             421, 428, 431                                                                 (deprecated), 22
DW.AT.rank, 9, 21, 117, 139, 139,                                             DW.AT.string.length, 10, 22, 132,
             221, 259, 266, 316, 317                                                       132, 133, 218, 259, 279, 373
DW.AT.recursive, 21, 80, 81, 220, 280                                         DW.AT.string.length.bit.size, 22,
DW.AT.reference, 21, 125, 131, 132,                                                        58, 132, 221, 259, 279
             221, 259, 280, 282                                               DW.AT.string.length.byte.size, 22,
DW.AT.return.addr, 22, 83, 87, 218,                                                        58, 132, 221, 259, 279, 373
             270, 273, 280                                                    DW.AT.tensor, 22, 115, 116, 222
DW.AT.rnglists.base, 22, 54, 69, 70,                                          DW.AT.threads.scaled, 22, 134, 220,
             221, 255, 269, 276, 278, 289,                                                 259, 272, 281
             421                                                              DW.AT.trampoline, 22, 92, 220, 273,
DW.AT.rvalue.reference, 22, 125,                                                           281
             131, 132, 221, 259, 280, 282,                                    DW.AT.type, 22, 48, 48, 59, 82, 85,
             341                                                                           95, 95, 96, 98, 102, 104, 113,
DW.AT.scale.divisor, 22, 110, 110,                                                         115~117, 121, 122, 127,
             222, 259, 267                                                                 129~131, 132, 133~137, 219,
DW.AT.scale.multiplier, 22, 110,                                                           260, 266~278, 281~285, 302,
             110, 222, 259, 267                                                            311, 312, 314, 315, 317, 320,
DW.AT.segment (deprecated), 219                                                            323~325, 328, 330, 332, 333,
DW.AT.sibling, 22, 25, 51, 217, 265                                                        335, 336, 338, 339, 341, 352,
DW.AT.signature, 22, 51, 119, 220,                                                         355, 358, 360~367, 369, 371,
             268, 271, 273, 279, 282, 284,                                                 373, 378, 386, 387, 390,
             413, 429, 432                                                                 398~401, 404~411, 413, 429,
DW.AT.small, 22, 110, 110, 220, 259,                                                       430, 432, 433
             267                                                              DW.AT.upper.bound, 22, 134, 134,
DW.AT.speciocation, 22, 51, 51, 75,                                                        218, 259, 272, 281, 311, 312,
             87, 102, 119, 125, 126, 142, 219,                                             314, 315, 317, 323, 325, 328,
             261, 266, 268, 271, 274, 279,                                                 360, 400
             280, 284, 336, 413, 430, 433                                     DW.AT.use.location, 22, 135, 135,
DW.AT.start.scope, 22, 87, 99, 218,                                                        136, 219, 259, 277
             266, 268, 270, 271, 273~275,                                     DW.AT.use.UTF8, 22, 68, 70~72,
             278, 279, 281~284                                                             220, 228, 259, 269, 276, 278,
DW.AT.static.link, 22, 83, 84, 84,                                                         283, 421
             219, 270, 281, 353, 357, 358                                     DW.AT.variable.parameter, 22, 102,
DW.AT.stmt.list, 22, 65, 70~72, 202,                                                       219, 259, 272
             217, 269, 276, 278, 283, 289,                                    DW.AT.virtuality, 23, 49, 121, 124,
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 467
                                                                   Index
             219, 240, 259, 273, 281                                          DW.ATE.unsigned.bitint, 108, 109,
DW.AT.visibility, 23, 48, 218, 239,                                                        238
             259, 266, 268~272, 274, 275,                                     DW.ATE.unsigned.char, 108, 238,
             277~279, 281~285                                                              302
DW.AT.vtable.elem.location, 23,                                               DW.ATE.unsigned.oxed, 108, 109,
             125, 220, 259, 281                                                            238
DW.ATE.address, 108, 237                                                      DW.ATE.UTF, 108, 109, 238, 361
DW.ATE.ASCII, 108, 109, 132, 238,                                             DW.CC.hi.user, 191, 243
             373                                                              DW.CC.lo.user, 191, 243
DW.ATE.boolean, 108, 237, 430                                                 DW.CC.nocall, 79, 79, 243
DW.ATE.complex.AEoat, 108, 110,                                               DW.CC.normal, 79, 79, 120, 243
             237                                                              DW.CC.pass.by.reference, 120, 243
DW.ATE.complex.signed, 108, 112,                                              DW.CC.pass.by.value, 120, 243
             238                                                              DW.CC.program, 79, 80, 80, 243
DW.ATE.complex.unsigned, 108,                                                 DW.CFA.advance.loc, 185, 185, 189,
             112, 238                                                                      251, 349
DW.ATE.decimal.AEoat, 108, 110,                                               DW.CFA.advance.loc1, 185, 185,
             238                                                                           251
DW.ATE.edited, 108, 111, 238                                                  DW.CFA.advance.loc2, 185, 185,
DW.ATE.AEoat, 108, 110, 237                                                                251
DW.ATE.hi.user, 191, 238                                                      DW.CFA.advance.loc4, 185, 185,
DW.ATE.imaginary.AEoat, 108, 110,                                                          251
             238                                                              DW.CFA.def.cfa, 185, 185, 251, 348
DW.ATE.imaginary.signed, 108,                                                 DW.CFA.def.cfa.expression, 184,
             112, 238                                                                      186, 186, 252
DW.ATE.imaginary.unsigned, 108,                                               DW.CFA.def.cfa.ooeset, 186, 186,
             112, 238                                                                      252, 349
DW.ATE.lo.user, 191, 238                                                      DW.CFA.def.cfa.ooeset.sf, 186, 186,
DW.ATE.numeric.string, 108, 109,                                                           252
             110, 112, 238                                                    DW.CFA.def.cfa.register, 185, 185,
DW.ATE.packed.decimal, 108, 109,                                                           252, 349
             110, 112, 238                                                    DW.CFA.def.cfa.sf, 185, 185, 252
DW.ATE.signed, 107, 108, 238, 328,                                            DW.CFA.expression, 184, 187, 187,
             402, 404, 405, 407, 408, 413                                                  252
DW.ATE.signed.bitint, 108, 109, 238                                           DW.CFA.hi.user, 191, 252
DW.ATE.signed.char, 108, 238                                                  DW.CFA.lo.user, 191, 252
DW.ATE.signed.oxed, 108, 109, 238                                             DW.CFA.nop, 183, 184, 188, 188,
DW.ATE.UCS, 108, 109, 132, 238,                                                            251, 348, 349
             373                                                              DW.CFA.ooeset, 186, 186, 187, 251,
DW.ATE.unsigned, 108, 238, 328                                                             349
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 468
                                                                   Index
DW.CFA.ooeset.extended, 187, 187,                                             DW.FORM.addrx, 9, 69, 195, 196,
             251                                                                           223, 223, 230, 289, 291, 295,
DW.CFA.ooeset.extended.sf, 187,                                                            419, 420, 427, 428, 430, 433
             187, 252                                                         DW.FORM.addrx1, 9, 69, 195, 196,
DW.CFA.register, 187, 187, 251, 348                                                        223, 223, 230, 291, 295, 419,
DW.CFA.remember.state, 188, 188,                                                           420, 427, 428
             251                                                              DW.FORM.addrx2, 9, 69, 195, 196,
DW.CFA.restore, 188, 188, 251, 349                                                         223, 223, 231, 291, 295, 419,
DW.CFA.restore.extended, 188, 188,                                                         420, 427, 428
             251                                                              DW.FORM.addrx3, 9, 69, 195, 196,
DW.CFA.restore.state, 188, 188, 251                                                        223, 223, 231, 291, 295, 419,
DW.CFA.same.value, 186, 186, 251,                                                          420, 427, 428
             348                                                              DW.FORM.addrx4, 9, 69, 195, 196,
DW.CFA.set.loc, 184, 184, 189, 251                                                         223, 223, 231, 291, 295, 419,
DW.CFA.undeoned, 186, 186, 189,                                                            420, 427, 428
             251, 348                                                         DW.FORM.addrx.ooeset, 216, 216
DW.CFA.val.expression, 184, 188,                                              DW.FORM.block, 165, 166, 174, 223,
             188, 252                                                                      229, 260, 412
DW.CFA.val.ooeset, 187, 187, 252                                              DW.FORM.block1, 166, 174, 223, 229
DW.CFA.val.ooeset.sf, 187, 187, 252                                           DW.FORM.block2, 166, 174, 223, 229
DW.CHILDREN.no, 215, 216, 302                                                 DW.FORM.block4, 166, 174, 223, 229
DW.CHILDREN.yes, 215, 216, 302                                                DW.FORM.data, 224, 224
DW.DEFAULTED.in.class, 126, 245                                               DW.FORM.data1, 165, 166, 174, 224,
DW.DEFAULTED.no, 126, 245                                                                  224, 230, 302
DW.DEFAULTED.out.of.class, 126,                                               DW.FORM.data16, 9, 166, 174, 224,
             245                                                                           224, 230
DW.DS.leading.overpunch, 111,                                                 DW.FORM.data2, 165, 166, 174, 224,
             239                                                                           224, 229
DW.DS.leading.separate, 111, 239                                              DW.FORM.data4, 11, 165, 166, 174,
DW.DS.trailing.overpunch, 111, 239                                                         224, 224, 229, 387
DW.DS.trailing.separate, 111, 239                                             DW.FORM.data8, 11, 165, 166, 174,
DW.DS.unsigned, 111, 239                                                                   224, 224, 229, 245, 430, 433
DW.DSC.label, 128, 244                                                        DW.FORM.data!n?, 107
DW.DSC.range, 128, 244                                                        DW.FORM.exprloc, 230
DW.END.big, 104, 239                                                          DW.FORM.exprval, 224, 260
DW.END.default, 104, 239                                                      DW.FORM.AEag, 166, 174, 224, 230,
DW.END.hi.user, 191, 239                                                                   260, 412
DW.END.little, 104, 239                                                       DW.FORM.AEag.present, 224, 230,
DW.END.lo.user, 191, 239                                                                   245
DW.FORM.addr, 46, 56, 193, 223,                                               DW.FORM.implicit.const, 9, 216,
             229, 302                                                                      216, 224, 230
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 469
                                                                   Index
DW.FORM.indirect, 216, 216, 217,                                              DW.FORM.strp8, 149, 165, 166, 174,
             230, 302                                                                      194, 195, 197, 228, 228, 231,
DW.FORM.line.strp, 9, 165, 166,                                                            290, 294, 419
             174, 206, 207, 228, 228, 230,                                    DW.FORM.strp.sup, 9, 165, 166,
             289, 292, 296, 418                                                            174, 204, 206, 228, 228, 230
DW.FORM.locdesc, 225                                                          DW.FORM.strp.sup8, 165, 166, 174,
DW.FORM.loclistx, 9, 47, 69, 225,                                                          204, 228, 228, 231
             230, 256, 291, 295                                               DW.FORM.strx, 10, 68, 73, 165, 166,
DW.FORM.ref1, 195, 226, 230, 395                                                           174, 195~197, 199, 228, 228,
DW.FORM.ref2, 36, 195, 226, 230,                                                           230, 289, 290, 294, 296,
             395                                                                           418~420, 428~430, 432, 433,
DW.FORM.ref4, 36, 195, 226, 230,                                                           435
             302, 395                                                         DW.FORM.strx1, 10, 68, 73, 165, 166,
DW.FORM.ref8, 195, 226, 230, 395                                                           174, 195~197, 199, 228, 228,
DW.FORM.ref!n?, 226, 398                                                                   230, 290, 294, 418~420, 428
DW.FORM.ref.addr, 12, 36, 194,                                                DW.FORM.strx2, 10, 68, 73, 165, 166,
             197, 206, 226, 227, 230, 289,                                                 174, 195~197, 199, 228, 228,
             290, 302, 393, 395~397, 415                                                   230, 290, 294, 418~420, 428
DW.FORM.ref.sig8, 146, 150, 211,                                              DW.FORM.strx3, 10, 68, 73, 165, 166,
             227, 230, 404, 429, 432                                                       174, 195~197, 199, 228, 228,
DW.FORM.ref.sup4, 9, 204, 227, 230                                                         230, 290, 294, 418~420, 428
DW.FORM.ref.sup8, 9, 204, 227, 230                                            DW.FORM.strx4, 10, 68, 73, 149, 165,
DW.FORM.ref.udata, 195, 226, 230,                                                          166, 174, 195~197, 199, 228,
             395                                                                           228, 230, 289, 290, 292, 294,
DW.FORM.rnglistx, 9, 56, 69, 226,                                                          418~420, 428
             230, 255, 291, 295                                               DW.FORM.udata, 165, 166, 174, 224,
DW.FORM.sdata, 166, 174, 224, 224,                                                         224, 230, 342
             230, 260, 386, 405, 408~410,                                     DW.ID.case.insensitive, 67, 68, 243,
             412                                                                           400
DW.FORM.sec.ooeset, 11, 47, 56, 71,                                           DW.ID.case.sensitive, 67, 67, 243
             166, 174, 194, 197, 206, 222,                                    DW.ID.down.case, 67, 67, 243
             223~226, 229, 230, 255, 256,                                     DW.ID.up.case, 67, 67, 243
             290, 291, 295, 302, 433                                          DW.IDX.compile.unit, 153, 245
DW.FORM.string, 164~166, 174, 195,                                            DW.IDX.die.ooeset, 153, 245
             227, 229, 260, 302, 342, 386,                                    DW.IDX.external, 153, 153, 245
             387, 405, 408~410, 412, 429,                                     DW.IDX.hi.user, 191, 245
             430                                                              DW.IDX.lo.user, 191, 245
DW.FORM.strp, 149, 165, 166, 174,                                             DW.IDX.parent, 153, 245
             194, 195, 197, 206, 228, 228,                                    DW.IDX.type.hash, 153, 245
             230, 254, 289, 290, 294, 342,                                    DW.IDX.type.unit, 153, 245
             419, 431
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 470
                                                                   Index
DW.INL.declared.inlined, 86, 244,                                             DW.LNAME.hi.user, 191, 242
             352, 355, 358, 371                                               DW.LNAME.HIP, 64, 242
DW.INL.declared.not.inlined, 86,                                              DW.LNAME.HLSL, 64, 242
             244                                                              DW.LNAME.Hylo, 64, 242
DW.INL.inlined, 86, 86, 244, 360                                              DW.LNAME.Java, 64, 241
DW.INL.not.inlined, 86, 86, 244                                               DW.LNAME.Julia, 64, 241
DW.LLE.base.address, 47, 237                                                  DW.LNAME.Kotlin, 64, 241
DW.LLE.base.addressx, 46, 69, 237,                                            DW.LNAME.lo.user, 191, 242
             291                                                              DW.LNAME.Modula2, 64, 241
DW.LLE.default.location, 46, 237                                              DW.LNAME.Modula3, 64, 241
DW.LLE.end.of.list, 46, 47, 237,                                              DW.LNAME.Mojo, 64, 242
             371, 434                                                         DW.LNAME.Move, 64, 242
DW.LLE.hi.user, 191, 237                                                      DW.LNAME.ObjC, 64, 241
DW.LLE.include.loclist, 47, 237                                               DW.LNAME.ObjC.plus.plus, 65,
DW.LLE.include.loclistx, 47, 237                                                           241
DW.LLE.lo.user, 191, 237                                                      DW.LNAME.OCaml, 65, 241
DW.LLE.ooeset.pair, 46, 46, 47, 237                                           DW.LNAME.Odin, 65, 242
DW.LLE.start.end, 47, 237, 371                                                DW.LNAME.OpenCL.C, 65, 241
DW.LLE.start.length, 47, 237, 434                                             DW.LNAME.OpenCL.CPP, 65, 242
DW.LLE.startx.endx, 46, 69, 237,                                              DW.LNAME.P4, 65, 242
             291                                                              DW.LNAME.Pascal, 65, 241
DW.LLE.startx.length, 46, 69, 237,                                            DW.LNAME.PLI, 65, 241
             291                                                              DW.LNAME.Python, 65, 241
DW.LNAME.Ada, 64, 241                                                         DW.LNAME.RenderScript, 65, 241
DW.LNAME.Assembly, 64, 242                                                    DW.LNAME.Ruby, 65, 242
DW.LNAME.BLISS, 64, 241                                                       DW.LNAME.Rust, 65, 241
DW.LNAME.C, 64, 241, 302                                                      DW.LNAME.Swift, 65, 241
DW.LNAME.C.plus.plus, 64, 241,                                                DW.LNAME.SYCL, 65, 242
             398, 404, 406, 429                                               DW.LNAME.UPC, 65, 241
DW.LNAME.C.sharp, 64, 242                                                     DW.LNAME.Zig, 65, 241
DW.LNAME.Cobol, 64, 241                                                       DW.LNCT.directory.index, 165,
DW.LNAME.CPP.for.OpenCL, 64,                                                               248, 342
             242                                                              DW.LNCT.hi.user, 166, 191, 248
DW.LNAME.Crystal, 64, 241                                                     DW.LNCT.lo.user, 166, 191, 248
DW.LNAME.D, 64, 241                                                           DW.LNCT.MD5, 166, 166, 248
DW.LNAME.Dylan, 64, 241                                                       DW.LNCT.path, 164, 166, 248, 342
DW.LNAME.Fortran, 64, 241, 400                                                DW.LNCT.size, 166, 166, 248, 342
DW.LNAME.GLSL, 64, 242                                                        DW.LNCT.source, 166, 166, 248, 342
DW.LNAME.GLSL.ES, 64, 242                                                     DW.LNCT.timestamp, 165, 165, 248,
DW.LNAME.Go, 64, 241                                                                       342
DW.LNAME.Haskell, 64, 241                                                     DW.LNCT.URL, 166, 166, 248, 342
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 471
                                                                   Index
DW.LNE.deone.ole (deprecated),                                                DW.MACRO.deone.strx, 175, 175,
             248                                                                           176, 197, 250, 289, 291, 296
DW.LNE.end.sequence, 171, 171,                                                DW.MACRO.deone.sup
             172, 248, 345                                                                 (deprecated), 250
DW.LNE.hi.user, 191, 248                                                      DW.MACRO.deone.sup4, 173, 175,
DW.LNE.lo.user, 191, 248                                                                   175, 176, 204, 250
DW.LNE.padding, 172, 172, 248                                                 DW.MACRO.deone.sup8, 173, 175,
DW.LNE.set.address, 172, 172, 194,                                                         175, 176, 204, 250
             248, 419                                                         DW.MACRO.end.ole, 174, 177, 177,
DW.LNE.set.discriminator, 172,                                                             250, 383, 384
             172, 248                                                         DW.MACRO.hi.user, 174, 191, 250
DW.LNE.set.prologue.epilogue,                                                 DW.MACRO.import, 178, 178, 250,
             172, 172, 248                                                                 289, 292, 384
DW.LNS.advance.line, 169, 169, 247                                            DW.MACRO.import.sup
DW.LNS.advance.pc, 169, 169, 170,                                                          (deprecated), 250
             247, 345                                                         DW.MACRO.import.sup4, 173, 178,
DW.LNS.const.add.pc, 170, 170,                                                             178, 204, 250
             247                                                              DW.MACRO.import.sup8, 173, 178,
DW.LNS.copy, 169, 169, 247                                                                 178, 204, 250
DW.LNS.extended.op, 159, 160,                                                 DW.MACRO.lo.user, 174, 191, 250
             171, 171, 247                                                    DW.MACRO.padding, 178, 178, 250
DW.LNS.oxed.advance.pc, 159,                                                  DW.MACRO.start.ole, 174, 177,
             170, 170, 247, 345                                                            177, 196, 250, 289, 291, 296,
DW.LNS.hi.user, 191                                                                        383~385
DW.LNS.lo.user, 191                                                           DW.MACRO.undef, 175, 175, 176,
DW.LNS.negate.stmt, 161, 169, 169,                                                         250, 383, 384
             247                                                              DW.MACRO.undef.strp, 175, 175,
DW.LNS.set.basic.block, 169, 169,                                                          176, 178, 194, 197, 204, 250,
             247                                                                           289, 291
DW.LNS.set.column, 169, 169, 247                                              DW.MACRO.undef.strx, 175, 175,
DW.LNS.set.epilogue.begin, 171,                                                            176, 197, 250, 289, 291, 296
             171, 247                                                         DW.MACRO.undef.sup
DW.LNS.set.ole, 169, 169, 247                                                              (deprecated), 250
DW.LNS.set.isa, 171, 171, 247                                                 DW.MACRO.undef.sup4, 173, 175,
DW.LNS.set.prologue.end, 170,                                                              175, 176, 204, 250
             170, 247                                                         DW.MACRO.undef.sup8, 173, 175,
DW.MACRO.deone, 175, 175, 176,                                                             175, 176, 204, 250
             250, 383, 384                                                    DW.OP.abs, 33, 34, 34, 233
DW.MACRO.deone.strp, 175, 175,                                                DW.OP.addr, 27, 27, 142, 193, 233,
             176, 178, 194, 197, 204, 250,                                                 304
             289, 291, 384
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 472
                                                                   Index
DW.OP.addrx, 28, 28, 69, 184, 195,                                            DW.OP.drop, 30, 30, 233, 303
             196, 235, 289, 291, 295, 419                                     DW.OP.dup, 29, 29, 233, 303
DW.OP.and, 34, 34, 233, 311, 312                                              DW.OP.entry.value, 37, 37, 38, 235,
DW.OP.bit.piece, 43, 43, 44, 235, 307                                                      306, 376~378, 381, 434
DW.OP.bra, 36, 36, 234                                                        DW.OP.eq, 35, 234
DW.OP.breg0, 29, 234, 376, 381                                                DW.OP.EXT, 38
DW.OP.breg1, 29, 234, 305, 306                                                DW.OP.extended, 38, 38, 236
DW.OP.breg31, 29, 234, 304                                                    DW.OP.fbreg, 29, 29, 235, 304, 305,
DW.OP.breg!n?, 29, 83                                                                      430, 434
DW.OP.bregx, 29, 29, 41, 235, 304,                                            DW.OP.form.tls.address, 32, 32, 33,
             390                                                                           142, 235
DW.OP.call2, 36, 36, 52, 184, 235                                             DW.OP.ge, 35, 234
DW.OP.call4, 36, 36, 52, 184, 235                                             DW.OP.gt, 35, 234
DW.OP.call.frame.cfa, 33, 33, 184,                                            DW.OP.hi.user, 38, 191, 236
             235, 430, 433                                                    DW.OP.implicit.pointer, 42, 42, 235,
DW.OP.call.ref, 36, 36, 52, 58, 184,                                                       368, 369, 371
             197, 206, 235, 261, 289, 290                                     DW.OP.implicit.value, 41, 41, 235,
DW.OP.const1s, 27, 233                                                                     368, 371
DW.OP.const1u, 27, 233                                                        DW.OP.le, 35, 234
DW.OP.const2s, 27, 233                                                        DW.OP.lit0, 27, 234
DW.OP.const2u, 27, 233                                                        DW.OP.lit1, 27, 234, 305, 311, 371,
DW.OP.const4s, 27, 233                                                                     377
DW.OP.const4u, 27, 233                                                        DW.OP.lit31, 27, 234
DW.OP.const8s, 27, 233                                                        DW.OP.lit!n?, 27, 35, 311, 312, 317,
DW.OP.const8u, 27, 233                                                                     323
DW.OP.const!n?!x?, 27, 33                                                     DW.OP.lo.user, 38, 191, 236
DW.OP.const!n?s, 27                                                           DW.OP.lt, 35, 234
DW.OP.const!n?u, 27                                                           DW.OP.minus, 33, 34, 34, 233
DW.OP.const.type, 27, 28, 28, 184,                                            DW.OP.mod, 34, 34, 234
             235                                                              DW.OP.mul, 33, 34, 34, 234, 317,
DW.OP.consts, 27, 27, 233                                                                  376, 378
DW.OP.constu, 27, 27, 233                                                     DW.OP.ne, 35, 234
DW.OP.constx, 28, 28, 69, 184, 195,                                           DW.OP.neg, 33, 34, 34, 234
             196, 235, 289, 291, 295                                          DW.OP.nop, 37, 37, 235
DW.OP.convert, 37, 37, 184, 236                                               DW.OP.not, 34, 34, 234
DW.OP.deref, 30, 30, 233, 304, 306,                                           DW.OP.or, 34, 34, 234
             311, 312, 317, 377, 378                                          DW.OP.over, 30, 30, 233, 303
DW.OP.deref.size, 30, 30, 31, 235,                                            DW.OP.pick, 30, 30, 233, 303
             381                                                              DW.OP.piece, 43, 43, 44, 235, 305,
DW.OP.deref.type, 31, 31, 184, 236                                                         307, 369, 371
DW.OP.div, 33, 34, 34, 233
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 473
                                                                   Index
DW.OP.plus, 33, 34, 34, 35, 234, 305,                                         DW.RLE.hi.user, 191, 253
             311, 312, 317, 323, 390                                          DW.RLE.include.rnglist, 56, 253
DW.OP.plus.uconst, 35, 35, 234,                                               DW.RLE.include.rnglistx, 56, 253
             304, 306, 332                                                    DW.RLE.lo.user, 191, 253
DW.OP.push.lane, 33, 33, 84, 236,                                             DW.RLE.ooeset.pair, 55, 56, 56, 253
             390                                                              DW.RLE.start.end, 56, 253
DW.OP.push.object.address, 32,                                                DW.RLE.start.length, 56, 253
             32, 37, 96, 123, 138, 184, 235,                                  DW.RLE.startx.endx, 55, 69, 253,
             310~313, 317                                                                  289, 292
DW.OP.reg0, 41, 234, 305, 307,                                                DW.RLE.startx.length, 55, 69, 253,
             376~378, 381                                                                  289, 292
DW.OP.reg1, 41, 234, 306, 307,                                                DW.SECT.ABBREV, 202
             376~378                                                          DW.SECT.INFO, 202
DW.OP.reg31, 41, 234                                                          DW.SECT.LINE, 202
DW.OP.reg!n?, 41, 83                                                          DW.SECT.LOCLISTS, 202
DW.OP.regval.bits, 28, 29, 29, 236                                            DW.SECT.MACRO, 202
DW.OP.regval.type, 28, 29, 29, 184,                                           DW.SECT.RNGLISTS, 202
             235                                                              DW.SECT.STR.OFFSETS, 202
DW.OP.regx, 41, 41, 235, 304, 390                                             DW.TAG.access.declaration, 16,
DW.OP.reinterpret, 37, 37, 184, 236                                                        122, 214, 266
DW.OP.rot, 30, 30, 233, 303                                                   DW.TAG.array.type, 16, 115, 213,
DW.OP.shl, 35, 35, 234                                                                     266, 311, 312, 314, 315, 317,
DW.OP.shr, 35, 35, 234                                                                     323, 325, 360, 400
DW.OP.shra, 35, 35, 234                                                       DW.TAG.atomic.type, 16, 113, 215,
DW.OP.skip, 36, 36, 234                                                                    266
DW.OP.stack.value, 41, 41, 235, 305,                                          DW.TAG.base.type, 16, 28, 29, 31,
             306, 368, 369, 371, 376, 378,                                                 32, 37, 106, 107, 114, 132, 214,
             390, 434                                                                      267, 302, 324, 328, 335, 338,
DW.OP.swap, 30, 30, 233, 303                                                               361, 373, 398, 402, 404, 405,
DW.OP.user.extended, 38, 38, 236                                                           407, 408, 413, 430
DW.OP.xderef, 31, 31, 233                                                     DW.TAG.call.site, 9, 16, 81, 94, 94,
DW.OP.xderef.size, 31, 31, 32, 235                                                         215, 267, 377, 378, 381
DW.OP.xderef.type, 32, 32, 236                                                DW.TAG.call.site.parameter, 16,
DW.OP.xor, 35, 35, 234                                                                     95, 96, 215, 268, 377, 378, 381
DW.ORD.col.major, 116, 244, 314,                                              DW.TAG.catch.block, 16, 98, 214,
             315                                                                           268
DW.ORD.row.major, 116, 244                                                    DW.TAG.class.type, 16, 118, 127,
DW.RLE.base.address, 56, 253                                                               213, 268, 338, 341, 406, 408,
DW.RLE.base.addressx, 55, 69, 253,                                                         413, 429, 432
             289, 292                                                         DW.TAG.coarray.type, 9, 16, 117,
DW.RLE.end.of.list, 55, 56, 253                                                            215, 268, 314, 315
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 474
                                                                   Index
DW.TAG.common.block, 16, 104,                                                 DW.TAG.imported.module, 16, 75,
             213, 269, 400                                                                 77, 214, 273, 336
DW.TAG.common.inclusion, 16, 83,                                              DW.TAG.imported.unit, 16, 78, 204,
             213, 269, 401, 402                                                            214, 273, 396, 398, 401, 402,
DW.TAG.compile.unit, 16, 62, 62,                                                           415
             71, 208, 213, 269, 290, 291, 295,                                DW.TAG.inheritance, 16, 121, 213,
             302, 396~399, 401, 402, 411,                                                  273
             418, 428, 429                                                    DW.TAG.inlined.subroutine, 16, 78,
DW.TAG.condition, 3, 16, 129, 215,                                                         81, 87, 88, 89, 91, 92, 94, 142,
             269                                                                           213, 273, 352, 353, 357, 359,
DW.TAG.const.type, 16, 113, 114,                                                           360, 371
             214, 269, 338, 341, 360, 373,                                    DW.TAG.interface.type, 16, 120,
             430                                                                           214, 273
DW.TAG.constant, 16, 101, 101, 110,                                           DW.TAG.label, 16, 97, 142, 213, 274
             129, 214, 270, 373, 400                                          DW.TAG.lexical.block, 16, 96, 213,
DW.TAG.dwarf.procedure, 16, 42,                                                            274, 376, 378, 413, 433
             52, 214, 270, 371                                                DW.TAG.lo.user, 191, 215
DW.TAG.dynamic.type, 16, 136,                                                 DW.TAG.member, 16, 94, 122, 129,
             137, 215, 270, 320                                                            213, 274, 312, 320, 321,
DW.TAG.entry.point, 16, 78, 213,                                                           323~325, 328, 330, 332, 333,
             270                                                                           363, 364, 366, 369, 398,
DW.TAG.enumeration.type, 16,                                                               404~406, 408~410
             116, 129, 130, 213, 271, 362                                     DW.TAG.module, 16, 74, 213, 274
DW.TAG.enumerator, 16, 130, 214,                                              DW.TAG.mutable.type
             271, 362                                                                      (deprecated), 215
DW.TAG.ole.type, 16, 136, 214, 271                                            DW.TAG.namelist, 16, 105, 214, 275
DW.TAG.formal.parameter, 16, 42,                                              DW.TAG.namelist.item, 16, 105,
             94, 96, 98, 101, 129, 131, 213,                                               214, 275
             272, 339, 341, 352, 353, 355,                                    DW.TAG.namespace, 16, 74, 74, 142,
             357~360, 364, 369, 371, 386,                                                  214, 275, 335~337, 404~410,
             387, 407, 413, 430, 433, 434                                                  413
DW.TAG.friend, 16, 122, 214, 260,                                             DW.TAG.packed.type, 16, 113, 214,
             272                                                                           275, 324
DW.TAG.generic.subrange, 9, 16,                                               DW.TAG.partial.unit, 16, 62, 62,
             117, 117, 134, 139, 215, 272,                                                 208, 214, 276, 290, 291, 295,
             316, 317                                                                      396, 397, 400, 401
DW.TAG.hi.user, 191, 215                                                      DW.TAG.pointer.type, 16, 113, 114,
DW.TAG.immutable.type, 16, 113,                                                            213, 260, 276, 302, 338, 341,
             215, 272                                                                      407, 409, 413, 430
DW.TAG.imported.declaration, 16,                                              DW.TAG.ptr.to.member.type, 16,
             76, 213, 273, 336                                                             135, 214, 260, 277, 341
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 475
                                                                   Index
DW.TAG.reference.type, 16, 113,                                               DW.TAG.try.block, 16, 98, 214, 283
             114, 213, 260, 277, 399, 430                                     DW.TAG.type.unit, 16, 62, 72, 208,
DW.TAG.restrict.type, 16, 113, 114,                                                        215, 283, 290, 295, 404, 406,
             214, 277                                                                      418, 429
DW.TAG.rvalue.reference.type, 16,                                             DW.TAG.typedef, 16, 115, 115, 213,
             113, 114, 215, 260, 277                                                       283, 302
DW.TAG.set.type, 16, 133, 214, 278                                            DW.TAG.union.type, 16, 118, 127,
DW.TAG.shared.type, 16, 113, 114,                                                          213, 284
             215, 278                                                         DW.TAG.unspecioed.parameters,
DW.TAG.skeleton.unit, 16, 69, 215,                                                         16, 83, 98, 131, 213, 284
             278, 425, 427                                                    DW.TAG.unspecioed.type, 16, 112,
DW.TAG.string.type, 16, 132, 213,                                                          214, 284
             279, 373                                                         DW.TAG.variable, 16, 42, 89, 94,
DW.TAG.structure.type, 16, 118,                                                            101, 102, 114, 124, 129, 142,
             127, 213, 279, 312, 320, 321,                                                 214, 284, 312, 314, 315, 320,
             323~325, 328, 330, 332, 333,                                                  323, 325, 328, 335~337, 341,
             363, 364, 366, 367, 369, 398,                                                 352, 353, 355, 357~364, 366,
             404, 405, 407, 410                                                            367, 369, 371, 373, 378, 390,
DW.TAG.subprogram, 16, 78, 79, 85,                                                         399~401, 411, 433, 434, 437
             86, 89, 91, 92, 113, 124, 142,                                   DW.TAG.variant, 16, 128, 213, 285,
             214, 260, 280, 281, 335, 336,                                                 330, 332, 333
             338, 339, 341, 352, 353, 355,                                    DW.TAG.variant.part, 16, 127, 214,
             357~360, 364, 365, 369, 371,                                                  285, 330~333
             376, 386, 387, 390, 399, 401,                                    DW.TAG.volatile.type, 16, 113, 114,
             402, 407, 410, 411, 413, 429,                                                 214, 285
             430, 432, 433                                                    DW.TAG.with.stmt, 16, 97, 214, 285
DW.TAG.subrange.type, 16, 116,                                                DW.UT.compile, 208, 209
             117, 129, 133, 139, 214, 240,                                    DW.UT.hi.user, 191, 208
             281, 311, 312, 314, 315, 323,                                    DW.UT.lo.user, 191, 208
             325, 328, 360, 400                                               DW.UT.partial, 208, 209
DW.TAG.subroutine.type, 16, 131,                                              DW.UT.skeleton, 208, 210
             213, 282, 341                                                    DW.UT.split.compile, 208, 210
DW.TAG.template.alias, 16, 137,                                               DW.UT.split.type, 208, 211
             215, 282, 366, 367                                               DW.UT.type, 208, 211
DW.TAG.template.type.parameter,                                               DW.VIRTUALITY.none, 49, 240
             16, 59, 214, 282, 363, 364, 366,                                 DW.VIRTUALITY.pure.virtual, 49,
             367                                                                           240
DW.TAG.template.value.parameter,                                              DW.VIRTUALITY.virtual, 49, 240
             16, 59, 214, 283                                                 DW.VIS.exported, 49, 240
DW.TAG.thrown.type, 16, 85, 214,                                              DW.VIS.local, 49, 240
             283                                                              DW.VIS.qualioed, 49, 240
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 476
                                                                   Index
DWARF compression, 391, 417                                                   elemental property of a subroutine,
DWARF duplicate elimination, 391,                                                          20
             see also DWARF compression,                                      elements of breg subrange type, 19
             see also split DWARF object                                      empty location description, 40
             ole                                                              encoding attribute, 106, 107, 219, 237
      examples, 397~399, 435                                                  encoding of base type, 20
DWARF expression, 27, see also                                                end-of-list
             location description                                                    of location list, 45
      arithmetic operations, 33                                                      of range list, 54
      control AEow operations, 35                                             end-of-list entry
      examples, 303                                                                  in location list, 236
      literal encodings, 27                                                   end_sequence, 157, 159, 171
      logical operations, 33                                                  endianity attribute, 104, 106, 220
      operator encoding, 232                                                  endianity of data, 20
      register based addressing, 28                                           entity, 15
      special operations, 37                                                  entry address, 57
      stack operations, 27, 29                                                entry address of a scope, 20
DWARF package ole, 435                                                        entry PC address, 57
DWARF package oles, 198                                                       entry PC attribute, 220
      section identioer encodings, 202                                               and abstract instance, 87
DWARF procedure, 52                                                                  for catch block, 98
DWARF procedure entry, 52                                                            for inlined subprogram, 87
DWARF Version 1, iii                                                                 for lexical block, 97
DWARF Version 2, iii, 2, 12, 13, 161,                                                for module initialization, 74
             193, 441                                                                for subroutine, 82
DWARF Version 3, iii, 11, 12, 161, 168,                                              for try block, 98
             215, 217, 441                                                           for with statement, 98
DWARF Version 4, 1, 2, 8, 10, 11, 27,                                         entry pc attribute, 68
             161, 199, 219, 248, 441                                                 and abstract instance, 87
DWARF Version 5, 1, 8, 9, 44, 54, 61,                                         entry point entry, 78
             65, 133, 141, 154, 160, 161, 163,                                enum class, see type-safe
             164, 183, 218, 219, 221, 241,                                                 enumeration
             246, 250, 254~256, 417, 441                                      enum, Rust, 332
DWARF Version 6, iii, 22, 58, 161, 441                                        enumeration class attribute, 221
dwo_id, 70, 210, 420, 425                                                     enumeration literal, see enumeration
Dylan, 64                                                                                  entry
dynamic number of array                                                       enumeration literal value, 19
             dimensions, 21                                                   enumeration stride (dimension of
                                                                                           array type), 18
elemental attribute, 80, 220                                                  enumeration type entry, 130
                                                                                     as array dimension, 116, 130
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 477
                                                                   Index
enumerator entry, 130                                                         file_name_format_count, 163, 342
epilogue, 179, 188                                                            file_name_format_table, 163, 164,
epilogue  begin, 171                                                                       342
epilogue code, 180                                                            file_names, 163~165, 342
epilogue end, 171                                                             file_names_count, 164, 342
epilogue_begin, 158, 159, 167, 169,                                           AEag, see also AEag class, 49, 50, 68, 79,
             171                                                                           80, 88, 101~103, 123, 130, 131,
epilogue_epilogue, 167                                                                     134
error value, 192                                                              AEag class, 24, 75, 79~81, 92, 94, 104,
exception thrown, see thrown type                                                          195, 218~222, 224, 230, 245
             entry                                                            foreign_type_unit_count, 149, 150
explicit attribute, 124, 220                                                  formal parameter, 82
explicit property of member function,                                         formal parameter entry, 101, 129
             20                                                                      in catch block, 98
export symbols (of structure, class or                                               with default value, 103
             union) attribute, 118                                            formal type parameter, see template
export symbols attribute, 75, 221                                                          type parameter entry
export symbols of a namespace, 20                                             FORTRAN, 9
export symbols of a structure, union                                          Fortran, 1, 32, 64, 68, 74, 76~78, 80, 81,
             or class, 20                                                                  83, 105, 132, 309, 313~315, 379,
exprloc, see also exprloc class                                                            396, 399
exprval class, 23, 57, 58, 186~188,                                                  common block, 83, 104
             217~222, 224, 230                                                       main program, 80
extended opcodes in line number                                                      module (Fortran 90), 74
             program, 171                                                            use statement, 76~78
extended type (Java), see inheritance                                         Fortran 2003, 109, 132, 372
             entry                                                            Fortran 90, 12, 74, 136, 138, 307, 309,
extensibility, 7, 191                                                                      319
extension attribute, 74, 220                                                  Fortran 90 array, 138
external attribute, 79, 101, 219                                              Fortran array, 307
external subroutine, 20                                                       Fortran array example, 309
external variable, 20                                                         Fortran example, 399
                                                                              frame base attribute, 83, 219
file, 157, 159                                                                frame description entry, 182
ole containing call site of non-inlined                                       friend attribute, 122, 219
             call, 18                                                         friend entry, 122
ole containing declaration, 51                                                friend relationship, 20
ole containing inlined subroutine                                             full compilation unit, 62
             call, 18                                                         function entry, see subroutine entry
ole containing source declaration, 19                                         function template instantiation, 85
ole type entry, 136                                                           fundamental type, see base type entry
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 478
                                                                   Index
generic type, 27, 28, 30~37                                                   incomplete, non-deoning, or separate
global namespace, 74, 75, see                                                              declaration corresponding to
             namespace (C++), global                                                       a declaration, 22
GNU C, 112                                                                    incomplete, non-deoning, or separate
Go, 64                                                                                     entity declaration, 19
                                                                              index attribute, 147
Haskell, 64                                                                   indirection to actual data, 19
header_length, 160, 206, 342                                                  inheritance entry, 121
hidden indirection, see data location                                         inherited member location, 19
             attribute                                                        initial length, 140, 148, 154, 160, 182,
high PC attribute, 53, 63, 74, 82, 87,                                                     183, 192, 193, 205, 206,
             96~98, 218, 354                                                               209~211, 246, 253~256
      and abstract instance, 87                                               initial length oeld, see initial length
high user attribute encoding, 222                                             initial_instructions, 183, 189
High-Level Shading Language, 64                                               initial_length, 209
HIP Language, 64                                                              initial_location, 182, 184, 189, 195
Hylo Language, 64                                                             inline attribute, 86, 218, 244
identioer case attribute, 67, 219                                             inline instances of inline
identioer case rule, 20                                                                    subprograms, 17
identioer names, 52, 58, 67                                                   inline namespace, 75, see also export
IEEE 754R decimal AEoating-point                                                           symbols attribute
             number, 108                                                      inlined call location attributes, 88
immutable type, 113                                                           inlined subprogram call
implementing type (Java), see                                                        examples, 350
             inheritance entry                                                inlined subprogram entry, 78, 87
implicit location description, 41                                                    in concrete instance, 87
implicit pointer example, 369, 371                                            inlined subroutine, 20
import attribute, 76~78, 218                                                  instructions, 184
imported declaration, 20                                                      integer constant, 51, 58, 79, 86, 88,
imported declaration entry, 76                                                             106, 107, 109, 111, 115, 123,
imported module attribute, 77                                                              124
imported module entry, 77                                                     interface type entry, 120
imported unit, 20                                                             Internet, 166
imported unit entry, 62, 78                                                   is optional attribute, 103, 218
include_index, 165                                                            is_stmt, 157, 159, 161, 169
incomplete declaration, 50                                                    is_supplementary, 203
incomplete structure/union/class,                                             isa, 158, 159, 171
             119                                                              ISO  10646 (Fortran string kind), 109
incomplete type, 115, 119                                                     ISO 10646 character set standard, 109,
incomplete type (Ada), 112                                                                 132, 228, 372
                                                                              ISO-deoned language names, 63, 240
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 479
                                                                   Index
ISO/IEC 10646-1:1993 character, 108                                           line containing call site of
ISO/IEC 10646-1:1993 character                                                             non-inlined call, 18
             (UCS-4), 108                                                     line number information, see also
ISO/IEC 646:1991 character, 108                                                            statement list attribute
ISO_10646 (Fortran string kind), 132                                          line number information for unit, 22
                                                                              line number of inlined subroutine
Java, 12, 64, 118, 120, 121                                                                call, 18
Julia, 64                                                                     line number of source declaration, 19
Kotlin, 64                                                                    line number opcodes
                                                                                     extended opcode encoding, 248
label entry, 97                                                                      ole entry format encoding, 248
language attribute, 72                                                               standard opcode encoding, 247
language attribute (Version 5), 218                                           line number program, 167
language attribute, encoding, 240                                                    extended opcodes, 171
language name attribute, 63, 116, 222                                                special opcodes, 167
language name encoding, 240                                                          standard opcodes, 169
language version attribute, 222                                               line_base, 161, 168, 169, 342, 343
language version encoding schemes,                                            line_range, 161, 168, 169, 342, 343
             66                                                               lineptr, see also lineptr class, 290
LEB128, 159, 162, 170, 223, 228, 231                                          lineptr class, 24, 72, 217, 222, 224, 229,
      examples, 232                                                                        230, 295
      signed, 29, 42, 169, 183, 185~187,                                      linkage name attribute, 59, 221
             216, 232                                                         list of discriminant values, 20
      signed, decoding of, 299                                                Little-Endian Base 128, see LEB128
      signed, encoding as, 231, 298                                           little-endian encoding, see endian
      unsigned, 27~29, 35, 37, 41, 43,                                                     attribute
             160, 169, 171, 172, 178, 183,                                    local_str_pool_size, 149, 152
             185~188, 212, 216, 223~226,                                      local_type_unit_count, 149, 150
             231, 232, 249, 260, 261                                          location, 123
      unsigned, decoding of, 298                                              location attribute, 36, 52, 98, 102, 104,
      unsigned, encoding as, 231, 297                                                      217, 354
LEB128 encoding                                                                      and abstract instance, 87
      algorithms, 297                                                         location description, 39, see also
      examples, 232                                                                        DWARF expression, 121, 123,
length, 182~184                                                                            125, 132, 135, 137
level-88 condition, COBOL, 129                                                       composite, 40
lexical block, 39, 96, 98                                                            empty, 40
lexical block entry, 96                                                              implicit, 41
lexical blocks, 57                                                                   memory, 40
line, 157, 159                                                                       simple, 40
                                                                                     single, 39
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 480
                                                                   Index
      use in location list, 39                                                maximum_operations_per_instruction,
location list, 39, 63, 83, 236, 261, 291,                                                  161, 168, 342
             295                                                              MD5, 166, 258, 261, 262, 404, 411
location list attribute, 219                                                  member entry (data), 122, 123
location list base attribute, 222                                                    as discriminant, 127
location lists base, 21                                                       member function entry, 124
location of uplevel frame, 22                                                 member function example, 338
location table base attribute, 69                                             member location for pointer to
locdesc class, 24, 39, 58, 217~221, 225,                                                   member type, 22
             230                                                              memory location description, 40
loclist, see also loclist class                                               minimum_instruction_length, 161,
loclist class, 24, 39, 44, 217~220, 222,                                                   168, 170, 342
             225, 229, 230, 291, 295                                          MIPS instruction set architecture, 155
loclistsptr, see also loclistsptr class                                       Modula-2, 48, 64, 74, 97
loclistsptr class, 24, 69, 222, 225, 229,                                            deonition module, 74
             230                                                              Modula-3, 64
lookup                                                                        module entry, 74
      by address, 154                                                         module priority, 21
      by name, 141                                                            Mojo Language, 64
low PC attribute, 53, 63, 74, 82, 87,                                         Move Language, 64
             96~98, 217, 354                                                  mutable attribute, 123, 220
      and abstract instance, 87                                               mutable property of member data, 21
low user attribute encoding, 222
lower bound attribute, 134, 218                                               name attribute, 52, 59, 63, 67, 74, 76,
      default, 134, 240                                                                    90, 97, 101, 104~106, 112, 113,
lower bound of subrange, 21                                                                115, 118, 120, 122, 129~133,
                                                                                           135~137, 217, 258~260
macptr, see also macptr class, 290                                            name index, 141
macptr class, 24, 221, 222, 225, 229,                                                case folding, 151
             230, 295                                                         name list item attribute, 219
macro formal parameter list, 176                                              name of declaration, 21
macro information, 172                                                        name_count, 149, 151, 152
macro information attribute, 65, 221                                          namelist entry, 105
macro information entry types                                                 namelist item, 21
      encoding, 249                                                           namelist item attribute, 105
macro preprocessor information, 21                                            namelist item entry, 105
main or starting subprogram, 21                                               names
main subprogram attribute, 68, 79,                                                   identioer, 52
             220                                                                     mangled, 58
mangled names, 52, 58, 92                                                     namespace (C++), 74
                                                                                     alias, 76
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 481
                                                                   Index
      example, 334                                                            opcode_operands_table_flag, 173,
      global, 75                                                                           383, 384
      unnamed, 75                                                             OpenCL C, 9, 65, 166
      using declaration, 75, 76, 78                                           OpenCL C++, 65
      using directive, 77                                                     OpenGL ES Shading Language, 64
namespace alias, 20                                                           OpenGL Shading Language, 64
namespace declaration entry, 75                                               operation advance, 168, 169, 343
namespace extension entry, 75                                                 operation pointer, 158, 161, 167, 168
namespace using declaration, 20                                               optional parameter, 20, 103
namespace using directive, 20                                                 ordering attribute, 104, 217
nested abstract instance, 87                                                  out-of-line instance, 91, see also
nested concrete inline instance, 88                                                        concrete out-of-line instance
non-constant parameter AEag, 22                                               out-of-line instances of inline
non-contiguous address ranges, 54                                                          subprograms, 17
non-contiguous range of code
             addresses, 21                                                    P4, 65
non-default alignment, 17                                                     package oles, 198
non-deoning declaration, 50                                                   packed qualioed type entry, 113
noreturn attribute, 21, 80, 221                                               packed type entry, 113
Number of lanes attribute, 21                                                 padding, 149, 183, 184, 200, 254
number of lanes attribute, 222                                                parameter, see this parameter, see
numerator of rational scale factor, 22,                                                    formal parameter entry, see
             222                                                                           macro formal parameter list,
                                                                                           see optional parameter
object (this, self) pointer of member                                                      attribute, see template type
             function, 21                                                                  parameter entry, see template
object ole linkage name of an entity,                                                      value parameter entry, see
             21                                                                            unspecioed parameters entry,
object pointer attribute, 125, 220                                                         see variable parameter
Objective C, 64, 125                                                                       attribute
Objective C++, 65                                                             parameter entry, 18
objects or types that are not actually                                        partial compilation unit, 62, 63
             declared in the source, 17                                       Pascal, 65, 97, 113, 118, 133, 136, 329,
OCaml, 65                                                                                  330, 332
Odin, 65                                                                      Pascal example, 324
offset_entry_count, 255, 256                                                  path name of compilation source, 21
offset_size_flag, 173, 175, 178,                                              picture string attribute, 220
             200~202, 383, 384                                                picture string for numeric string
op_index, 157~159, 161, 167~170, 172                                                       type, 21
opcode_base, 161, 162, 168, 342                                               PL/I, 65
opcode_operands_table, 173, 174                                               pointer or reference types, 17
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 482
                                                                   Index
pointer qualioed type entry, 113                                              recursive property of a subroutine, 21
pointer to member, 135                                                        reduced scope of declaration, 22
pointer to member entry, 135                                                  reference, see also reference class, 51,
pointer to member type, 135, 136                                                           57, 68, 75~78, 83, 85, 102, 105,
pointer to member type entry, 135                                                          113, 115, 119, 125, 127, 132,
pointer type entry, 114                                                                    135
previous namespace extension or                                               reference attribute, 221
             original namespace, 20                                           reference class, 24, 92, 94, 103, 104,
primitive data types of compilation                                                        132, 217~221, 226, 230, 245
             unit, 17                                                         reference qualioed type entry, 113
priority attribute, 74, 219                                                   reference type, 114
producer attribute, 67, 218                                                   reference type entry, 113
producer extensibility, see                                                   reference type entry, lvalue, see
             extensibility                                                                 reference type entry
producer id, 192                                                              reference type entry, rvalue, see
producer-specioc extensions, see                                                           rvalue reference type entry
             extensibility                                                    renamed declaration, see imported
PROGRAM statement, 68                                                                      declaration entry
programming language name, 21                                                 RenderScript, 65
programming language version, 21                                              reserved target address, 26
prologue, 179, 180                                                            reserved values
prologue  end, 170, 171                                                              error, 192
prologue_end, 158, 159, 167, 169, 170                                                initial length, 192
prologue_epilogue, 158, 159, 169,                                             restrict qualioed type, 113
             171, 172                                                         restricted type entry, 113
prototyped attribute, 80, 131, 218                                            return address attribute, 83, 218
pure attribute, 80, 220                                                              and abstract instance, 87
pure property of a subroutine, 21                                             return address from a call, 18
Python, 65                                                                    return type of subroutine, 82
                                                                              return_address_register, 183
range list, 63, 99, 100, 252, 253, 291,                                       rnglist, see also rnglist class
             295                                                              rnglist class, 24, 54, 218, 220, 222, 226,
range list base                                                                            230, 291, 295
      encoding, 221                                                           rnglistsptr, see also rnglistsptr class
ranges attribute, 53, 54, 63, 74, 82, 87,                                     rnglistsptr class, 24, 69, 99, 221, 222,
             96~98, 220                                                                    226, 229, 230
      and abstract instance, 87                                               Ruby, 65
ranges lists, 22                                                              Rust, 65, 112, 332, 333
ranges table base attribute, 69                                               rvalue reference qualioed type entry,
rank attribute, 221                                                                        113
recursive attribute, 80, 220                                                  rvalue reference type entry, 113
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 483
                                                                   Index
rvaluereference attribute, 221                                                signed LEB128, see LEB128, signed
                                                                              SIMD Vectorization, 84
sbyte, 140, 161, 258                                                          simple location description, 40
scalar coarray, see coarray                                                   single location description, 39
scale factor for oxed-point type, 22                                          size of an address, 26, see also
scaled encodings, 109                                                                      address_size, 27, 30, 31, 132,
      binary, 109                                                                          154, 160, 211, 246
      composition of, 110                                                     skeleton compilation unit, 69
      decimal, 109                                                            SLEB128, 231
      AEoating-point, 110                                                     slot_count, 200
      rational, 110                                                           small attribute, 110, 220
section group, 392~399, 401, 403, 414,                                        special opcodes in line number
             415                                                                           program, 167
      name, 394                                                               specialized .debug_line.dwo section,
section length, 140, 149                                                                   429
      use in headers, 206                                                     specialized line number table, 72,
section ooeset, 11, 140, 209~212, 246                                                      196, 418
      alignment of, 257                                                       speciocation attribute, 75, 87, 119,
      in .debug.aranges header, 154,                                                       125, 126, 219
             246                                                              split DWARF object ole, 69, 70, 72,
      in .debug.info header, 209~212                                                       143, 147, 195, 198, 222, 288,
      in class lineptr value, 224                                                          417, 422, 425, 426, 428
      in class loclist value, 225                                                    example, 422
      in class loclistsptr, 225                                                      object ole name, 20
      in class macptr value, 225                                              split DWARF object ole name
      in class reference value, 226                                                  encoding, 221
      in class rnglist value, 226                                             split DWARF object ole name
      in class rnglistsptr, 226                                                            attribute, 69
      in class string value, 228                                              split type unit, 72
      in FDE header, 183                                                      standard opcodes in line number
      in macro information attribute, 65                                                   program, 169
      in statement list attribute, 65                                         standard_opcode_lengths, 162, 342
      use in headers, 206                                                     start scope attribute, 99, 218
section_count, 200                                                                   and abstract instance, 87
section_offset, 149                                                           statement list attribute, 65, 72, 217
self pointer attribute, see object                                            static link attribute, 219
             pointer attribute                                                str_format, 149, 152, 289, 290, 292
set type entry, 133                                                           str_offsets, 149
shared qualioed type entry, 113                                               stride attribute, see bit stride attribute
sibling attribute, 25, 51, 217                                                             or byte stride attribute
signature attribute, 220                                                      string, see also string class
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 484
                                                                   Index
string class, 24, 52, 92, 103, 217, 218,                                      supplementary object ole, 8, 17, 24,
             220, 221, 227, 229~231                                                        175, 178, 203, 204, 227, 228,
string length attribute, 132, 218                                                          287, 288
      size of length, 221                                                     Swift, 65
      size of length data, 132                                                SYCL, 65
string length of string type, 22
      size of, 22                                                             tag, 15
string length size attribute, 132                                             tag names, see debugging
string ooeset section attribute, 68                                                        information entry
string ooesets attribute, 222                                                        list of, 23
string ooesets base attribute, 73                                             target address, 184
string ooesets information, 290                                                      reserved, 26
string ooesets information for unit, 22                                       target subroutine of trampoline, 22
string type entry, 132                                                        template alias entry, 137
strooesetsptr, see also strooesetsptr class                                   template alias example, 365, 366
strooesetsptr class, 25, 68, 73, 222, 229,                                    template alias example 1, 366
             230                                                              template alias example 2, 367
structure type entry, 118                                                     template instantiation, 59
subprogram called, 18                                                                and special compilation unit, 127
subprogram entry, 78, 79                                                             function, 85
      as member function, 124                                                 template type parameter entry, 59
      use for template instantiation, 85                                      template value parameter, 19
      use in inlined subprogram, 86                                           template value parameter entry, 59
subrange stride (dimension of array                                           Tensor (array) type, 22
             type), 18                                                        tensor attribute, 222
subrange type entry, 133                                                      this parameter, 49, 92
      as array dimension, 116                                                 this pointer attribute, see object
subroutine call site summary                                                               pointer attribute
             attributes, 81                                                   thread scaled attribute, 220
subroutine entry, 78                                                          thread-local storage, 32
subroutine formal parameters, 82                                              threads scaled attribute, 134
subroutine frame base address, 20                                             thrown exception, see thrown type
subroutine or subroutine type, 17                                                          entry
subroutine prototype, 21                                                      thrown type entry, 85
subroutine return address save                                                trampoline (subprogram) entry, 92
             location, 22                                                     trampoline attribute, 92, 220
subroutine type entry, 131                                                    try block, 98
sup_checksum, 203                                                             try block entry, 98
sup_checksum_len, 203                                                         try/catch blocks, 57
sup.olename, 203                                                              type
                                                                                     of call site, 22
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 485
                                                                   Index
      of declaration, 22                                                      uhalf, 140, 149, 154, 160, 170, 173, 185,
      of string type components, 22                                                        200, 203, 209~211, 246,
      of subroutine return, 22                                                             253~256, 258
type attribute, 48, 59, 82, 85, 98, 113,                                      ULEB128, 174, 175, 231
             115, 116, 121, 122, 127,                                         unallocated variable, 102
             129~131, 133~136, 219                                            Unicode, 109, 151, 228, 361, see also
      of call site entry, 95                                                               UTF-8
      of string type entry, 132                                               Unioed Parallel C, see UPC
type modioer, see atomic type entry,                                          union type entry, 118
             see constant type entry, see                                     unit, see compilation unit
             packed type entry, see pointer                                   unit containing main or starting
             type entry, see reference type                                                subprogram, 21
             entry, see restricted type entry,                                unit header unit type encodings, 208
             see shared type entry, see                                       unit_count, 200
             volatile type entry                                              unit_length, 148, 154, 160, 209~211,
type modioer entry, 113                                                                    246, 253~256, 342
type safe enumeration deonition, 20                                           unit_type, 9, 208~211
type safe enumeration types, 130                                              unnamed namespace, see namespace
type signature, 22, 24, 119, 211, 227,                                                     (C++), unnamed
             258, 403, 404                                                    unsigned LEB128, see LEB128,
      computation, 258                                                                     unsigned
      computation grammar, 411                                                unspecioed parameters entry, 83, 131
      example computation, 403                                                       in catch block, 98
type unit, 72, see also compilation                                           unspecioed type entry, 112
             unit, 73, 119, 208, 211, 212,                                    unwind, see virtual unwind
             227, 258, 261, 262, 404, 415                                     UPC, 22, 65, 113, 114, 134
      specialized .debug_line.dwo                                             uplevel address, see static link
             section in, 429                                                               attribute
type unit entry, 72                                                           upper bound attribute, 134, 218
type unit set, 199                                                                   default unknown, 134
type unit signature, 70, 435                                                  upper bound of subrange, 22
type-safe enumeration, 362                                                    use location attribute, 135
type_offset, 212                                                              use statement, see Fortran, use
type_signature, 211                                                                        statement
typedef entry, 115                                                            use UTF8 attribute, 22, 68, 220, 228
                                                                              using declaration, see namespace
ubyte, 140, 149, 150, 154, 159~162,                                                        (C++), using declaration
             167, 173, 182~185, 203,                                          using directive, see namespace (C++),
             209~211, 246, 254~256, 258                                                    using directive
UCS character, 108                                                            UTF character, 108
                                                                              UTF-8, 12, 22, 68, 182, 220, 228
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 486
                                                                   Index
uword, 140, 149, 150, 185, 200, 255,                                          VVMM language version encoding
             256, 258                                                                      scheme, 64~66
                                                                              VVMMPP language version
vallist class, 24, 38, 222, 229, 230                                                       encoding scheme, 64~66
value list, 291, 295
value lists, 38                                                               with statement entry, 97
value pointed to by an argument, 18
variable entry, 101                                                           YYYY language version encoding
variable length data, see LEB128                                                           scheme, 64~66
variable parameter attribute, 102, 219                                        YYYYMM language version
variant entry, 128                                                                         encoding scheme, 64~66
variant part entry, 127                                                       YYYYRR language version encoding
version, 149, 154, 160, 182, 200, 203,                                                     scheme, 65, 66
             209~211, 246, 253~256, 342                                       Zig, 65
version number
      address lookup table, 154
      address range table, 246
      address table, 254
      call frame information, 182, 251
      compilation unit, 209, 210
      CU index information, 200
      line number information, 160, 247
      location list table, 256
      macro information, 249
      name index table, 149, 245
      range list table, 255
      string ooesets table, 254
      summary by section, 441
      TU index information, 200
      type unit, 211
virtual function vtable slot, 23
virtual unwind, 179
virtuality attribute, 49, 219
virtuality of member function or base
             class, 23
visibility attribute, 48, 218
visibility of declaration, 23
void type, see unspecioed type entry
volatile qualioed type entry, 113
vtable element location attribute, 125,
             220
November 1, 2024                                  ***WORKING DRAFT***                                                           Page 487
